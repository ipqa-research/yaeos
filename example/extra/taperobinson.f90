!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 13 Sep 2023 12:36
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 13 Sep 2023 12:36
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 13 Sep 2023 12:36
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 13 Sep 2023 12:36
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 13 Sep 2023 12:36
!
MODULE autodiff_tapenade_pr76_demo
   USE YAEOS__CONSTANTS, ONLY : pr, r
   USE YAEOS__TAPENADE_AR_API, ONLY : armodeltapenade
   use yaeos__tapenade_interfaces
   IMPLICIT NONE
   type, extends(ArModelTapenade) :: TPR76
      REAL(pr), ALLOCATABLE :: kij(:, :), lij(:, :)
      REAL(pr), ALLOCATABLE :: ac(:), b(:), k(:)
      REAL(pr), ALLOCATABLE :: tc(:), pc(:), w(:)
      REAL(pr) :: del1=1.+SQRT(2.)
      REAL(pr) :: del2=1.-SQRT(2.)
   contains
      procedure :: ar
      procedure :: ar_d
      procedure :: ar_b
      procedure :: ar_d_b
      procedure :: ar_d_d
      procedure :: get_v0 => VOLUME_INITALIZER
   end type TPR76

CONTAINS
   type(TPR76) function setup_model(tc, pc, w, kij, lij)
      real(pr), intent(in) :: tc(:)
      real(pr), intent(in) :: pc(:)
      real(pr), intent(in) :: w(:)
      real(pr), intent(in) :: kij(:, :)
      real(pr), intent(in) :: lij(:, :)

      setup_model%components%tc = tc
      setup_model%components%pc = pc
      setup_model%components%w = w

      setup_model%ac = 0.45723553 * R**2 * tc**2 / pc
      setup_model%b = 0.07779607 * R * tc/pc
      setup_model%k = 0.37464 + 1.54226 * w - 0.26993 * w**2

      setup_model%kij = kij
      setup_model%lij = lij
   end function setup_model


!  Differentiation of ar_d_d in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: arval arvaldd arvald arvald0
!   with respect to varying inputs: t v
!   RW status of diff variables: t:in v:in arval:out arvaldd:out
!                arvald:out arvald0:out
!  Differentiation of ar_d in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: arval arvald
!   with respect to varying inputs: t v
!   RW status of diff variables: t:in v:in arval:out arvald:out
!  Differentiation of ar in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: arval
!   with respect to varying inputs: n t v
!   RW status of diff variables: n:in t:in v:in arval:out
   SUBROUTINE AR_D_D_D(model, n, nd, v, vd1, vd0, vd, t, td1, td0, td, &
   &   arval, arvald1, arvald0, arvald0d, arvald, arvaldd0, arvaldd, &
   &   arvalddd)
      IMPLICIT NONE
      class(TPR76), INTENT(IN) :: model
      REAL(pr), INTENT(IN) :: n(:), v, t
      REAL(pr), INTENT(IN) :: vd1, td1
      REAL(pr), INTENT(IN) :: vd0, td0
      REAL(pr), INTENT(IN) :: nd(:), vd, td
      REAL(pr), INTENT(OUT) :: arval
      REAL(pr), INTENT(OUT) :: arvald1
      REAL(pr), INTENT(OUT) :: arvald0
      REAL(pr), INTENT(OUT) :: arvald0d
      REAL(pr), INTENT(OUT) :: arvald
      REAL(pr), INTENT(OUT) :: arvaldd0
      REAL(pr), INTENT(OUT) :: arvaldd
      REAL(pr), INTENT(OUT) :: arvalddd
      REAL(pr) :: amix, a(SIZE(n)), ai(SIZE(n)), z2(SIZE(n)), nij
      REAL(pr) :: amixd1, ad1(SIZE(n))
      REAL(pr) :: amixd0, ad0(SIZE(n))
      REAL(pr) :: amixd0d, ad0d(SIZE(n))
      REAL(pr) :: amixd, ad(SIZE(n)), nijd
      REAL(pr) :: amixdd0, add0(SIZE(n))
      REAL(pr) :: amixdd, add(SIZE(n))
      REAL(pr) :: amixddd, addd(SIZE(n))
      REAL(pr) :: bmix
      REAL(pr) :: bmixd
      REAL(pr) :: b_v
      REAL(pr) :: b_vd1
      REAL(pr) :: b_vd0
      REAL(pr) :: b_vd0d
      REAL(pr) :: b_vd
      REAL(pr) :: b_vdd0
      REAL(pr) :: b_vdd
      REAL(pr) :: b_vddd
      REAL(pr) :: aij(SIZE(n), SIZE(n)), bij(SIZE(n), SIZE(n))
      INTEGER :: i, j
      REAL(pr) :: tc(SIZE(n)), pc(SIZE(n)), w(SIZE(n))
      REAL(pr) :: ac(SIZE(n)), b(SIZE(n)), k(SIZE(n))
      REAL(pr) :: del1, del2
      REAL(pr) :: kij(SIZE(n), SIZE(n)), lij(SIZE(n), SIZE(n))
      INTRINSIC SQRT
      INTRINSIC SUM
      INTRINSIC LOG
      INTRINSIC SIZE
      REAL(pr), DIMENSION(SIZE(n)) :: arg1
      REAL(pr), DIMENSION(SIZE(n)) :: arg1d1
      REAL(pr), DIMENSION(SIZE(n)) :: arg1d0
      REAL(pr), DIMENSION(SIZE(n)) :: arg1d0d
      REAL(pr), DIMENSION(SIZE(n)) :: arg1d
      REAL(pr), DIMENSION(SIZE(n)) :: arg1dd0
      REAL(pr), DIMENSION(SIZE(n)) :: arg1dd
      REAL(pr), DIMENSION(SIZE(n)) :: arg1ddd
      REAL(pr), DIMENSION(SIZE(n)) :: result1
      REAL(pr), DIMENSION(SIZE(n)) :: result1d1
      REAL(pr), DIMENSION(SIZE(n)) :: result1d0
      REAL(pr), DIMENSION(SIZE(n)) :: result1d0d
      REAL(pr), DIMENSION(SIZE(n)) :: result1d
      REAL(pr), DIMENSION(SIZE(n)) :: result1dd0
      REAL(pr), DIMENSION(SIZE(n)) :: result1dd
      REAL(pr), DIMENSION(SIZE(n)) :: result1ddd
      REAL(pr), DIMENSION(SIZE(n)) :: arg2
      REAL(pr), DIMENSION(SIZE(n)) :: arg2d1
      REAL(pr), DIMENSION(SIZE(n)) :: arg2d0
      REAL(pr), DIMENSION(SIZE(n)) :: arg2d0d
      REAL(pr), DIMENSION(SIZE(n)) :: arg2d
      REAL(pr), DIMENSION(SIZE(n)) :: arg2dd0
      REAL(pr), DIMENSION(SIZE(n)) :: arg2dd
      REAL(pr), DIMENSION(SIZE(n)) :: arg2ddd
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10d
      REAL(pr) :: arg11
      REAL(pr) :: arg11d1
      REAL(pr) :: arg11d0
      REAL(pr) :: arg11d0d
      REAL(pr) :: arg11d
      REAL(pr) :: arg11dd0
      REAL(pr) :: arg11dd
      REAL(pr) :: arg11ddd
      REAL(pr), DIMENSION(SIZE(n)) :: temp
      REAL(pr), DIMENSION(SIZE(n)) :: tempd0
      REAL(pr), DIMENSION(SIZE(n)) :: tempd
      REAL(pr), DIMENSION(SIZE(n)) :: tempdd
      REAL(pr) :: temp0
      REAL(pr) :: temp0d0
      REAL(pr) :: temp0d
      REAL(pr) :: temp0dd
      REAL(pr) :: temp1
      REAL(pr) :: temp2
      REAL(pr) :: temp2d0
      REAL(pr) :: temp2d
      REAL(pr) :: temp3
      REAL(pr) :: temp3d0
      REAL(pr) :: temp3d
      REAL(pr) :: temp3dd
      REAL(pr) :: temp4
      REAL(pr) :: temp4d0
      REAL(pr) :: temp4d
      REAL(pr) :: temp4dd
      REAL(pr) :: temp5
      REAL(pr) :: temp5d0
      REAL(pr) :: temp5d
      REAL(pr) :: temp5dd

      REAL(pr), DIMENSION(SIZE(n)) :: temp6
      REAL(pr), DIMENSION(SIZE(n)) :: temp6d
      REAL(pr) :: temp7
      REAL(pr) :: temp7d
      REAL(pr) :: temp8
      REAL(pr) :: temp8d
      REAL(pr) :: temp9
      REAL(pr) :: temp9d
      REAL(pr) :: temp10
      REAL(pr) :: temp10d
      REAL(pr) :: temp11
      REAL(pr) :: temp12
      REAL(pr) :: temp12d
      REAL(pr) :: temp13
      REAL(pr) :: temp13d
      REAL(pr), DIMENSION(SIZE(n)) :: temp14
      REAL(pr) :: temp15
      REAL(pr) :: temp16
      REAL(pr) :: temp17
      REAL(pr) :: temp18
      REAL(pr) :: temp19
      LOGICAL, DIMENSION(SIZE(n)) :: mask
      LOGICAL, DIMENSION(SIZE(n)) :: mask0
      LOGICAL, DIMENSION(SIZE(n)) :: mask1
      LOGICAL, DIMENSION(SIZE(n)) :: mask2
      LOGICAL, DIMENSION(SIZE(n)) :: mask3
      LOGICAL, DIMENSION(SIZE(n)) :: mask4
      LOGICAL, DIMENSION(SIZE(n)) :: mask5
      LOGICAL, DIMENSION(SIZE(n)) :: mask6
      LOGICAL, DIMENSION(SIZE(n)) :: mask7
      LOGICAL, DIMENSION(SIZE(n)) :: mask8
      LOGICAL, DIMENSION(SIZE(n)) :: mask9
      LOGICAL, DIMENSION(SIZE(n)) :: mask10
      LOGICAL, DIMENSION(SIZE(n)) :: mask11
      tc = model%components%tc
      pc = model%components%pc
      w = model%components%w
      ac = model%ac
      b = model%b
      k = model%k
      kij = model%kij
      lij = model%lij
      del1 = model%del1
      del2 = model%del2
      arg1d(:) = td/tc
      arg1d0(:) = td0/tc
      arg1d1(:) = td1/tc
      arg1(:) = t/tc
      temp14 = SQRT(arg1(:))
      mask(:) = arg1(:) .EQ. 0.0
      WHERE (mask(:))
         temp6d = 0.0_pr
      ELSEWHERE
         temp6d = arg1d1(:)/(2.0*temp14)
      END WHERE
      temp6 = temp14
      mask0(:) = arg1(:) .EQ. 0.0
      WHERE (mask0(:)) tempd = 0.0_pr
      tempdd = 0.0_pr
      mask1(:) = .NOT.arg1(:) .EQ. 0.0
      WHERE (mask1(:))
         temp14 = arg1d0(:)/(2.0*temp6)
         tempdd = -(temp14*temp6d/temp6)
         tempd = temp14
      END WHERE
      tempd0 = temp6d
      temp = temp6
      mask2(:) = arg1(:) .EQ. 0.0
      WHERE (mask2(:)) result1d = 0.0_pr
      result1dd = 0.0_pr
      mask3(:) = .NOT.arg1(:) .EQ. 0.0
      WHERE (mask3(:))
         temp14 = arg1d(:)/(2.0*temp)
         temp6d = -(temp14*tempd0/temp)
         temp6 = temp14
      END WHERE
      result1ddd = 0.0_pr
      mask4(:) = .NOT.arg1(:) .EQ. 0.0
      WHERE (mask4(:))
         temp14 = temp6*tempd/temp
         result1ddd = -((tempd*temp6d+temp6*tempdd-temp14*tempd0)/temp)
         result1dd = -temp14
      END WHERE
      result1dd0 = 0.0_pr
      mask5(:) = .NOT.arg1(:) .EQ. 0.0
      WHERE (mask5(:))
         result1dd0 = temp6d
         result1d = temp6
      END WHERE
      result1d0d = tempdd
      result1d0 = tempd
      result1d1 = tempd0
      result1 = temp
      arg2ddd(:) = -(ac*2*k*((k*(1.0-result1)+1.0)*result1ddd-result1dd*k*&
      &     result1d1-k*(result1d0*result1dd0+result1d*result1d0d)))
      arg2dd(:) = -(ac*2*k*((k*(1.0-result1)+1.0)*result1dd-result1d*k*&
      &     result1d0))
      arg2dd0(:) = -(ac*2*k*((k*(1.0-result1)+1.0)*result1dd0-result1d*k*&
      &     result1d1))
      arg2d(:) = -(ac*2*(k*(1.0-result1)+1.0)*k*result1d)
      arg2d0d(:) = -(ac*2*k*((k*(1.0-result1)+1.0)*result1d0d-result1d0*k*&
      &     result1d1))
      arg2d0(:) = -(ac*2*(k*(1.0-result1)+1.0)*k*result1d0)
      arg2d1(:) = -(ac*2*(k*(1.0-result1)+1.0)*k*result1d1)
      arg2(:) = ac*(1.0+k*(1.0-result1))**2
      temp14 = SQRT(arg2(:))
      mask6(:) = arg2(:) .EQ. 0.0
      WHERE (mask6(:))
         temp6d = 0.0_pr
      ELSEWHERE
         temp6d = arg2d1(:)/(2.0*temp14)
      END WHERE
      temp6 = temp14
      mask7(:) = arg2(:) .EQ. 0.0
      WHERE (mask7(:))
         tempdd = 0.0_pr
         tempd = 0.0_pr
      ELSEWHERE
         temp14 = arg2d0(:)/(2.0*temp6)
         tempdd = (arg2d0d(:)-temp14*2.0*temp6d)/(2.0*temp6)
         tempd = temp14
      END WHERE
      tempd0 = temp6d
      temp = temp6
      mask8(:) = arg2(:) .EQ. 0.0
      WHERE (mask8(:)) ad = 0.0_pr
      add = 0.0_pr
      mask9(:) = .NOT.arg2(:) .EQ. 0.0
      WHERE (mask9(:))
         temp14 = arg2d(:)/(2.0*temp)
         temp6d = (arg2dd0(:)-temp14*2.0*tempd0)/(2.0*temp)
         temp6 = temp14
      END WHERE
      addd = 0.0_pr
      mask10(:) = .NOT.arg2(:) .EQ. 0.0
      WHERE (mask10(:))
         temp14 = (arg2dd(:)-2.0*temp6*tempd)/(2.0*temp)
         addd = (arg2ddd(:)-2.0*(tempd*temp6d+temp6*tempdd)-temp14*2.0*&
         &       tempd0)/(2.0*temp)
         add = temp14
      END WHERE
      add0 = 0.0_pr
      mask11(:) = .NOT.arg2(:) .EQ. 0.0
      WHERE (mask11(:))
         add0 = temp6d
         ad = temp6
      END WHERE
      ad0d = tempdd
      ad0 = tempd
      ad1 = tempd0
      a = temp
      amix = 0.0
      bmix = 0.0
      bmixd = 0.0_pr
      amixd = 0.0_pr
      amixd0 = 0.0_pr
      amixdd = 0.0_pr
      amixddd = 0.0_pr
      amixd1 = 0.0_pr
      amixd0d = 0.0_pr
      amixdd0 = 0.0_pr
      DO i=1,SIZE(n)-1
         DO j=i+1,SIZE(n)
            nijd = n(j)*nd(i) + n(i)*nd(j)
            nij = n(i)*n(j)
            temp0 = 2*(-kij(i, j)+1)
            temp7d = nijd*ad1(i) + nij*add0(i)
            temp7 = nijd*a(i) + nij*ad(i)
            temp15 = nijd*ad0(i) + nij*add(i)
            amixddd = amixddd + temp0*(ad0(j)*temp7d+temp7*ad0d(j)+temp15*&
            &         ad1(j)+a(j)*(nijd*ad0d(i)+nij*addd(i))+nij*(ad0(i)*add0(j)+ad(&
            &         j)*ad0d(i)+add(j)*ad1(i)+a(i)*addd(j)))
            amixdd = amixdd + temp0*(temp7*ad0(j)+a(j)*temp15+nij*(ad(j)*ad0&
            &         (i)+a(i)*add(j)))
            amixdd0 = amixdd0 + temp0*(temp7*ad1(j)+a(j)*temp7d+nij*(ad(j)*&
            &         ad1(i)+a(i)*add0(j)))
            amixd = amixd + temp0*(a(j)*temp7+nij*(a(i)*ad(j)))
            amixd0d = amixd0d + temp0*nij*(ad0(i)*ad1(j)+a(j)*ad0d(i)+ad0(j)&
            &         *ad1(i)+a(i)*ad0d(j))
            amixd0 = amixd0 + temp0*nij*(a(j)*ad0(i)+a(i)*ad0(j))
            amixd1 = amixd1 + temp0*nij*(a(j)*ad1(i)+a(i)*ad1(j))
            amix = amix + temp0*(nij*a(i)*a(j))
            bmixd = bmixd + (b(i)+b(j))*(1-lij(i, j))*nijd
            bmix = bmix + nij*(b(i)+b(j))*(1-lij(i, j))
         END DO
      END DO
      arg1ddd(:) = 2**2*n*nd*(ad0*ad1+a*ad0d) + n**2*2*(ad0*add0+ad*ad0d+&
      &     add*ad1+a*addd)
      arg1dd(:) = n*2**2*nd*a*ad0 + n**2*2*(ad*ad0+a*add)
      arg1dd0(:) = n*2**2*nd*a*ad1 + n**2*2*(ad*ad1+a*add0)
      arg1d(:) = a**2*2*n*nd + n**2*2*a*ad
      arg1d0d(:) = n**2*2*(ad0*ad1+a*ad0d)
      arg1d0(:) = n**2*2*a*ad0
      arg1d1(:) = n**2*2*a*ad1
      arg1(:) = n**2*a**2
      amixddd = amixddd + SUM(arg1ddd(:))
      amixdd = amixdd + SUM(arg1dd(:))
      amixdd0 = amixdd0 + SUM(arg1dd0(:))
      amixd = amixd + SUM(arg1d(:))
      amixd0d = amixd0d + SUM(arg1d0d(:))
      amixd0 = amixd0 + SUM(arg1d0(:))
      amixd1 = amixd1 + SUM(arg1d1(:))
      amix = amix + SUM(arg1(:))
      arg10d(:) = model%b*2*n*nd
      arg10(:) = n**2*model%b
      bmixd = bmixd + SUM(arg10d(:))
      bmix = bmix + SUM(arg10(:))
      temp0 = SUM(n)
      bmixd = (bmixd-bmix*SUM(nd)/temp0)/temp0
      bmix = bmix/temp0
      temp15 = bmix*vd/v
      temp7d = -(temp15*vd1/v)
      temp7 = temp15
      temp15 = (bmixd-temp7)/v
      temp8d = (-temp7d-temp15*vd1)/v
      temp8 = temp15
      temp15 = (temp7/v-temp8)/v
      b_vddd = vd0*((temp7d-temp7*vd1/v)/v-temp8d-temp15*vd1)/v
      b_vdd = vd0*temp15
      b_vdd0 = temp8d
      b_vd = temp8
      temp15 = bmix*vd0/(v*v)
      b_vd0d = temp15*2*vd1/v
      b_vd0 = -temp15
      b_vd1 = -(bmix*vd1/v**2)
      b_v = bmix/v
      temp15 = (del1*b_v+1.0)/(del2*b_v+1.0)
      temp8d = (del1-temp15*del2)*b_vd1/(del2*b_v+1.0)
      temp8 = temp15
      temp15 = b_vd0/(del2*b_v+1.0)
      temp0dd = (del1-del2*temp8)*(b_vd0d-temp15*del2*b_vd1)/(del2*b_v+1.0&
      &     ) - temp15*del2*temp8d
      temp0d = (del1-del2*temp8)*temp15
      temp0d0 = temp8d
      temp0 = temp8
      temp15 = b_vd/(del2*b_v+1.0)
      temp8d = (b_vdd0-temp15*del2*b_vd1)/(del2*b_v+1.0)
      temp8 = temp15
      temp15 = b_vdd - del2*temp8*b_vd0
      temp16 = (del1-del2*temp0)/(del2*b_v+1.0)
      arg11ddd = temp15*(-(del2*temp0d0)-temp16*del2*b_vd1)/(del2*b_v+1.0)&
      &     + temp16*(b_vddd-del2*(b_vd0*temp8d+temp8*b_vd0d)) - del2*(temp0d*&
      &     temp8d+temp8*temp0dd)
      arg11dd = temp16*temp15 - del2*(temp8*temp0d)
      arg11dd0 = (del1-del2*temp0)*temp8d - temp8*del2*temp0d0
      arg11d = (del1-del2*temp0)*temp8
      arg11d0d = temp0dd
      arg11d0 = temp0d
      arg11d1 = temp0d0
      arg11 = temp0
      temp16 = b_vd0/(-b_v+1.0)
      temp0dd = -((b_vd0d+temp16*b_vd1)/(1.0-b_v))
      temp0d = -temp16
      temp0d0 = -(b_vd1/(1.0-b_v))
      temp0 = LOG(-b_v + 1.0)
      temp1 = SUM(n)
      temp2d = r*bmix*(del1-del2)*td0
      temp2d0 = r*bmix*(del1-del2)*td1
      temp2 = r*(del1-del2)*t*bmix
      temp16 = (amixd0-temp2d*amix/temp2)/temp2
      temp3dd = (amixd0d-temp2d*(amixd1-amix*temp2d0/temp2)/temp2-temp16*&
      &     temp2d0)/temp2
      temp3d = temp16
      temp3d0 = (amixd1-amix*temp2d0/temp2)/temp2
      temp3 = amix/temp2
      temp4dd = (arg11d0d-arg11d0*arg11d1/arg11)/arg11
      temp4d = arg11d0/arg11
      temp4d0 = arg11d1/arg11
      temp4 = LOG(arg11)
      temp5dd = -(temp1*temp0dd) - temp4d*temp3d0 - temp3*temp4dd - temp3d&
      &     *temp4d0 - temp4*temp3dd
      temp5d = -(temp1*temp0d) - temp3*temp4d - temp4*temp3d
      temp5d0 = -(temp1*temp0d0) - temp3*temp4d0 - temp4*temp3d0
      temp5 = -(temp1*temp0) - temp4*temp3
      temp8d = (temp4d0-temp4*temp2d0/temp2)/temp2
      temp8 = temp4/temp2
      temp7d = bmixd*td1
      temp7 = bmix*td + bmixd*t
      temp9d = amixdd0 - r*(del1-del2)*(temp7*temp3d0+temp3*temp7d)
      temp9 = amixd - r*(del1-del2)*temp3*temp7
      temp16 = temp3*arg11d/arg11
      temp10d = (arg11d*temp3d0+temp3*arg11dd0-temp16*arg11d1)/arg11
      temp10 = temp16
      temp11 = SUM(nd)
      temp16 = b_vd/(-b_v+1.0)
      temp12d = (b_vdd0+temp16*b_vd1)/(1.0-b_v)
      temp12 = temp16
      temp13d = temp1*temp12d - temp11*temp0d0 - temp10d - temp8*temp9d - &
      &     temp9*temp8d
      temp13 = temp1*temp12 - temp11*temp0 - temp10 - temp9*temp8
      temp16 = temp9/temp2
      temp15 = amixdd - r*(del1-del2)*(temp7*temp3d+bmixd*td0*temp3)
      temp17 = (arg11d*temp3d+temp3*arg11dd-temp10*arg11d0)/arg11
      temp18 = (b_vdd+temp12*b_vd0)/(-b_v+1.0)
      temp19 = temp1*temp18 - temp11*temp0d - temp17 - temp8*temp15 - (&
      &     temp4d-temp2d*temp8)*temp16
      arvalddd = r*(td0*temp13d+temp19*td1+t*(temp1*(b_vddd+b_vd0*temp12d+&
      &     temp12*b_vd0d+temp18*b_vd1)/(1.0-b_v)-temp11*temp0dd-(temp3d*&
      &     arg11dd0+arg11d*temp3dd+arg11dd*temp3d0+temp3*arg11ddd-arg11d0*&
      &     temp10d-temp10*arg11d0d-temp17*arg11d1)/arg11-temp15*temp8d-temp8*&
      &     (amixddd-r*(del1-del2)*(temp3d*temp7d+temp7*temp3dd+bmixd*td0*&
      &     temp3d0))-temp16*(temp4dd-temp2d*temp8d)-(temp4d-temp2d*temp8)*(&
      &     temp9d-temp16*temp2d0)/temp2)+td*temp5dd)
      arvaldd = r*(td0*temp13+t*temp19+td*temp5d)
      arvaldd0 = r*(temp13*td1+t*temp13d+td*temp5d0)
      arvald = r*(t*temp13+td*temp5)
      arvald0d = r*(temp5d*td1+t*temp5dd+td0*temp5d0)
      arvald0 = r*(t*temp5d+temp5*td0)
      arvald1 = r*(t*temp5d0+temp5*td1)
      arval = r*(temp5*t)
   end subroutine AR_D_D_D

!  Differentiation of ar_d in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: arval arvald
!   with respect to varying inputs: t v
!   RW status of diff variables: t:in v:in arval:out arvald:out
!  Differentiation of ar in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: arval
!   with respect to varying inputs: n t v
!   RW status of diff variables: n:in t:in v:in arval:out
   SUBROUTINE AR_D_D(model, n, nd, v, vd0, vd, t, td0, td, arval, arvald0&
   &   , arvald, arvaldd)
      IMPLICIT NONE
      class(TPR76), INTENT(IN) :: model
      REAL(pr), INTENT(IN) :: n(:), v, t
      REAL(pr), INTENT(IN) :: vd0, td0
      REAL(pr), INTENT(IN) :: nd(:), vd, td
      REAL(pr), INTENT(OUT) :: arval
      REAL(pr), INTENT(OUT) :: arvald0
      REAL(pr), INTENT(OUT) :: arvald
      REAL(pr), INTENT(OUT) :: arvaldd
      REAL(pr) :: amix, a(SIZE(n)), ai(SIZE(n)), z2(SIZE(n)), nij
      REAL(pr) :: amixd0, ad0(SIZE(n))
      REAL(pr) :: amixd, ad(SIZE(n)), nijd
      REAL(pr) :: amixdd, add(SIZE(n))
      REAL(pr) :: bmix
      REAL(pr) :: bmixd
      REAL(pr) :: b_v
      REAL(pr) :: b_vd0
      REAL(pr) :: b_vd
      REAL(pr) :: b_vdd
      REAL(pr) :: aij(SIZE(n), SIZE(n)), bij(SIZE(n), SIZE(n))
      INTEGER :: i, j
      REAL(pr) :: tc(SIZE(n)), pc(SIZE(n)), w(SIZE(n))
      REAL(pr) :: ac(SIZE(n)), b(SIZE(n)), k(SIZE(n))
      REAL(pr) :: del1, del2
      REAL(pr) :: kij(SIZE(n), SIZE(n)), lij(SIZE(n), SIZE(n))
      INTRINSIC SQRT
      INTRINSIC SUM
      INTRINSIC LOG
      INTRINSIC SIZE
      REAL(pr), DIMENSION(SIZE(n)) :: arg1
      REAL(pr), DIMENSION(SIZE(n)) :: arg1d0
      REAL(pr), DIMENSION(SIZE(n)) :: arg1d
      REAL(pr), DIMENSION(SIZE(n)) :: arg1dd
      REAL(pr), DIMENSION(SIZE(n)) :: result1
      REAL(pr), DIMENSION(SIZE(n)) :: result1d0
      REAL(pr), DIMENSION(SIZE(n)) :: result1d
      REAL(pr), DIMENSION(SIZE(n)) :: result1dd
      REAL(pr), DIMENSION(SIZE(n)) :: arg2
      REAL(pr), DIMENSION(SIZE(n)) :: arg2d0
      REAL(pr), DIMENSION(SIZE(n)) :: arg2d
      REAL(pr), DIMENSION(SIZE(n)) :: arg2dd
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10d
      REAL(pr) :: arg11
      REAL(pr) :: arg11d0
      REAL(pr) :: arg11d
      REAL(pr) :: arg11dd
      REAL(pr), DIMENSION(SIZE(n)) :: temp
      REAL(pr), DIMENSION(SIZE(n)) :: tempd
      REAL(pr) :: temp0
      REAL(pr) :: temp0d
      REAL(pr) :: temp1
      REAL(pr) :: temp2
      REAL(pr) :: temp2d
      REAL(pr) :: temp3
      REAL(pr) :: temp3d
      REAL(pr) :: temp4
      REAL(pr) :: temp4d
      REAL(pr) :: temp5
      REAL(pr) :: temp5d

      REAL(pr), DIMENSION(SIZE(n)) :: temp6
      REAL(pr) :: temp7
      REAL(pr) :: temp8
      REAL(pr) :: temp9
      REAL(pr) :: temp10
      REAL(pr) :: temp11
      REAL(pr) :: temp12
      REAL(pr) :: temp13
      LOGICAL, DIMENSION(SIZE(n)) :: mask
      LOGICAL, DIMENSION(SIZE(n)) :: mask0
      LOGICAL, DIMENSION(SIZE(n)) :: mask1
      LOGICAL, DIMENSION(SIZE(n)) :: mask2
      LOGICAL, DIMENSION(SIZE(n)) :: mask3
      LOGICAL, DIMENSION(SIZE(n)) :: mask4
      tc = model%components%tc
      pc = model%components%pc
      w = model%components%w
      ac = model%ac
      b = model%b
      k = model%k
      kij = model%kij
      lij = model%lij
      del1 = model%del1
      del2 = model%del2
      arg1d(:) = td/tc
      arg1d0(:) = td0/tc
      arg1(:) = t/tc
      temp6 = SQRT(arg1(:))
      mask(:) = arg1(:) .EQ. 0.0
      WHERE (mask(:))
         tempd = 0.0_pr
      ELSEWHERE
         tempd = arg1d0(:)/(2.0*temp6)
      END WHERE
      temp = temp6
      mask0(:) = arg1(:) .EQ. 0.0
      WHERE (mask0(:)) result1d = 0.0_pr
      result1dd = 0.0_pr
      mask1(:) = .NOT.arg1(:) .EQ. 0.0
      WHERE (mask1(:))
         temp6 = arg1d(:)/(2.0*temp)
         result1dd = -(temp6*tempd/temp)
         result1d = temp6
      END WHERE
      result1d0 = tempd
      result1 = temp
      arg2dd(:) = -(ac*2*k*((k*(1.0-result1)+1.0)*result1dd-result1d*k*&
      &     result1d0))
      arg2d(:) = -(ac*2*(k*(1.0-result1)+1.0)*k*result1d)
      arg2d0(:) = -(ac*2*(k*(1.0-result1)+1.0)*k*result1d0)
      arg2(:) = ac*(1.0+k*(1.0-result1))**2
      temp6 = SQRT(arg2(:))
      mask2(:) = arg2(:) .EQ. 0.0
      WHERE (mask2(:))
         tempd = 0.0_pr
      ELSEWHERE
         tempd = arg2d0(:)/(2.0*temp6)
      END WHERE
      temp = temp6
      mask3(:) = arg2(:) .EQ. 0.0
      WHERE (mask3(:)) ad = 0.0_pr
      add = 0.0_pr
      mask4(:) = .NOT.arg2(:) .EQ. 0.0
      WHERE (mask4(:))
         temp6 = arg2d(:)/(2.0*temp)
         add = (arg2dd(:)-temp6*2.0*tempd)/(2.0*temp)
         ad = temp6
      END WHERE
      ad0 = tempd
      a = temp
      amix = 0.0
      bmix = 0.0
      bmixd = 0.0_pr
      amixd = 0.0_pr
      amixd0 = 0.0_pr
      amixdd = 0.0_pr
      DO i=1,SIZE(n)-1
         DO j=i+1,SIZE(n)
            nijd = n(j)*nd(i) + n(i)*nd(j)
            nij = n(i)*n(j)
            temp0 = 2*(-kij(i, j)+1)
            temp7 = nijd*a(i) + nij*ad(i)
            amixdd = amixdd + temp0*(temp7*ad0(j)+a(j)*(nijd*ad0(i)+nij*add(&
            &         i))+nij*(ad(j)*ad0(i)+a(i)*add(j)))
            amixd = amixd + temp0*(a(j)*temp7+nij*(a(i)*ad(j)))
            amixd0 = amixd0 + temp0*nij*(a(j)*ad0(i)+a(i)*ad0(j))
            amix = amix + temp0*(nij*a(i)*a(j))
            bmixd = bmixd + (b(i)+b(j))*(1-lij(i, j))*nijd
            bmix = bmix + nij*(b(i)+b(j))*(1-lij(i, j))
         END DO
      END DO
      arg1dd(:) = n*2**2*nd*a*ad0 + n**2*2*(ad*ad0+a*add)
      arg1d(:) = a**2*2*n*nd + n**2*2*a*ad
      arg1d0(:) = n**2*2*a*ad0
      arg1(:) = n**2*a**2
      amixdd = amixdd + SUM(arg1dd(:))
      amixd = amixd + SUM(arg1d(:))
      amixd0 = amixd0 + SUM(arg1d0(:))
      amix = amix + SUM(arg1(:))
      arg10d(:) = model%b*2*n*nd
      arg10(:) = n**2*model%b
      bmixd = bmixd + SUM(arg10d(:))
      bmix = bmix + SUM(arg10(:))
      temp0 = SUM(n)
      bmixd = (bmixd-bmix*SUM(nd)/temp0)/temp0
      bmix = bmix/temp0
      temp7 = bmix*vd/v
      temp8 = (bmixd-temp7)/v
      b_vdd = (temp7/v-temp8)*vd0/v
      b_vd = temp8
      b_vd0 = -(bmix*vd0/v**2)
      b_v = bmix/v
      temp8 = (del1*b_v+1.0)/(del2*b_v+1.0)
      temp0d = (del1-temp8*del2)*b_vd0/(del2*b_v+1.0)
      temp0 = temp8
      temp8 = b_vd/(del2*b_v+1.0)
      arg11dd = (del1-del2*temp0)*(b_vdd-temp8*del2*b_vd0)/(del2*b_v+1.0) &
      &     - temp8*del2*temp0d
      arg11d = (del1-del2*temp0)*temp8
      arg11d0 = temp0d
      arg11 = temp0
      temp0d = -(b_vd0/(1.0-b_v))
      temp0 = LOG(-b_v + 1.0)
      temp1 = SUM(n)
      temp2d = r*bmix*(del1-del2)*td0
      temp2 = r*(del1-del2)*t*bmix
      temp3d = (amixd0-amix*temp2d/temp2)/temp2
      temp3 = amix/temp2
      temp4d = arg11d0/arg11
      temp4 = LOG(arg11)
      temp5d = -(temp1*temp0d) - temp3*temp4d - temp4*temp3d
      temp5 = -(temp1*temp0) - temp4*temp3
      temp8 = temp4/temp2
      temp7 = bmix*td + bmixd*t
      temp9 = amixd - r*(del1-del2)*temp3*temp7
      temp10 = temp3*arg11d/arg11
      temp11 = SUM(nd)
      temp12 = b_vd/(-b_v+1.0)
      temp13 = temp1*temp12 - temp11*temp0 - temp10 - temp9*temp8
      arvaldd = r*(temp13*td0+t*(temp1*(b_vdd+temp12*b_vd0)/(1.0-b_v)-&
      &     temp11*temp0d-(arg11d*temp3d+temp3*arg11dd-temp10*arg11d0)/arg11-&
      &     temp8*(amixdd-r*(del1-del2)*(temp7*temp3d+temp3*bmixd*td0))-temp9*&
      &     (temp4d-temp8*temp2d)/temp2)+td*temp5d)
      arvald = r*(t*temp13+td*temp5)
      arvald0 = r*(t*temp5d+temp5*td0)
      arval = r*(temp5*t)
   end subroutine AR_D_D

!  Differentiation of ar_d in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: nd n t v arval arvald vd td
!   with respect to varying inputs: nd n t v arval arvald vd td
!   RW status of diff variables: nd:incr n:incr t:incr v:incr arval:in-zero
!                arvald:in-zero vd:incr td:incr
!  Differentiation of ar in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: arval
!   with respect to varying inputs: n t v
!   RW status of diff variables: n:in t:in v:in arval:out
   SUBROUTINE AR_D_B(model, n, nb, nd, ndb, v, vb, vd, vdb, t, tb, td, &
   &   tdb, arval, arvalb, arvald, arvaldb)
      IMPLICIT NONE
      class(TPR76), INTENT(IN) :: model
      REAL(pr), INTENT(IN) :: n(:), v, t
      REAL(pr) :: nb(:), vb, tb
      REAL(pr), INTENT(IN) :: nd(:), vd, td
      REAL(pr) :: ndb(:), vdb, tdb
      REAL(pr) :: arval
      REAL(pr) :: arvalb
      REAL(pr) :: arvald
      REAL(pr) :: arvaldb
      REAL(pr) :: amix, a(SIZE(n)), ai(SIZE(n)), z2(SIZE(n)), nij
      REAL(pr) :: amixb, ab(SIZE(n)), nijb
      REAL(pr) :: amixd, ad(SIZE(n)), nijd
      REAL(pr) :: amixdb, adb(SIZE(n)), nijdb
      REAL(pr) :: bmix
      REAL(pr) :: bmixb
      REAL(pr) :: bmixd
      REAL(pr) :: bmixdb
      REAL(pr) :: b_v
      REAL(pr) :: b_vb
      REAL(pr) :: b_vd
      REAL(pr) :: b_vdb
      REAL(pr) :: aij(SIZE(n), SIZE(n)), bij(SIZE(n), SIZE(n))
      INTEGER :: i, j
      REAL(pr) :: tc(SIZE(n)), pc(SIZE(n)), w(SIZE(n))
      REAL(pr) :: ac(SIZE(n)), b(SIZE(n)), k(SIZE(n))
      REAL(pr) :: del1, del2
      REAL(pr) :: kij(SIZE(n), SIZE(n)), lij(SIZE(n), SIZE(n))
      INTRINSIC SQRT
      INTRINSIC SUM
      INTRINSIC LOG
      INTRINSIC SIZE
      REAL(pr), DIMENSION(SIZE(n)) :: arg1
      REAL(pr), DIMENSION(SIZE(n)) :: arg1b
      REAL(pr), DIMENSION(SIZE(n)) :: arg1d
      REAL(pr), DIMENSION(SIZE(n)) :: arg1db
      REAL(pr), DIMENSION(SIZE(n)) :: result1
      REAL(pr), DIMENSION(SIZE(n)) :: result1b
      REAL(pr), DIMENSION(SIZE(n)) :: result1d
      REAL(pr), DIMENSION(SIZE(n)) :: result1db
      REAL(pr), DIMENSION(SIZE(n)) :: arg2
      REAL(pr), DIMENSION(SIZE(n)) :: arg2b
      REAL(pr), DIMENSION(SIZE(n)) :: arg2d
      REAL(pr), DIMENSION(SIZE(n)) :: arg2db
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10b
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10d
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10db
      REAL(pr) :: arg11
      REAL(pr) :: arg11b
      REAL(pr) :: arg11d
      REAL(pr) :: arg11db
      REAL(pr), DIMENSION(SIZE(n)) :: temp
      REAL(pr), DIMENSION(SIZE(n)) :: tempb
      REAL(pr) :: temp0
      REAL(pr) :: temp0b
      REAL(pr) :: temp1
      REAL(pr) :: temp1b
      REAL(pr) :: temp2
      REAL(pr) :: temp2b
      REAL(pr) :: temp3
      REAL(pr) :: temp3b
      REAL(pr) :: temp4
      REAL(pr) :: temp4b
      REAL(pr) :: temp5
      REAL(pr) :: temp5b

      LOGICAL, DIMENSION(SIZE(n)) :: mask
      LOGICAL, DIMENSION(SIZE(n)) :: mask0
      REAL(pr), DIMENSION(SIZE(n)) :: tempb0
      REAL(pr) :: temp6
      REAL(pr) :: tempb1
      REAL(pr) :: temp7
      REAL(pr) :: tempb2
      REAL(pr), DIMENSION(SIZE(n, 1)) :: tempb3
      REAL(pr) :: temp8
      REAL(pr) :: tempb4
      REAL(pr) :: temp9
      REAL(pr) :: temp10
      REAL(pr) :: temp11
      REAL(pr) :: temp12
      REAL(pr) :: tempb5
      REAL(pr) :: tempb6
      REAL(pr) :: tempb7
      REAL(pr) :: tempb8
      INTEGER :: ad_from
      INTEGER :: ad_to
      INTEGER :: ad_to0
      INTEGER :: arg12
      LOGICAL, DIMENSION(SIZE(n)) :: mask1
      LOGICAL, DIMENSION(SIZE(n)) :: mask2
      LOGICAL, DIMENSION(SIZE(n)) :: mask3
      LOGICAL, DIMENSION(SIZE(n)) :: mask4
      tc = model%components%tc
      ac = model%ac
      b = model%b
      k = model%k
      kij = model%kij
      lij = model%lij
      del1 = model%del1
      del2 = model%del2
      arg1d(:) = td/tc
      arg1(:) = t/tc
      temp = SQRT(arg1(:))
      mask(:) = arg1(:) .EQ. 0.0
      WHERE (mask(:))
         result1d = 0.0_pr
      ELSEWHERE
         result1d = arg1d(:)/(2.0*temp)
      END WHERE
      result1 = temp
      arg2d(:) = -(ac*2*(k*(1.0-result1)+1.0)*k*result1d)
      arg2(:) = ac*(1.0+k*(1.0-result1))**2
      arg12 = SIZE(n)
      CALL PUSHREAL8ARRAY(temp, arg12)
      temp = SQRT(arg2(:))
      mask0(:) = arg2(:) .EQ. 0.0
      WHERE (mask0(:))
         ad = 0.0_pr
      ELSEWHERE
         ad = arg2d(:)/(2.0*temp)
      END WHERE
      a = temp
      amix = 0.0
      bmix = 0.0
      bmixd = 0.0_pr
      amixd = 0.0_pr
      DO i=1,SIZE(n)-1
         ad_from = i + 1
         DO j=ad_from,SIZE(n)
            nijd = n(j)*nd(i) + n(i)*nd(j)
            nij = n(i)*n(j)
            temp0 = 2*(-kij(i, j)+1)
            amixd = amixd + temp0*(a(j)*(a(i)*nijd+nij*ad(i))+nij*a(i)*ad(j)&
            &         )
            amix = amix + temp0*(nij*a(i)*a(j))
            bmixd = bmixd + (b(i)+b(j))*(1-lij(i, j))*nijd
            bmix = bmix + nij*(b(i)+b(j))*(1-lij(i, j))
         END DO
         CALL PUSHINTEGER4(j - 1)
         CALL PUSHINTEGER4(ad_from)
      END DO
      CALL PUSHINTEGER4(i - 1)
      arg1d(:) = a**2*2*n*nd + n**2*2*a*ad
      arg1(:) = n**2*a**2
      amixd = amixd + SUM(arg1d(:))
      amix = amix + SUM(arg1(:))
      arg10d(:) = model%b*2*n*nd
      arg10(:) = n**2*model%b
      bmixd = bmixd + SUM(arg10d(:))
      bmix = bmix + SUM(arg10(:))
      temp0 = SUM(n)
      CALL PUSHREAL8(bmixd)
      bmixd = (bmixd-bmix*SUM(nd)/temp0)/temp0
      CALL PUSHREAL8(bmix)
      bmix = bmix/temp0
      b_vd = (bmixd-bmix*vd/v)/v
      b_v = bmix/v
      CALL PUSHREAL8(temp0)
      temp0 = (del1*b_v+1.0)/(del2*b_v+1.0)
      arg11d = (del1-temp0*del2)*b_vd/(del2*b_v+1.0)
      arg11 = temp0
      temp0 = LOG(-b_v + 1.0)
      temp1 = SUM(n)
      temp2 = r*(del1-del2)*t*bmix
      temp3 = amix/temp2
      temp4 = LOG(arg11)
      temp5 = -(temp1*temp0) - temp4*temp3
      tempb4 = r*arvaldb
      temp12 = temp1*b_vd/(-b_v+1.0)
      temp11 = SUM(nd)
      temp10 = temp3*arg11d/arg11
      temp6 = bmix*td + t*bmixd
      temp9 = amixd - r*(del1-del2)*temp3*temp6
      temp7 = temp4/temp2
      temp5b = t*r*arvalb + td*tempb4
      tb = tb + temp5*r*arvalb + (temp12-temp0*temp11-temp10-temp9*temp7)*&
      &     tempb4
      tempb5 = t*tempb4
      tempb6 = tempb5/(1.0-b_v)
      temp0b = -(temp11*tempb5) - temp1*temp5b
      ndb = ndb - temp0*tempb5
      tempb7 = -(tempb5/arg11)
      amixdb = -(temp7*tempb5)
      tempb8 = r*(del1-del2)*temp7*tempb5
      tempb2 = -(temp9*tempb5/temp2)
      temp4b = tempb2 - temp3*temp5b
      temp3b = temp6*tempb8 + arg11d*tempb7 - temp4*temp5b
      temp2b = -(temp7*tempb2) - amix*temp3b/temp2**2
      tempb1 = temp3*tempb8
      tdb = tdb + temp5*tempb4 + bmix*tempb1
      arg11db = temp3*tempb7
      arg11b = temp4b/arg11 - temp10*tempb7
      temp1b = b_vd*tempb6 - temp0*temp5b
      amixb = temp3b/temp2
      tempb4 = r*(del1-del2)*temp2b
      bmixb = td*tempb1 + t*tempb4
      tb = tb + bmixd*tempb1 + bmix*tempb4
      temp0 = (del1*b_v+1.0)/(del2*b_v+1.0)
      temp8 = b_vd/(del2*b_v+1.0)
      tempb4 = (del1-del2*temp0)*arg11db/(del2*b_v+1.0)
      b_vdb = temp1*tempb6 + tempb4
      b_vb = temp12*tempb6 - temp0b/(1.0-b_v) - del2*temp8*tempb4
      temp0b = arg11b - del2*temp8*arg11db
      CALL POPREAL8(temp0)
      tempb4 = temp0b/(del2*b_v+1.0)
      b_vb = b_vb + (del1-del2*(del1*b_v+1.0)/(del2*b_v+1.0))*tempb4
      temp7 = bmix*vd/v
      tempb4 = b_vdb/v
      bmixdb = t*tempb1 + tempb4
      tempb2 = -(tempb4/v)
      bmixb = bmixb + b_vb/v + vd*tempb2
      vb = vb - bmix*b_vb/v**2 - (bmixd-temp7)*tempb4/v - temp7*tempb2
      vdb = vdb + bmix*tempb2
      CALL POPREAL8(bmix)
      CALL POPREAL8(bmixd)
      temp6 = bmix/temp0
      temp8 = SUM(nd)
      tempb2 = bmixdb/temp0
      bmixdb = tempb2
      tempb1 = -(temp8*tempb2/temp0)
      temp0b = -(bmix*bmixb/temp0**2) - (bmixd-temp8*temp6)*tempb2/temp0 -&
      &     temp6*tempb1
      bmixb = bmixb/temp0 + tempb1
      arg10b = 0.0_pr
      arg10b = bmixb
      arg10db = 0.0_pr
      arg10db = bmixdb
      arg1b = 0.0_pr
      arg1b = amixb
      arg1db = 0.0_pr
      arg1db = amixdb
      ab = 0.0_pr
      arg1(:) = t/tc
      adb = 0.0_pr
      tempb3 = 2*a**2*arg1db
      nb = nb + temp1b + temp0b + 2*n*model%b*arg10b + nd*model%b*2*&
      &     arg10db + 2*n*a**2*arg1b + 2**2*n*a*ad*arg1db + nd*tempb3
      ndb = ndb + n*model%b*2*arg10db - temp6*tempb2 + n*tempb3
      tempb0 = 2*n**2*arg1db
      ab = 2*a*n**2*arg1b + 2**2*a*n*nd*arg1db + ad*tempb0
      adb = a*tempb0
      CALL POPINTEGER4(ad_to0)
      DO i=ad_to0,1,-1
         CALL POPINTEGER4(ad_from)
         CALL POPINTEGER4(ad_to)
         DO j=ad_to,ad_from,-1
            temp0 = 2*(-kij(i, j)+1)
            tempb2 = a(j)*temp0*amixb
            nij = n(i)*n(j)
            nijb = (1-lij(i, j))*(b(i)+b(j))*bmixb + a(i)*tempb2
            nijd = n(j)*nd(i) + n(i)*nd(j)
            ab(j) = ab(j) + nij*a(i)*temp0*amixb
            ab(i) = ab(i) + nij*tempb2
            tempb1 = temp0*amixdb
            ab(j) = ab(j) + (a(i)*nijd+nij*ad(i))*tempb1
            tempb2 = a(j)*tempb1
            nijdb = (1-lij(i, j))*(b(i)+b(j))*bmixdb + a(i)*tempb2
            nijb = nijb + a(i)*ad(j)*tempb1 + ad(i)*tempb2
            ab(i) = ab(i) + nij*ad(j)*tempb1 + nijd*tempb2
            adb(j) = adb(j) + nij*a(i)*tempb1
            adb(i) = adb(i) + nij*tempb2
            nb(i) = nb(i) + n(j)*nijb
            nb(j) = nb(j) + n(i)*nijb + nd(i)*nijdb
            ndb(i) = ndb(i) + n(j)*nijdb
            nb(i) = nb(i) + nd(j)*nijdb
            ndb(j) = ndb(j) + n(i)*nijdb
         END DO
      END DO
      tempb = 0.0_pr
      tempb = ab
      arg2db = 0.0_pr
      arg2b = 0.0_pr
      result1b = 0.0_pr
      result1db = 0.0_pr
      arg1d(:) = td/tc
      arg1db = 0.0_pr
      arg1b = 0.0_pr
      mask1(:) = .NOT.mask0(:)
      WHERE (mask1(:))
         tempb0 = adb/(2.0*temp)
         arg2db = tempb0
         tempb = tempb - arg2d*tempb0/temp
      END WHERE
      tempb0 = -(ac*2*k*arg2db)
      arg12 = SIZE(n)
      CALL POPREAL8ARRAY(temp, arg12)
      mask2 = arg2 .EQ. 0.0
      WHERE (mask2)
         arg2b = 0.0_pr
      ELSEWHERE
         arg2b = tempb/(2.0*SQRT(arg2))
      END WHERE
      result1b = -(k*2*(k*(1.0-result1)+1.0)*ac*arg2b) - k*result1d*tempb0
      result1db = (k*(1.0-result1)+1.0)*tempb0
      tempb = 0.0_pr
      tempb = result1b
      mask3(:) = .NOT.mask(:)
      WHERE (mask3(:))
         tempb0 = result1db/(2.0*temp)
         arg1db = tempb0
         tempb = tempb - arg1d*tempb0/temp
      END WHERE
      mask4 = arg1 .EQ. 0.0
      WHERE (mask4)
         arg1b = 0.0_pr
      ELSEWHERE
         arg1b = tempb/(2.0*SQRT(arg1))
      END WHERE
      tb = tb + SUM(arg1b/tc)
      tdb = tdb + SUM(arg1db/tc)
      arvalb = 0.0_pr
      arvaldb = 0.0_pr
   end subroutine AR_D_B

!  Differentiation of ar in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: arval
!   with respect to varying inputs: n t v
!   RW status of diff variables: n:in t:in v:in arval:out
   SUBROUTINE AR_D(model, n, nd, v, vd, t, td, arval, arvald)
      IMPLICIT NONE
      class(TPR76), INTENT(IN) :: model
      REAL(pr), INTENT(IN) :: n(:), v, t
      REAL(pr), INTENT(IN) :: nd(:), vd, td
      REAL(pr), INTENT(OUT) :: arval
      REAL(pr), INTENT(OUT) :: arvald
      REAL(pr) :: amix, a(SIZE(n)), ai(SIZE(n)), z2(SIZE(n)), nij
      REAL(pr) :: amixd, ad(SIZE(n)), nijd
      REAL(pr) :: bmix
      REAL(pr) :: bmixd
      REAL(pr) :: b_v
      REAL(pr) :: b_vd
      REAL(pr) :: aij(SIZE(n), SIZE(n)), bij(SIZE(n), SIZE(n))
      INTEGER :: i, j
      REAL(pr) :: tc(SIZE(n)), pc(SIZE(n)), w(SIZE(n))
      REAL(pr) :: ac(SIZE(n)), b(SIZE(n)), k(SIZE(n))
      REAL(pr) :: del1, del2
      REAL(pr) :: kij(SIZE(n), SIZE(n)), lij(SIZE(n), SIZE(n))
      INTRINSIC SQRT
      INTRINSIC SUM
      INTRINSIC LOG
      INTRINSIC SIZE
      REAL(pr), DIMENSION(SIZE(n)) :: arg1
      REAL(pr), DIMENSION(SIZE(n)) :: arg1d
      REAL(pr), DIMENSION(SIZE(n)) :: result1
      REAL(pr), DIMENSION(SIZE(n)) :: result1d
      REAL(pr), DIMENSION(SIZE(n)) :: arg2
      REAL(pr), DIMENSION(SIZE(n)) :: arg2d
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10d
      REAL(pr) :: arg11
      REAL(pr) :: arg11d
      REAL(pr), DIMENSION(SIZE(n)) :: temp
      REAL(pr) :: temp0
      REAL(pr) :: temp1
      REAL(pr) :: temp2
      REAL(pr) :: temp3
      REAL(pr) :: temp4
      REAL(pr) :: temp5

      LOGICAL, DIMENSION(SIZE(n)) :: mask
      LOGICAL, DIMENSION(SIZE(n)) :: mask0
      tc = model%components%tc
      pc = model%components%pc
      w = model%components%w
      ac = model%ac
      b = model%b
      k = model%k
      kij = model%kij
      lij = model%lij
      del1 = model%del1
      del2 = model%del2
      arg1d(:) = td/tc
      arg1(:) = t/tc
      temp = SQRT(arg1(:))
      mask(:) = arg1(:) .EQ. 0.0
      WHERE (mask(:))
         result1d = 0.0_pr
      ELSEWHERE
         result1d = arg1d(:)/(2.0*temp)
      END WHERE
      result1 = temp
      arg2d(:) = -(ac*2*(k*(1.0-result1)+1.0)*k*result1d)
      arg2(:) = ac*(1.0+k*(1.0-result1))**2
      temp = SQRT(arg2(:))
      mask0(:) = arg2(:) .EQ. 0.0
      WHERE (mask0(:))
         ad = 0.0_pr
      ELSEWHERE
         ad = arg2d(:)/(2.0*temp)
      END WHERE
      a = temp
      amix = 0.0
      bmix = 0.0
      bmixd = 0.0_pr
      amixd = 0.0_pr
      DO i=1,SIZE(n)-1
         DO j=i+1,SIZE(n)
            nijd = n(j)*nd(i) + n(i)*nd(j)
            nij = n(i)*n(j)
            temp0 = 2*(-kij(i, j)+1)
            amixd = amixd + temp0*(a(j)*(a(i)*nijd+nij*ad(i))+nij*a(i)*ad(j)&
            &         )
            amix = amix + temp0*(nij*a(i)*a(j))
            bmixd = bmixd + (b(i)+b(j))*(1-lij(i, j))*nijd
            bmix = bmix + nij*(b(i)+b(j))*(1-lij(i, j))
         END DO
      END DO
      arg1d(:) = a**2*2*n*nd + n**2*2*a*ad
      arg1(:) = n**2*a**2
      amixd = amixd + SUM(arg1d(:))
      amix = amix + SUM(arg1(:))
      arg10d(:) = model%b*2*n*nd
      arg10(:) = n**2*model%b
      bmixd = bmixd + SUM(arg10d(:))
      bmix = bmix + SUM(arg10(:))
      temp0 = SUM(n)
      bmixd = (bmixd-bmix*SUM(nd)/temp0)/temp0
      bmix = bmix/temp0
      b_vd = (bmixd-bmix*vd/v)/v
      b_v = bmix/v
      temp0 = (del1*b_v+1.0)/(del2*b_v+1.0)
      arg11d = (del1-temp0*del2)*b_vd/(del2*b_v+1.0)
      arg11 = temp0
      temp0 = LOG(-b_v + 1.0)
      temp1 = SUM(n)
      temp2 = r*(del1-del2)*t*bmix
      temp3 = amix/temp2
      temp4 = LOG(arg11)
      temp5 = -(temp1*temp0) - temp4*temp3
      arvald = r*(t*(temp1*b_vd/(1.0-b_v)-temp0*SUM(nd)-temp3*arg11d/arg11&
      &     -temp4*(amixd-temp3*r*(del1-del2)*(bmix*td+t*bmixd))/temp2)+temp5*&
      &     td)
      arval = r*(temp5*t)
   end subroutine AR_D

!  Differentiation of ar in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: arval
!   with respect to varying inputs: n t v arval
!   RW status of diff variables: n:out t:out v:out arval:in-zero
   SUBROUTINE AR_B(model, n, nb, v, vb, t, tb, arval, arvalb)
      IMPLICIT NONE
      class(TPR76), INTENT(IN) :: model
      REAL(pr), INTENT(IN) :: n(:), v, t
      REAL(pr) :: nb(:), vb, tb
      REAL(pr) :: arval
      REAL(pr) :: arvalb
      REAL(pr) :: amix, a(SIZE(n)), ai(SIZE(n)), z2(SIZE(n)), nij
      REAL(pr) :: amixb, ab(SIZE(n)), nijb
      REAL(pr) :: bmix
      REAL(pr) :: bmixb
      REAL(pr) :: b_v
      REAL(pr) :: b_vb
      REAL(pr) :: aij(SIZE(n), SIZE(n)), bij(SIZE(n), SIZE(n))
      INTEGER :: i, j
      REAL(pr) :: tc(SIZE(n)), pc(SIZE(n)), w(SIZE(n))
      REAL(pr) :: ac(SIZE(n)), b(SIZE(n)), k(SIZE(n))
      REAL(pr) :: del1, del2
      REAL(pr) :: kij(SIZE(n), SIZE(n)), lij(SIZE(n), SIZE(n))
      INTRINSIC SQRT
      INTRINSIC SUM
      INTRINSIC LOG
      INTRINSIC SIZE
      REAL(pr), DIMENSION(SIZE(n)) :: arg1
      REAL(pr), DIMENSION(SIZE(n)) :: arg1b
      REAL(pr), DIMENSION(SIZE(n)) :: result1
      REAL(pr), DIMENSION(SIZE(n)) :: result1b
      REAL(pr), DIMENSION(SIZE(n)) :: arg2
      REAL(pr), DIMENSION(SIZE(n)) :: arg2b
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10b
      REAL(pr) :: arg11
      REAL(pr) :: arg11b

      REAL(pr) :: temp
      REAL(pr) :: tempb
      REAL(pr) :: temp0
      REAL(pr) :: temp1
      REAL(pr) :: temp2
      REAL(pr) :: temp3
      REAL(pr) :: temp4
      REAL(pr) :: tempb0
      REAL(pr) :: tempb1
      INTEGER :: ad_from
      INTEGER :: ad_to
      INTEGER :: ad_to0
      tc = model%components%tc
      ac = model%ac
      b = model%b
      k = model%k
      kij = model%kij
      lij = model%lij
      del1 = model%del1
      del2 = model%del2
      arg1(:) = t/tc
      result1 = SQRT(arg1(:))
      arg2(:) = ac*(1.0+k*(1.0-result1))**2
      a = SQRT(arg2(:))
      amix = 0.0
      bmix = 0.0
      DO i=1,SIZE(n)-1
         ad_from = i + 1
         DO j=ad_from,SIZE(n)
            nij = n(i)*n(j)
            amix = amix + 2*nij*(a(i)*a(j))*(1-kij(i, j))
            bmix = bmix + nij*(b(i)+b(j))*(1-lij(i, j))
         END DO
         CALL PUSHINTEGER4(j - 1)
         CALL PUSHINTEGER4(ad_from)
      END DO
      CALL PUSHINTEGER4(i - 1)
      arg1(:) = n**2*a**2
      amix = amix + SUM(arg1(:))
      arg10(:) = n**2*model%b
      bmix = bmix + SUM(arg10(:))
      CALL PUSHREAL8(bmix)
      bmix = bmix/SUM(n)
      b_v = bmix/v
      arg11 = (1.0+del1*b_v)/(1.0+del2*b_v)
      nb = 0.0_pr
      temp0 = LOG(-b_v + 1.0)
      temp1 = SUM(n)
      temp2 = r*(del1-del2)*t*bmix
      temp3 = amix/temp2
      temp4 = LOG(arg11)
      tempb = t*r*arvalb
      nb = -(temp0*tempb)
      b_vb = temp1*tempb/(1.0-b_v)
      arg11b = -(temp3*tempb/arg11)
      tempb0 = -(temp4*tempb/temp2)
      amixb = tempb0
      tempb1 = -(r*(del1-del2)*temp3*tempb0)
      tb = (-(temp1*temp0)-temp4*temp3)*r*arvalb + bmix*tempb1
      tempb = arg11b/(del2*b_v+1.0)
      b_vb = b_vb + (del1-del2*(del1*b_v+1.0)/(del2*b_v+1.0))*tempb
      bmixb = t*tempb1 + b_vb/v
      vb = -(bmix*b_vb/v**2)
      CALL POPREAL8(bmix)
      temp = SUM(n)
      nb = nb - bmix*bmixb/temp**2
      bmixb = bmixb/temp
      arg10b = 0.0_pr
      arg10b = bmixb
      arg1b = 0.0_pr
      arg1b = amixb
      nb = nb + 2*n*model%b*arg10b + 2*n*a**2*arg1b
      ab = 0.0_pr
      ab = 2*a*n**2*arg1b
      CALL POPINTEGER4(ad_to0)
      DO i=ad_to0,1,-1
         CALL POPINTEGER4(ad_from)
         CALL POPINTEGER4(ad_to)
         DO j=ad_to,ad_from,-1
            tempb = (1-kij(i, j))*2*amixb
            nij = n(i)*n(j)
            nijb = (1-lij(i, j))*(b(i)+b(j))*bmixb + a(i)*a(j)*tempb
            ab(i) = ab(i) + nij*a(j)*tempb
            ab(j) = ab(j) + nij*a(i)*tempb
            nb(i) = nb(i) + n(j)*nijb
            nb(j) = nb(j) + n(i)*nijb
         END DO
      END DO
      arg2b = 0.0_pr
      WHERE (arg2 .EQ. 0.0)
         arg2b = 0.0_pr
      ELSEWHERE
         arg2b = ab/(2.0*SQRT(arg2))
      END WHERE
      result1b = 0.0_pr
      result1b = -(k*2*(k*(1.0-result1)+1.0)*ac*arg2b)
      arg1(:) = t/tc
      arg1b = 0.0_pr
      WHERE (arg1 .EQ. 0.0)
         arg1b = 0.0_pr
      ELSEWHERE
         arg1b = result1b/(2.0*SQRT(arg1))
      END WHERE
      tb = tb + SUM(arg1b/tc)
      arvalb = 0.0_pr
   end subroutine AR_B

   SUBROUTINE AR(model, n, v, t, arval)
      IMPLICIT NONE
      class(TPR76), INTENT(IN) :: model
      REAL(pr), INTENT(IN) :: n(:), v, t
      REAL(pr), INTENT(OUT) :: arval
      REAL(pr) :: amix, a(SIZE(n)), ai(SIZE(n)), z2(SIZE(n)), nij
      REAL(pr) :: bmix
      REAL(pr) :: b_v
      REAL(pr) :: aij(SIZE(n), SIZE(n)), bij(SIZE(n), SIZE(n))
      INTEGER :: i, j
      REAL(pr) :: tc(SIZE(n)), pc(SIZE(n)), w(SIZE(n))
      REAL(pr) :: ac(SIZE(n)), b(SIZE(n)), k(SIZE(n))
      REAL(pr) :: del1, del2
      REAL(pr) :: kij(SIZE(n), SIZE(n)), lij(SIZE(n), SIZE(n))
      INTRINSIC SQRT
      INTRINSIC SUM
      INTRINSIC LOG
      INTRINSIC SIZE
      REAL(pr), DIMENSION(SIZE(n)) :: arg1
      REAL(pr), DIMENSION(SIZE(n)) :: result1
      REAL(pr), DIMENSION(SIZE(n)) :: arg2
      REAL(pr), DIMENSION(SIZE(n, 1)) :: arg10
      REAL(pr) :: arg11

      tc = model%components%tc
      pc = model%components%pc
      w = model%components%w
      ac = model%ac
      b = model%b
      k = model%k
      kij = model%kij
      lij = model%lij
      del1 = model%del1
      del2 = model%del2
      arg1(:) = t/tc
      result1 = SQRT(arg1(:))
      arg2(:) = ac*(1.0+k*(1.0-result1))**2
      a = SQRT(arg2(:))
      amix = 0.0
      bmix = 0.0
      DO i=1,SIZE(n)-1
         DO j=i+1,SIZE(n)
            nij = n(i)*n(j)
            amix = amix + 2*nij*(a(i)*a(j))*(1-kij(i, j))
            bmix = bmix + nij*(b(i)+b(j))*(1-lij(i, j))
         END DO
      END DO
      arg1(:) = n**2*a**2
      amix = amix + SUM(arg1(:))
      arg10(:) = n**2*model%b
      bmix = bmix + SUM(arg10(:))
      bmix = bmix/SUM(n)
      b_v = bmix/v
      arg11 = (1.0+del1*b_v)/(1.0+del2*b_v)
      arval = (-(SUM(n)*LOG(1.0-b_v))-amix/(r*t*bmix)*1.0/(del1-del2)*LOG(&
      &     arg11))*(r*t)
   end subroutine AR

   FUNCTION VOLUME_INITALIZER(self, n, p, t) RESULT (v0)
      IMPLICIT NONE
      class(TPR76), INTENT(IN) :: self
      REAL(pr), INTENT(IN) :: n(:)
      REAL(pr), INTENT(IN) :: p
      REAL(pr), INTENT(IN) :: t
      REAL(pr) :: v0
      INTRINSIC SUM
      v0 = SUM(n*self%b)/SUM(self%b)
   end function VOLUME_INITALIZER

end module autodiff_tapenade_pr76_demo

