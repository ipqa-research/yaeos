var tipuesearch = {"pages":[{"title":" yaeos ","text":"yaeos Documentation Developers Available models Available properties A little taste of yaeos How to install/run it Dependencies Debian/Ubuntu-like Installing yaeos Developing with vscode Available examples Including new models with Automatic Differentiation. Hyperdual Numbers autodiff Tapenade-based autodiff There are multiple open source equations of state libraries, like: Clapeyron julia FeOs rust with Python bindings teqp C++ with Python bindings thermo python thermopack Fortran with Python bindings CoolProp C++ with Python bindings Here we are presenting yet another (still in development) one, that tackles the\nsame problem just, in another way. Mostly exploiting the readability and\nextensibility of Modern Fortran for scientists to have an easy way to implement\nnew thermodynamic models without dealing with lower-level languages but still\ngetting decent performance.\nAnd also this framework provides the possibility of using analytically obtained\nderivatives, so both options are easily available. This is an experimental work in progress, and we recommend the before\nmentioned libraries if you are intending to use some of this in real work.\nBig part of the code comes from a refactoring process of older codes so\nnot all parts are easily readable, yet. We focus mainly on that the addition of a new thermodynamic model as easily as\npossible. Also providing our models too! Documentation The latest API documentation for the main branch can be found:\n   - Fortran API documentation - Python API documentation The Fortran API documentation can also be generated by processing the source\nfiles with FORD . On the\nother hand, the Python API documentation can be generated by processing the\nsource files with Sphinx . Developers This library is currently maintained by the research group of Prof. Martín Cismondi-Duarte at IPQA (UNC-CONICET) Available models CubicEoS SoaveRedlichKwong PengRobinson76 PengRobinson78 ExcessGibbs models NRTL UNIFAC VLE Available properties Bulk Properties Volume(n, P, T) Pressure(n, V, T) Residual Properties H&#94;R(n, V, T) S&#94;R(n, V, T) G&#94;R(n, V, T) Cv&#94;R(n, V, T) Cp&#94;R(n, V, T) Phase-Equilibria FlashPT, FlashVT Saturation points (bubble, dew and liquid-liquid) Phase Envelope PT (isopleths) A little taste of yaeos A lot of users get the bad picture of Fortran being old and archaic since most\nof the codes they’ve seen are written in ancient F77 . use yaeos , only : PengRobinson76 , ArModel integer , parameter :: n = 2 ! Number of components real ( 8 ) :: V , T , P , dPdN ( n ) ! variables to calculate class ( ArModel ), allocatable :: model ! Model real ( pr ) :: z ( n ), tc ( n ), pc ( n ), w ( n ), kij ( n , n ), lij ( n , n ) z = [ 0.3 , 0.7 ] tc = [ 19 0. , 31 0. ] pc = [ 1 4. , 3 0. ] w = [ 0.001 , 0.03 ] kij = reshape ([ 0. , 0.1 , 0.1 , 0. ], [ n , n ]) lij = kij / 2 model = PengRobinson76 ( tc , pc , w , kij , lij ) V = 1 T = 150 call model % pressure ( z , V , T , P ) print * , P ! Obtain derivatives adding them as optional arguments! call model % pressure ( model , z , V , T , P , dPdN = dPdN ) print * , dPdN Examples of code with simple applications showing the capabilities of yaeos can be found at example/tutorials . Each example can be run\nwith: fpm run --example <example name here> Not providing any examples will show all the possible examples that can be run. How to install/run it Dependencies yaeos needs to have both lapack and nlopt libraries on your system. Debian/Ubuntu-like sudo apt install libnlopt-dev libblas-dev liblapack-dev Installing yaeos yaeos is intended to use as a fpm package. fpm is the Fortran Package Manager, which automates the compilation and running\nprocess of Fortran libraries/programs. You can either: Generate a new project that uses yaeos as a dependency with: bash\nfpm new my_project In the fpm.toml file add: toml\n[dependencies]\nyaeos = {git=\"https://github.com/ipqa-research/yaeos\"} Clone this repository and just modify the executables in the app directory bash\ngit clone https://github.com/ipqa-research/yaeos\ncd yaeos\nfpm run Developing with vscode If your intention is either to develop for yaeos or to explore in more detail\nthe library with debugging. We provide some predefined defuaults to work with vscode . You can add them to the cloned repository by running: git clone https://github.com/ipqa-research/vscode-fortran .vscode From the project main directory Available examples In this repository we provide a series of examples of the different things that\ncan be calculated with yaeos . The source codes for the examples can be seen\nat the example/tutorials directory. All the examples can be run with fpm run --example <example_name_here> Including new models with Automatic Differentiation. Hyperdual Numbers autodiff We are using the hyperdual module developed by Philipp Rehner and Gernot Bauer The automatic differentiation API isn’t fully optimized yet so performance is\nmuch slower than it should be. A complete implementation of the PR76 Equation of State can me found in example/adiff/adiff_pr76.f90 . Or in the documentation pages. Tapenade-based autodiff It is also possible to differentiate with tapenade . Examples can be seen\nin the documentation pages or in The tools directory Developer Info Federico Benelli PhD student with focus on reservoir PVT simulation.","tags":"home","url":"index.html"},{"title":"NRTL – yaeos ","text":"type, public, extends( GeModelTapenade ) :: NRTL Non-Random-Two-Liquid model with: Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: a (:,:) A_{ij} matrix real(kind=pr), public, allocatable :: b (:,:) B_{ij} matrix real(kind=pr), public, allocatable :: c (:,:) C_{ij} matrix type( Substances ), public :: components Substances contained in the module Constructor public        interface NRTL public  function init (a, b, c) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: a (:,:) real(kind=pr), intent(in) :: b (:,:) real(kind=pr), intent(in) :: c (:,:) Return Value type( NRTL ) Type-Bound Procedures procedure, public :: excess_enthalpy public  subroutine excess_enthalpy (self, n, T, He, HeT, Hen) Calculate Excess enthalpy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: He Excess enthalpy real(kind=pr), intent(out), optional :: HeT real(kind=pr), intent(out), optional :: Hen (:) procedure, public :: excess_entropy public  subroutine excess_entropy (self, n, T, Se, SeT, Sen) Calculate Excess entropy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Se Excess entropy real(kind=pr), intent(out), optional :: SeT real(kind=pr), intent(out), optional :: Sen (:) procedure, public :: excess_gibbs private  subroutine excess_gibbs (self, n, t, Ge, GeT, GeT2, Gen, GeTn, Gen2) Excess Gibbs model generic interface Arguments Type Intent Optional Attributes Name class( GeModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ge real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Gen real(kind=pr), intent(out), optional, dimension(size(n)) :: GeTn real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) procedure, public :: ge => EXCESS_GIBBS public  subroutine EXCESS_GIBBS (model, n, t, ge) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ge procedure, public :: ge_b => EXCESS_GIBBS_B public  subroutine EXCESS_GIBBS_B (model, n, nb, t, tb, ge, geb) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: ge real(kind=pr) :: geb procedure, public :: ge_d => EXCESS_GIBBS_D public  subroutine EXCESS_GIBBS_D (model, n, nd, t, td, ge, ged) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged procedure, public :: ge_d_b => EXCESS_GIBBS_D_B public  subroutine EXCESS_GIBBS_D_B (model, n, nb, nd, ndb, t, tb, td, tdb, ge, geb, ged, gedb) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr) :: ndb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr), intent(in) :: td real(kind=pr) :: tdb real(kind=pr) :: ge real(kind=pr) :: geb real(kind=pr) :: ged real(kind=pr) :: gedb procedure, public :: ge_d_d => EXCESS_GIBBS_D_D public  subroutine EXCESS_GIBBS_D_D (model, n, nd, t, td0, td, ge, ged0, ged, gedd) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged0 real(kind=pr), intent(out) :: ged real(kind=pr), intent(out) :: gedd procedure, public :: ln_activity_coefficient public  subroutine ln_activity_coefficient (self, n, T, lngamma, dlngammadT, dlngammadn) Calculate natural logarithm of activity coefficients. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: lngamma (:) Natural logarithm of activity coefficients real(kind=pr), intent(out), optional :: dlngammadT (size(n)) real(kind=pr), intent(out), optional :: dlngammadn (size(n),size(n))","tags":"","url":"type/nrtl.html"},{"title":"PsiFunction – yaeos ","text":"type, public, abstract :: PsiFunction function UNIFAC functions abstract type Description Abstract derived type for UNIFAC models temperature dependent functions Type-Bound Procedures procedure( temperature_dependence ), public, deferred :: psi subroutine temperature_dependence(self, systems_groups, T, psi, dpsi_dt, dpsi_dt2) Prototype temperature_dependence interface Interface subroutine for UNIFAC models temperature dependent\nfunctions Arguments Type Intent Optional Attributes Name class( PsiFunction ) :: self PsiFunction type variable class( Groups ) :: systems_groups Groups type variable containig all the system’s groups. See the groups_stew variable on the UNIFAC documentation. real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: psi (:,:) real(kind=pr), intent(out), optional :: dpsi_dt (:,:) real(kind=pr), intent(out), optional :: dpsi_dt2 (:,:)","tags":"","url":"type/psifunction.html"},{"title":"QuadraticPsi – yaeos ","text":"type, public, extends( PsiFunction ) :: QuadraticPsi Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: Aij (:,:) real(kind=pr), public, allocatable :: Bij (:,:) real(kind=pr), public, allocatable :: Cij (:,:) Type-Bound Procedures procedure, public :: psi => Quadratic_temperature_dependence public  subroutine Quadratic_temperature_dependence (self, systems_groups, T, psi, dpsi_dt, dpsi_dt2) Read more… Arguments Type Intent Optional Attributes Name class( QuadraticPsi ) :: self function class( Groups ) :: systems_groups Groups in the system real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: psi (:,:) real(kind=pr), intent(out), optional :: dpsi_dt (:,:) real(kind=pr), intent(out), optional :: dpsi_dt2 (:,:)","tags":"","url":"type/quadraticpsi.html"},{"title":"UNIFACPsi – yaeos ","text":"type, public, extends( PsiFunction ) :: UNIFACPsi Original UNIFAC function References Dortmund Data Bank Software & Separation Technology Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975).\nGroup‐contribution estimation of activity coefficients in nonideal liquid\nmixtures. AIChE Journal, 21(6), 1086–1099. https://doi.org/10.1002/aic.690210607 Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979).\nVapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and\nExtension. Industrial & Engineering Chemistry Process Design and\nDevelopment, 18(4), 714–722. https://doi.org/10.1021/i260072a024 Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid\nequilibriums by UNIFAC group contribution. Revision and extension. 2.\nIndustrial & Engineering Chemistry Process Design and Development, 21(1),\n118–127. https://doi.org/10.1021/i200016a021 Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983).\nVapor-liquid equilibriums by UNIFAC group contribution. Revision and\nextension. 3. Industrial & Engineering Chemistry Process Design and\nDevelopment, 22(4), 676–678. https://doi.org/10.1021/i200023a023 Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987).\nVapor-liquid equilibria by UNIFAC group contribution. 4. Revision and\nextension. Industrial & Engineering Chemistry Research, 26(1), 159–161. https://doi.org/10.1021/ie00061a030 Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., &\nGmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group\ncontribution. 5. Revision and extension. Industrial & Engineering\nChemistry Research, 30 (10), 2352–2355. https://doi.org/10.1021/ie00058a017 Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria\nby UNIFAC Group Contribution. 6. Revision and Extension. Industrial &\nEngineering Chemistry Research, 42(1), 183–188. https://doi.org/10.1021/ie020506l SINTEF - Thermopack Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: Aij (:,:) Type-Bound Procedures procedure, public :: psi => UNIFAC_temperature_dependence public  subroutine UNIFAC_temperature_dependence (self, systems_groups, T, psi, dpsi_dt, dpsi_dt2) Implementation of the function of the UNIFAC model. Read more… Arguments Type Intent Optional Attributes Name class( UNIFACPsi ) :: self function class( Groups ) :: systems_groups Groups in the system real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: psi (:,:) real(kind=pr), intent(out), optional :: dpsi_dt (:,:) real(kind=pr), intent(out), optional :: dpsi_dt2 (:,:)","tags":"","url":"type/unifacpsi.html"},{"title":"TXEnvelMP – yaeos ","text":"type, public :: TXEnvelMP Multiphase PT envelope. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) type( MPPoint ), public, allocatable :: points (:) Array of converged points. real(kind=pr), public, allocatable :: z0 (:) real(kind=pr), public, allocatable :: zi (:) Type-Bound Procedures procedure, public, nopass :: get_values_from_X private  subroutine get_values_from_X (X, np, z0, zi, beta_w, x_l, w, betas, T, alpha) Extract the values of the variables from the vector X. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: z0 (:) Initial mixture composition. real(kind=pr), intent(in) :: zi (:) Second mixture composition. real(kind=pr), intent(in) :: beta_w Reference phase beta. real(kind=pr), intent(out) :: x_l (np,size(z0)) Mole fractions of the main phases. real(kind=pr), intent(out) :: w (size(z0)) Mole fractions of the incipient phase. real(kind=pr), intent(out) :: betas (np) Fractions of the main phases. real(kind=pr), intent(out) :: T Pressure [bar]. real(kind=pr), intent(out) :: alpha . procedure, public, nopass :: solve_point private  subroutine solve_point (model, z0, zi, np, P, beta_w, X, ns, S, dXdS, F, df, iters, max_iterations) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) integer, intent(in) :: np Number of main phases real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(in) :: dXdS (size(X)) real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix integer, intent(out) :: iters integer, intent(in) :: max_iterations procedure, public :: write => write_envelope_TX_MP private  subroutine write_envelope_TX_MP (env, unit) Arguments Type Intent Optional Attributes Name class( TXEnvelMP ), intent(in) :: env integer, intent(in) :: unit","tags":"","url":"type/txenvelmp.html"},{"title":"MPPoint – yaeos ","text":"type, private :: MPPoint Multiphase equilibria point. Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: T Temperature [K] real(kind=pr), public :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), public, allocatable :: betas (:) Fractions of the main phases. integer, public :: iters Number of iterations needed to converge the point. integer, public :: nc Number of components integer, public :: np Number of phases integer, public :: ns Number of the specified variable. real(kind=pr), public, allocatable :: w (:) Mole fractions of the incipient phase. real(kind=pr), public, allocatable :: x_l (:,:) Mole fractions of the main phases.","tags":"","url":"type/mppoint~3.html"},{"title":"ContinuationVariable – yaeos ","text":"type, public :: ContinuationVariable Components Type Visibility Attributes Name Initial real(kind=pr), public :: S real(kind=pr), public, allocatable :: X (:) real(kind=pr), public :: dS integer, public :: ns","tags":"","url":"type/continuationvariable.html"},{"title":"UNIQUAC – yaeos ","text":"type, public, extends( GeModel ) :: UNIQUAC UNIQUAC model Description UNIQUAC ( uni versal qua si c hemical) Excess Gibbs free energy\nmodel. With: Example use yaeos , only : pr , setup_uniquac , UNIQUAC integer , parameter :: nc = 3 real ( pr ) :: rs ( nc ), qs ( nc ) real ( pr ) :: b ( nc , nc ) real ( pr ) :: n ( nc ) real ( pr ) :: ln_gammas ( nc ), T type ( UNIQUAC ) :: model rs = [ 0.92_pr , 2.1055_pr , 3.1878_pr ] qs = [ 1.4_pr , 1.972_pr , 2.4_pr ] T = 29 8.15_pr ! Calculate bij from DUij. We need -DU/R to get bij b ( 1 , :) = [ 0.0_pr , - 52 6.02_pr , - 30 9.64_pr ] b ( 2 , :) = [ 31 8.06_pr , 0.0_pr , 9 1.532_pr ] b ( 3 , :) = [ - 132 5.1_pr , - 30 2.57_pr , 0.0_pr ] model = setup_uniquac ( qs , rs , bij = b ) n = [ 0.8_pr , 0.1_pr , 0.2_pr ] call model % ln_activity_coefficient ( n , T , ln_gammas ) print * , exp ( ln_gammas ) ! [8.856, 0.860, 1.425] Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: aij (:,:) Interaction parameters matrix real(kind=pr), public, allocatable :: bij (:,:) Interaction parameters matrix real(kind=pr), public, allocatable :: cij (:,:) Interaction parameters matrix type( Substances ), public :: components Substances contained in the module real(kind=pr), public, allocatable :: dij (:,:) Interaction parameters matrix real(kind=pr), public, allocatable :: eij (:,:) Interaction parameters matrix real(kind=pr), public, allocatable :: qs (:) Molecule’s relative areas real(kind=pr), public, allocatable :: rs (:) Molecule’s relative volumes real(kind=pr), public :: z = 10.0_pr Model coordination number Type-Bound Procedures procedure, public :: excess_enthalpy public  subroutine excess_enthalpy (self, n, T, He, HeT, Hen) Calculate Excess enthalpy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: He Excess enthalpy real(kind=pr), intent(out), optional :: HeT real(kind=pr), intent(out), optional :: Hen (:) procedure, public :: excess_entropy public  subroutine excess_entropy (self, n, T, Se, SeT, Sen) Calculate Excess entropy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Se Excess entropy real(kind=pr), intent(out), optional :: SeT real(kind=pr), intent(out), optional :: Sen (:) procedure, public :: excess_gibbs public  subroutine excess_gibbs (self, n, T, Ge, GeT, GeT2, Gen, GeTn, Gen2) Calculate the excess Gibbs free energy and its derivatives of the\nUNIQUAC model. Arguments Type Intent Optional Attributes Name class( UNIQUAC ), intent(in) :: self UNIQUAC model real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Excess Gibbs energy real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional :: Gen (size(n)) real(kind=pr), intent(out), optional :: GeTn (size(n)) real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) procedure, public :: ln_activity_coefficient public  subroutine ln_activity_coefficient (self, n, T, lngamma, dlngammadT, dlngammadn) Calculate natural logarithm of activity coefficients. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: lngamma (:) Natural logarithm of activity coefficients real(kind=pr), intent(out), optional :: dlngammadT (size(n)) real(kind=pr), intent(out), optional :: dlngammadn (size(n),size(n)) procedure, public :: taus public  subroutine taus (self, T, tau, tauT, tauT2) Calculate the temperature dependence term of the UNIQUAC model. Arguments Type Intent Optional Attributes Name class( UNIQUAC ), intent(in) :: self UNIQUAC model real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: tau (size(self%qs),size(self%qs)) UNIQUAC temperature dependence term real(kind=pr), intent(out), optional :: tauT (size(self%qs),size(self%qs)) real(kind=pr), intent(out), optional :: tauT2 (size(self%qs),size(self%qs))","tags":"","url":"type/uniquac.html"},{"title":"PXEnvelMP – yaeos ","text":"type, public :: PXEnvelMP Multiphase PX envelope. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) Molar relation between two mixtures. type( MPPoint ), public, allocatable :: points (:) Array of converged points. real(kind=pr), public, allocatable :: z0 (:) Original mixture mole fractions. real(kind=pr), public, allocatable :: zi (:) Other mixture mole fractions Type-Bound Procedures procedure, public, nopass :: get_values_from_X private  subroutine get_values_from_X (X, np, z0, zi, beta_w, x_l, w, betas, P, alpha) Extract the values of the variables from the vector X. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: z0 (:) Initial mixture composition. real(kind=pr), intent(in) :: zi (:) Second mixture composition. real(kind=pr), intent(in) :: beta_w Reference phase beta. real(kind=pr), intent(out) :: x_l (np,size(z0)) Mole fractions of the main phases. real(kind=pr), intent(out) :: w (size(z0)) Mole fractions of the incipient phase. real(kind=pr), intent(out) :: betas (np) Fractions of the main phases. real(kind=pr), intent(out) :: P Pressure [bar]. real(kind=pr), intent(out) :: alpha . procedure, public, nopass :: solve_point private  subroutine solve_point (model, z0, zi, np, T, beta_w, X, ns, S, dXdS, F, df, iters, max_iterations) Solve the system of equations for a multiphase point. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z0 (:) First mixture composition. real(kind=pr), intent(in) :: zi (:) Second mixture composition. integer, intent(in) :: np Number of main phases real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(in) :: dXdS (size(X)) Sensitivity of the variables wrt the specification real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix integer, intent(out) :: iters Number of iterations needed to converge the point integer, intent(in) :: max_iterations Maximum number of iterations to solve the point procedure, public :: write => write_envelope_PX_MP private  subroutine write_envelope_PX_MP (env, unit) Arguments Type Intent Optional Attributes Name class( PXEnvelMP ), intent(in) :: env integer, intent(in) :: unit","tags":"","url":"type/pxenvelmp.html"},{"title":"MPPoint – yaeos ","text":"type, private :: MPPoint Multiphase equilibria point. Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: T Temperature [K] real(kind=pr), public :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), public, allocatable :: betas (:) Fractions of the main phases. integer, public :: iters Number of iterations needed to converge the point. integer, public :: nc Number of components integer, public :: np Number of phases integer, public :: ns Number of the specified variable. real(kind=pr), public, allocatable :: w (:) Mole fractions of the incipient phase. real(kind=pr), public, allocatable :: x_l (:,:) Mole fractions of the main phases.","tags":"","url":"type/mppoint~2.html"},{"title":"GeModel – yaeos ","text":"type, public, abstract, extends( BaseModel ) :: GeModel Excess Gibbs energy model. Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module Type-Bound Procedures procedure, public :: excess_enthalpy public  subroutine excess_enthalpy (self, n, T, He, HeT, Hen) Calculate Excess enthalpy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: He Excess enthalpy real(kind=pr), intent(out), optional :: HeT real(kind=pr), intent(out), optional :: Hen (:) procedure, public :: excess_entropy public  subroutine excess_entropy (self, n, T, Se, SeT, Sen) Calculate Excess entropy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Se Excess entropy real(kind=pr), intent(out), optional :: SeT real(kind=pr), intent(out), optional :: Sen (:) procedure( excess_gibbs ), public, deferred :: excess_gibbs subroutine excess_gibbs(self, n, T, Ge, GeT, GeT2, Gen, GeTn, Gen2) Prototype Calculate Excess Gibbs and its derivatives. Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Excess Gibbs free energy real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional :: Gen (size(n)) real(kind=pr), intent(out), optional :: GeTn (size(n)) real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) procedure, public :: ln_activity_coefficient public  subroutine ln_activity_coefficient (self, n, T, lngamma, dlngammadT, dlngammadn) Calculate natural logarithm of activity coefficients. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: lngamma (:) Natural logarithm of activity coefficients real(kind=pr), intent(out), optional :: dlngammadT (size(n)) real(kind=pr), intent(out), optional :: dlngammadn (size(n),size(n))","tags":"","url":"type/gemodel.html"},{"title":"AlphaFunction – yaeos ","text":"type, public, abstract :: AlphaFunction Abstract derived type that describe the required\nprocedure for an alpha function. Type-Bound Procedures procedure( abs_alpha ), public, deferred :: alpha subroutine abs_alpha(self, Tr, a, dadt, dadt2) Prototype Arguments Type Intent Optional Attributes Name class( AlphaFunction ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","url":"type/alphafunction.html"},{"title":"CubicEoS – yaeos ","text":"type, public, extends( ArModel ) :: CubicEoS Cubic Equation of State. Generic Cubic Equation of State as defined by Michelsen and Mollerup\nwith a parameter that is not constant,\nand a parameter that depends on it. In the case of a\ntwo parameter EoS like PengRobinson the is the same for\nall components so it can be considered as a constant instead of a\nvariable. The expression of the Equation is: Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: ac (:) Attractive critical parameter class( AlphaFunction ), public, allocatable :: alpha AlphaFunction derived type. Uses the abstract derived type AlphaFunction to define the\nAlpha function that the CubicEoS will use. The Alpha function\nreceives the reduced temperature and returns the values of alpha\nand its derivatives, named a , dadt and dadt2 respectively. Examples Callign the AlphaFunction of a setted up model. use yaeos , only : CubicEoS , PengRobinson76 type ( CubicEoS ) :: eos eos = PengRobinson76 ( tc , pc , w ) call eos % alpha % alpha ( Tr , a , dadt , dadt2 ) real(kind=pr), public, allocatable :: b (:) Repulsive parameter type( Substances ), public :: components Substances contained in the module real(kind=pr), public, allocatable :: del1 (:) paramter real(kind=pr), public, allocatable :: del2 (:) paramter class( CubicMixRule ), public, allocatable :: mixrule CubicMixRule derived type. Uses the abstract derived type CubicMixRule to define the\nmixing rule that the CubicEoS will use. It includes internally\nthree methods to calculate the corresponding parameters for the\nCubic EoS: Dmix , Bmix and D1mix . Examples Calculation of the B parameter. use yaeos , only : CubicEoS , PengRobinson76 type ( CubicEoS ) :: eos eos = PengRobinson76 ( tc , pc , w ) call eos % mixrule % Bmix ( n , eos % b , B , dBi , dBij ) Calculation of the D parameter. use yaeos , only : CubicEoS , PengRobinson76 type ( CubicEoS ) :: eos eos = PengRobinson76 ( tc , pc , w ) ! The mixing rule takes the `a` parameters of the components so ! they should be calculated externally call eos % alpha % alpha ( Tr , a , dadt , dadt2 ) a = a * eos % ac dadt = dadt * eos % ac / eos % components % Tc dadt = dadt * eos % ac / eos % components % Tc ** 2 ! Calculate parameter call eos % mixrule % Dmix ( n , T , a , dadt , dadt2 , D , dDdT , dDdT2 , dDi , dDidT , dDij ) Calculation of the D1 parameter. use yaeos , only : CubicEoS , PengRobinson76 type ( CubicEoS ) :: eos eos = PengRobinson76 ( tc , pc , w ) call eos % mixrule % D1mix ( n , eos % del1 , D1 , dD1i , dD1ij ) character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure, public :: Cp_residual_vt private  subroutine Cp_residual_vt (eos, n, V, T, Cp) Calculate residual heat capacity pressure constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cp heat capacity P constant [bar L / K] procedure, public :: Cv_residual_vt private  subroutine Cv_residual_vt (eos, n, V, T, Cv) Calculate residual heat capacity volume constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cv heat capacity V constant [bar L / K] procedure, public :: Psat_pure private  function Psat_pure (eos, ncomp, T) Calculation of saturation pressure of a pure component using the\nsecant method. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model that will be used integer, intent(in) :: ncomp Number of component in the mixture from which the saturation pressure\nwill be calculated real(kind=pr), intent(in) :: T Temperature [K] Return Value real(kind=pr) procedure, public :: enthalpy_residual_vt private  subroutine enthalpy_residual_vt (eos, n, V, T, Hr, HrV, HrT, Hrn) Calculate residual enthalpy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Hr Residual enthalpy [bar L] real(kind=pr), intent(out), optional :: HrV real(kind=pr), intent(out), optional :: HrT real(kind=pr), intent(out), optional :: Hrn (size(n)) procedure, public :: entropy_residual_vt private  subroutine entropy_residual_vt (eos, n, V, T, Sr, SrV, SrT, Srn) Calculate residual entropy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Sr Entropy [bar L / K] real(kind=pr), intent(out), optional :: SrV real(kind=pr), intent(out), optional :: SrT real(kind=pr), intent(out), optional :: Srn (size(n)) procedure, public :: get_v0 => v0 public  function v0 (self, n, p, t) Cubic EoS volume initializer.\nFor a Cubic Equation of State, the covolume calculated with the mixing\nrule is a good estimate for the initial volume solver on the liquid\nregion. Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) procedure, public :: gibbs_residual_vt private  subroutine gibbs_residual_vt (eos, n, V, T, Gr, GrV, GrT, Grn) Calculate residual Gibbs energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Gr Gibbs energy [bar L] real(kind=pr), intent(out), optional :: GrV real(kind=pr), intent(out), optional :: GrT real(kind=pr), intent(out), optional :: Grn (size(n)) procedure, public :: internal_energy_residual_vt private  subroutine internal_energy_residual_vt (eos, n, V, T, Ur, UrV, UrT, Urn) Calculate residual internal energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ur Internal energy [bar L] real(kind=pr), intent(out), optional :: UrV real(kind=pr), intent(out), optional :: UrT real(kind=pr), intent(out), optional :: Urn (size(n)) procedure, public :: lnfug_vt private  subroutine lnfug_vt (eos, n, V, T, P, lnf, dlnfdV, dlnfdT, dlnfdn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnf (size(n)) vector real(kind=pr), intent(out), optional :: dlnfdV (size(n)) Volume derivative real(kind=pr), intent(out), optional :: dlnfdT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnfdn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: lnphi_pt private  subroutine lnphi_pt (eos, n, P, T, V, root_type, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given pressure and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: V Volume [L] character(len=*), intent(in) :: root_type Type of root desired [“liquid”, “vapor”, “stable”] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) ln(phi) Temperature derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) ln(phi) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (size(n)) procedure, public :: lnphi_vt private  subroutine lnphi_vt (eos, n, V, T, P, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity coefficent. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: pressure private  subroutine pressure (eos, n, V, T, P, dPdV, dPdT, dPdn) Calculate pressure. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: P Pressure [bar] real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: residual_helmholtz => GenericCubic_Ar public  subroutine GenericCubic_Ar (self, n, v, t, ar, arv, ArT, artv, arv2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz Energy for a generic Cubic Equation of State. Read more… Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: ar Residual Helmholtz real(kind=pr), intent(out), optional :: arv real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: artv real(kind=pr), intent(out), optional :: arv2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) procedure, public :: set_delta1 public  subroutine set_delta1 (self, delta1) Arguments Type Intent Optional Attributes Name class( CubicEoS ) :: self real(kind=pr), intent(in) :: delta1 (:) procedure, public :: set_mixrule public  subroutine set_mixrule (self, mixrule) Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(inout) :: self class( CubicMixRule ), intent(in) :: mixrule procedure, public :: volume public  subroutine volume (eos, n, P, T, V, root_type) Volume solver optimized for Cubic Equations of State. Read more… Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: eos real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: V character(len=*), intent(in) :: root_type","tags":"","url":"type/cubiceos.html"},{"title":"CubicMixRule – yaeos ","text":"type, public, abstract :: CubicMixRule Abstract derived type that describe the required\nprocedure for a mixing rule on a Cubic EoS Components Type Visibility Attributes Name Initial logical, public :: dn2 = .false. Calculate second order derivatives Type-Bound Procedures procedure( abs_Bmix ), public, deferred :: Bmix subroutine abs_Bmix(self, n, bi, B, dBi, dBij) Prototype Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) procedure( abs_D1mix ), public, deferred :: D1mix subroutine abs_D1mix(self, n, d1i, D1, dD1i, dD1ij) Prototype Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:) procedure( abs_Dmix ), public, deferred :: Dmix subroutine abs_Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Prototype Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:)","tags":"","url":"type/cubicmixrule.html"},{"title":"PXEnvel2 – yaeos ","text":"type, public :: PXEnvel2 Two-phase PX envelope.\nPhase boundary line of a fluid at constant temperature\nwith variation in composition. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) Second fluid molar fraction type( CriticalPoint ), public, allocatable :: cps (:) Critical points found along the line. type( EquilibriumState ), public, allocatable :: points (:) Each point through the line. real(kind=pr), public, allocatable :: z0 (:) Original fluid composition real(kind=pr), public, allocatable :: z_inj (:) Second fluid composition","tags":"","url":"type/pxenvel2.html"},{"title":"CriticalPoint – yaeos ","text":"type, private :: CriticalPoint Critical point Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: alpha","tags":"","url":"type/criticalpoint.html"},{"title":"PXEnvel3 – yaeos ","text":"type, public :: PXEnvel3 Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: P (:) Pressure [bar] real(kind=pr), public, allocatable :: S (:) Specified value to solve point i real(kind=pr), public :: T Temperature [K] real(kind=pr), public, allocatable :: alpha (:) Mole fraction of other fluid real(kind=pr), public, allocatable :: beta (:) Mole fraction between phase x and phase y integer, public, allocatable :: ns (:) Specified variable to solve point i real(kind=pr), public, allocatable :: w (:,:) Mole fraction of phase x real(kind=pr), public, allocatable :: x (:,:) Mole fraction of phase x real(kind=pr), public, allocatable :: y (:,:) Mole fraction of phase x","tags":"","url":"type/pxenvel3.html"},{"title":"ArModel – yaeos ","text":"type, public, abstract, extends( BaseModel ) :: ArModel Abstract residual Helmholtz model. This derived type defines the basics needed for the calculation\nof residual properties.\nThe basics of a residual Helmholtz model is a routine that calculates\nall the needed derivatives of residual_helmholtz and\na volume initializer function, that is used to initialize a Newton\nsolver of volume when specifying pressure. Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure, public :: Cp_residual_vt private  subroutine Cp_residual_vt (eos, n, V, T, Cp) Calculate residual heat capacity pressure constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cp heat capacity P constant [bar L / K] procedure, public :: Cv_residual_vt private  subroutine Cv_residual_vt (eos, n, V, T, Cv) Calculate residual heat capacity volume constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cv heat capacity V constant [bar L / K] procedure, public :: Psat_pure private  function Psat_pure (eos, ncomp, T) Calculation of saturation pressure of a pure component using the\nsecant method. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model that will be used integer, intent(in) :: ncomp Number of component in the mixture from which the saturation pressure\nwill be calculated real(kind=pr), intent(in) :: T Temperature [K] Return Value real(kind=pr) procedure, public :: enthalpy_residual_vt private  subroutine enthalpy_residual_vt (eos, n, V, T, Hr, HrV, HrT, Hrn) Calculate residual enthalpy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Hr Residual enthalpy [bar L] real(kind=pr), intent(out), optional :: HrV real(kind=pr), intent(out), optional :: HrT real(kind=pr), intent(out), optional :: Hrn (size(n)) procedure, public :: entropy_residual_vt private  subroutine entropy_residual_vt (eos, n, V, T, Sr, SrV, SrT, Srn) Calculate residual entropy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Sr Entropy [bar L / K] real(kind=pr), intent(out), optional :: SrV real(kind=pr), intent(out), optional :: SrT real(kind=pr), intent(out), optional :: Srn (size(n)) procedure( abs_volume_initializer ), public, deferred :: get_v0 function abs_volume_initializer(self, n, p, t) Prototype Function that provides an initializer value for the liquid-root\nof newton solver of volume. In the case the model will use the volume_michelsen routine this value should provide the co-volume\nof the model. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Ar Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: t Temperature [K] Return Value real(kind=pr) Initial volume [L] procedure, public :: gibbs_residual_vt private  subroutine gibbs_residual_vt (eos, n, V, T, Gr, GrV, GrT, Grn) Calculate residual Gibbs energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Gr Gibbs energy [bar L] real(kind=pr), intent(out), optional :: GrV real(kind=pr), intent(out), optional :: GrT real(kind=pr), intent(out), optional :: Grn (size(n)) procedure, public :: internal_energy_residual_vt private  subroutine internal_energy_residual_vt (eos, n, V, T, Ur, UrV, UrT, Urn) Calculate residual internal energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ur Internal energy [bar L] real(kind=pr), intent(out), optional :: UrV real(kind=pr), intent(out), optional :: UrT real(kind=pr), intent(out), optional :: Urn (size(n)) procedure, public :: lnfug_vt private  subroutine lnfug_vt (eos, n, V, T, P, lnf, dlnfdV, dlnfdT, dlnfdn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnf (size(n)) vector real(kind=pr), intent(out), optional :: dlnfdV (size(n)) Volume derivative real(kind=pr), intent(out), optional :: dlnfdT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnfdn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: lnphi_pt private  subroutine lnphi_pt (eos, n, P, T, V, root_type, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given pressure and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: V Volume [L] character(len=*), intent(in) :: root_type Type of root desired [“liquid”, “vapor”, “stable”] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) ln(phi) Temperature derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) ln(phi) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (size(n)) procedure, public :: lnphi_vt private  subroutine lnphi_vt (eos, n, V, T, P, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity coefficent. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: pressure private  subroutine pressure (eos, n, V, T, P, dPdV, dPdT, dPdn) Calculate pressure. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: P Pressure [bar] real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure( abs_residual_helmholtz ), public, deferred :: residual_helmholtz subroutine abs_residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Prototype Residual Helmholtz model generic interface. This interface represents how an Ar model should be implemented.\nBy our standard, a Resiudal Helmholtz model takes as input: The mixture’s number of moles vector. Volume, by default in liters. Temperature, by default in Kelvin. All the output arguments are optional. While this keeps a long\nsignature for the implementation, this is done this way to take\nadvantage of any inner optimizations to calculate derivatives\ninside the procedure. Once the model is implemented, the signature can be short like model%residual_helmholtz(n, v, t, ArT2=dArdT2) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self ArModel real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: Ar Residual Helmoltz energy real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) procedure, public :: volume public  subroutine volume (eos, n, P, T, V, root_type) Volume solver routine for residual Helmholtz models. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: V Volume [L] character(len=*), intent(in) :: root_type Desired root-type to solve. Options are: [\"liquid\", \"vapor\", \"stable\"]","tags":"","url":"type/armodel.html"},{"title":"TXEnvel2 – yaeos ","text":"type, public :: TXEnvel2 Two-phase TX envelope.\nPhase boundary line of a fluid at constant temperature\nwith variation in composition. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) Second fluid molar fraction type( CriticalPoint ), public, allocatable :: cps (:) Critical points found along the line. type( EquilibriumState ), public, allocatable :: points (:) Each point through the line. real(kind=pr), public, allocatable :: z0 (:) Original fluid composition real(kind=pr), public, allocatable :: z_inj (:) Second fluid composition","tags":"","url":"type/txenvel2.html"},{"title":"CriticalPoint – yaeos ","text":"type, private :: CriticalPoint Critical point Components Type Visibility Attributes Name Initial real(kind=pr), public :: T Temperature [K] real(kind=pr), public :: alpha","tags":"","url":"type/criticalpoint~2.html"},{"title":"PurePsat – yaeos ","text":"type, public :: PurePsat Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: P (:) Pressure [Pa] real(kind=pr), public, allocatable :: T (:) Temperature [K] real(kind=pr), public, allocatable :: Vx (:) Molar volume [L/mol] in the liquid phase real(kind=pr), public, allocatable :: Vy (:) Molar volume [L/mol] in the vapor phase type(linear_interp_1d), private :: interpolator_get_P type(linear_interp_1d), private :: interpolator_get_T Type-Bound Procedures procedure, public :: get_P public  function get_P (pt, T) result(P) Get the saturation pressure for a given temperature. Read more… Arguments Type Intent Optional Attributes Name class( PurePsat ), intent(inout) :: pt real(kind=pr), intent(in) :: T Return Value real(kind=pr) procedure, public :: get_T public  function get_T (pt, P) result(T) Get the saturation temperature for a given pressure. Read more… Arguments Type Intent Optional Attributes Name class( PurePsat ), intent(inout) :: pt real(kind=pr), intent(in) :: P Return Value real(kind=pr)","tags":"","url":"type/purepsat.html"},{"title":"PTEnvelMP – yaeos ","text":"type, public :: PTEnvelMP Multiphase PT envelope. Components Type Visibility Attributes Name Initial type( MPPoint ), public, allocatable :: points (:) Array of converged points. Type-Bound Procedures procedure, public, nopass :: get_values_from_X private  subroutine get_values_from_X (X, np, z, x_l, w, betas, P, T) Extract the values of the variables from the vector X. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: z (:) Mixture composition. real(kind=pr), intent(out) :: x_l (np,size(z)) Mole fractions of the main phases. real(kind=pr), intent(out) :: w (size(z)) Mole fractions of the incipient phase. real(kind=pr), intent(out) :: betas (np) Fractions of the main phases. real(kind=pr), intent(out) :: P Pressure [bar]. real(kind=pr), intent(out) :: T Temperature [K]. procedure, public, nopass :: solve_point private  subroutine solve_point (model, z, np, beta_w, X, ns, S, dXdS, F, df, iters, max_iterations) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z (:) Mixture global composition. integer, intent(in) :: np Number of main phases real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(in) :: dXdS (size(X)) real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix integer, intent(out) :: iters Number of iterations to solve the current point integer, intent(in) :: max_iterations Maximum number of iterations to solve the point procedure, public :: write => write_envelope_PT_MP private  subroutine write_envelope_PT_MP (env, unit) Arguments Type Intent Optional Attributes Name class( PTEnvelMP ), intent(in) :: env integer, intent(in) :: unit","tags":"","url":"type/ptenvelmp.html"},{"title":"MPPoint – yaeos ","text":"type, private :: MPPoint Multiphase equilibria point. Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: T Temperature [K] real(kind=pr), public :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), public, allocatable :: betas (:) Fractions of the main phases. integer, public :: iters Number of iterations needed to converge the point. integer, public :: nc Number of components integer, public :: np Number of phases integer, public :: ns Number of the specified variable. real(kind=pr), public, allocatable :: w (:) Mole fractions of the incipient phase. real(kind=pr), public, allocatable :: x_l (:,:) Mole fractions of the main phases.","tags":"","url":"type/mppoint.html"},{"title":"BaseModel – yaeos ","text":"type, public, abstract :: BaseModel Base model type. Contains the important parts of most models and other procedures. Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module","tags":"","url":"type/basemodel.html"},{"title":"ArModelTapenade – yaeos ","text":"type, public, abstract, extends( ArModel ) :: ArModelTapenade Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure, public :: Cp_residual_vt private  subroutine Cp_residual_vt (eos, n, V, T, Cp) Calculate residual heat capacity pressure constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cp heat capacity P constant [bar L / K] procedure, public :: Cv_residual_vt private  subroutine Cv_residual_vt (eos, n, V, T, Cv) Calculate residual heat capacity volume constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cv heat capacity V constant [bar L / K] procedure, public :: Psat_pure private  function Psat_pure (eos, ncomp, T) Calculation of saturation pressure of a pure component using the\nsecant method. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model that will be used integer, intent(in) :: ncomp Number of component in the mixture from which the saturation pressure\nwill be calculated real(kind=pr), intent(in) :: T Temperature [K] Return Value real(kind=pr) procedure( tapenade_ar ), public, deferred :: ar subroutine tapenade_ar(model, n, v, t, arval) Prototype Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: arval procedure( tapenade_ar_b ), public, deferred :: ar_b subroutine tapenade_ar_b(model, n, nb, v, vb, t, tb, arval, arvalb) Prototype Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: arval real(kind=pr) :: arvalb procedure( tapenade_ar_d ), public, deferred :: ar_d subroutine tapenade_ar_d(model, n, nd, v, vd, t, td, arval, arvald) Prototype Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald procedure( tapenade_ar_d_b ), public, deferred :: ar_d_b subroutine tapenade_ar_d_b(model, n, nb, nd, ndb, v, vb, vd, vdb, t, tb, td, tdb, arval, arvalb, arvald, arvaldb) Prototype Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr) :: ndb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: vd real(kind=pr) :: vdb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr), intent(in) :: td real(kind=pr) :: tdb real(kind=pr) :: arval real(kind=pr) :: arvalb real(kind=pr) :: arvald real(kind=pr) :: arvaldb procedure( tapenade_ar_d_d ), public, deferred :: ar_d_d subroutine tapenade_ar_d_d(model, n, nd, v, vd0, vd, t, td0, td, arval, arvald0, arvald, arvaldd) Prototype Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd0 real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald0 real(kind=pr), intent(out) :: arvald real(kind=pr), intent(out) :: arvaldd procedure, public :: enthalpy_residual_vt private  subroutine enthalpy_residual_vt (eos, n, V, T, Hr, HrV, HrT, Hrn) Calculate residual enthalpy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Hr Residual enthalpy [bar L] real(kind=pr), intent(out), optional :: HrV real(kind=pr), intent(out), optional :: HrT real(kind=pr), intent(out), optional :: Hrn (size(n)) procedure, public :: entropy_residual_vt private  subroutine entropy_residual_vt (eos, n, V, T, Sr, SrV, SrT, Srn) Calculate residual entropy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Sr Entropy [bar L / K] real(kind=pr), intent(out), optional :: SrV real(kind=pr), intent(out), optional :: SrT real(kind=pr), intent(out), optional :: Srn (size(n)) procedure( abs_volume_initializer ), public, deferred :: get_v0 function abs_volume_initializer(self, n, p, t) Prototype Function that provides an initializer value for the liquid-root\nof newton solver of volume. In the case the model will use the volume_michelsen routine this value should provide the co-volume\nof the model. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Ar Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: t Temperature [K] Return Value real(kind=pr) Initial volume [L] procedure, public :: gibbs_residual_vt private  subroutine gibbs_residual_vt (eos, n, V, T, Gr, GrV, GrT, Grn) Calculate residual Gibbs energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Gr Gibbs energy [bar L] real(kind=pr), intent(out), optional :: GrV real(kind=pr), intent(out), optional :: GrT real(kind=pr), intent(out), optional :: Grn (size(n)) procedure, public :: internal_energy_residual_vt private  subroutine internal_energy_residual_vt (eos, n, V, T, Ur, UrV, UrT, Urn) Calculate residual internal energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ur Internal energy [bar L] real(kind=pr), intent(out), optional :: UrV real(kind=pr), intent(out), optional :: UrT real(kind=pr), intent(out), optional :: Urn (size(n)) procedure, public :: lnfug_vt private  subroutine lnfug_vt (eos, n, V, T, P, lnf, dlnfdV, dlnfdT, dlnfdn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnf (size(n)) vector real(kind=pr), intent(out), optional :: dlnfdV (size(n)) Volume derivative real(kind=pr), intent(out), optional :: dlnfdT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnfdn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: lnphi_pt private  subroutine lnphi_pt (eos, n, P, T, V, root_type, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given pressure and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: V Volume [L] character(len=*), intent(in) :: root_type Type of root desired [“liquid”, “vapor”, “stable”] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) ln(phi) Temperature derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) ln(phi) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (size(n)) procedure, public :: lnphi_vt private  subroutine lnphi_vt (eos, n, V, T, P, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity coefficent. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: pressure private  subroutine pressure (eos, n, V, T, P, dPdV, dPdT, dPdn) Calculate pressure. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: P Pressure [bar] real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: residual_helmholtz private  subroutine residual_helmholtz (self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz model generic interface Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) procedure, public :: volume public  subroutine volume (eos, n, P, T, V, root_type) Volume solver routine for residual Helmholtz models. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: V Volume [L] character(len=*), intent(in) :: root_type Desired root-type to solve. Options are: [\"liquid\", \"vapor\", \"stable\"]","tags":"","url":"type/armodeltapenade.html"},{"title":"GeModelTapenade – yaeos ","text":"type, public, abstract, extends( GeModel ) :: GeModelTapenade Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module Type-Bound Procedures procedure, public :: excess_enthalpy public  subroutine excess_enthalpy (self, n, T, He, HeT, Hen) Calculate Excess enthalpy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: He Excess enthalpy real(kind=pr), intent(out), optional :: HeT real(kind=pr), intent(out), optional :: Hen (:) procedure, public :: excess_entropy public  subroutine excess_entropy (self, n, T, Se, SeT, Sen) Calculate Excess entropy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Se Excess entropy real(kind=pr), intent(out), optional :: SeT real(kind=pr), intent(out), optional :: Sen (:) procedure, public :: excess_gibbs private  subroutine excess_gibbs (self, n, t, Ge, GeT, GeT2, Gen, GeTn, Gen2) Excess Gibbs model generic interface Arguments Type Intent Optional Attributes Name class( GeModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ge real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Gen real(kind=pr), intent(out), optional, dimension(size(n)) :: GeTn real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) procedure( tapenade_ge ), public, deferred :: ge subroutine tapenade_ge(model, n, t, ge) Prototype Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ge procedure( tapenade_ge_b ), public, deferred :: ge_b subroutine tapenade_ge_b(model, n, nb, t, tb, ge, geb) Prototype Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: ge real(kind=pr) :: geb procedure( tapenade_ge_d ), public, deferred :: ge_d subroutine tapenade_ge_d(model, n, nd, t, td, ge, ged) Prototype Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged procedure( tapenade_ge_d_b ), public, deferred :: ge_d_b subroutine tapenade_ge_d_b(model, n, nb, nd, ndb, t, tb, td, tdb, ge, geb, ged, gedb) Prototype Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr) :: ndb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr), intent(in) :: td real(kind=pr) :: tdb real(kind=pr) :: ge real(kind=pr) :: geb real(kind=pr) :: ged real(kind=pr) :: gedb procedure( tapenade_ge_d_d ), public, deferred :: ge_d_d subroutine tapenade_ge_d_d(model, n, nd, t, td0, td, ge, ged0, ged, gedd) Prototype Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged0 real(kind=pr), intent(out) :: ged real(kind=pr), intent(out) :: gedd procedure, public :: ln_activity_coefficient public  subroutine ln_activity_coefficient (self, n, T, lngamma, dlngammadT, dlngammadn) Calculate natural logarithm of activity coefficients. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: lngamma (:) Natural logarithm of activity coefficients real(kind=pr), intent(out), optional :: dlngammadT (size(n)) real(kind=pr), intent(out), optional :: dlngammadn (size(n),size(n))","tags":"","url":"type/gemodeltapenade.html"},{"title":"UNIFAC – yaeos ","text":"type, public, extends( GeModel ) :: UNIFAC UNIFAC model Classic liquid-vapor UNIFAC model derived type Description This type holds the needed parameters for using a UNIFAC model\nmainly group areas, volumes and what temperature dependence function to use. It also holds the individual molecules of a particular system and\nthe set of all groups in the system as a “stew” of groups instead of\nbeing them included in particular molecules. Examples ! UNIFAC model with ethanol-formic acid mix and calculate gammas use yaeos , only : pr , Groups , setup_unifac , UNIFAC type ( UNIFAC ) :: model type ( Groups ) :: molecules ( 2 ) real ( pr ) :: ln_gammas ( 2 ) ! Ethanol definition [CH3, CH2, OH] molecules ( 1 )% groups_ids = [ 1 , 2 , 14 ] ! Subgroups ids molecules ( 1 )% number_of_groups = [ 1 , 1 , 1 ] ! Subgroups occurrences ! formic acid definition [HCOOH] molecules ( 2 )% groups_ids = [ 43 ] molecules ( 2 )% number_of_groups = [ 1 ] ! Model setup model = setup_unifac ( molecules ) ! Calculate ln_gammas call model % ln_activity_coefficient ([ 0.5_pr , 0.5_pr ], 29 8.0_pr , ln_gammas ) print * , ln_gammas ! result: 0.10505475697637946   0.28073129552766890 References Dortmund Data Bank Software & Separation Technology Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975).\nGroup‐contribution estimation of activity coefficients in nonideal liquid\nmixtures. AIChE Journal, 21(6), 1086–1099. https://doi.org/10.1002/aic.690210607 Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979).\nVapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and\nExtension. Industrial & Engineering Chemistry Process Design and\nDevelopment, 18(4), 714–722. https://doi.org/10.1021/i260072a024 Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid\nequilibriums by UNIFAC group contribution. Revision and extension. 2.\nIndustrial & Engineering Chemistry Process Design and Development, 21(1),\n118–127. https://doi.org/10.1021/i200016a021 Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983).\nVapor-liquid equilibriums by UNIFAC group contribution. Revision and\nextension. 3. Industrial & Engineering Chemistry Process Design and\nDevelopment, 22(4), 676–678. https://doi.org/10.1021/i200023a023 Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987).\nVapor-liquid equilibria by UNIFAC group contribution. 4. Revision and\nextension. Industrial & Engineering Chemistry Research, 26(1), 159–161. https://doi.org/10.1021/ie00061a030 Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., &\nGmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group\ncontribution. 5. Revision and extension. Industrial & Engineering\nChemistry Research, 30 (10), 2352–2355. https://doi.org/10.1021/ie00058a017 Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria\nby UNIFAC Group Contribution. 6. Revision and Extension. Industrial &\nEngineering Chemistry Research, 42(1), 183–188. https://doi.org/10.1021/ie020506l SINTEF - Thermopack Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module real(kind=pr), public :: d = 1.0_pr Model constant d, exponent of the group volume in Flory-Huggins real(kind=pr), public, allocatable :: group_area (:) Group areas real(kind=pr), public, allocatable :: group_volume (:) Group volumes type( Groups ), public :: groups_stew All the groups present in the system type( Groups ), public, allocatable :: molecules (:) Substances present in the system integer, public :: ngroups Total number of individual groups in the mixture integer, public :: nmolecules Total number of molecules in the mixture class( PsiFunction ), public, allocatable :: psi_function Temperature dependance function of the model real(kind=pr), public, allocatable :: qk (:) Area of each group k real(kind=pr), public, allocatable :: thetas_ij (:,:) Area fractions of the groups j on molecules i real(kind=pr), public, allocatable :: vij (:,:) Ocurrences of each group j on each molecule i real(kind=pr), public :: z = 10.0_pr Model constant z Type-Bound Procedures procedure, public :: Ge_combinatorial public  subroutine Ge_combinatorial (self, n, T, Ge, dGe_dn, dGe_dn2) Calculate the UNIFAC combinatorial term of Gibbs excess energy Read more… Arguments Type Intent Optional Attributes Name class( UNIFAC ) :: self real(kind=pr), intent(in) :: n (self%nmolecules) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Combinatorial Gibbs excess energy real(kind=pr), intent(out), optional :: dGe_dn (self%nmolecules) real(kind=pr), intent(out), optional :: dGe_dn2 (self%nmolecules,self%nmolecules) procedure, public :: Ge_residual public  subroutine Ge_residual (self, n, T, Ge, dGe_dn, dGe_dn2, dGe_dT, dGe_dT2, dGe_dTn) Evaluate the UNIFAC residual term Read more… Arguments Type Intent Optional Attributes Name class( UNIFAC ) :: self real(kind=pr), intent(in) :: n (self%nmolecules) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Residual Gibbs excess energy real(kind=pr), intent(out), optional :: dGe_dn (self%nmolecules) real(kind=pr), intent(out), optional :: dGe_dn2 (self%nmolecules,self%nmolecules) real(kind=pr), intent(out), optional :: dGe_dT real(kind=pr), intent(out), optional :: dGe_dT2 real(kind=pr), intent(out), optional :: dGe_dTn (self%nmolecules) procedure, public :: excess_enthalpy public  subroutine excess_enthalpy (self, n, T, He, HeT, Hen) Calculate Excess enthalpy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: He Excess enthalpy real(kind=pr), intent(out), optional :: HeT real(kind=pr), intent(out), optional :: Hen (:) procedure, public :: excess_entropy public  subroutine excess_entropy (self, n, T, Se, SeT, Sen) Calculate Excess entropy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Se Excess entropy real(kind=pr), intent(out), optional :: SeT real(kind=pr), intent(out), optional :: Sen (:) procedure, public :: excess_gibbs public  subroutine excess_gibbs (self, n, T, Ge, GeT, GeT2, Gen, GeTn, Gen2) Calculate the Gibbs excess energy of the UNIFAC model Read more… Arguments Type Intent Optional Attributes Name class( UNIFAC ), intent(in) :: self UNIFAC model real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Excess Gibbs energy real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional :: Gen (size(n)) real(kind=pr), intent(out), optional :: GeTn (size(n)) real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) procedure, public :: ln_activity_coefficient public  subroutine ln_activity_coefficient (self, n, T, lngamma, dlngammadT, dlngammadn) Calculate natural logarithm of activity coefficients. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: lngamma (:) Natural logarithm of activity coefficients real(kind=pr), intent(out), optional :: dlngammadT (size(n)) real(kind=pr), intent(out), optional :: dlngammadn (size(n),size(n))","tags":"","url":"type/unifac.html"},{"title":"CriticalLine – yaeos ","text":"type, public :: CriticalLine CriticalLine Description This derived type is used to store a critical line between two fluids.\nThe critical line is calculated using the critical_line function. It\nuses the continuation method. Examples A critical line can be calculated between two fluids using the critical_line function.\nIn this example we calculate the critical of a binary mixture of\ncarbon dioxide and bicyclohexyl. use yaeos implicit none type ( CubicEoS ) :: model type ( CriticalLine ) :: cl real ( pr ) :: z0 ( 2 ), zi ( 2 ) z0 = [ 1 , 0 ] ! Pure carbon dioxide zi = [ 0 , 1 ] ! Pure bicyclohexyl ! Setup the model tc = [ 30 4.21_pr , 72 7.0_pr ] pc = [ 7 3.83_pr , 2 5.6_pr ] w = [ 0.223621_pr , 0.427556_pr ] model = PengRobinson76 ( tc , pc , w ) ! Calculate the critical line cl = critical_line ( model , a0 = 0.99_pr , z0 = z0 , zi = zi , dS0 =- 0.01_pr ) Components Type Visibility Attributes Name Initial type( EquilibriumState ), public :: CEP Critical End Point real(kind=pr), public, allocatable :: P (:) Pressure [bar] real(kind=pr), public, allocatable :: T (:) Temperature [K] real(kind=pr), public, allocatable :: V (:) Volume [L/mol] real(kind=pr), public, allocatable :: a (:) Molar fraction of the second fluid integer, public, allocatable :: iters (:) Iterations needed for this point integer, public, allocatable :: ns (:) Specified variable real(kind=pr), public, allocatable :: z0 (:) Molar fractions of the first fluid real(kind=pr), public, allocatable :: zi (:) Molar fractions of the second fluid","tags":"","url":"type/criticalline.html"},{"title":"CPSpecs – yaeos ","text":"type, private :: CPSpecs Enumerator to handle the possible specifications for a critical point. Components Type Visibility Attributes Name Initial integer, public :: P = 4 Specify integer, public :: T = 3 Specify integer, public :: V = 2 Specify integer, public :: a = 1 Specify","tags":"","url":"type/cpspecs.html"},{"title":"GeGCModelParameters – yaeos ","text":"type, public :: GeGCModelParameters GeGCModelParameters group contribution model parameters container Description Type to represent a UNIFAC like models parameters. The type must be\nprovided with the subgroups ids, maingroups ids, subgroups Rs,\nsubgroups Qs, subgroups maingroups, and maingroups interaction\nparameters. Specifically, the type requires , , and for the maingroups interaction parameters. In the case of\nthe classic UNIFAC model that only requires parameters, the and must be set as null matrixes.\nThe documentation and source code of yaeos UNIFACParameters function could be consulted to understand how to instantiate a GeGCModelParameters object with the classic liquid-vapor UNIFAC\nparameters defined in DDBST. References Dortmund Data Bank Software & Separation Technology Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: maingroups_aij (:,:) Maingroup interaction parameters matrix real(kind=pr), public, allocatable :: maingroups_bij (:,:) Maingroup interaction parameters matrix real(kind=pr), public, allocatable :: maingroups_cij (:,:) Maingroup interaction parameters matrix integer, public, allocatable :: maingroups_ids (:) ID of each model’s maingroup real(kind=pr), public, allocatable :: subgroups_Qs (:) value of each subgroup real(kind=pr), public, allocatable :: subgroups_Rs (:) value of each subgroup integer, public, allocatable :: subgroups_ids (:) ID of each model’s subgroup integer, public, allocatable :: subgroups_maingroups (:) Maingroup of each subgroup Type-Bound Procedures procedure, public :: check_consistency public  subroutine check_consistency (self) Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ), intent(in) :: self procedure, public :: get_maingroup_index public  function get_maingroup_index (self, maingroup_id) result(maingroup_idx) Get index of the maingoup with id: maingoup_id Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_id ID of the subgroup Return Value integer Index of the maingroup on the self%maingroups_ids vector procedure, public :: get_maingroups_aij public  function get_maingroups_aij (self, maingroup_i_id, maingroup_j_id) result(aij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_i_id ID of the maingroup i integer, intent(in) :: maingroup_j_id ID of the maingroup j Return Value real(kind=pr) Interaction parameter procedure, public :: get_maingroups_bij public  function get_maingroups_bij (self, maingroup_i_id, maingroup_j_id) result(bij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_i_id ID of the maingroup i integer, intent(in) :: maingroup_j_id ID of the maingroup j Return Value real(kind=pr) Interaction parameter procedure, public :: get_maingroups_cij public  function get_maingroups_cij (self, maingroup_i_id, maingroup_j_id) result(cij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_i_id ID of the maingroup i integer, intent(in) :: maingroup_j_id ID of the maingroup j Return Value real(kind=pr) Interaction parameter procedure, public :: get_subgroup_Q public  function get_subgroup_Q (self, subgroup_id) result(subgroup_Q) Get the subgroup’s value Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value real(kind=pr) value of the subgroup procedure, public :: get_subgroup_R public  function get_subgroup_R (self, subgroup_id) result(subgroup_R) Get the subgroup’s value Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value real(kind=pr) value of the subgroup procedure, public :: get_subgroup_index public  function get_subgroup_index (self, subgroup_id) result(subgroup_idx) Get index of the subgroup with id: subgroup_id Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value integer Index of the subgroup on the self%subgroups_ids vector procedure, public :: get_subgroup_maingroup public  function get_subgroup_maingroup (self, subgroup_id) result(subgroup_maingroup) Get the subgroup’s maingroup Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value integer Maingroup of the subgroup procedure, public :: get_subgroups_aij public  function get_subgroups_aij (self, subgroup_i_id, subgroup_j_id) result(aij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_i_id ID of the subgroup i integer, intent(in) :: subgroup_j_id ID of the subgroup j Return Value real(kind=pr) Interaction parameter procedure, public :: get_subgroups_bij public  function get_subgroups_bij (self, subgroup_i_id, subgroup_j_id) result(bij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_i_id ID of the subgroup i integer, intent(in) :: subgroup_j_id ID of the subgroup j Return Value real(kind=pr) Interaction parameter procedure, public :: get_subgroups_cij public  function get_subgroups_cij (self, subgroup_i_id, subgroup_j_id) result(cij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_i_id ID of the subgroup i integer, intent(in) :: subgroup_j_id ID of the subgroup j Return Value real(kind=pr) Interaction parameter","tags":"","url":"type/gegcmodelparameters.html"},{"title":"AlphaMathiasCopeman – yaeos ","text":"type, public, extends( AlphaFunction ) :: AlphaMathiasCopeman Mathias Copeman function. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: c1 (:) real(kind=pr), public, allocatable :: c2 (:) real(kind=pr), public, allocatable :: c3 (:) Type-Bound Procedures procedure, public :: alpha => alpha_mc public  subroutine alpha_mc (self, Tr, a, dadt, dadt2) MathiasCopeman alpha function definition Arguments Type Intent Optional Attributes Name class( AlphaMathiasCopeman ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","url":"type/alphamathiascopeman.html"},{"title":"AlphaRKPR – yaeos ","text":"type, public, extends( AlphaFunction ) :: AlphaRKPR RKPR function Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: k (:) parameter. Type-Bound Procedures procedure, public :: alpha => alpha_rkpr public  subroutine alpha_rkpr (self, Tr, a, dadt, dadt2) Arguments Type Intent Optional Attributes Name class( AlphaRKPR ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) Reduced temperature real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","url":"type/alpharkpr.html"},{"title":"AlphaSoave – yaeos ","text":"type, public, extends( AlphaFunction ) :: AlphaSoave Soave function. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: k (:) parameter. Type-Bound Procedures procedure, public :: alpha Alpha function public  subroutine alpha (self, Tr, a, dadt, dadt2) Soave function and it’s derivatives. Arguments Type Intent Optional Attributes Name class( AlphaSoave ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) Reduced temperature real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","url":"type/alphasoave.html"},{"title":"PTEnvel3 – yaeos ","text":"type, public :: PTEnvel3 Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: P (:) Pressures [bar] real(kind=pr), public, allocatable :: S (:) Value of specification real(kind=pr), public, allocatable :: T (:) Temperatures [K] real(kind=pr), public, allocatable :: beta (:) Mole fraction between phase x and phase y integer, public, allocatable :: its (:) Number of needed iterations integer, public, allocatable :: ns (:) Number of specified variable real(kind=pr), public, allocatable :: w (:,:) Mole fraction of phase x real(kind=pr), public, allocatable :: x (:,:) Mole fraction of phase x real(kind=pr), public, allocatable :: y (:,:) Mole fraction of phase x","tags":"","url":"type/ptenvel3.html"},{"title":"PTEnvel2 – yaeos ","text":"type, public :: PTEnvel2 Two-phase isopleth.\nPhase boundary line of a fluid at constant composition. Components Type Visibility Attributes Name Initial type( CriticalPoint ), public, allocatable :: cps (:) Critical points found along the line. type( EquilibriumState ), public, allocatable :: points (:) Each point through the line. Type-Bound Procedures procedure, public, pass :: write => write_PTEnvel2 private  subroutine write_PTEnvel2 (pt2, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( PTEnvel2 ), intent(in) :: pt2 integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg generic, public :: write (FORMATTED) => write private  subroutine write_PTEnvel2 (pt2, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( PTEnvel2 ), intent(in) :: pt2 integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","url":"type/ptenvel2.html"},{"title":"CriticalPoint – yaeos ","text":"type, private :: CriticalPoint Critical point Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: T Temperature [K]","tags":"","url":"type/criticalpoint~3.html"},{"title":"Gerg2008 – yaeos ","text":"type, public, extends( ArModelAdiff ) :: Gerg2008 Components Type Visibility Attributes Name Initial type( Gerg2008Binary ), public, allocatable :: binaries (:,:) type( Substances ), public :: components Substances contained in the module character(len=:), public, allocatable :: name Name of the model type( Gerg2008Pure ), public, allocatable :: pures (:) type( CubicEoS ), public :: srk Type-Bound Procedures procedure, public :: Cp_residual_vt private  subroutine Cp_residual_vt (eos, n, V, T, Cp) Calculate residual heat capacity pressure constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cp heat capacity P constant [bar L / K] procedure, public :: Cv_residual_vt private  subroutine Cv_residual_vt (eos, n, V, T, Cv) Calculate residual heat capacity volume constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cv heat capacity V constant [bar L / K] procedure, public :: Psat_pure private  function Psat_pure (eos, ncomp, T) Calculation of saturation pressure of a pure component using the\nsecant method. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model that will be used integer, intent(in) :: ncomp Number of component in the mixture from which the saturation pressure\nwill be calculated real(kind=pr), intent(in) :: T Temperature [K] Return Value real(kind=pr) procedure, public :: ar => arfun public  function arfun (self, n, v, t) result(arval) Arguments Type Intent Optional Attributes Name class( Gerg2008 ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual ) procedure, public :: enthalpy_residual_vt private  subroutine enthalpy_residual_vt (eos, n, V, T, Hr, HrV, HrT, Hrn) Calculate residual enthalpy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Hr Residual enthalpy [bar L] real(kind=pr), intent(out), optional :: HrV real(kind=pr), intent(out), optional :: HrT real(kind=pr), intent(out), optional :: Hrn (size(n)) procedure, public :: entropy_residual_vt private  subroutine entropy_residual_vt (eos, n, V, T, Sr, SrV, SrT, Srn) Calculate residual entropy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Sr Entropy [bar L / K] real(kind=pr), intent(out), optional :: SrV real(kind=pr), intent(out), optional :: SrT real(kind=pr), intent(out), optional :: Srn (size(n)) procedure, public :: get_v0 => volume_initalizer public  function volume_initalizer (self, n, p, t) result(v0) Arguments Type Intent Optional Attributes Name class( Gerg2008 ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) procedure, public :: gibbs_residual_vt private  subroutine gibbs_residual_vt (eos, n, V, T, Gr, GrV, GrT, Grn) Calculate residual Gibbs energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Gr Gibbs energy [bar L] real(kind=pr), intent(out), optional :: GrV real(kind=pr), intent(out), optional :: GrT real(kind=pr), intent(out), optional :: Grn (size(n)) procedure, public :: internal_energy_residual_vt private  subroutine internal_energy_residual_vt (eos, n, V, T, Ur, UrV, UrT, Urn) Calculate residual internal energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ur Internal energy [bar L] real(kind=pr), intent(out), optional :: UrV real(kind=pr), intent(out), optional :: UrT real(kind=pr), intent(out), optional :: Urn (size(n)) procedure, public :: lnfug_vt private  subroutine lnfug_vt (eos, n, V, T, P, lnf, dlnfdV, dlnfdT, dlnfdn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnf (size(n)) vector real(kind=pr), intent(out), optional :: dlnfdV (size(n)) Volume derivative real(kind=pr), intent(out), optional :: dlnfdT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnfdn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: lnphi_pt private  subroutine lnphi_pt (eos, n, P, T, V, root_type, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given pressure and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: V Volume [L] character(len=*), intent(in) :: root_type Type of root desired [“liquid”, “vapor”, “stable”] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) ln(phi) Temperature derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) ln(phi) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (size(n)) procedure, public :: lnphi_vt private  subroutine lnphi_vt (eos, n, V, T, P, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity coefficent. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: pressure private  subroutine pressure (eos, n, V, T, P, dPdV, dPdT, dPdn) Calculate pressure. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: P Pressure [bar] real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: residual_helmholtz public  subroutine residual_helmholtz (self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) procedure, public :: volume public  subroutine volume (eos, n, P, T, V, root_type) Volume solver routine for residual Helmholtz models. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: V Volume [L] character(len=*), intent(in) :: root_type Desired root-type to solve. Options are: [\"liquid\", \"vapor\", \"stable\"]","tags":"","url":"type/gerg2008.html"},{"title":"GERG2008Selector – yaeos ","text":"type, private :: GERG2008Selector Components Type Visibility Attributes Name Initial integer, public :: argon = 21 integer, public :: carbon_dioxide = 3 integer, public :: carbon_monoxide = 17 integer, public :: decane = 14 integer, public :: ethane = 4 integer, public :: helium = 20 integer, public :: hydrogen = 15 integer, public :: hydrogen_sulfide = 19 integer, public :: isobutane = 7 integer, public :: isopentane = 9 integer, public :: methane = 1 integer, public :: nbutane = 6 integer, public :: nheptane = 11 integer, public :: nhexane = 10 integer, public :: nitrogen = 2 integer, public :: noctane = 12 integer, public :: nonane = 13 integer, public :: npentane = 8 integer, public :: oxygen = 16 integer, public :: propane = 5 integer, public :: water = 18","tags":"","url":"type/gerg2008selector.html"},{"title":"hyperdual – yaeos ","text":"type, public, bind(c) :: hyperdual Components Type Visibility Attributes Name Initial real(kind=pr), public :: f0 = 0 real part of the hyperdual number real(kind=pr), public :: f1 = 0 \\f$\\varepsilon_1\\f$-part of  the hyperdual number real(kind=pr), public :: f12 = 0 \\f$\\varepsilon_1\\varepsilon_2\\f$-part of the real(kind=pr), public :: f2 = 0 \\f$\\varepsilon_2\\f$-part of  the hyperdual number","tags":"","url":"type/hyperdual.html"},{"title":"GeModelAdiff – yaeos ","text":"type, public, abstract, extends( GeModel ) :: GeModelAdiff Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module Type-Bound Procedures procedure( hyperdual_Ge ), public, deferred :: Ge function hyperdual_Ge(self, n, t) Prototype Arguments Type Intent Optional Attributes Name class( GeModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: t Return Value type( hyperdual ) procedure, public :: excess_enthalpy public  subroutine excess_enthalpy (self, n, T, He, HeT, Hen) Calculate Excess enthalpy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: He Excess enthalpy real(kind=pr), intent(out), optional :: HeT real(kind=pr), intent(out), optional :: Hen (:) procedure, public :: excess_entropy public  subroutine excess_entropy (self, n, T, Se, SeT, Sen) Calculate Excess entropy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Se Excess entropy real(kind=pr), intent(out), optional :: SeT real(kind=pr), intent(out), optional :: Sen (:) procedure, public :: excess_gibbs public  subroutine excess_gibbs (self, n, t, Ge, GeT, GeT2, Gen, GeTn, Gen2) Arguments Type Intent Optional Attributes Name class( GeModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ge real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Gen real(kind=pr), intent(out), optional, dimension(size(n)) :: GeTn real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) procedure, public :: ln_activity_coefficient public  subroutine ln_activity_coefficient (self, n, T, lngamma, dlngammadT, dlngammadn) Calculate natural logarithm of activity coefficients. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: lngamma (:) Natural logarithm of activity coefficients real(kind=pr), intent(out), optional :: dlngammadT (size(n)) real(kind=pr), intent(out), optional :: dlngammadn (size(n),size(n))","tags":"","url":"type/gemodeladiff.html"},{"title":"Substances – yaeos ","text":"type, public :: Substances Set of pure components Components Type Visibility Attributes Name Initial character(len=50), public, allocatable :: names (:) Composition names. real(kind=pr), public, allocatable :: pc (:) Critical Pressure [bar] real(kind=pr), public, allocatable :: tc (:) Critical Temperature [K] real(kind=pr), public, allocatable :: vc (:) Critical Volume [L/mol] real(kind=pr), public, allocatable :: w (:) Acentric factor","tags":"","url":"type/substances.html"},{"title":"Groups – yaeos ","text":"type, public :: Groups Groups Derived type used to represent a molecule and its UNIFAC groups. Description Derived type used to represent a molecule and its UNIFAC groups. Is\nnecessary to specify the subgroups ids and the subgroups on each\nmolecule as shown in the example. Examples ! Define toluene molecule groups use yaeos , only : Groups type ( Groups ) :: toluene ! Toluene [ACH, ACCH3] toluene % groups_ids = [ 9 , 11 ] ! Subgroups ids toluene % number_of_groups = [ 5 , 1 ] ! Subgroups occurrences References Dortmund Data Bank Software & Separation Technology Components Type Visibility Attributes Name Initial integer, public, allocatable :: groups_ids (:) Indexes (ids) of each subgroup in the main group matrix integer, public, allocatable :: number_of_groups (:) Occurrences of each subgroup in the molecule real(kind=pr), public :: surface_area Molecule surface area real(kind=pr), public :: volume Molecule volume","tags":"","url":"type/groups.html"},{"title":"EquilibriumState – yaeos ","text":"type, public :: EquilibriumState Description of a two-phase equilibria state. Contains the relevant information of an equilibrium point obtained\nfrom some kind of equilibria calculation. Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: T Temperature [K] real(kind=pr), public :: Vx Heavy-phase volume [L/mol] real(kind=pr), public :: Vy Light-phase volume [L/mol] real(kind=pr), public :: beta Mole fraction of light-phase integer, public :: iters = 0 Iterations needed to reach the state character(len=14), public :: kind Kind of point [“bubble”, “dew”, “liquid-liquid”, “split”] real(kind=pr), public, allocatable :: x (:) Heavy-phase molar fractions real(kind=pr), public, allocatable :: y (:) Light-phase molar fractions Type-Bound Procedures generic, public :: write (FORMATTED) => write public  subroutine write_EquilibriumState (eq, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( EquilibriumState ), intent(in) :: eq integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, private, pass :: write => write_EquilibriumState public  subroutine write_EquilibriumState (eq, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( EquilibriumState ), intent(in) :: eq integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","url":"type/equilibriumstate.html"},{"title":"QMR – yaeos ","text":"type, public, extends( CubicMixRule ) :: QMR Quadratic Mixing Rule (QMR) derived type. Classic Van der Waals mixing\nrules. QMR depends on binary interaction parameters, on a Cubic EoS\nthe mixture is obtained by the combination of an attractive and\nrepulsive parameter matrices. By default the attractive parameter matrix is calculated with: generating the matrix, but this procedure can be overriden\nreplacing the aij pointer procedure. Components Type Visibility Attributes Name Initial logical, public :: dn2 = .false. Calculate second order derivatives real(kind=pr), public, allocatable :: k (:,:) Attractive Binary Interatction parameter matrix real(kind=pr), public, allocatable :: l (:,:) Repulsive Binary Interatction parameter matrix Type-Bound Procedures procedure, public :: Bmix Repulsive parameter mixing rule public  subroutine Bmix (self, n, bi, B, dBi, dBij) Mixture repulsive parameter. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector. real(kind=pr), intent(in) :: bi (:) Pure components repulsive parameters. real(kind=pr), intent(out) :: B Mixture repulsive parameter. real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) procedure, public :: D1mix => RKPR_D1mix public  subroutine RKPR_D1mix (self, n, d1i, D1, dD1i, dD1ij) RKPR parameter mixing rule. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:) procedure, public :: Dmix Attractive parameter mixing rule public  subroutine Dmix (self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Attractive parameter mixing rule with quadratic mix. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: ai (:) Pure components attractive parameters real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D Mixture attractive parameter real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) procedure, public :: aij => kij_constant Default attractive parameter combining rule public  subroutine kij_constant (self, T, a, dadt, dadt2, aij, daijdt, daijdt2) Combining rule that uses constant values. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: a (:) Pure components attractive parameters (\\a_i) real(kind=pr), intent(in) :: dadt (:) real(kind=pr), intent(in) :: dadt2 (:) real(kind=pr), intent(out) :: aij (:,:) Matrix real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:)","tags":"","url":"type/qmr.html"},{"title":"QMRTD – yaeos ","text":"type, public, extends( QMR ) :: QMRTD Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: Tref (:,:) logical, public :: dn2 = .false. Calculate second order derivatives real(kind=pr), public, allocatable :: k (:,:) Attractive Binary Interatction parameter matrix real(kind=pr), public, allocatable :: k0 (:,:) real(kind=pr), public, allocatable :: l (:,:) Repulsive Binary Interatction parameter matrix Type-Bound Procedures procedure, public :: Bmix Repulsive parameter mixing rule public  subroutine Bmix (self, n, bi, B, dBi, dBij) Mixture repulsive parameter. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector. real(kind=pr), intent(in) :: bi (:) Pure components repulsive parameters. real(kind=pr), intent(out) :: B Mixture repulsive parameter. real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) procedure, public :: D1mix => RKPR_D1mix public  subroutine RKPR_D1mix (self, n, d1i, D1, dD1i, dD1ij) RKPR parameter mixing rule. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:) procedure, public :: Dmix Attractive parameter mixing rule public  subroutine Dmix (self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Attractive parameter mixing rule with quadratic mix. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: ai (:) Pure components attractive parameters real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D Mixture attractive parameter real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) procedure, public :: aij => kij_exp_tdep public  subroutine kij_exp_tdep (self, T, a, dadt, dadt2, aij, daijdt, daijdt2) Combining rule that uses temperature dependant values.\nWith the following expression: Read more… Arguments Type Intent Optional Attributes Name class( QMRTD ), intent(in) :: self real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: a (:) Pure components attractive parameters (\\a_i) real(kind=pr), intent(in) :: dadt (:) real(kind=pr), intent(in) :: dadt2 (:) real(kind=pr), intent(out) :: aij (:,:) Matrix real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:)","tags":"","url":"type/qmrtd.html"},{"title":"Gerg2008Binary – yaeos ","text":"type, public :: Gerg2008Binary Components Type Visibility Attributes Name Initial real(kind=8), public :: Bt Binary temperature interaction parameters real(kind=8), public :: Bv Binary volume interaction parameters real(kind=8), public :: Fij real(kind=8), public :: Gt Binary temperature interaction parameters real(kind=8), public :: Gv Binary volume interaction parameters integer, public :: Kexpij integer, public :: Kpolij real(kind=8), public, allocatable :: betaij (:) real(kind=8), public, allocatable :: dij (:) real(kind=8), public, allocatable :: epsij (:) real(kind=8), public, allocatable :: ethaij (:) real(kind=8), public, allocatable :: gammaij (:) integer, public :: i Component i integer, public :: j Component j real(kind=8), public, allocatable :: nij (:) real(kind=8), public, allocatable :: tij (:)","tags":"","url":"type/gerg2008binary.html"},{"title":"Gerg2008Pure – yaeos ","text":"type, public :: Gerg2008Pure Components Type Visibility Attributes Name Initial integer, public :: Kexp integer, public :: Kpol real(kind=8), public, allocatable :: c (:) real(kind=8), public, allocatable :: d (:) real(kind=8), public, allocatable :: n (:) real(kind=8), public, allocatable :: t (:)","tags":"","url":"type/gerg2008pure.html"},{"title":"HV – yaeos ","text":"type, public, extends( CubicMixRule ) :: HV Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: bi (:) real(kind=pr), public, allocatable :: del1 (:) logical, public :: dn2 = .false. Calculate second order derivatives class( GeModel ), public, allocatable :: ge Type-Bound Procedures procedure, public :: Bmix => BmixHV private  subroutine BmixHV (self, n, bi, B, dBi, dBij) Quadratinc mixing rule for the repulsive parameter. Read more… Arguments Type Intent Optional Attributes Name class( HV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) procedure, public :: D1Mix => D1MixHV private  subroutine D1MixHV (self, n, d1i, D1, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name class( HV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:) procedure, public :: Dmix => DmixHV private  subroutine DmixHV (self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Arguments Type Intent Optional Attributes Name class( HV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:)","tags":"","url":"type/hv.html"},{"title":"MHV – yaeos ","text":"type, public, extends( CubicMixRule ) :: MHV Michelsen’s modified Huron-Vidal mixing rule Mixing rule at zero-pressure which allows for the inclusion of an\nexcess-gibbs model. Description This mixing rule is based on the aproximate zero-pressure limit\n of a cubic equation of state. At the aproximate zero-pressure limit the\nattractive parameter can be expressed as: Where is a weak function of temperature. In the case of MHV and simplicity it is considered that depends on the model used. Examples To use the modified Huron-Vidal mixing rule it is necessary to define\na CubicEoS and replace its original mixing rule with the one generated\nby the user. type ( MHV ) :: mixrule type ( NRTL ) :: ge_model type ( CubicEoS ) :: model ! Define the Ge model to be used and the CubicEoS ge_model = NRTL ( a , b , c ) model = SoaveRedlichKwong ( tc , pc , w ) ! Use the initialization function to setup mixrule = MHV ( ge = ge_model , q =- 0.593_pr , bi = model % b ) ! Replace the original mixrule on the previously defined model model % mixrule = mixrule ! Ready to do calculations call pressure ( model , n , v , T ) References Components Type Visibility Attributes Name Initial logical, public :: dn2 = .false. Calculate second order derivatives class( GeModel ), public, allocatable :: ge real(kind=pr), public, allocatable :: l (:,:) real(kind=pr), public :: q real(kind=pr), private, allocatable :: B real(kind=pr), private, allocatable :: bi (:) real(kind=pr), private, allocatable :: dBi (:) real(kind=pr), private, allocatable :: dBij (:,:) Constructor public        interface MHV private  function init_mhv (Ge, b, q, lij) result(mixrule) Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: Ge real(kind=pr), intent(in) :: b (:) real(kind=pr), intent(in) :: q real(kind=pr), intent(in), optional :: lij (:,:) Return Value type( MHV ) Type-Bound Procedures procedure, public :: Bmix => BmixMHV private  subroutine BmixMHV (self, n, bi, B, dBi, dBij) Quadratinc mixing rule for the repulsive parameter, using as a combining rule. Read more… Arguments Type Intent Optional Attributes Name class( MHV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) procedure, public :: D1Mix => D1MixMHV private  subroutine D1MixMHV (self, n, d1i, D1, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name class( MHV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:) procedure, public :: Dmix => DmixMHV public  subroutine DmixMHV (self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Mixing rule at infinite pressure as defined in the book of Michelsen and\nMøllerup. Read more… Arguments Type Intent Optional Attributes Name class( MHV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:)","tags":"","url":"type/mhv.html"},{"title":"ArModelAdiff – yaeos ","text":"type, public, abstract, extends( ArModel ) :: ArModelAdiff Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure( hyperdual_Ar ), public, deferred :: Ar function hyperdual_Ar(self, n, v, t) Prototype Arguments Type Intent Optional Attributes Name class( ArModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual ) procedure, public :: Cp_residual_vt private  subroutine Cp_residual_vt (eos, n, V, T, Cp) Calculate residual heat capacity pressure constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cp heat capacity P constant [bar L / K] procedure, public :: Cv_residual_vt private  subroutine Cv_residual_vt (eos, n, V, T, Cv) Calculate residual heat capacity volume constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cv heat capacity V constant [bar L / K] procedure, public :: Psat_pure private  function Psat_pure (eos, ncomp, T) Calculation of saturation pressure of a pure component using the\nsecant method. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model that will be used integer, intent(in) :: ncomp Number of component in the mixture from which the saturation pressure\nwill be calculated real(kind=pr), intent(in) :: T Temperature [K] Return Value real(kind=pr) procedure, public :: enthalpy_residual_vt private  subroutine enthalpy_residual_vt (eos, n, V, T, Hr, HrV, HrT, Hrn) Calculate residual enthalpy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Hr Residual enthalpy [bar L] real(kind=pr), intent(out), optional :: HrV real(kind=pr), intent(out), optional :: HrT real(kind=pr), intent(out), optional :: Hrn (size(n)) procedure, public :: entropy_residual_vt private  subroutine entropy_residual_vt (eos, n, V, T, Sr, SrV, SrT, Srn) Calculate residual entropy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Sr Entropy [bar L / K] real(kind=pr), intent(out), optional :: SrV real(kind=pr), intent(out), optional :: SrT real(kind=pr), intent(out), optional :: Srn (size(n)) procedure( abs_volume_initializer ), public, deferred :: get_v0 function abs_volume_initializer(self, n, p, t) Prototype Function that provides an initializer value for the liquid-root\nof newton solver of volume. In the case the model will use the volume_michelsen routine this value should provide the co-volume\nof the model. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Ar Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: t Temperature [K] Return Value real(kind=pr) Initial volume [L] procedure, public :: gibbs_residual_vt private  subroutine gibbs_residual_vt (eos, n, V, T, Gr, GrV, GrT, Grn) Calculate residual Gibbs energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Gr Gibbs energy [bar L] real(kind=pr), intent(out), optional :: GrV real(kind=pr), intent(out), optional :: GrT real(kind=pr), intent(out), optional :: Grn (size(n)) procedure, public :: internal_energy_residual_vt private  subroutine internal_energy_residual_vt (eos, n, V, T, Ur, UrV, UrT, Urn) Calculate residual internal energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ur Internal energy [bar L] real(kind=pr), intent(out), optional :: UrV real(kind=pr), intent(out), optional :: UrT real(kind=pr), intent(out), optional :: Urn (size(n)) procedure, public :: lnfug_vt private  subroutine lnfug_vt (eos, n, V, T, P, lnf, dlnfdV, dlnfdT, dlnfdn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnf (size(n)) vector real(kind=pr), intent(out), optional :: dlnfdV (size(n)) Volume derivative real(kind=pr), intent(out), optional :: dlnfdT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnfdn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: lnphi_pt private  subroutine lnphi_pt (eos, n, P, T, V, root_type, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given pressure and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: V Volume [L] character(len=*), intent(in) :: root_type Type of root desired [“liquid”, “vapor”, “stable”] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) ln(phi) Temperature derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) ln(phi) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (size(n)) procedure, public :: lnphi_vt private  subroutine lnphi_vt (eos, n, V, T, P, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity coefficent. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: pressure private  subroutine pressure (eos, n, V, T, P, dPdV, dPdT, dPdn) Calculate pressure. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: P Pressure [bar] real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) procedure, public :: residual_helmholtz public  subroutine residual_helmholtz (self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) procedure, public :: volume public  subroutine volume (eos, n, P, T, V, root_type) Volume solver routine for residual Helmholtz models. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: V Volume [L] character(len=*), intent(in) :: root_type Desired root-type to solve. Options are: [\"liquid\", \"vapor\", \"stable\"]","tags":"","url":"type/armodeladiff.html"},{"title":"temperature_dependence – yaeos","text":"interface public  subroutine temperature_dependence(self, systems_groups, T, psi, dpsi_dt, dpsi_dt2) Arguments Type Intent Optional Attributes Name class( PsiFunction ) :: self PsiFunction type variable class( Groups ) :: systems_groups Groups type variable containig all the system’s groups. See the groups_stew variable on the UNIFAC documentation. real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: psi (:,:) real(kind=pr), intent(out), optional :: dpsi_dt (:,:) real(kind=pr), intent(out), optional :: dpsi_dt2 (:,:) Description temperature_dependence interface Interface subroutine for UNIFAC models temperature dependent\nfunctions","tags":"","url":"interface/temperature_dependence.html"},{"title":"continuation_function – yaeos","text":"interface public  subroutine continuation_function(X, ns, S, F, dF, dFdS) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out) :: dF (:,:) real(kind=pr), intent(out) :: dFdS (:)","tags":"","url":"interface/continuation_function.html"},{"title":"continuation_solver – yaeos","text":"interface public  subroutine continuation_solver(fun, iters, X, ns, S, dS, dXdS, point, max_iters, F, df, dfds, tol) Arguments Type Intent Optional Attributes Name procedure( continuation_function ) :: fun Function to solve integer, intent(out) :: iters Number of iterations needed real(kind=pr), intent(inout) :: X (:) Variables vector integer, intent(in) :: ns Specification number real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(in) :: dS Delta spec real(kind=pr), intent(in) :: dXdS (:) integer, intent(in) :: point Point number integer, intent(in) :: max_iters Maximum iterations real(kind=pr), intent(out) :: F (:) Function values at solved point real(kind=pr), intent(out) :: df (:,:) Jacobian values real(kind=pr), intent(out) :: dfds (:) dFdS real(kind=pr), intent(in) :: tol Solver tolerance Description Solver to solve a point during numerical contination.","tags":"","url":"interface/continuation_solver.html"},{"title":"continuation_stopper – yaeos","text":"interface public  function continuation_stopper(X, ns, S, dS, dXdS, iterations) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(inout) :: ns Position of specified variable real(kind=pr), intent(inout) :: S Specification variable value real(kind=pr), intent(inout) :: dS Step of specification in the method real(kind=pr), intent(inout) :: dXdS (:) integer, intent(in) :: iterations Iterations needed to converge point Return Value logical Description Function that returns true if the method should stop","tags":"","url":"interface/continuation_stopper.html"},{"title":"process – yaeos","text":"interface public  subroutine process(X, ns, S, dS, dXdS, iterations) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(inout) :: ns Position of specified variable real(kind=pr), intent(inout) :: S Specification variable value real(kind=pr), intent(inout) :: dS Step of specification in the method real(kind=pr), intent(inout) :: dXdS (:) integer, intent(in) :: iterations Iterations needed to converge point Description Subroutine to make variation in the method after a point converged","tags":"","url":"interface/process.html"},{"title":"excess_gibbs – yaeos","text":"interface public  subroutine excess_gibbs(self, n, T, Ge, GeT, GeT2, Gen, GeTn, Gen2) Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Excess Gibbs free energy real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional :: Gen (size(n)) real(kind=pr), intent(out), optional :: GeTn (size(n)) real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) Description Calculate Excess Gibbs and its derivatives.","tags":"","url":"interface/excess_gibbs.html"},{"title":"abs_Bmix – yaeos","text":"interface public  subroutine abs_Bmix(self, n, bi, B, dBi, dBij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:)","tags":"","url":"interface/abs_bmix.html"},{"title":"abs_D1mix – yaeos","text":"interface public  subroutine abs_D1mix(self, n, d1i, D1, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:)","tags":"","url":"interface/abs_d1mix.html"},{"title":"abs_Dmix – yaeos","text":"interface public  subroutine abs_Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:)","tags":"","url":"interface/abs_dmix.html"},{"title":"abs_alpha – yaeos","text":"interface public  subroutine abs_alpha(self, Tr, a, dadt, dadt2) Arguments Type Intent Optional Attributes Name class( AlphaFunction ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","url":"interface/abs_alpha.html"},{"title":"abs_residual_helmholtz – yaeos","text":"interface private  subroutine abs_residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self ArModel real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: Ar Residual Helmoltz energy real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Description Residual Helmholtz model generic interface. This interface represents how an Ar model should be implemented.\nBy our standard, a Resiudal Helmholtz model takes as input: The mixture’s number of moles vector. Volume, by default in liters. Temperature, by default in Kelvin. All the output arguments are optional. While this keeps a long\nsignature for the implementation, this is done this way to take\nadvantage of any inner optimizations to calculate derivatives\ninside the procedure. Once the model is implemented, the signature can be short like model%residual_helmholtz(n, v, t, ArT2=dArdT2)","tags":"","url":"interface/abs_residual_helmholtz.html"},{"title":"abs_volume_initializer – yaeos","text":"interface private  function abs_volume_initializer(self, n, p, t) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Ar Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: t Temperature [K] Return Value real(kind=pr) Initial volume [L] Description Function that provides an initializer value for the liquid-root\nof newton solver of volume. In the case the model will use the volume_michelsen routine this value should provide the co-volume\nof the model.","tags":"","url":"interface/abs_volume_initializer.html"},{"title":"tapenade_ar – yaeos","text":"interface private  subroutine tapenade_ar(model, n, v, t, arval) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: arval","tags":"","url":"interface/tapenade_ar.html"},{"title":"tapenade_ar_b – yaeos","text":"interface private  subroutine tapenade_ar_b(model, n, nb, v, vb, t, tb, arval, arvalb) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: arval real(kind=pr) :: arvalb","tags":"","url":"interface/tapenade_ar_b.html"},{"title":"tapenade_ar_d – yaeos","text":"interface private  subroutine tapenade_ar_d(model, n, nd, v, vd, t, td, arval, arvald) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald","tags":"","url":"interface/tapenade_ar_d.html"},{"title":"tapenade_ar_d_b – yaeos","text":"interface private  subroutine tapenade_ar_d_b(model, n, nb, nd, ndb, v, vb, vd, vdb, t, tb, td, tdb, arval, arvalb, arvald, arvaldb) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr) :: ndb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: vd real(kind=pr) :: vdb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr), intent(in) :: td real(kind=pr) :: tdb real(kind=pr) :: arval real(kind=pr) :: arvalb real(kind=pr) :: arvald real(kind=pr) :: arvaldb","tags":"","url":"interface/tapenade_ar_d_b.html"},{"title":"tapenade_ar_d_d – yaeos","text":"interface private  subroutine tapenade_ar_d_d(model, n, nd, v, vd0, vd, t, td0, td, arval, arvald0, arvald, arvaldd) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd0 real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald0 real(kind=pr), intent(out) :: arvald real(kind=pr), intent(out) :: arvaldd","tags":"","url":"interface/tapenade_ar_d_d.html"},{"title":"tapenade_ge – yaeos","text":"interface private  subroutine tapenade_ge(model, n, t, ge) Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ge","tags":"","url":"interface/tapenade_ge.html"},{"title":"tapenade_ge_b – yaeos","text":"interface private  subroutine tapenade_ge_b(model, n, nb, t, tb, ge, geb) Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: ge real(kind=pr) :: geb","tags":"","url":"interface/tapenade_ge_b.html"},{"title":"tapenade_ge_d – yaeos","text":"interface private  subroutine tapenade_ge_d(model, n, nd, t, td, ge, ged) Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged","tags":"","url":"interface/tapenade_ge_d.html"},{"title":"tapenade_ge_d_b – yaeos","text":"interface private  subroutine tapenade_ge_d_b(model, n, nb, nd, ndb, t, tb, td, tdb, ge, geb, ged, gedb) Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr) :: ndb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr), intent(in) :: td real(kind=pr) :: tdb real(kind=pr) :: ge real(kind=pr) :: geb real(kind=pr) :: ged real(kind=pr) :: gedb","tags":"","url":"interface/tapenade_ge_d_b.html"},{"title":"tapenade_ge_d_d – yaeos","text":"interface private  subroutine tapenade_ge_d_d(model, n, nd, t, td0, td, ge, ged0, ged, gedd) Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged0 real(kind=pr), intent(out) :: ged real(kind=pr), intent(out) :: gedd","tags":"","url":"interface/tapenade_ge_d_d.html"},{"title":"Ares – yaeos","text":"interface public  subroutine Ares(z, v, t, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z))","tags":"","url":"interface/ares.html"},{"title":"initial_volume – yaeos","text":"interface public  function initial_volume(z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr)","tags":"","url":"interface/initial_volume.html"},{"title":"f_1d – yaeos","text":"interface public  subroutine f_1d(x, f, df) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x real(kind=pr), intent(out) :: f real(kind=pr), intent(out) :: df","tags":"","url":"interface/f_1d.html"},{"title":"hyperdual_Ge – yaeos","text":"interface public  function hyperdual_Ge(self, n, t) Arguments Type Intent Optional Attributes Name class( GeModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: t Return Value type( hyperdual )","tags":"","url":"interface/hyperdual_ge.html"},{"title":"get_aij – yaeos","text":"interface public  subroutine get_aij(self, T, ai, daidt, daidt2, aij, daijdt, daijdt2) Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: aij (:,:) real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:) Description Combining rule for the attractive parameter. From previously calculated attractive parameters calculate the matrix and it’s corresponding derivatives.","tags":"","url":"interface/get_aij.html"},{"title":"hyperdual_Ar – yaeos","text":"interface public  function hyperdual_Ar(self, n, v, t) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual )","tags":"","url":"interface/hyperdual_ar.html"},{"title":"pressure_equality_V_beta_xy – yaeos","text":"public  subroutine pressure_equality_V_beta_xy(model, T, V, beta, x, y, Vx, Vy, P) Uses iso_fortran_env Solve pressure equality between two phases at a given temperature,\ntotal volume, vapor molar fractions and compositions. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: V Total volume [L/mol] real(kind=pr), intent(in) :: beta Molar fraction of light-phase real(kind=pr), intent(in) :: x (:) Molar fractions of heavy-phase real(kind=pr), intent(in) :: y (:) Molar fractions of light-phase real(kind=pr), intent(inout) :: Vx Heavy-phase molar volume [L/mol] real(kind=pr), intent(inout) :: Vy Light-Phase molar volume [L/mol] real(kind=pr), intent(out) :: P Pressure [bar] Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Bx Liquid phase covolume real(kind=pr), public :: Px real(kind=pr), public :: Py real(kind=pr), public :: dPxdV real(kind=pr), public :: dPydV real(kind=pr), public :: dVydVx Derivative of Vy wrt Vx real(kind=pr), public :: dh dh/ real(kind=pr), public :: h Pressure equality integer, public :: its real(kind=pr), public :: stepv","tags":"","url":"proc/pressure_equality_v_beta_xy.html"},{"title":"UNIFACParameters – yaeos","text":"public  function UNIFACParameters() UNIFACParameters UNIFAC parameters Description Create a Instance of the yaeos GeGCModelParameters with the classic\nliquid-vapor UNIFAC parameters. Examples ! Instantiate an UNIFAC model with ethanol-water mix and calculate gammas use yaeos , only : pr , Groups , setup_unifac , UNIFAC use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( UNIFAC ) :: model type ( Groups ) :: molecules ( 2 ) real ( pr ) :: ln_gammas ( 2 ) type ( GeGCModelParameters ) :: parameters ! Ethanol definition [CH3, CH2, OH] molecules ( 1 )% groups_ids = [ 1 , 2 , 14 ] ! Subgroups ids molecules ( 1 )% number_of_groups = [ 1 , 1 , 1 ] ! Subgroups occurrences ! Water definition [H2O] molecules ( 2 )% groups_ids = [ 16 ] molecules ( 2 )% number_of_groups = [ 1 ] parameters = UNIFACParameters () ! Model setup ! Disclaimer: the default parameters object can be ommited in the ! setup_unifac call, because if the parameters argument is not ! provided, the return of the constructor UNIFACParameters() will be ! used either way. This is just a demostration. model = setup_unifac ( molecules , parameters ) ! Calculate ln_gammas call model % ln_activity_coefficient ([ 0.5_pr , 0.5_pr ], 29 8.0_pr , ln_gammas ) print * , ln_gammas ! result: 0.18534142000449058    0.40331395945417559 References Dortmund Data Bank Software & Separation Technology Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975).\nGroup‐contribution estimation of activity coefficients in nonideal liquid\nmixtures. AIChE Journal, 21(6), 1086–1099. https://doi.org/10.1002/aic.690210607 Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979).\nVapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and\nExtension. Industrial & Engineering Chemistry Process Design and\nDevelopment, 18(4), 714–722. https://doi.org/10.1021/i260072a024 Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid\nequilibriums by UNIFAC group contribution. Revision and extension. 2.\nIndustrial & Engineering Chemistry Process Design and Development, 21(1),\n118–127. https://doi.org/10.1021/i200016a021 Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983).\nVapor-liquid equilibriums by UNIFAC group contribution. Revision and\nextension. 3. Industrial & Engineering Chemistry Process Design and\nDevelopment, 22(4), 676–678. https://doi.org/10.1021/i200023a023 Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987).\nVapor-liquid equilibria by UNIFAC group contribution. 4. Revision and\nextension. Industrial & Engineering Chemistry Research, 26(1), 159–161. https://doi.org/10.1021/ie00061a030 Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., &\nGmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group\ncontribution. 5. Revision and extension. Industrial & Engineering\nChemistry Research, 30 (10), 2352–2355. https://doi.org/10.1021/ie00058a017 Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria\nby UNIFAC Group Contribution. 6. Revision and Extension. Industrial &\nEngineering Chemistry Research, 42(1), 183–188. https://doi.org/10.1021/ie020506l Arguments None Return Value type( GeGCModelParameters )","tags":"","url":"proc/unifacparameters.html"},{"title":"init – yaeos","text":"public  function init(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: a (:,:) real(kind=pr), intent(in) :: b (:,:) real(kind=pr), intent(in) :: c (:,:) Return Value type( NRTL )","tags":"","url":"proc/init.html"},{"title":"EXCESS_GIBBS – yaeos","text":"public  subroutine EXCESS_GIBBS(model, n, t, ge) Type Bound NRTL Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ge Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a (size(n),size(n)) real(kind=pr), public, dimension(size(n)) :: arg1 real(kind=pr), public, dimension(size(n)) :: arg2 real(kind=pr), public :: b (size(n),size(n)) real(kind=pr), public :: c (size(n),size(n)) real(kind=pr), public :: down real(kind=pr), public :: g (size(n),size(n)) integer, public :: i integer, public :: j real(kind=pr), public :: tau (size(n),size(n)) real(kind=pr), public :: x (size(n))","tags":"","url":"proc/excess_gibbs.html"},{"title":"EXCESS_GIBBS_B – yaeos","text":"public  subroutine EXCESS_GIBBS_B(model, n, nb, t, tb, ge, geb) Type Bound NRTL Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: ge real(kind=pr) :: geb Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a (size(n),size(n)) integer, public :: ad_to real(kind=pr), public, dimension(size(n)) :: arg1 real(kind=pr), public, dimension(size(n)) :: arg1b real(kind=pr), public, dimension(size(n)) :: arg2 real(kind=pr), public, dimension(size(n)) :: arg2b real(kind=pr), public :: b (size(n),size(n)) real(kind=pr), public :: c (size(n),size(n)) real(kind=pr), public :: down real(kind=pr), public :: g (size(n),size(n)) real(kind=pr), public :: gb (size(n),size(n)) integer, public :: i integer, public :: j real(kind=pr), public :: tau (size(n),size(n)) real(kind=pr), public :: taub (size(n),size(n)) real(kind=pr), public :: temp real(kind=pr), public :: temp0 real(kind=pr), public :: tempb real(kind=pr), public :: tempb0 real(kind=pr), public :: x (size(n)) real(kind=pr), public :: xb (size(n))","tags":"","url":"proc/excess_gibbs_b.html"},{"title":"EXCESS_GIBBS_D – yaeos","text":"public  subroutine EXCESS_GIBBS_D(model, n, nd, t, td, ge, ged) Type Bound NRTL Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a (size(n),size(n)) real(kind=pr), public, dimension(size(n)) :: arg1 real(kind=pr), public, dimension(size(n)) :: arg1d real(kind=pr), public, dimension(size(n)) :: arg2 real(kind=pr), public, dimension(size(n)) :: arg2d real(kind=pr), public :: b (size(n),size(n)) real(kind=pr), public :: c (size(n),size(n)) real(kind=pr), public :: down real(kind=pr), public :: g (size(n),size(n)) real(kind=pr), public :: gd (size(n),size(n)) integer, public :: i integer, public :: j real(kind=pr), public :: tau (size(n),size(n)) real(kind=pr), public :: taud (size(n),size(n)) real(kind=pr), public :: temp real(kind=pr), public :: temp0 real(kind=pr), public :: temp1 real(kind=pr), public :: x (size(n)) real(kind=pr), public :: xd (size(n))","tags":"","url":"proc/excess_gibbs_d.html"},{"title":"EXCESS_GIBBS_D_B – yaeos","text":"public  subroutine EXCESS_GIBBS_D_B(model, n, nb, nd, ndb, t, tb, td, tdb, ge, geb, ged, gedb) Type Bound NRTL Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr) :: ndb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr), intent(in) :: td real(kind=pr) :: tdb real(kind=pr) :: ge real(kind=pr) :: geb real(kind=pr) :: ged real(kind=pr) :: gedb Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a (size(n),size(n)) integer, public :: ad_to real(kind=pr), public, dimension(size(n)) :: arg1 integer, public :: arg10 real(kind=pr), public, dimension(size(n)) :: arg1b real(kind=pr), public, dimension(size(n)) :: arg1d real(kind=pr), public, dimension(size(n)) :: arg1db real(kind=pr), public, dimension(size(n)) :: arg2 real(kind=pr), public, dimension(size(n)) :: arg2b real(kind=pr), public, dimension(size(n)) :: arg2d real(kind=pr), public, dimension(size(n)) :: arg2db real(kind=pr), public :: b (size(n),size(n)) real(kind=pr), public :: c (size(n),size(n)) real(kind=pr), public :: down real(kind=pr), public :: g (size(n),size(n)) real(kind=pr), public :: gb (size(n),size(n)) real(kind=pr), public :: gd (size(n),size(n)) real(kind=pr), public :: gdb (size(n),size(n)) integer, public :: i integer, public :: j real(kind=pr), public :: result1 real(kind=pr), public :: tau (size(n),size(n)) real(kind=pr), public :: taub (size(n),size(n)) real(kind=pr), public :: taud (size(n),size(n)) real(kind=pr), public :: taudb (size(n),size(n)) real(kind=pr), public :: temp real(kind=pr), public :: temp0 real(kind=pr), public :: temp0b real(kind=pr), public :: temp1 real(kind=pr), public :: temp1b real(kind=pr), public, dimension(size(n, 1)) :: temp2 real(kind=pr), public :: temp3 real(kind=pr), public :: temp4 real(kind=pr), public :: temp5 real(kind=pr), public :: tempb real(kind=pr), public, dimension(size(n, 1)) :: tempb0 real(kind=pr), public, dimension(size(n, 1)) :: tempb1 real(kind=pr), public :: tempb2 real(kind=pr), public, dimension(size(n)) :: tempb3 real(kind=pr), public :: tempb4 real(kind=pr), public :: tempb5 real(kind=pr), public :: x (size(n)) real(kind=pr), public :: xb (size(n)) real(kind=pr), public :: xd (size(n)) real(kind=pr), public :: xdb (size(n))","tags":"","url":"proc/excess_gibbs_d_b.html"},{"title":"EXCESS_GIBBS_D_D – yaeos","text":"public  subroutine EXCESS_GIBBS_D_D(model, n, nd, t, td0, td, ge, ged0, ged, gedd) Type Bound NRTL Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged0 real(kind=pr), intent(out) :: ged real(kind=pr), intent(out) :: gedd Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a (size(n),size(n)) real(kind=pr), public, dimension(size(n)) :: arg1 real(kind=pr), public, dimension(size(n)) :: arg1d real(kind=pr), public, dimension(size(n)) :: arg1d0 real(kind=pr), public, dimension(size(n)) :: arg1dd real(kind=pr), public, dimension(size(n)) :: arg2 real(kind=pr), public, dimension(size(n)) :: arg2d real(kind=pr), public, dimension(size(n)) :: arg2d0 real(kind=pr), public, dimension(size(n)) :: arg2dd real(kind=pr), public :: b (size(n),size(n)) real(kind=pr), public :: c (size(n),size(n)) real(kind=pr), public :: down real(kind=pr), public :: g (size(n),size(n)) real(kind=pr), public :: gd (size(n),size(n)) real(kind=pr), public :: gd0 (size(n),size(n)) real(kind=pr), public :: gdd (size(n),size(n)) integer, public :: i integer, public :: j real(kind=pr), public :: tau (size(n),size(n)) real(kind=pr), public :: taud (size(n),size(n)) real(kind=pr), public :: taud0 (size(n),size(n)) real(kind=pr), public :: taudd (size(n),size(n)) real(kind=pr), public :: temp real(kind=pr), public :: temp0 real(kind=pr), public :: temp0d real(kind=pr), public :: temp1 real(kind=pr), public :: temp1d real(kind=pr), public, dimension(size(b, 1), size(b, 2)) :: temp2 real(kind=pr), public, dimension(size(n), size(n)) :: temp3 real(kind=pr), public, dimension(size(n)) :: temp4 real(kind=pr), public :: temp5 real(kind=pr), public :: temp6 real(kind=pr), public :: tempd real(kind=pr), public :: x (size(n)) real(kind=pr), public :: xd (size(n))","tags":"","url":"proc/excess_gibbs_d_d.html"},{"title":"EXCESS_GIBBS_D_D_D – yaeos","text":"public  subroutine EXCESS_GIBBS_D_D_D(model, n, nd, t, td1, td0, td, ge, ged1, ged0, ged0d, ged, gedd0, gedd, geddd) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td1 real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged1 real(kind=pr), intent(out) :: ged0 real(kind=pr), intent(out) :: ged0d real(kind=pr), intent(out) :: ged real(kind=pr), intent(out) :: gedd0 real(kind=pr), intent(out) :: gedd real(kind=pr), intent(out) :: geddd Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a (size(n),size(n)) real(kind=pr), public, dimension(size(n)) :: arg1 real(kind=pr), public, dimension(size(n)) :: arg1d real(kind=pr), public, dimension(size(n)) :: arg1d0 real(kind=pr), public, dimension(size(n)) :: arg1d0d real(kind=pr), public, dimension(size(n)) :: arg1d1 real(kind=pr), public, dimension(size(n)) :: arg1dd real(kind=pr), public, dimension(size(n)) :: arg1dd0 real(kind=pr), public, dimension(size(n)) :: arg1ddd real(kind=pr), public, dimension(size(n)) :: arg2 real(kind=pr), public, dimension(size(n)) :: arg2d real(kind=pr), public, dimension(size(n)) :: arg2d0 real(kind=pr), public, dimension(size(n)) :: arg2d0d real(kind=pr), public, dimension(size(n)) :: arg2d1 real(kind=pr), public, dimension(size(n)) :: arg2dd real(kind=pr), public, dimension(size(n)) :: arg2dd0 real(kind=pr), public, dimension(size(n)) :: arg2ddd real(kind=pr), public :: b (size(n),size(n)) real(kind=pr), public :: c (size(n),size(n)) real(kind=pr), public :: down real(kind=pr), public :: g (size(n),size(n)) real(kind=pr), public :: gd (size(n),size(n)) real(kind=pr), public :: gd0 (size(n),size(n)) real(kind=pr), public :: gd0d (size(n),size(n)) real(kind=pr), public :: gd1 (size(n),size(n)) real(kind=pr), public :: gdd (size(n),size(n)) real(kind=pr), public :: gdd0 (size(n),size(n)) real(kind=pr), public :: gddd (size(n),size(n)) integer, public :: i integer, public :: j real(kind=pr), public :: tau (size(n),size(n)) real(kind=pr), public :: taud (size(n),size(n)) real(kind=pr), public :: taud0 (size(n),size(n)) real(kind=pr), public :: taud0d (size(n),size(n)) real(kind=pr), public :: taud1 (size(n),size(n)) real(kind=pr), public :: taudd (size(n),size(n)) real(kind=pr), public :: taudd0 (size(n),size(n)) real(kind=pr), public :: tauddd (size(n),size(n)) real(kind=pr), public :: temp real(kind=pr), public :: temp0 real(kind=pr), public :: temp0d real(kind=pr), public :: temp0d0 real(kind=pr), public :: temp0dd real(kind=pr), public :: temp1 real(kind=pr), public :: temp10 real(kind=pr), public :: temp11 real(kind=pr), public :: temp1d real(kind=pr), public :: temp1d0 real(kind=pr), public :: temp1dd real(kind=pr), public, dimension(size(b, 1), size(b, 2)) :: temp2 real(kind=pr), public, dimension(size(b, 1), size(b, 2)) :: temp2d real(kind=pr), public, dimension(size(n), size(n)) :: temp3 real(kind=pr), public, dimension(size(n), size(n)) :: temp3d real(kind=pr), public, dimension(size(n)) :: temp4 real(kind=pr), public, dimension(size(n)) :: temp4d real(kind=pr), public :: temp5 real(kind=pr), public :: temp5d real(kind=pr), public :: temp6 real(kind=pr), public :: temp6d real(kind=pr), public, dimension(size(b, 1), size(b, 2)) :: temp7 real(kind=pr), public, dimension(size(n), size(n)) :: temp8 real(kind=pr), public, dimension(size(n)) :: temp9 real(kind=pr), public :: tempd real(kind=pr), public :: tempd0 real(kind=pr), public :: tempdd real(kind=pr), public :: x (size(n)) real(kind=pr), public :: xd (size(n))","tags":"","url":"proc/excess_gibbs_d_d_d.html"},{"title":"NRTL – yaeos","text":"public interface NRTL Module Procedures public  function init (a, b, c) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: a (:,:) real(kind=pr), intent(in) :: b (:,:) real(kind=pr), intent(in) :: c (:,:) Return Value type( NRTL )","tags":"","url":"interface/nrtl.html"},{"title":"DortmundParameters – yaeos","text":"public  function DortmundParameters() Arguments None Return Value type( GeGCModelParameters ) Variables Type Visibility Attributes Name Initial integer, public :: nmg integer, public :: nsg","tags":"","url":"proc/dortmundparameters.html"},{"title":"betalimits – yaeos","text":"public  subroutine betalimits(z, K, bmin, bmax) betalimits Description Define beta limits to avoid overshooting when solving the Rachford-Rice\nequation. This is based on the assumtion that either and . Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Molar fractions vector real(kind=pr), intent(in) :: K (:) K-factors real(kind=pr), intent(out) :: bmin Minimum beta value real(kind=pr), intent(out) :: bmax Maximum beta value Variables Type Visibility Attributes Name Initial real(kind=pr), public, dimension(size(z)) :: vmax real(kind=pr), public, dimension(size(z)) :: vmin","tags":"","url":"proc/betalimits.html"},{"title":"betato01 – yaeos","text":"public  subroutine betato01(z, K) betato01 Description Modify K-factor values to assure that lies between (0,1) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Molar fractions of the system real(kind=pr) :: K (:) K factors Variables Type Visibility Attributes Name Initial real(kind=pr), public :: g0 real(kind=pr), public :: g1","tags":"","url":"proc/betato01.html"},{"title":"rachford_rice – yaeos","text":"public  subroutine rachford_rice(z, K, beta, rr, drrdb) rachford_rice Description Rachford-Rice equation for a two phase system. This equation is used to\ncalculate the value that satisfies the mass balance\nbetween two phases. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Mole fractions vector real(kind=pr), intent(in) :: K (:) K-factors real(kind=pr), intent(in) :: beta value real(kind=pr), intent(out) :: rr Rachford-Rice function value real(kind=pr), intent(out) :: drrdb Derivative of the Rachford-Rice function Variables Type Visibility Attributes Name Initial real(kind=pr), public :: denom (size(z))","tags":"","url":"proc/rachford_rice.html"},{"title":"solve_rr – yaeos","text":"public  subroutine solve_rr(z, K, beta, beta_min, beta_max) solve_rr Description Solve the Rachford-Rice Equation using the Newton method. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Mole fractions vector real(kind=pr), intent(in) :: K (:) K-factors real(kind=pr), intent(out) :: beta value real(kind=pr), intent(out) :: beta_min Lower limit for real(kind=pr), intent(out) :: beta_max Upper limit for Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dgdb real(kind=pr), public :: g real(kind=pr), public :: step","tags":"","url":"proc/solve_rr.html"},{"title":"solve_system – yaeos","text":"public  function solve_system(a, b) result(x) Uses iso_fortran_env Solve a linear sytem AX = b Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: a (size(b),size(b)) real(kind=pr), intent(in) :: b (:) Return Value real(kind=pr), (size(b)) Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a_lapack (size(b),size(b)) real(kind=dp), public :: b_lapack (size(b)) integer, public, parameter :: dp = selected_real_kind(15) integer, public :: info integer, public :: ipiv (size(b)) integer, public :: lda integer, public :: ldb integer, public :: n integer, public :: nrhs Interfaces interface subroutine dgesv(n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name integer :: n integer :: nrhs real(kind=dp) :: a (n,n) integer :: lda integer :: ipiv (n) real(kind=dp) :: b (n) integer :: ldb integer :: info","tags":"","url":"proc/solve_system.html"},{"title":"cubic_roots – yaeos","text":"public  subroutine cubic_roots(parameters, real_roots, complex_roots, flag) Uses yaeos__auxiliar Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: parameters (4) real(kind=pr), intent(out) :: real_roots (3) complex(kind=pr), intent(out) :: complex_roots (3) integer, intent(out) :: flag flag that identifies which case the solution is\n- 0 : 3 real rotos, one of them repeated (use real_roots(1) and real_roots(2))\n- 1 : 1 real root, 2 complex roots.\n  Use real_roots(1) and complex_roots(1) and complex_roots(2)\n- -1 : 3 real roots, all different Variables Type Visibility Attributes Name Initial real(kind=pr), public :: disc real(kind=pr), public :: nan real(kind=pr), public :: p real(kind=pr), public, parameter :: pi = atan(1.0_pr)*4.0_pr real(kind=pr), public :: q real(kind=pr), public :: theta real(kind=pr), public :: u real(kind=pr), public :: v","tags":"","url":"proc/cubic_roots.html"},{"title":"cubic_roots_rosendo – yaeos","text":"public  subroutine cubic_roots_rosendo(parameters, real_roots, complex_roots, flag) Uses yaeos__auxiliar Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: parameters (4) real(kind=pr), intent(out) :: real_roots (3) complex(kind=pr), intent(out) :: complex_roots (3) integer, intent(out) :: flag Variables Type Visibility Attributes Name Initial real(kind=16), public :: A real(kind=16), public :: B real(kind=16), public :: Q real(kind=16), public :: R real(kind=16), public :: alp real(kind=16), public :: bet real(kind=16), public :: d1 real(kind=16), public :: d2 real(kind=16), public :: d3 real(kind=16), public :: gam integer, public :: i real(kind=pr), public, parameter :: pi = atan(1.0_pr)*4.0_pr real(kind=16), public :: theta","tags":"","url":"proc/cubic_roots_rosendo.html"},{"title":"eigen – yaeos","text":"public  subroutine eigen(A, eigenvalues, eigenvectors) eigen Description Calculate the eigenvalues and eigenvectors of a real symmetric matrix A using LAPACK’s dsyev . The eigenvectors are stored in the columns\nof eigenvectors . The eigenvalues are stored in eigenvalues . Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: A (:,:) real(kind=pr), intent(out) :: eigenvalues (:) real(kind=pr), intent(out), optional :: eigenvectors (:,:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ain (size(A,1),size(A,1)) integer, public :: istat integer, public :: n real(kind=pr), public :: work (size(A,1)*10) Interfaces interface subroutine dsyev(JOBZ, UPLO, N, A, lda, W, WORK, LWORK, INFO) Arguments Type Intent Optional Attributes Name character(len=1) :: JOBZ character(len=1) :: UPLO integer :: N double precision :: A (lda,*) integer :: lda double precision :: W (*) double precision :: WORK (*) integer :: LWORK integer :: INFO","tags":"","url":"proc/eigen.html"},{"title":"Quadratic_temperature_dependence – yaeos","text":"public  subroutine Quadratic_temperature_dependence(self, systems_groups, T, psi, dpsi_dt, dpsi_dt2) Quadratic temperature dependence Type Bound QuadraticPsi Arguments Type Intent Optional Attributes Name class( QuadraticPsi ) :: self function class( Groups ) :: systems_groups Groups in the system real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: psi (:,:) real(kind=pr), intent(out), optional :: dpsi_dt (:,:) real(kind=pr), intent(out), optional :: dpsi_dt2 (:,:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a real(kind=pr), public :: b real(kind=pr), public :: c real(kind=pr), public :: dudt real(kind=pr), public :: dudt2 integer, public :: i integer, public :: j integer, public :: ngroups real(kind=pr), public :: u","tags":"","url":"proc/quadratic_temperature_dependence.html"},{"title":"UNIFAC_temperature_dependence – yaeos","text":"public  subroutine UNIFAC_temperature_dependence(self, systems_groups, T, psi, dpsi_dt, dpsi_dt2) UNIFAC temperature dependence Implementation of the function of the UNIFAC model. References Dortmund Data Bank Software & Separation Technology Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975).\nGroup‐contribution estimation of activity coefficients in nonideal liquid\nmixtures. AIChE Journal, 21(6), 1086–1099. https://doi.org/10.1002/aic.690210607 Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979).\nVapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and\nExtension. Industrial & Engineering Chemistry Process Design and\nDevelopment, 18(4), 714–722. https://doi.org/10.1021/i260072a024 Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid\nequilibriums by UNIFAC group contribution. Revision and extension. 2.\nIndustrial & Engineering Chemistry Process Design and Development, 21(1),\n118–127. https://doi.org/10.1021/i200016a021 Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983).\nVapor-liquid equilibriums by UNIFAC group contribution. Revision and\nextension. 3. Industrial & Engineering Chemistry Process Design and\nDevelopment, 22(4), 676–678. https://doi.org/10.1021/i200023a023 Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987).\nVapor-liquid equilibria by UNIFAC group contribution. 4. Revision and\nextension. Industrial & Engineering Chemistry Research, 26(1), 159–161. https://doi.org/10.1021/ie00061a030 Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., &\nGmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group\ncontribution. 5. Revision and extension. Industrial & Engineering\nChemistry Research, 30 (10), 2352–2355. https://doi.org/10.1021/ie00058a017 Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria\nby UNIFAC Group Contribution. 6. Revision and Extension. Industrial &\nEngineering Chemistry Research, 42(1), 183–188. https://doi.org/10.1021/ie020506l SINTEF - Thermopack Type Bound UNIFACPsi Arguments Type Intent Optional Attributes Name class( UNIFACPsi ) :: self function class( Groups ) :: systems_groups Groups in the system real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: psi (:,:) real(kind=pr), intent(out), optional :: dpsi_dt (:,:) real(kind=pr), intent(out), optional :: dpsi_dt2 (:,:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Eij (size(self%Aij,1),size(self%Aij,2)) integer, public :: ngroups","tags":"","url":"proc/unifac_temperature_dependence.html"},{"title":"GenericCubic_Ar – yaeos","text":"public  subroutine GenericCubic_Ar(n, v, t, B, dBi, dBij, D, dDi, dDij, dDidT, dDdT, dDdT2, D1, dD1i, dD1ij, ar, arv, ArT, artv, arv2, ArT2, Arn, ArVn, ArTn, Arn2) Uses yaeos__constants Residual Helmholtz Energy for a generic Cubic Equation of State. Calculates the residual Helmholtz Energy for a generic Cubic EoS as\ndefined by Michelsen and Møllerup: This routine assumes that the is not a constant parameter\n(as it uses to be in classical Cubic EoS) to be compatible with the\nthree parameter EoS RKPR where is not a constant and\nhas its own mixing rule. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in) :: B Repulsive parameter [L] real(kind=pr), intent(in) :: dBi (size(n)) real(kind=pr), intent(in) :: dBij (size(n),size(n)) real(kind=pr), intent(in) :: D Attractive parameter real(kind=pr), intent(in) :: dDi (size(n)) real(kind=pr), intent(in) :: dDij (size(n),size(n)) real(kind=pr), intent(in) :: dDidT (size(n)) real(kind=pr), intent(in) :: dDdT real(kind=pr), intent(in) :: dDdT2 real(kind=pr), intent(in) :: D1 parameter real(kind=pr), intent(in) :: dD1i (size(n)) real(kind=pr), intent(in) :: dD1ij (size(n),size(n)) real(kind=pr), intent(out), optional :: ar Residual Helmholtz real(kind=pr), intent(out), optional :: arv real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: artv real(kind=pr), intent(out), optional :: arv2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AUX real(kind=pr), public :: FFB real(kind=pr), public :: FFBB real(kind=pr), public :: FFBV real(kind=pr), public :: auxD2 real(kind=pr), public :: d2 real(kind=pr), public :: f real(kind=pr), public :: fB real(kind=pr), public :: fBD1 real(kind=pr), public :: fD1 real(kind=pr), public :: fD1D1 real(kind=pr), public :: fVD1 real(kind=pr), public :: fv real(kind=pr), public :: fv2 real(kind=pr), public :: g real(kind=pr), public :: gv real(kind=pr), public :: gv2 integer, public :: i integer, public :: j integer, public :: nc real(kind=pr), public :: totn","tags":"","url":"proc/genericcubic_ar.html"},{"title":"tx_envelope – yaeos","text":"public  function tx_envelope(model, z0, zi, np, P, x_l0, w0, betas0, T0, alpha0, ns0, dS0, beta_w, points) Uses yaeos__auxiliar Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) integer, intent(in) :: np real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: x_l0 (np,size(z0)) real(kind=pr), intent(in) :: w0 (size(z0)) real(kind=pr), intent(in) :: betas0 (np) real(kind=pr), intent(in) :: T0 real(kind=pr), intent(in) :: alpha0 integer, intent(in) :: ns0 real(kind=pr), intent(in) :: dS0 real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. integer, intent(in), optional :: points Return Value type( TXEnvelMP ) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: F (size(z0)*np+np+2) real(kind=pr), private :: S Specified value real(kind=pr), private :: T real(kind=pr), private :: X (size(z0)*np+np+2) real(kind=pr), private :: X0 (size(X)) Initial guess for the point real(kind=pr), private :: alpha real(kind=pr), private, allocatable :: alphas (:) real(kind=pr), private :: betas (np) real(kind=pr), private :: dF (size(z0)*np+np+2,size(z0)*np+np+2) real(kind=pr), private :: dS Step size of the specification for the next point real(kind=pr), private :: dX (size(z0)*np+np+2) real(kind=pr), private :: dXdS (size(z0)*np+np+2) type( MPPoint ), private, allocatable :: env_points (:) integer, private :: i Point calculation index integer, private :: inner Number of times a failed point is retried to converge integer, private :: its integer, private :: lb Lower bound, index of the first component of a phase integer, private :: max_iterations = 100 integer, private :: nc integer, private :: ns Number of the specified variable integer, private :: number_of_points type( MPPoint ), private :: point integer, private :: ub Upper bound, index of the last component of a phase real(kind=pr), private :: w (size(z0)) real(kind=pr), private :: x_l (np,size(z0))","tags":"","url":"proc/tx_envelope.html"},{"title":"tx_F_NP – yaeos","text":"public  subroutine tx_F_NP(model, z0, zi, np, P, beta_w, X, ns, S, F, df) Uses iso_fortran_env Function to solve at each point of a multi-phase envelope. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: ns Number of specification. real(kind=pr), intent(in) :: S Specification value. real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated. real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix. Variables Type Visibility Attributes Name Initial real(kind=pr), private :: K (np,size(z0)) real(kind=pr), private :: T real(kind=pr), private :: Vl (np) real(kind=pr), private :: Vw real(kind=pr), private :: alpha real(kind=pr), private :: betas (np) real(kind=pr), private :: denom (size(z0)) real(kind=pr), private :: denomdlnK (np,size(z0),size(z0)) real(kind=pr), private, dimension(size(z0), size(z0)) :: dlnphi_dn real(kind=pr), private, dimension(np, size(z0), size(z0)) :: dlnphi_dn_l real(kind=pr), private, dimension(size(z0), size(z0)) :: dlnphi_dn_w real(kind=pr), private :: dlnphi_dt (size(z0)) real(kind=pr), private, dimension(np, size(z0)) :: dlnphi_dt_l real(kind=pr), private, dimension(size(z0)) :: dlnphi_dt_w real(kind=pr), private :: dwda (size(z0)) real(kind=pr), private :: dwdb (np,size(z0)) real(kind=pr), private :: dwdlnK (np,size(z0)) real(kind=pr), private :: dx_l_dlnK (np,np,size(z0)) real(kind=pr), private :: dzda (size(z0)) integer, private :: i integer, private :: idx_1 integer, private :: idx_2 integer, private :: j integer, private :: l integer, private :: lb real(kind=pr), private :: lnphi (size(z0)) real(kind=pr), private, dimension(np, size(z0)) :: lnphi_l real(kind=pr), private, dimension(size(z0)) :: lnphi_w real(kind=pr), private :: moles (size(z0)) integer, private :: nc integer, private :: phase integer, private :: ub real(kind=pr), private, dimension(size(z0)) :: w real(kind=pr), private, dimension(np, size(z0)) :: x_l real(kind=pr), private :: z (size(z0))","tags":"","url":"proc/tx_f_np.html"},{"title":"detect_critical – yaeos","text":"private  subroutine detect_critical(nc, np, X, dXdS, ns, dS, S) detect_critical Detect if the system is close to a critical point. Description When the system is close to a critical point, the values\nare close to zero, since the composition of the incipient phase and the phase are similar (equal in the critical point). This can be used\nto detect if the system is close to a critical point and force a jump\nabove it. References Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. real(kind=pr), intent(inout) :: S Specification value. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: lb integer, private :: ub","tags":"","url":"proc/detect_critical.html"},{"title":"get_values_from_X – yaeos","text":"private  subroutine get_values_from_X(X, np, z0, zi, beta_w, x_l, w, betas, T, alpha) get_values_from_X Extract the values of the variables from the vector X. Type Bound TXEnvelMP Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: z0 (:) Initial mixture composition. real(kind=pr), intent(in) :: zi (:) Second mixture composition. real(kind=pr), intent(in) :: beta_w Reference phase beta. real(kind=pr), intent(out) :: x_l (np,size(z0)) Mole fractions of the main phases. real(kind=pr), intent(out) :: w (size(z0)) Mole fractions of the incipient phase. real(kind=pr), intent(out) :: betas (np) Fractions of the main phases. real(kind=pr), intent(out) :: T Pressure [bar]. real(kind=pr), intent(out) :: alpha . Variables Type Visibility Attributes Name Initial real(kind=pr), private :: K (np,size(z0)) integer, private :: i Loop index. integer, private :: l Phase index. integer, private :: lb Lower bound of each phase. integer, private :: nc Number of components. integer, private :: ub Upper bound of each phase. real(kind=pr), private :: z (size(z0))","tags":"","url":"proc/get_values_from_x.html"},{"title":"solve_point – yaeos","text":"private  subroutine solve_point(model, z0, zi, np, P, beta_w, X, ns, S, dXdS, F, df, iters, max_iterations) Uses iso_fortran_env yaeos__math Type Bound TXEnvelMP Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) integer, intent(in) :: np Number of main phases real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(in) :: dXdS (size(X)) real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix integer, intent(out) :: iters integer, intent(in) :: max_iterations Variables Type Visibility Attributes Name Initial real(kind=pr), private :: X0 (size(X)) real(kind=pr), private :: dX (size(X)) integer, private :: iT integer, private :: ia integer, private :: nc","tags":"","url":"proc/solve_point.html"},{"title":"update_specification – yaeos","text":"private  subroutine update_specification(its, nc, np, X, dF, dXdS, ns, dS) update_specification Change the specified variable for the next step. Description Using the information of a converged point and the Jacobian matrix of\nthe function. It is possible to determine the sensitivity of the\nvariables with respect to the specification. This information is used\nto update the specification for the next point. Choosing the variable\nwith the highest sensitivity.\nThis can be done by solving the system of equations: for the vector. The variable with the highest value\nof is chosen as the new specification. References Arguments Type Intent Optional Attributes Name integer, intent(in) :: its Iterations to solve the current point. integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dF (:,:) Jacobian matrix. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. Variables Type Visibility Attributes Name Initial real(kind=pr), private :: dFdS (size(X)) Sensitivity of the functions wrt the specification. integer, private :: i integer, private :: lb Lower bound of each phase integer, private :: ub Upper bound of each phase","tags":"","url":"proc/update_specification.html"},{"title":"write_envelope_TX_MP – yaeos","text":"private  subroutine write_envelope_TX_MP(env, unit) Type Bound TXEnvelMP Arguments Type Intent Optional Attributes Name class( TXEnvelMP ), intent(in) :: env integer, intent(in) :: unit Variables Type Visibility Attributes Name Initial real(kind=pr), private :: P real(kind=pr), private :: T real(kind=pr), private :: alpha real(kind=pr), private, allocatable :: betas (:) integer, private :: i integer, private :: j integer, private :: nc integer, private :: np real(kind=pr), private, allocatable :: w (:) real(kind=pr), private, allocatable :: x_l (:,:)","tags":"","url":"proc/write_envelope_tx_mp.html"},{"title":"continuation – yaeos","text":"public  function continuation(f, X0, ns0, S0, dS0, max_points, solver_tol, update_specification, postprocess, solver, stop) result(XS) Numerical continuation of a function. Uses Algower method of numerical continuation to trace a line that\nsolves a system of the kind: Where is the variables vector and (S)\\ is the value of the\nspecification.\nThe method works with by providing a good set of initial points to\nsolve the system of equations with an extrapolation using the previous\nsolved point information. Arguments Type Intent Optional Attributes Name procedure( continuation_function ) :: f Function to trace real(kind=pr), intent(in) :: X0 (:) Initial point integer, intent(in) :: ns0 Initial specification real(kind=pr), intent(in) :: S0 Initial specification value real(kind=pr), intent(in) :: dS0 Initial integer, intent(in) :: max_points Maximum number of points to trace real(kind=pr), intent(in) :: solver_tol Point solver tolerance procedure( process ), optional :: update_specification Procedure to select the new specification and define the next step\n(\\DeltaS)\\, defaults to: ns = maxloc ( abs ( dXdS ), dim = 1 ) dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) dS = sign ( minval ( abs ([ 0.05_pr , dS ])), dS ) procedure( process ), optional :: postprocess Any kind of postprocess that could be done after defining the\nnext step procedure( continuation_solver ), optional :: solver Solver procedures, uses Newton-Raphson by default procedure( continuation_stopper ), optional :: stop Stopping procedure Return Value real(kind=pr), (max_points,size(X0)) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: S real(kind=pr), public :: X (size(X0)) real(kind=pr), public :: dF (size(X0),size(X0)) real(kind=pr), public :: dFdS (size(X0)) real(kind=pr), public :: dS real(kind=pr), public :: dXdS (size(X0)) real(kind=pr), public :: fval (size(X0)) integer, public :: i integer, public :: max_iters = 500 integer, public :: newton_its integer, public :: ns","tags":"","url":"proc/continuation.html"},{"title":"full_newton – yaeos","text":"public  subroutine full_newton(fun, iters, X, ns, S, dS, dXdS, point, max_iters, F, df, dfds, tol) Uses yaeos__math_linalg yaeos__auxiliar Subroutine to solve a point. Procedure that solves a point with the Newton-Raphson method. Arguments Type Intent Optional Attributes Name procedure( continuation_function ) :: fun Function to solve integer, intent(out) :: iters Number of iterations needed real(kind=pr), intent(inout) :: X (:) Variables vector integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(in) :: dS real(kind=pr), intent(in) :: dXdS (:) integer, intent(in) :: point integer, intent(in) :: max_iters Maximum iterations real(kind=pr), intent(out) :: F (:) Function values at solved point real(kind=pr), intent(out) :: df (:,:) Jacobian values real(kind=pr), intent(out) :: dfds (:) dFdS real(kind=pr), intent(in) :: tol Variables Type Visibility Attributes Name Initial real(kind=pr), public :: X0 (size(X)) real(kind=pr), public :: dX (size(X)) real(kind=pr), public :: solve_tol","tags":"","url":"proc/full_newton.html"},{"title":"setup_uniquac – yaeos","text":"public  function setup_uniquac(qs, rs, aij, bij, cij, dij, eij) Instantiate a UNIQUAC model. Non provided interaction parameters are set to zero matrices. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: qs (:) Molecule’s relative volumes real(kind=pr), intent(in) :: rs (size(qs)) Molecule’s relative areas real(kind=pr), intent(in), optional :: aij (size(qs),size(qs)) Interaction parameters matrix , zero matrix if no provided. real(kind=pr), intent(in), optional :: bij (size(qs),size(qs)) Interaction parameters matrix , zero matrix if no provided. real(kind=pr), intent(in), optional :: cij (size(qs),size(qs)) Interaction parameters matrix , zero matrix if no provided. real(kind=pr), intent(in), optional :: dij (size(qs),size(qs)) Interaction parameters matrix , zero matrix if no provided. real(kind=pr), intent(in), optional :: eij (size(qs),size(qs)) Interaction parameters matrix , zero matrix if no provided. Return Value type( UNIQUAC )","tags":"","url":"proc/setup_uniquac.html"},{"title":"excess_gibbs – yaeos","text":"public  subroutine excess_gibbs(self, n, T, Ge, GeT, GeT2, Gen, GeTn, Gen2) Calculate the excess Gibbs free energy and its derivatives of the\nUNIQUAC model. Type Bound UNIQUAC Arguments Type Intent Optional Attributes Name class( UNIQUAC ), intent(in) :: self UNIQUAC model real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Excess Gibbs energy real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional :: Gen (size(n)) real(kind=pr), intent(out), optional :: GeTn (size(n)) real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: GeT2_aux real(kind=pr), public :: GeT_aux real(kind=pr), public :: GeTn_aux (size(n)) real(kind=pr), public :: Ge_aux real(kind=pr), public :: Ge_comb real(kind=pr), public :: Ge_res real(kind=pr), public :: Gen2_aux (size(n),size(n)) real(kind=pr), public :: Gen_aux (size(n)) real(kind=pr), public :: Gen_comb (size(n)) real(kind=pr), public :: Gen_res (size(n)) real(kind=pr), public :: d2tau (size(n),size(n)) real(kind=pr), public :: d2thetak_dnidnj (size(n),size(n),size(n)) real(kind=pr), public :: diff_aux (size(n)) real(kind=pr), public :: dln_nk_dni (size(n),size(n)) logical, public :: dn logical, public :: dn2 logical, public :: dt logical, public :: dt2 logical, public :: dt_or_dtn real(kind=pr), public :: dtau (size(n),size(n)) real(kind=pr), public :: dthetak_dni (size(n),size(n)) logical, public :: dtn integer, public :: i integer, public :: j integer, public :: k real(kind=pr), public :: n_tot integer, public :: nc real(kind=pr), public :: q_i real(kind=pr), public :: q_j real(kind=pr), public :: q_k real(kind=pr), public :: r_i real(kind=pr), public :: r_j real(kind=pr), public :: r_k real(kind=pr), public :: sum_d2theta_tau_lk (size(n)) real(kind=pr), public :: sum_dtheta_l_dtau_lk (size(n),size(n)) real(kind=pr), public :: sum_dtheta_l_tau_lk (size(n),size(n)) real(kind=pr), public :: sum_nq real(kind=pr), public :: sum_nr real(kind=pr), public :: sum_theta_l_d2tau_lk (size(n)) real(kind=pr), public :: sum_theta_l_dtau_lk (size(n)) real(kind=pr), public :: sum_thetal_tau_lk (size(n)) real(kind=pr), public :: tau (size(n),size(n)) real(kind=pr), public :: thetak (size(n)) real(kind=pr), public :: trm1 real(kind=pr), public :: trm2 real(kind=pr), public :: trm3 real(kind=pr), public :: trm4 real(kind=pr), public :: trm5 real(kind=pr), public :: trm6","tags":"","url":"proc/excess_gibbs.html"},{"title":"taus – yaeos","text":"public  subroutine taus(self, T, tau, tauT, tauT2) Calculate the temperature dependence term of the UNIQUAC model. Type Bound UNIQUAC Arguments Type Intent Optional Attributes Name class( UNIQUAC ), intent(in) :: self UNIQUAC model real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: tau (size(self%qs),size(self%qs)) UNIQUAC temperature dependence term real(kind=pr), intent(out), optional :: tauT (size(self%qs),size(self%qs)) real(kind=pr), intent(out), optional :: tauT2 (size(self%qs),size(self%qs)) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: d2u (size(self%qs),size(self%qs)) logical, public :: dt logical, public :: dt2 real(kind=pr), public :: du (size(self%qs),size(self%qs)) real(kind=pr), public :: tau_aux (size(self%qs),size(self%qs)) logical, public :: tt real(kind=pr), public :: u (size(self%qs),size(self%qs))","tags":"","url":"proc/taus.html"},{"title":"px_envelope – yaeos","text":"public  function px_envelope(model, z0, zi, np, T, x_l0, w0, betas0, P0, alpha0, ns0, dS0, beta_w, points) Uses yaeos__auxiliar px_envelope Calculation of a multiphase Px envelope. Description Calculates a phase envelope at costant temperature, using a numerical\ncontinuation method. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z0 (:) Original fluid composition. real(kind=pr), intent(in) :: zi (:) Other fluid compostion. integer, intent(in) :: np Number of phases, without including the reference phaes real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: x_l0 (np,size(z0)) Initial guess for composition of phases. real(kind=pr), intent(in) :: w0 (size(z0)) Initial guess for composition of reference phase. real(kind=pr), intent(in) :: betas0 (np) Mole fractions of each phase. Excluding the reference phase. real(kind=pr), intent(in) :: P0 Initial guess for pressure [bar] real(kind=pr), intent(in) :: alpha0 Initial guess for relation between two fluids integer, intent(in) :: ns0 First specified variable. The first nc*np values correspond to\nthe different , which are sorted like . From nc*np+1 to nc*np + np , the different values. nc*np+np+1 and cp*np+np+2 are and , \nrespectively. real(kind=pr), intent(in) :: dS0 First step to extrapolate for next point calculation. After that\nIt will use an adaptive algorithm. real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. integer, intent(in), optional :: points Maximum number of points to calculate. Return Value type( PXEnvelMP ) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: F (size(z0)*np+np+2) real(kind=pr), private :: P real(kind=pr), private :: S Specified value real(kind=pr), private :: X (size(z0)*np+np+2) real(kind=pr), private :: X0 (size(X)) Initial guess for the point real(kind=pr), private :: alpha real(kind=pr), private, allocatable :: alphas (:) real(kind=pr), private :: betas (np) real(kind=pr), private :: dF (size(z0)*np+np+2,size(z0)*np+np+2) real(kind=pr), private :: dS Step size of the specification for the next point real(kind=pr), private :: dX (size(z0)*np+np+2) real(kind=pr), private :: dXdS (size(z0)*np+np+2) type( MPPoint ), private, allocatable :: env_points (:) integer, private :: i Point calculation index integer, private :: ia integer, private :: inner Number of times a failed point is retried to converge integer, private :: its integer, private :: lb Lower bound, index of the first component of a phase integer, private :: max_iterations = 100 integer, private :: nc integer, private :: ns Number of the specified variable integer, private :: number_of_points type( MPPoint ), private :: point integer, private :: ub Upper bound, index of the last component of a phase real(kind=pr), private :: w (size(z0)) real(kind=pr), private :: x_l (np,size(z0)) real(kind=pr), private :: z (size(z0))","tags":"","url":"proc/px_envelope.html"},{"title":"px_F_NP – yaeos","text":"public  subroutine px_F_NP(model, z0, zi, np, T, beta_w, X, ns, S, F, df) Uses iso_fortran_env px_F_NP System of equations to solve a multiphase-point at constant \ntemperature. Description A multiphase equilibria point between np+1 phases and nc components, where the np+1 phase is a phase taken as reference for\nthe calculation of equilibria rations , \ncan be defined by the system of equations: Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z0 (:) First mixture composition. real(kind=pr), intent(in) :: zi (:) Second mixture composition. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: T Temperature [K]. real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: ns Number of specification. real(kind=pr), intent(in) :: S Specification value. real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated. real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix. Variables Type Visibility Attributes Name Initial real(kind=pr), private :: K (np,size(z0)) real(kind=pr), private :: P real(kind=pr), private :: Vl (np) real(kind=pr), private :: Vw real(kind=pr), private :: alpha real(kind=pr), private :: betas (np) real(kind=pr), private :: denom (size(z0)) real(kind=pr), private :: denomdlnK (np,size(z0),size(z0)) real(kind=pr), private, dimension(size(z0), size(z0)) :: dlnphi_dn real(kind=pr), private, dimension(np, size(z0), size(z0)) :: dlnphi_dn_l real(kind=pr), private, dimension(size(z0), size(z0)) :: dlnphi_dn_w real(kind=pr), private :: dlnphi_dp (size(z0)) real(kind=pr), private, dimension(np, size(z0)) :: dlnphi_dp_l real(kind=pr), private, dimension(size(z0)) :: dlnphi_dp_w real(kind=pr), private :: dlnphi_dt (size(z0)) real(kind=pr), private, dimension(np, size(z0)) :: dlnphi_dt_l real(kind=pr), private, dimension(size(z0)) :: dlnphi_dt_w real(kind=pr), private :: dwda (size(z0)) real(kind=pr), private :: dwdb (np,size(z0)) real(kind=pr), private :: dwdlnK (np,size(z0)) real(kind=pr), private :: dx_l_dlnK (np,np,size(z0)) real(kind=pr), private :: dzda (size(z0)) integer, private :: i integer, private :: idx_1 integer, private :: idx_2 integer, private :: j integer, private :: l integer, private :: lb real(kind=pr), private :: lnphi (size(z0)) real(kind=pr), private, dimension(np, size(z0)) :: lnphi_l real(kind=pr), private, dimension(size(z0)) :: lnphi_w real(kind=pr), private :: moles (size(z0)) integer, private :: nc integer, private :: phase integer, private :: ub real(kind=pr), private, dimension(size(z0)) :: w real(kind=pr), private, dimension(np, size(z0)) :: x_l real(kind=pr), private :: z (size(z0))","tags":"","url":"proc/px_f_np.html"},{"title":"detect_critical – yaeos","text":"private  subroutine detect_critical(nc, np, X, dXdS, ns, dS, S) detect_critical Detect if the system is close to a critical point. Description When the system is close to a critical point, the values\nare close to zero, since the composition of the incipient phase and the phase are similar (equal in the critical point). This can be used\nto detect if the system is close to a critical point and force a jump\nabove it. References Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. real(kind=pr), intent(inout) :: S Specification value. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: lb integer, private :: ub","tags":"","url":"proc/detect_critical~2.html"},{"title":"get_values_from_X – yaeos","text":"private  subroutine get_values_from_X(X, np, z0, zi, beta_w, x_l, w, betas, P, alpha) get_values_from_X Extract the values of the variables from the vector X. Type Bound PXEnvelMP Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: z0 (:) Initial mixture composition. real(kind=pr), intent(in) :: zi (:) Second mixture composition. real(kind=pr), intent(in) :: beta_w Reference phase beta. real(kind=pr), intent(out) :: x_l (np,size(z0)) Mole fractions of the main phases. real(kind=pr), intent(out) :: w (size(z0)) Mole fractions of the incipient phase. real(kind=pr), intent(out) :: betas (np) Fractions of the main phases. real(kind=pr), intent(out) :: P Pressure [bar]. real(kind=pr), intent(out) :: alpha . Variables Type Visibility Attributes Name Initial real(kind=pr), private :: K (np,size(z0)) integer, private :: i Loop index. integer, private :: l Phase index. integer, private :: lb Lower bound of each phase. integer, private :: nc Number of components. integer, private :: ub Upper bound of each phase. real(kind=pr), private :: z (size(z0))","tags":"","url":"proc/get_values_from_x~2.html"},{"title":"solve_point – yaeos","text":"private  subroutine solve_point(model, z0, zi, np, T, beta_w, X, ns, S, dXdS, F, df, iters, max_iterations) Uses iso_fortran_env yaeos__math solve_point Solve the system of equations for a multiphase point. Description Solves the point of a multiphase system using the Newton-Raphson \nmethod. The system of equations is defined in px_F_NP Type Bound PXEnvelMP Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z0 (:) First mixture composition. real(kind=pr), intent(in) :: zi (:) Second mixture composition. integer, intent(in) :: np Number of main phases real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(in) :: dXdS (size(X)) Sensitivity of the variables wrt the specification real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix integer, intent(out) :: iters Number of iterations needed to converge the point integer, intent(in) :: max_iterations Maximum number of iterations to solve the point Variables Type Visibility Attributes Name Initial real(kind=pr), private :: X0 (size(X)) real(kind=pr), private :: dX (size(X)) integer, private :: iP integer, private :: ia integer, private :: nc","tags":"","url":"proc/solve_point~2.html"},{"title":"update_specification – yaeos","text":"private  subroutine update_specification(its, nc, np, X, dF, dXdS, ns, dS) update_specification Change the specified variable for the next step. Description Using the information of a converged point and the Jacobian matrix of\nthe function. It is possible to determine the sensitivity of the\nvariables with respect to the specification. This information is used\nto update the specification for the next point. Choosing the variable\nwith the highest sensitivity.\nThis can be done by solving the system of equations: for the vector. The variable with the highest value\nof is chosen as the new specification. References Arguments Type Intent Optional Attributes Name integer, intent(in) :: its Iterations to solve the current point. integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dF (:,:) Jacobian matrix. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. Variables Type Visibility Attributes Name Initial real(kind=pr), private :: dFdS (size(X)) Sensitivity of the functions wrt the specification. integer, private :: i integer, private :: lb Lower bound of each phase integer, private :: ub Upper bound of each phase","tags":"","url":"proc/update_specification~2.html"},{"title":"write_envelope_PX_MP – yaeos","text":"private  subroutine write_envelope_PX_MP(env, unit) Type Bound PXEnvelMP Arguments Type Intent Optional Attributes Name class( PXEnvelMP ), intent(in) :: env integer, intent(in) :: unit Variables Type Visibility Attributes Name Initial real(kind=pr), private :: P real(kind=pr), private :: T real(kind=pr), private :: alpha real(kind=pr), private, allocatable :: betas (:) integer, private :: i integer, private :: j integer, private :: nc integer, private :: np real(kind=pr), private, allocatable :: w (:) real(kind=pr), private, allocatable :: x_l (:,:)","tags":"","url":"proc/write_envelope_px_mp.html"},{"title":"excess_enthalpy – yaeos","text":"public  subroutine excess_enthalpy(self, n, T, He, HeT, Hen) Calculate Excess enthalpy and its derivatives. References [1] https://en.wikipedia.org/wiki/Gibbs%E2%80%93Helmholtz_equation Type Bound GeModel Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: He Excess enthalpy real(kind=pr), intent(out), optional :: HeT real(kind=pr), intent(out), optional :: Hen (:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ge real(kind=pr), public :: GeT real(kind=pr), public :: GeT2 real(kind=pr), public :: GeTn (size(n)) real(kind=pr), public :: Gen (size(n))","tags":"","url":"proc/excess_enthalpy.html"},{"title":"excess_entropy – yaeos","text":"public  subroutine excess_entropy(self, n, T, Se, SeT, Sen) Calculate Excess entropy and its derivatives. Type Bound GeModel Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Se Excess entropy real(kind=pr), intent(out), optional :: SeT real(kind=pr), intent(out), optional :: Sen (:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ge real(kind=pr), public :: GeT real(kind=pr), public :: GeT2 real(kind=pr), public :: GeTn (size(n))","tags":"","url":"proc/excess_entropy.html"},{"title":"ln_activity_coefficient – yaeos","text":"public  subroutine ln_activity_coefficient(self, n, T, lngamma, dlngammadT, dlngammadn) Calculate natural logarithm of activity coefficients. Type Bound GeModel Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: lngamma (:) Natural logarithm of activity coefficients real(kind=pr), intent(out), optional :: dlngammadT (size(n)) real(kind=pr), intent(out), optional :: dlngammadn (size(n),size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ge real(kind=pr), public :: GeTn (size(n)) real(kind=pr), public :: Gen (size(n)) real(kind=pr), public :: Gen2 (size(n),size(n)) logical, public :: dn logical, public :: dt logical, public :: tt","tags":"","url":"proc/ln_activity_coefficient.html"},{"title":"v0 – yaeos","text":"public  function v0(self, n, p, t) Cubic EoS volume initializer.\nFor a Cubic Equation of State, the covolume calculated with the mixing\nrule is a good estimate for the initial volume solver on the liquid\nregion. Type Bound CubicEoS Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dbi (size(n)) real(kind=pr), public :: dbij (size(n),size(n))","tags":"","url":"proc/v0.html"},{"title":"GenericCubic_Ar – yaeos","text":"public  subroutine GenericCubic_Ar(self, n, v, t, ar, arv, ArT, artv, arv2, ArT2, Arn, ArVn, ArTn, Arn2) Uses yaeos__constants yaeos__models_ar_genericcubic_base Residual Helmholtz Energy for a generic Cubic Equation of State. Calculates the residual Helmholtz Energy for a generic Cubic EoS as\ndefined by Michelsen and Møllerup: This routine assumes that the is not a constant parameter\n(as it uses to be in classical Cubic EoS) to be compatible with the\nthree parameter EoS RKPR where is not a constant and\nhas its own mixing rule. Type Bound CubicEoS Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: ar Residual Helmholtz real(kind=pr), intent(out), optional :: arv real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: artv real(kind=pr), intent(out), optional :: arv2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: B real(kind=pr), public :: D real(kind=pr), public :: Tr (size(n)) real(kind=pr), public :: a (size(n)) real(kind=pr), public :: d1 real(kind=pr), public :: dBi (size(n)) real(kind=pr), public :: dBij (size(n),size(n)) real(kind=pr), public :: dD1i (size(n)) real(kind=pr), public :: dD1ij (size(n),size(n)) real(kind=pr), public :: dDdT real(kind=pr), public :: dDdT2 real(kind=pr), public :: dDi (size(n)) real(kind=pr), public :: dDidT (size(n)) real(kind=pr), public :: dDij (size(n),size(n)) real(kind=pr), public :: dadt (size(n)) real(kind=pr), public :: dadt2 (size(n)) integer, public :: nc real(kind=pr), public :: totn","tags":"","url":"proc/genericcubic_ar~2.html"},{"title":"set_delta1 – yaeos","text":"public  subroutine set_delta1(self, delta1) Type Bound CubicEoS Arguments Type Intent Optional Attributes Name class( CubicEoS ) :: self real(kind=pr), intent(in) :: delta1 (:)","tags":"","url":"proc/set_delta1.html"},{"title":"set_mixrule – yaeos","text":"public  subroutine set_mixrule(self, mixrule) Type Bound CubicEoS Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(inout) :: self class( CubicMixRule ), intent(in) :: mixrule","tags":"","url":"proc/set_mixrule.html"},{"title":"volume – yaeos","text":"public  subroutine volume(eos, n, P, T, V, root_type) Uses yaeos__constants yaeos__math_linalg yaeos__models_solvers Cubic EoS volume solver Volume solver optimized for Cubic Equations of State. @warn\nThis routine intends to use the analyitical solution of the cubic\nequation, but due to errors in the solutions it is not used. And\nthe general volume solver by Michelsen is used instead.\n@endwarn Description Cubic equations can be analytically solved. Using an anallytical\nsolution provides the best possible solution in terms of speed and\nprecision. This subroutine uses the modified cardano method proposed\nby Rosendo. Examples use yaeos , only : CubicEoS , PengRobinson type ( CubicEoS ) :: eos eos = PengRobinson ( tc , pc , w ) ! Possible roots to solve call eos % volume ( n , P , T , V , \"liquid\" ) call eos % volume ( n , P , T , V , \"vapor\" ) call eos % volume ( n , P , T , V , \"stable\" ) References [1] “Thermodynamic Models: Fundamental and Computational Aspects”,\n Michael L. Michelsen, Jørgen M. Mollerup.\n Tie-Line Publications, Denmark (2004) doi [2] “A Note on the Analytical Solution of Cubic Equations of State\nin Process Simulation”, Rosendo Monroy-Loperena doi Type Bound CubicEoS Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: eos real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: V character(len=*), intent(in) :: root_type Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AT_Liq real(kind=pr), public :: AT_Vap real(kind=pr), public :: Ar real(kind=pr), public :: Bmix real(kind=pr), public :: D real(kind=pr), public :: D1 real(kind=pr), public :: D2 real(kind=pr), public :: Tr (size(n)) real(kind=pr), public :: V_liq real(kind=pr), public :: V_vap real(kind=pr), public :: a (size(n)) real(kind=pr), public :: cp (4) complex(kind=pr), public :: cr (3) real(kind=pr), public :: dBi (size(n)) real(kind=pr), public :: dBij (size(n),size(n)) real(kind=pr), public :: dD1i (size(n)) real(kind=pr), public :: dD1ij (size(n),size(n)) real(kind=pr), public :: dDdT real(kind=pr), public :: dDdT2 real(kind=pr), public :: dDi (size(n)) real(kind=pr), public :: dDidT (size(n)) real(kind=pr), public :: dDij (size(n),size(n)) real(kind=pr), public :: dadt (size(n)) real(kind=pr), public :: dadt2 (size(n)) integer, public :: flag real(kind=pr), public :: rr (3) real(kind=pr), public :: totn real(kind=pr), public :: z (size(n))","tags":"","url":"proc/volume.html"},{"title":"px_envelope_2ph – yaeos","text":"public  function px_envelope_2ph(model, z0, alpha0, z_injection, first_point, points, iterations, delta_0, specified_variable_0, solver, stop_conditions) result(envelopes) Uses yaeos__auxiliar PX two-phase envelope calculation procedure. Phase envelope calculation using the continuation method.\nDefaults to solving the saturation temperature and continues with\nan increment in it. The variable to specify can be changed by modifying specified_variable_0 with the corresponding variable number. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Thermodyanmic model real(kind=pr), intent(in) :: z0 (:) Vector of molar fractions of the global composition (main phase) real(kind=pr), intent(in) :: alpha0 First point of real(kind=pr), intent(in) :: z_injection (:) Vector of molar fractions of the injection fluid type( EquilibriumState ) :: first_point integer, intent(in), optional :: points Maxmimum number of points, defaults to 500 integer, intent(in), optional :: iterations Point solver maximum iterations, defaults to 100 real(kind=pr), intent(in), optional :: delta_0 Initial extrapolation integer, intent(in), optional :: specified_variable_0 Position of specified variable, since the vector of variables is the values for specification\nwill be for the equilibria constants, for and for . procedure( continuation_solver ), optional :: solver Specify solver for each point, defaults to a full newton procedure procedure( continuation_stopper ), optional :: stop_conditions Function that returns true if the continuation method should stop Return Value type( PXEnvel2 ) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: S0 Initial specification value real(kind=pr), private :: T real(kind=pr), private :: X (size(z)+2) real(kind=pr), private, allocatable :: XS (:,:) real(kind=pr), private :: dS0 Initial specification step character(len=14), private :: kind integer, private :: max_iterations Maximum number of iterations integer, private :: max_points Maximum number of points integer, private :: nc Number of components integer, private :: ns Number of specified variable real(kind=pr), private :: z (size(z0)) Composition at some point Subroutines subroutine detect_critical (X, dXdS, ns, S, dS) Critical point detection Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables real(kind=pr), intent(inout) :: dXdS (:) Variation of variables wrt S integer, intent(inout) :: ns Number of specified variable real(kind=pr), intent(inout) :: S Specification value real(kind=pr), intent(inout) :: dS Step in specification recursive subroutine foo (X, ns, S, F, dF, dFdS) Function that needs to be solved at each envelope point Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out) :: dF (:,:) real(kind=pr), intent(out) :: dFdS (:) subroutine save_point (X, iters) Save the converged point Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: iters subroutine update_spec (X, ns, S, dS, dXdS, step_iters) Update the specification during continuation. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(inout) :: ns Number of specified variable in the vector real(kind=pr), intent(inout) :: S Variable specification value real(kind=pr), intent(inout) :: dS Step in specification real(kind=pr), intent(inout) :: dXdS (:) Variation of variables with respect to specification integer, intent(in) :: step_iters Iterations used in the solver","tags":"","url":"proc/px_envelope_2ph.html"},{"title":"PSRK – yaeos","text":"public  function PSRK(tc, pc, w, molecules, c1, c2, c3) result(model) Uses yaeos__models_cubic_mixing_rules_huron_vidal yaeos__models_ge_implementations yaeos__models_ar_cubic_alphas yaeos__models_ar_genericcubic yaeos__models_ge_group_contribution_groups Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical temperature [K] real(kind=pr), intent(in) :: pc (:) Critical pressure [bar] real(kind=pr), intent(in) :: w (:) Acentric factor type( Groups ), intent(in) :: molecules (:) real(kind=pr), intent(in), optional :: c1 (:) real(kind=pr), intent(in), optional :: c2 (:) real(kind=pr), intent(in), optional :: c3 (:) Return Value type( CubicEoS ) Variables Type Visibility Attributes Name Initial type( AlphaSoave ), private :: alpha type( AlphaMathiasCopeman ), private :: alpha_mc type( Substances ), private :: composition type( UNIFAC ), private :: ge integer, private :: i type( MHV ), private :: mixrule integer, private :: nc","tags":"","url":"proc/psrk.html"},{"title":"PengRobinson76 – yaeos","text":"public  function PengRobinson76(tc, pc, w, kij, lij) result(model) Uses yaeos__substance yaeos__models_ar_cubic_quadratic_mixing yaeos__models_ar_genericcubic yaeos__models_ar_cubic_alphas yaeos__constants PengRobinson76. Using the critical constants setup the parameters to use the\nPengRobinson Equation of State There is also the optional posibility to include the and matrices. Using by default Classic Van der Waals mixing\nrules. After setting up the model, it is possible to redefine either the\nmixing rule or the alpha function using a different derived type\ndefined outside the function. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical Temperatures [K] real(kind=pr), intent(in) :: pc (:) Critical Pressures [bar] real(kind=pr), intent(in) :: w (:) Acentric Factors real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS ) Variables Type Visibility Attributes Name Initial type( AlphaSoave ), private :: alpha type( Substances ), private :: composition integer, private :: i type( QMR ), private :: mixrule integer, private :: nc","tags":"","url":"proc/pengrobinson76.html"},{"title":"PengRobinson78 – yaeos","text":"public  function PengRobinson78(tc, pc, w, kij, lij) result(model) Uses yaeos__substance yaeos__models_ar_cubic_quadratic_mixing yaeos__models_ar_genericcubic yaeos__models_ar_cubic_alphas yaeos__constants PengRobinson78. Using the critical constants setup the parameters to use the\nPengRobinson Equation of State There is also the optional posibility to include the and matrices. Using by default Classic Van der Waals mixing\nrules. After setting up the model, it is possible to redefine either the\nmixing rule or the alpha function using a different derived type\ndefined outside the function. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical Temperatures [K] real(kind=pr), intent(in) :: pc (:) Critical Pressures [bar] real(kind=pr), intent(in) :: w (:) Acentric Factors real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS ) Variables Type Visibility Attributes Name Initial type( AlphaSoave ), private :: alpha type( Substances ), private :: composition integer, private :: i type( QMR ), private :: mixrule integer, private :: nc","tags":"","url":"proc/pengrobinson78.html"},{"title":"RKPR – yaeos","text":"public  function RKPR(tc, pc, w, zc, kij, lij, delta_1, k) result(model) Uses yaeos__models_ar_cubic_alphas yaeos__models_ar_cubic_quadratic_mixing RKPR Equation of State The RKPR EoS extends the classical formulation of Cubic Equations\nof State by freeing the parameter . This extra degree\nprovides extra ways of implementing the equation in comparison\nof other Cubic EoS (like PR and SRK) which are limited to definition\nof their critical constants. Besides that extra parameter, the RKRR includes another function: In this implementation we take the simplest form which correlates\nthe extra parameter to the critical compressibility factor and\nthe parameter of the function to and : Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical Temperature [K] real(kind=pr), intent(in) :: pc (:) Critical Pressure [bar] real(kind=pr), intent(in) :: w (:) Acentric Factor real(kind=pr), intent(in) :: zc (:) Critical compressibility real(kind=pr), intent(in), optional :: kij (:,:) k_{ij} matrix real(kind=pr), intent(in), optional :: lij (:,:) l_{ij} matrix real(kind=pr), intent(in), optional :: delta_1 (:) real(kind=pr), intent(in), optional :: k (:) Return Value type( CubicEoS ) Variables Type Visibility Attributes Name Initial real(kind=pr), private, parameter :: A0 = 0.0017 real(kind=pr), private, parameter :: A1 = -2.4407 real(kind=pr), private, parameter :: B0 = 1.9681 real(kind=pr), private, parameter :: B1 = 7.4513 real(kind=pr), private, parameter :: C0 = -2.6238 real(kind=pr), private, parameter :: C1 = 12.504 real(kind=pr), private :: OMa (size(pc)) real(kind=pr), private :: OMb (size(pc)) real(kind=pr), private :: Psat_i real(kind=pr), private :: Zc_eos (size(pc)) type( AlphaRKPR ), private :: alpha type( Substances ), private :: composition real(kind=pr), private, parameter :: d1 = 0.428364 real(kind=pr), private, parameter :: d2 = 18.496215 real(kind=pr), private, parameter :: d3 = 0.338426 real(kind=pr), private, parameter :: d4 = 0.66 real(kind=pr), private, parameter :: d5 = 789.723105 real(kind=pr), private, parameter :: d6 = 2.512392 real(kind=pr), private :: diff integer, private :: i type( QMR ), private :: mixrule integer, private :: nc","tags":"","url":"proc/rkpr.html"},{"title":"SoaveRedlichKwong – yaeos","text":"public  function SoaveRedlichKwong(tc, pc, w, kij, lij) result(model) Uses yaeos__models_ar_cubic_alphas yaeos__models_ar_genericcubic yaeos__models_ar_cubic_quadratic_mixing SoaveRedlichKwong. Using the critical constants setup the parameters to use the\nSoaveRedlichKwong Equation of State There is also the optional posibility to include the k_{ij} and l_{ij}\nmatrices. Using by default Classic Van der Waals mixing rules. After setting up the model, it is possible to redefine either the\nmixing rule or the alpha function using a different derived type\ndefined outside the function. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical temperature [K] real(kind=pr), intent(in) :: pc (:) Critical pressure [bar] real(kind=pr), intent(in) :: w (:) Acentric factor real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS ) Variables Type Visibility Attributes Name Initial type( AlphaSoave ), private :: alpha type( Substances ), private :: composition integer, private :: i type( QMR ), private :: mixrule integer, private :: nc","tags":"","url":"proc/soaveredlichkwong.html"},{"title":"refit_rkpr_k – yaeos","text":"public  subroutine refit_rkpr_k(model, component) Uses yaeos__models_ar_cubic_alphas yaeos__equilibria_boundaries_pure_saturation refit_rkpr_k Refit the parameter of the RKPR EoS to match the acentric\nfactor Arguments Type Intent Optional Attributes Name type( CubicEoS ), intent(inout) :: model The model to be refitted integer, intent(in) :: component Component index to refit Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Pc type( PurePsat ), private :: Psat real(kind=pr), private :: Psat_i real(kind=pr), private :: Tc type( AlphaRKPR ), private :: alpha real(kind=pr), private :: diff integer, private :: i real(kind=pr), private :: w","tags":"","url":"proc/refit_rkpr_k.html"},{"title":"get_OMa_OMb – yaeos","text":"private  subroutine get_OMa_OMb(del1, OMa, OMb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: del1 (:) real(kind=pr), intent(out) :: OMa (size(del1)) real(kind=pr), intent(out) :: OMb (size(del1)) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: d1 (size(del1)) real(kind=pr), private :: y (size(del1))","tags":"","url":"proc/get_oma_omb.html"},{"title":"px_envelope_3ph – yaeos","text":"public  function px_envelope_3ph(model, z0, zi, T, x0, y0, w0, beta0, P0, a0, ns0, dS0, points) result(envelope) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: x0 (:) real(kind=pr), intent(in) :: y0 (:) real(kind=pr), intent(in) :: w0 (:) real(kind=pr), intent(in) :: beta0 real(kind=pr), intent(in) :: P0 real(kind=pr), intent(in) :: a0 integer, intent(in) :: ns0 real(kind=pr), intent(in) :: dS0 integer, intent(in) :: points Return Value type( PXEnvel3 ) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: F (size(z0)*2+3) real(kind=pr), private :: P (points) real(kind=pr), private :: S Specified value real(kind=pr), private :: Xvars (size(z0)*2+3) real(kind=pr), private :: a (points) real(kind=pr), private :: beta (points) real(kind=pr), private :: dF (size(z0)*2+3,size(z0)*2+3) real(kind=pr), private :: dS Specified value step for next point extrapolation real(kind=pr), private :: dX (size(z0)*2+3) real(kind=pr), private :: dXdS (size(z0)*2+3) integer, private :: i integer, private :: its real(kind=pr), private :: kx (size(z0)) real(kind=pr), private :: ky (size(z0)) integer, private :: max_its = 500 integer, private :: nc integer, private :: ns Specified variable real(kind=pr), private :: w (points,size(z0)) real(kind=pr), private :: x (points,size(z0)) real(kind=pr), private :: y (points,size(z0))","tags":"","url":"proc/px_envelope_3ph.html"},{"title":"critical_interpol – yaeos","text":"private  function critical_interpol(Xnew, Xold, idx) result(a) critical_interpol Critical point interpolation Description This function calculates the parameter to interpolate the\nvalues of the variables at the critical point. The interpolation\nis done using the equation: Where is the old value of the variables and is the new value of the variables. The critical point is the point\nwhere the variables change sign, so the interpolation is done to\nfind the value of the variables at the critical point. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xnew (:) New value of the variables real(kind=pr), intent(in) :: Xold (:) Old value of the variables integer, intent(in) :: idx (:) Index of the variables to interpolate Return Value real(kind=pr) Variables Type Visibility Attributes Name Initial integer, private :: ncomp","tags":"","url":"proc/critical_interpol.html"},{"title":"get_values_from_X – yaeos","text":"public  subroutine get_values_from_X(z0, zi, Xvars, x, y, w, P, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) real(kind=pr), intent(in) :: Xvars (size(z0)*2+3) real(kind=pr), intent(out) :: x (size(z0)) real(kind=pr), intent(out) :: y (size(z0)) real(kind=pr), intent(out) :: w (size(z0)) real(kind=pr), intent(out) :: P real(kind=pr), intent(out) :: alpha real(kind=pr), intent(out) :: beta Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Kx ((Size(Xvars)-3)/2) real(kind=pr), private :: Ky ((Size(Xvars)-3)/2) integer, private :: nc real(kind=pr), private :: z (size(z0))","tags":"","url":"proc/get_values_from_x~3.html"},{"title":"solve_point – yaeos","text":"public  subroutine solve_point(model, z0, zi, T, ns, S, X, F, dF, its, maxits) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) real(kind=pr), intent(in) :: T integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(inout) :: X (:) real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out) :: dF (:,:) integer, intent(inout) :: its integer, intent(in) :: maxits Variables Type Visibility Attributes Name Initial real(kind=pr), private :: dX (size(X)) integer, private :: nc","tags":"","url":"proc/solve_point~3.html"},{"title":"detect_critical – yaeos","text":"private  subroutine detect_critical(X, dXdS, ns, S, dS) detect_critical Critical point detection Description If the values of lnK (X[:nc]) change sign then a critical point\nHas passed, since for this to happen all variables should pass\nthrough zero. Near critical points (lnK < 0.05) points are harder\nto converge, so more steps in the extrapolation vector are made to\njump over the critical point.\nIf the critical point is detected then the kind of the point is\nchanged and the point is saved using an interpolation knowing that With is the variables at the critical point, is the new initialization point of the method and is the\nparameter to interpolate the values. This subroutine finds the\nvalue of to obtain . Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables real(kind=pr), intent(inout) :: dXdS (:) Variation of variables wrt S integer, intent(inout) :: ns Number of specified variable real(kind=pr), intent(inout) :: S Specification value real(kind=pr), intent(inout) :: dS Step in specification Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Xc (size(X)) Value at (near) critical point real(kind=pr), private :: Xnew (size(X)) Value of the next initialization real(kind=pr), private :: Xold (size(X)) Old value of X real(kind=pr), private :: a Parameter for interpolation integer, private :: critical_set ((size(X)-3)/2) integer, private :: first_set ((size(X)-3)/2) logical, private :: found_critical integer, private :: i integer, private :: idx ((size(X)-3)/2) integer, private :: nc integer, private :: second_set ((size(X)-3)/2) real(kind=pr), private :: step (size(X))","tags":"","url":"proc/detect_critical~3.html"},{"title":"px_F_three_phases – yaeos","text":"private  subroutine px_F_three_phases(model, z0, zi, T, Xvars, ns, S, F, df) Uses iso_fortran_env Function to solve at each point of a three phase envelope. The vector of variables X corresponds to: While the equations are: Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: Xvars (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(Xvars)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) Jacobian matrix Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Kx (size(z0)) real(kind=pr), private :: Ky (size(z0)) real(kind=pr), private :: P real(kind=pr), private :: Vw real(kind=pr), private :: Vx real(kind=pr), private :: Vy real(kind=pr), private :: alpha real(kind=pr), private :: beta real(kind=pr), private, dimension(size(z0), size(z0)) :: dlnphi_dn_w real(kind=pr), private, dimension(size(z0), size(z0)) :: dlnphi_dn_x real(kind=pr), private, dimension(size(z0), size(z0)) :: dlnphi_dn_y real(kind=pr), private, dimension(size(z0)) :: dlnphi_dp_w real(kind=pr), private, dimension(size(z0)) :: dlnphi_dp_x real(kind=pr), private, dimension(size(z0)) :: dlnphi_dp_y real(kind=pr), private, dimension(size(z0)) :: dlnphi_dt_w real(kind=pr), private, dimension(size(z0)) :: dlnphi_dt_x real(kind=pr), private, dimension(size(z0)) :: dlnphi_dt_y real(kind=pr), private :: dwdKx (size(z0)) real(kind=pr), private :: dwdKy (size(z0)) real(kind=pr), private :: dwda (size(z0)) real(kind=pr), private :: dwdb (size(z0)) real(kind=pr), private :: dxdKx (size(z0)) real(kind=pr), private :: dxdKy (size(z0)) real(kind=pr), private :: dydKx (size(z0)) real(kind=pr), private :: dydKy (size(z0)) real(kind=pr), private :: dzda (size(z0)) integer, private :: i integer, private :: j real(kind=pr), private, dimension(size(z0)) :: lnphi_w real(kind=pr), private, dimension(size(z0)) :: lnphi_x real(kind=pr), private, dimension(size(z0)) :: lnphi_y integer, private :: nc real(kind=pr), private, dimension(size(z0)) :: w real(kind=pr), private, dimension(size(z0)) :: x real(kind=pr), private, dimension(size(z0)) :: y real(kind=pr), private :: z (size(z0))","tags":"","url":"proc/px_f_three_phases.html"},{"title":"update_specification – yaeos","text":"private  subroutine update_specification(its, X, dF, dXdS, ns, dS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: its real(kind=pr), intent(inout) :: X (:) real(kind=pr), intent(inout) :: dF (:,:) real(kind=pr), intent(inout) :: dXdS (:) integer, intent(inout) :: ns real(kind=pr), intent(inout) :: dS Variables Type Visibility Attributes Name Initial real(kind=pr), private :: dFdS (size(X)) integer, private :: nc","tags":"","url":"proc/update_specification~3.html"},{"title":"PSRKParameters – yaeos","text":"public  function PSRKParameters() Arguments None Return Value type( GeGCModelParameters ) Variables Type Visibility Attributes Name Initial integer, public :: nmg integer, public :: nsg","tags":"","url":"proc/psrkparameters.html"},{"title":"Psat_pure – yaeos","text":"private  function Psat_pure(eos, ncomp, T) Calculation of saturation pressure of a pure component using the\nsecant method. Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model that will be used integer, intent(in) :: ncomp Number of component in the mixture from which the saturation pressure\nwill be calculated real(kind=pr), intent(in) :: T Temperature [K] Return Value real(kind=pr) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: P1 real(kind=pr), private :: P2 real(kind=pr), private :: f1 real(kind=pr), private :: f2 real(kind=pr), private :: n (size(eos)) Functions function diff (P) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: P Return Value real(kind=pr)","tags":"","url":"proc/psat_pure.html"},{"title":"size_ar_model – yaeos","text":"private pure function size_ar_model(eos) Get the size of the model. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Return Value integer","tags":"","url":"proc/size_ar_model.html"},{"title":"volume – yaeos","text":"public  subroutine volume(eos, n, P, T, V, root_type) Uses yaeos__constants yaeos__math Volume solver routine for residual Helmholtz models. Solves volume roots using newton method. Given pressure and\ntemperature. Description This subroutine solves the volume using a newton method. The variable root_type is used to specify the desired root to solve. The options\nare: [\"liquid\", \"vapor\", \"stable\"] Examples eos = PengRobinson76 ( Tc , Pc , w ) n = [ 1.0_pr , 1.0_pr ] T = 30 0.0_pr P = 1.0_pr call eos % volume ( n , P , T , V , root_type = \"liquid\" ) call eos % volume ( n , P , T , V , root_type = \"vapor\" ) call eos % volume ( n , P , T , V , root_type = \"stable\" ) Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: V Volume [L] character(len=*), intent(in) :: root_type Desired root-type to solve. Options are: [\"liquid\", \"vapor\", \"stable\"] Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Gr real(kind=pr), private :: GrL real(kind=pr), private :: GrV real(kind=pr), private :: Vliq real(kind=pr), private :: Vvap integer, private :: max_iters = 30 real(kind=pr), private :: tol = 1e-7 real(kind=pr), private :: totnRT Subroutines subroutine foo (x, f, df) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x real(kind=pr), intent(out) :: f real(kind=pr), intent(out) :: df","tags":"","url":"proc/volume~2.html"},{"title":"Cp_residual_vt – yaeos","text":"private  subroutine Cp_residual_vt(eos, n, V, T, Cp) Uses yaeos__constants Calculate residual heat capacity pressure constant given V and T. Examples eos = PengRobinson76 ( Tc , Pc , w ) n = [ 1.0_pr , 1.0_pr ] T = 30 0.0_pr V = 1.0_pr call eos % Cp_residual_vt ( n , V , T , Cp = Cp ) Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cp heat capacity P constant [bar L / K] Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Cv real(kind=pr), private :: P real(kind=pr), private :: dPdT real(kind=pr), private :: dPdV real(kind=pr), private :: n_t","tags":"","url":"proc/cp_residual_vt.html"},{"title":"Cv_residual_vt – yaeos","text":"private  subroutine Cv_residual_vt(eos, n, V, T, Cv) Calculate residual heat capacity volume constant given V and T. Examples eos = PengRobinson76 ( Tc , Pc , w ) n = [ 1.0_pr , 1.0_pr ] T = 30 0.0_pr V = 1.0_pr call eos % Cv_residual_vt ( n , V , T , Cv = Cv ) Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cv heat capacity V constant [bar L / K] Variables Type Visibility Attributes Name Initial real(kind=pr), private :: ArT2","tags":"","url":"proc/cv_residual_vt.html"},{"title":"enthalpy_residual_vt – yaeos","text":"private  subroutine enthalpy_residual_vt(eos, n, V, T, Hr, HrV, HrT, Hrn) Calculate residual enthalpy given volume and temperature. Examples eos = PengRobinson76 ( Tc , Pc , w ) n = [ 1.0_pr , 1.0_pr ] T = 30 0.0_pr V = 1.0_pr call eos % enthalpy_residual_vt (& n , V , T , Hr = Hr , HrV = HrV , HrT = HrT , Hrn = Hrn & ) Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Hr Residual enthalpy [bar L] real(kind=pr), intent(out), optional :: HrV real(kind=pr), intent(out), optional :: HrT real(kind=pr), intent(out), optional :: Hrn (size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Ar real(kind=pr), private :: ArT real(kind=pr), private :: ArT2 real(kind=pr), private :: ArTV real(kind=pr), private :: ArTn (size(n)) real(kind=pr), private :: ArV real(kind=pr), private :: ArV2 real(kind=pr), private :: ArVn (size(n)) real(kind=pr), private :: Arn (size(n))","tags":"","url":"proc/enthalpy_residual_vt.html"},{"title":"entropy_residual_vt – yaeos","text":"private  subroutine entropy_residual_vt(eos, n, V, T, Sr, SrV, SrT, Srn) Calculate residual entropy given volume and temperature. Examples eos = PengRobinson76 ( Tc , Pc , w ) n = [ 1.0_pr , 1.0_pr ] T = 30 0.0_pr V = 1.0_pr call eos % entropy_residual_vt (& n , V , T , Sr = Sr , SrV = SrV , SrT = SrT , Srn = Srn & ) Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Sr Entropy [bar L / K] real(kind=pr), intent(out), optional :: SrV real(kind=pr), intent(out), optional :: SrT real(kind=pr), intent(out), optional :: Srn (size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Ar real(kind=pr), private :: ArT real(kind=pr), private :: ArT2 real(kind=pr), private :: ArTV real(kind=pr), private :: ArTn (size(n))","tags":"","url":"proc/entropy_residual_vt.html"},{"title":"gibbs_residual_vt – yaeos","text":"private  subroutine gibbs_residual_vt(eos, n, V, T, Gr, GrV, GrT, Grn) Uses yaeos__constants Calculate residual Gibbs energy given volume and temperature. Examples eos = PengRobinson76 ( Tc , Pc , w ) n = [ 1.0_pr , 1.0_pr ] T = 30 0.0_pr V = 1.0_pr call eos % gibbs_residual_vt (& n , V , T , Gr = Gr , GrV = GrV , GrT = GrT , Grn = Grn & ) Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Gr Gibbs energy [bar L] real(kind=pr), intent(out), optional :: GrV real(kind=pr), intent(out), optional :: GrT real(kind=pr), intent(out), optional :: Grn (size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Ar real(kind=pr), private :: ArT real(kind=pr), private :: ArTV real(kind=pr), private :: ArV real(kind=pr), private :: ArV2 real(kind=pr), private :: ArVn (size(n)) real(kind=pr), private :: Arn (size(n))","tags":"","url":"proc/gibbs_residual_vt.html"},{"title":"internal_energy_residual_vt – yaeos","text":"private  subroutine internal_energy_residual_vt(eos, n, V, T, Ur, UrV, UrT, Urn) Calculate residual internal energy given volume and temperature. Examples eos = PengRobinson76 ( Tc , Pc , w ) n = [ 1.0_pr , 1.0_pr ] T = 30 0.0_pr V = 1.0_pr call eos % internal_energy_residual_vt (& n , V , T , Ur = Ur , UrV = UrV , UrT = UrT , Urn = Urn & ) Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ur Internal energy [bar L] real(kind=pr), intent(out), optional :: UrV real(kind=pr), intent(out), optional :: UrT real(kind=pr), intent(out), optional :: Urn (size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Ar real(kind=pr), private :: ArT real(kind=pr), private :: ArT2 real(kind=pr), private :: ArTV real(kind=pr), private :: ArTn (size(n)) real(kind=pr), private :: ArV real(kind=pr), private :: Arn (size(n))","tags":"","url":"proc/internal_energy_residual_vt.html"},{"title":"lnfug_vt – yaeos","text":"private  subroutine lnfug_vt(eos, n, V, T, P, lnf, dlnfdV, dlnfdT, dlnfdn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given volume and temperature. Calculate the natural logarithm of the fugacity and its derivatives.\nThe routine gives the possibility to calculate the pressure and it’s\nderivatives. Examples eos = PengRobinson76 ( Tc , Pc , w ) n = [ 1.0_pr , 1.0_pr ] T = 30 0.0_pr V = 1.0_pr call eos % lnfug_vt (& n , V , T , lnf = lnf , & dlnfdV = dlnfdV , dlnfdT = dlnfdT , dlnfdn = dlnfdn & ) Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnf (size(n)) vector real(kind=pr), intent(out), optional :: dlnfdV (size(n)) Volume derivative real(kind=pr), intent(out), optional :: dlnfdT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnfdn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Ar real(kind=pr), private :: ArTV real(kind=pr), private, dimension(size(n)) :: ArTn real(kind=pr), private :: ArV real(kind=pr), private :: ArV2 real(kind=pr), private, dimension(size(n)) :: ArVn real(kind=pr), private, dimension(size(n)) :: Arn real(kind=pr), private :: Arn2 (size(n),size(n)) real(kind=pr), private :: P_in real(kind=pr), private :: RT real(kind=pr), private :: Z real(kind=pr), private :: dPdT_in real(kind=pr), private :: dPdV_in real(kind=pr), private :: dPdn_in (size(n)) integer, private :: i integer, private :: j integer, private :: nc real(kind=pr), private :: totn","tags":"","url":"proc/lnfug_vt.html"},{"title":"lnphi_pt – yaeos","text":"private  subroutine lnphi_pt(eos, n, P, T, V, root_type, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Uses iso_fortran_env Calculate natural logarithm of fugacity given pressure and temperature. Calculate the natural logarithm of the fugacity coefficient and its\nderivatives given pressure and temperature. This routine will obtain\nthe desired volume root at the specified pressure and calculate\nfugacity at that point.The routine gives the possibility to calculate\nthe pressure derivatives and volume. Examples eos = PengRobinson76 ( Tc , Pc , w ) n = [ 1.0_pr , 1.0_pr ] T = 30 0.0_pr V = 1.0_pr call eos % lnphi_pt (& n , V , T , lnPhi = lnPhi , & dlnPhidP = dlnPhidP , dlnPhidT = dlnPhidT , dlnPhidn = dlnPhidn & ) Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: V Volume [L] character(len=*), intent(in) :: root_type Type of root desired [“liquid”, “vapor”, “stable”] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) ln(phi) Temperature derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) ln(phi) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: P_in real(kind=pr), private :: V_in","tags":"","url":"proc/lnphi_pt.html"},{"title":"lnphi_vt – yaeos","text":"private  subroutine lnphi_vt(eos, n, V, T, P, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity coefficent. Calculate the natural logarithm of the fugacity coefficient and its\nderivatives given volume and temperature. The routine gives the\npossibility to calculate the pressure and it’s derivatives. Examples eos = PengRobinson76 ( Tc , Pc , w ) n = [ 1.0_pr , 1.0_pr ] T = 30 0.0_pr V = 1.0_pr call eos % lnphi_vt (& n , V , T , lnPhi = lnPhi , & dlnPhidP = dlnPhidP , dlnPhidT = dlnPhidT , dlnPhidn = dlnPhidn & ) Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Ar real(kind=pr), private :: ArTV real(kind=pr), private, dimension(size(n)) :: ArTn real(kind=pr), private :: ArV real(kind=pr), private :: ArV2 real(kind=pr), private, dimension(size(n)) :: ArVn real(kind=pr), private, dimension(size(n)) :: Arn real(kind=pr), private :: Arn2 (size(n),size(n)) real(kind=pr), private :: P_in real(kind=pr), private :: RT real(kind=pr), private :: Z real(kind=pr), private :: dPdT_in real(kind=pr), private :: dPdV_in real(kind=pr), private :: dPdn_in (size(n)) integer, private :: i integer, private :: j integer, private :: nc real(kind=pr), private :: totn","tags":"","url":"proc/lnphi_vt.html"},{"title":"pressure – yaeos","text":"private  subroutine pressure(eos, n, V, T, P, dPdV, dPdT, dPdn) Calculate pressure. Calculate pressure using residual helmholtz models. Examples eos = PengRobinson76 ( Tc , Pc , w ) n = [ 1.0_pr , 1.0_pr ] T = 30 0.0_pr V = 1.0_pr call eos % pressure ( n , V , T , P , dPdV = dPdV , dPdT = dPdT , dPdn = dPdn ) Type Bound ArModel Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: P Pressure [bar] real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Ar real(kind=pr), private :: ArTV real(kind=pr), private :: ArV real(kind=pr), private :: ArV2 real(kind=pr), private :: ArVn (size(eos)) real(kind=pr), private :: totn","tags":"","url":"proc/pressure.html"},{"title":"size – yaeos","text":"public interface size Module Procedures private pure function size_ar_model (eos) Get the size of the model. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Return Value integer","tags":"","url":"interface/size.html"},{"title":"tx_envelope_2ph – yaeos","text":"public  function tx_envelope_2ph(model, z0, alpha0, z_injection, first_point, points, iterations, delta_0, specified_variable_0, solver, stop_conditions) result(envelopes) Uses yaeos__auxiliar TX two-phase envelope calculation procedure. Phase envelope calculation using the continuation method.\nDefaults to solving the saturation temperature and continues with\nan increment in it. The variable to specify can be changed by modifying specified_variable_0 with the corresponding variable number. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Thermodyanmic model real(kind=pr), intent(in) :: z0 (:) Vector of molar fractions of the global composition (main phase) real(kind=pr), intent(in) :: alpha0 First point of real(kind=pr), intent(in) :: z_injection (:) Vector of molar fractions of the injection fluid type( EquilibriumState ) :: first_point integer, intent(in), optional :: points Maxmimum number of points, defaults to 500 integer, intent(in), optional :: iterations Point solver maximum iterations, defaults to 100 real(kind=pr), intent(in), optional :: delta_0 Initial extrapolation integer, intent(in), optional :: specified_variable_0 Position of specified variable, since the vector of variables is the values for specification\nwill be for the equilibria constants, for and for . procedure( continuation_solver ), optional :: solver Specify solver for each point, defaults to a full newton procedure procedure( continuation_stopper ), optional :: stop_conditions Function that returns true if the continuation method should stop Return Value type( TXEnvel2 ) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: P real(kind=pr), private :: S0 Initial specification value real(kind=pr), private :: X (size(z)+2) real(kind=pr), private, allocatable :: XS (:,:) real(kind=pr), private :: dS0 Initial specification step character(len=14), private :: kind integer, private :: max_iterations Maximum number of iterations integer, private :: max_points Maximum number of points integer, private :: nc Number of components integer, private :: ns Number of specified variable real(kind=pr), private :: z (size(z0)) Composition at some point Subroutines subroutine detect_critical (X, dXdS, ns, S, dS) Critical point detection Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables real(kind=pr), intent(inout) :: dXdS (:) Variation of variables wrt S integer, intent(inout) :: ns Number of specified variable real(kind=pr), intent(inout) :: S Specification value real(kind=pr), intent(inout) :: dS Step in specification recursive subroutine foo (X, ns, S, F, dF, dFdS) Function that needs to be solved at each envelope point Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out) :: dF (:,:) real(kind=pr), intent(out) :: dFdS (:) subroutine save_point (X, iters) Save the converged point Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: iters subroutine update_spec (X, ns, S, dS, dXdS, step_iters) Update the specification during continuation. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(inout) :: ns Number of specified variable in the vector real(kind=pr), intent(inout) :: S Variable specification value real(kind=pr), intent(inout) :: dS Step in specification real(kind=pr), intent(inout) :: dXdS (:) Variation of variables with respect to specification integer, intent(in) :: step_iters Iterations used in the solver","tags":"","url":"proc/tx_envelope_2ph.html"},{"title":"ar_consistency – yaeos","text":"public  subroutine ar_consistency(eos, n, V, T, eq31, eq33, eq34, eq36, eq37) ar_consistency models consistency tests. Description The evaluated equations are taken from Fundamentals & Computational\nAspects 2 ed. by Michelsen and Mollerup Chapter 2 section 3. The\n“eq” are evaluations of the left hand side of the following\nexpressions: Equation 31: Equation 33: Equation 34: Equation 36: Equation 37: The consistency test could be applied to any instantiated ArModel as shown in the following example. Examples use yaeos , only : pr , SoaveRedlichKwong , ArModel use yaeos__consistency_armodel , only : ar_consistency class ( ArModel ), allocatable :: model real ( pr ) :: tc ( 4 ), pc ( 4 ), w ( 4 ) real ( pr ) :: n ( 4 ), T , V real ( pr ) :: eq31 , eq33 ( size ( n ), size ( n )), eq34 ( size ( n )), eq36 , eq37 n = [ 1.5 , 0.2 , 0.7 , 2.3 ] tc = [ 19 0.564 , 42 5.12 , 30 0.11 , 32 0.25 ] pc = [ 4 5.99 , 3 7.96 , 3 9.23 , 4 0.21 ] w = [ 0.0115478 , 0.200164 , 0.3624 , 0.298 ] T = 600_pr V = 0.5_pr model = SoaveRedlichKwong ( tc , pc , w ) call ar_consistency (& model , n , V , T , eq31 = eq31 , eq33 = eq33 , eq34 = eq34 , eq36 = eq36 , eq37 = eq37 & ) All eqXX variables should be close to zero. References Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models:\nFundamentals & computational aspects (2. ed). Tie-Line Publications. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Equation of state real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: eq31 MM Eq. 31 real(kind=pr), intent(out), optional :: eq33 (size(n),size(n)) MM Eq. 33 real(kind=pr), intent(out), optional :: eq34 (size(n)) MM Eq. 34 real(kind=pr), intent(out), optional :: eq36 MM Eq. 36 real(kind=pr), intent(out), optional :: eq37 MM Eq. 37 Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Grp real(kind=pr), public :: Grv real(kind=pr), public :: Hrv real(kind=pr), public :: P real(kind=pr), public :: dPdn (size(n)) real(kind=pr), public :: dlnPhidP (size(n)) real(kind=pr), public :: dlnPhidT (size(n)) real(kind=pr), public :: dlnPhidn (size(n),size(n)) integer, public :: i integer, public :: j real(kind=pr), public :: lnphi (size(n)) real(kind=pr), public :: ntot real(kind=pr), public :: z","tags":"","url":"proc/ar_consistency.html"},{"title":"numeric_ar_derivatives – yaeos","text":"public  subroutine numeric_ar_derivatives(eos, n, V, T, d_n, d_v, d_t, Ar, ArV, ArT, Arn, ArV2, ArT2, ArTV, ArVn, ArTn, Arn2) numeric_ar_derivatives Evaluate the Helmholtz derivatives with central finite difference. Description Tool to facilitate the development of new ArModel by testing\nthe implementation of analytic derivatives. Examples use yaeos , only : pr , SoaveRedlichKwong , ArModel use yaeos__consistency_armodel , only : numeric_ar_derivatives class ( ArModel ), allocatable :: model real ( pr ) :: tc ( 4 ), pc ( 4 ), w ( 4 ) real ( pr ) :: n ( 4 ), T , V real ( pr ) :: Ar_num , ArV_num , ArT_num , Arn_num ( size ( n )), ArV2_num , ArT2_num real ( pr ) :: ArTV_num , ArVn_num ( size ( n )), ArTn_num ( size ( n )) real ( pr ) :: Arn2_num ( size ( n ), size ( n )) n = [ 1.5 , 0.2 , 0.7 , 2.3 ] tc = [ 19 0.564 , 42 5.12 , 30 0.11 , 32 0.25 ] pc = [ 4 5.99 , 3 7.96 , 3 9.23 , 4 0.21 ] w = [ 0.0115478 , 0.200164 , 0.3624 , 0.298 ] T = 600_pr V = 0.5_pr model = SoaveRedlichKwong ( tc , pc , w ) call numeric_ar_derivatives (& model , n , V , T , d_n = 0.0001_pr , d_v = 0.0001_pr , d_t = 0.01_pr , & Ar = Ar_num , ArV = ArV_num , ArT = ArT_num , ArTV = ArTV_num , ArV2 = ArV2_num , & ArT2 = ArT2_num , Arn = Arn_num , ArVn = ArVn_num , ArTn = ArTn_num , & Arn2 = Arn2_num & ) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Equation of state real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: d_n Moles finite difference step real(kind=pr), intent(in) :: d_v Volume finite difference step real(kind=pr), intent(in) :: d_t Temperature finite difference step real(kind=pr), intent(out) :: Ar Residual Helmoltz energy real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ar_aux1 real(kind=pr), public :: Ar_aux2 real(kind=pr), public :: Ar_aux3 real(kind=pr), public :: Ar_aux4 real(kind=pr), public :: dn_aux1 (size(n)) real(kind=pr), public :: dn_aux2 (size(n)) integer, public :: i integer, public :: j","tags":"","url":"proc/numeric_ar_derivatives.html"},{"title":"ADMM_REBASE – yaeos","text":"public interface ADMM_REBASE Subroutines public  subroutine ADMM_REBASE(base) bind(c, name='ADMM_rebase') Arguments Type Intent Optional Attributes Name type(C_PTR) :: base","tags":"","url":"interface/admm_rebase.html"},{"title":"ADMM_REBASESHADOWED – yaeos","text":"public interface ADMM_REBASESHADOWED Subroutines public  subroutine ADMM_REBASESHADOWED(base, baseb) bind(c, name=     'ADMM_rebaseShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR) :: base type(C_PTR) :: baseb","tags":"","url":"interface/admm_rebaseshadowed.html"},{"title":"ADMM_REGISTER – yaeos","text":"public interface ADMM_REGISTER Subroutines public  subroutine ADMM_REGISTER(base, obase, size, nbelem) bind(c, name=     'ADMM_register') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size integer, VALUE :: nbelem","tags":"","url":"interface/admm_register.html"},{"title":"ADMM_REGISTERSHADOWED – yaeos","text":"public interface ADMM_REGISTERSHADOWED Subroutines public  subroutine ADMM_REGISTERSHADOWED(base, obase, size, baseb, obaseb, sizeb, nbelem) bind(c, name='ADMM_registerShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size type(C_PTR), VALUE :: baseb type(C_PTR), VALUE :: obaseb integer, VALUE :: sizeb integer, VALUE :: nbelem","tags":"","url":"interface/admm_registershadowed.html"},{"title":"ADMM_UNREGISTER – yaeos","text":"public interface ADMM_UNREGISTER Subroutines public  subroutine ADMM_UNREGISTER(base, nbelem) bind(c, name=     'ADMM_unregister') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base integer :: nbelem","tags":"","url":"interface/admm_unregister.html"},{"title":"ADMM_UNREGISTERSHADOWED – yaeos","text":"public interface ADMM_UNREGISTERSHADOWED Subroutines public  subroutine ADMM_UNREGISTERSHADOWED(base, baseb, nbelem) bind(c,      name='ADMM_unregisterShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: baseb integer :: nbelem","tags":"","url":"interface/admm_unregistershadowed.html"},{"title":"POPPOINTER8 – yaeos","text":"public interface POPPOINTER8 Subroutines public  subroutine POPPOINTER8(pp) bind(c, name='popPointer8') Arguments Type Intent Optional Attributes Name type(C_PTR) :: pp","tags":"","url":"interface/poppointer8.html"},{"title":"PUSHPOINTER8 – yaeos","text":"public interface PUSHPOINTER8 Subroutines public  subroutine PUSHPOINTER8(pp) bind(c, name='pushPointer8') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: pp","tags":"","url":"interface/pushpointer8.html"},{"title":"tm – yaeos","text":"public  function tm(model, z, w, P, T, d, dtpd) Alternative formulation of tangent-plane-distance Michelsen’s modified function, . Description Alternative formulation of the reduced tangent plane function,\nwhere the test phase is defined in moles, which enables for unconstrained\nminimization. Examples Calculation of tm tm = tpd ( model , z , w , P , T ) --------------------------- Using precalculated trial-phase data It is possible to calculate externaly the d_i vector and use it for\nlater calculations. call fugacity_tp (& model , z , T = T , P = P , V = Vz , root_type = \"stable\" , lnphip = lnphi_z & ) lnphi_z = lnphi_z - log ( P ) di = log ( z ) + lnphi_z tm = tpd ( model , z , w , P , T , d = di ) --------------------------- References Thermodynamic Models: Fundamental and Computational Aspects, Michael L.\nMichelsen, Jørgen M. Mollerup. Tie-Line Publications, Denmark (2004) doi Arguments Type Intent Optional Attributes Name class( BaseModel ), intent(in) :: model Thermodynamic model real(kind=pr), intent(in) :: z (:) Feed composition real(kind=pr), intent(in) :: w (:) Test-phase mole numbers vector real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in), optional :: d (:) vector real(kind=pr), intent(out), optional :: dtpd (:) Return Value real(kind=pr) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: di (size(z)) real(kind=pr), public :: lnphi_w (size(z)) real(kind=pr), public :: lnphi_z (size(z)) real(kind=pr), public :: vw real(kind=pr), public :: vz","tags":"","url":"proc/tm.html"},{"title":"min_tpd – yaeos","text":"public  subroutine min_tpd(model, z, P, T, mintpd, w, all_minima) Arguments Type Intent Optional Attributes Name class( BaseModel ), target :: model Thermodynamic model real(kind=pr), intent(in) :: z (:) Feed composition real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: mintpd Minimal value of real(kind=pr), intent(out) :: w (:) Trial composition real(kind=pr), intent(out), optional :: all_minima (:,:) All the found minima Variables Type Visibility Attributes Name Initial real(kind=pr), public :: V real(kind=pr), public :: di (size(z)) real(kind=pr), public :: dw (size(w)) real(kind=pr), public :: dx (size(w)) integer, public :: i integer, public :: j real(kind=pr), public :: lnphi_w (size(w)) real(kind=pr), public :: lnphi_z (size(z)) real(kind=pr), public :: mins (size(w)) integer, public :: nc integer, public :: stat real(kind=pr), public :: ws (size(w),size(w))","tags":"","url":"proc/min_tpd.html"},{"title":"POPREAL8 – yaeos","text":"interface public  subroutine POPREAL8(a) Arguments Type Intent Optional Attributes Name real(kind=pr) :: a","tags":"","url":"interface/popreal8.html"},{"title":"POPREAL8ARRAY – yaeos","text":"interface public  subroutine POPREAL8ARRAY(a, n) Arguments Type Intent Optional Attributes Name real(kind=pr), dimension(n) :: a integer :: n","tags":"","url":"interface/popreal8array.html"},{"title":"popinteger4 – yaeos","text":"interface public  subroutine popinteger4(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","url":"interface/popinteger4.html"},{"title":"pushinteger4 – yaeos","text":"interface public  subroutine pushinteger4(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","url":"interface/pushinteger4.html"},{"title":"pushreal8 – yaeos","text":"interface public  subroutine pushreal8(a) Arguments Type Intent Optional Attributes Name real(kind=pr) :: a","tags":"","url":"interface/pushreal8.html"},{"title":"pushreal8array – yaeos","text":"interface public  subroutine pushreal8array(a, n) Arguments Type Intent Optional Attributes Name real(kind=pr), dimension(n) :: a integer :: n","tags":"","url":"interface/pushreal8array.html"},{"title":"solve_point – yaeos","text":"public  subroutine solve_point(eos, n, P, T, V, Pcalc, ZETA, ZETMIN, ZETMAX, AT, iter) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: P Objective pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: V Obtained volume [L] real(kind=pr), intent(out) :: Pcalc Calculated pressure at V [bar] real(kind=pr), intent(inout) :: ZETA real(kind=pr), intent(inout) :: ZETMIN real(kind=pr), intent(inout) :: ZETMAX real(kind=pr), intent(out) :: AT integer, intent(out) :: iter Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ar real(kind=pr), public :: ArV real(kind=pr), public :: ArV2 real(kind=pr), public :: B real(kind=pr), public :: del real(kind=pr), public :: der real(kind=pr), public :: totn","tags":"","url":"proc/solve_point~4.html"},{"title":"volume_michelsen – yaeos","text":"public  subroutine volume_michelsen(eos, n, P, T, V, root_type, max_iters, V0) Uses iso_fortran_env yaeos__auxiliar Volume solver at a given pressure. Obtain the volume using the method described by Michelsen and Møllerup.\nWhile can be obtained with a simple Newton method, a better\napproach is solving where is the EoS covolume.\nThis method is easier to solve because: and At chapter 3 page 94 of Michelsen and Møllerup’s book a more complete\nexplanation can be seen Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos real(kind=pr), intent(in) :: n (:) Mixture moles real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: V Volume [L] character(len=*), intent(in), optional :: root_type Type of root [“vapor” | “liquid” | “stable”] integer, intent(in), optional :: max_iters Maxiumum number of iterations, defaults to 100 real(kind=pr), intent(in), optional :: V0 Specified initial volume Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AT real(kind=pr), public :: AVAP real(kind=pr), public :: B Covolume real(kind=pr), public :: VVAP real(kind=pr), public :: ZETA real(kind=pr), public :: ZETMAX real(kind=pr), public :: ZETMIN integer, public :: iter integer, public :: maximum_iterations real(kind=pr), public :: pcalc character(len=10), public :: root real(kind=pr), public :: totn","tags":"","url":"proc/volume_michelsen.html"},{"title":"get_P – yaeos","text":"public  function get_P(pt, T) result(P) Get pressure Get the saturation pressure for a given temperature. Description This function returns the saturation pressure for a given temperature.\nThe function uses an interpolator to get the required value. Examples P = pt % get_P ( T ) Type Bound PurePsat Arguments Type Intent Optional Attributes Name class( PurePsat ), intent(inout) :: pt real(kind=pr), intent(in) :: T Return Value real(kind=pr)","tags":"","url":"proc/get_p.html"},{"title":"get_T – yaeos","text":"public  function get_T(pt, P) result(T) Get temperature Get the saturation temperature for a given pressure. Description This function returns the saturation temperature for a given pressure.\nThe function uses an interpolator to get the required value. Examples T = pt % get_T ( P ) Type Bound PurePsat Arguments Type Intent Optional Attributes Name class( PurePsat ), intent(inout) :: pt real(kind=pr), intent(in) :: P Return Value real(kind=pr)","tags":"","url":"proc/get_t.html"},{"title":"pure_saturation_line – yaeos","text":"public  function pure_saturation_line(model, component, minP, minT) result(pt) Uses yaeos__auxiliar Pure saturation line Saturation pressures and temperatures for a pure component. Description This function calculates the saturation line for a pure component.\nStarting from the pure component critical point, the function traces\nthe saturation line using the continuation method.\nThe function returns a PurePsat object with the saturation\ntemperatures and pressures. The object also contains interpolators\nto get the saturation temperature for a given pressure and vice versa. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Thermodyanmic model integer, intent(in) :: component Component index to calculate the line real(kind=pr), intent(in) :: minP Minimum pressure [bar] real(kind=pr), intent(in) :: minT Minimum temperature [K] Return Value type( PurePsat ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F (4) real(kind=pr), public :: P real(kind=pr), public :: Pc real(kind=pr), public :: S real(kind=pr), public :: T real(kind=pr), public :: Tc real(kind=pr), public :: Vc real(kind=pr), public :: Vx real(kind=pr), public :: Vy real(kind=pr), public :: X (4) Variables [lnVx, lnVy, lnP, lnT] real(kind=pr), public :: dF (4,4) real(kind=pr), public :: dFdS (4) real(kind=pr), public :: dS real(kind=pr), public :: dXdS (4) integer, public :: i integer, public :: its integer, public :: nc integer, public :: ns integer, public :: points real(kind=pr), public :: z (size(model))","tags":"","url":"proc/pure_saturation_line.html"},{"title":"solve_point – yaeos","text":"public  subroutine solve_point(model, ncomp, nc, X, ns, S, F, dF, dFdS, its) Solve point Solve a saturation point for a pure component. Description The set of equations to solve is: Where is an specification function defined as: The vector of variables is equal to . Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Thermodynamic model integer, intent(in) :: ncomp Component index integer, intent(in) :: nc Total number of components real(kind=pr), intent(inout) :: X (4) Variables integer, intent(in) :: ns Variable index to solve. If the real(kind=pr), intent(in) :: S Variable value specified to solve real(kind=pr), intent(out) :: F (4) Function real(kind=pr), intent(out) :: dF (4,4) Jacobian real(kind=pr), intent(out) :: dFdS (4) Derivative of the function with respect to S integer, intent(out) :: its Number of iterations Variables Type Visibility Attributes Name Initial real(kind=pr), public :: B real(kind=pr), public :: Py real(kind=pr), public :: Pz real(kind=pr), public :: T real(kind=pr), public :: Vy real(kind=pr), public :: Vz real(kind=pr), public :: Xnew (4) real(kind=pr), public :: dPdTy real(kind=pr), public :: dPdTz real(kind=pr), public :: dPdVy real(kind=pr), public :: dPdVz real(kind=pr), public :: dX (4) real(kind=pr), public :: dlnfdt_y (nc) real(kind=pr), public :: dlnfdt_z (nc) real(kind=pr), public :: dlnfdv_y (nc) real(kind=pr), public :: dlnfdv_z (nc) integer, public :: i real(kind=pr), public :: lnfug_y (nc) real(kind=pr), public :: lnfug_z (nc) real(kind=pr), public :: z (nc) Subroutines subroutine isofugacity (X, F, dF, dFdS) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (4) real(kind=pr), intent(out) :: F (4) real(kind=pr), intent(out) :: dF (4,4) real(kind=pr), intent(out) :: dFdS (4)","tags":"","url":"proc/solve_point~5.html"},{"title":"pt_envelope – yaeos","text":"public  function pt_envelope(model, z, np, x_l0, w0, betas0, P0, T0, ns0, dS0, beta_w, points, max_pressure) Uses yaeos__auxiliar pt_envelope Calculation of a multiphase PT envelope. Description Calculates a PT envelope is calculated using the continuation method.\nThe envelope is calculated by solving the system of equations for each\npoint of the envelope. The system of equations is solved using the\nNewton-Raphson method. This function requires the system specification conditions, which are\nthe fluid composition (\\z), the number of phases that are not\nincipient; defined as , proper intialization values, the\nvariables that end with 0 are the initial guess; the mole fraction\nof the reference phase beta_w which when it is equal to 0 means that\nwe are calculating a phase boundary. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z (:) Mixture global composition. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: x_l0 (np,size(z)) Initial guess for the mole fractions of each phase. arranged as\nan array of size (np, nc) , where nc is the number of components\nand np the number of main phases. Each row correspond to the\ncomposition of each main phaase. real(kind=pr), intent(in) :: w0 (size(z)) Initial guess for the mole fractions of the\nreference/incipient phase. real(kind=pr), intent(in) :: betas0 (np) Initial guess for the fractions of the main phases. arranged as\nan array of size (np) , where np is the number of main phases. real(kind=pr), intent(in) :: P0 Initial guess for the pressure [bar]. real(kind=pr), intent(in) :: T0 Initial guess for the temperature [K]. integer, intent(in) :: ns0 Number of the specified variable.\nThe variable to be specified. This is the variable that will be\nused to calculate the first point of the envelope. The variable\ncan be any of the variables in the vector X, but it is recommended\nto use the temperature or pressure. The variables are aranged as\nfollows: X(1:nc*np) = ln(K_i&#94;l) : X(nc*np+1:nc*np+np) = \\beta_i&#94;l : Fraction of each main phase. X(nc*np+np+1) = ln(P) : Pressure [bar]. X(nc*np+np+2) = ln(T) : Temperature [K]. real(kind=pr), intent(in) :: dS0 Step size of the specification for the next point.\nThis is the step size that will be used to calculate the next point.\nInside the algorithm this value is modified to adapt the step size\nto facilitate the convergence of each point. real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. integer, intent(in), optional :: points Number of points to calculate. real(kind=pr), intent(in), optional :: max_pressure Maximum pressure [bar] to calculate.\nIf the pressure of the point is greater than this value, the\ncalculation is stopped.\nThis is useful to avoid calculating envelopes that go to infinite\nvalues of pressure. Return Value type( PTEnvelMP ) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: F (size(z)*np+np+2) Vector of functions valuated. real(kind=pr), private :: P Pressure [bar]. real(kind=pr), private :: S Specified value real(kind=pr), private :: T Temperature [K]. real(kind=pr), private :: X (size(z)*np+np+2) Vector of variables. real(kind=pr), private :: X0 (size(X)) Initial guess for the point real(kind=pr), private :: betas (np) Fractions of the main phases. real(kind=pr), private :: dF (size(z)*np+np+2,size(z)*np+np+2) Jacobian matrix. real(kind=pr), private :: dS Step size of the specification for the next point real(kind=pr), private :: dX (size(z)*np+np+2) Step for next point estimation. real(kind=pr), private :: dXdS (size(z)*np+np+2) Sensitivity of the variables wrt the specification. type( MPPoint ), private, allocatable :: env_points (:) Array of converged points. integer, private :: i Point calculation index integer, private :: iP Index of the pressure variable. integer, private :: iT Index of the temperature variable. integer, private :: inner Number of times a failed point is retried to converge integer, private :: its Number of iterations to solve the current point. integer, private :: lb Lower bound, index of the first component of a phase real(kind=pr), private :: max_P Maximum pressure [bar] to calculate. integer, private :: max_iterations = 10 Maximum number of iterations to solve the point. integer, private :: nc Number of components. integer, private :: ns Number of the specified variable integer, private :: number_of_points Number of points to calculate. type( MPPoint ), private :: point Converged point. integer, private :: ub Upper bound, index of the last component of a phase real(kind=pr), private :: w (size(z)) Mole fractions of the incipient phase. real(kind=pr), private :: x_l (np,size(z)) Mole fractions of the main phases.","tags":"","url":"proc/pt_envelope.html"},{"title":"pt_F_NP – yaeos","text":"public  subroutine pt_F_NP(model, z, np, beta_w, X, ns, S, F, df) Uses iso_fortran_env Function to solve at each point of a multi-phase envelope. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z (:) Mixture global composition. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: ns Number of specification. real(kind=pr), intent(in) :: S Specification value. real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated. real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix. Variables Type Visibility Attributes Name Initial real(kind=pr), private :: K (np,size(z)) real(kind=pr), private :: P real(kind=pr), private :: T real(kind=pr), private :: Vl (np) real(kind=pr), private :: Vw real(kind=pr), private :: betas (np) real(kind=pr), private :: denom (size(z)) real(kind=pr), private :: denomdlnK (np,size(z),size(z)) real(kind=pr), private, dimension(size(z), size(z)) :: dlnphi_dn real(kind=pr), private, dimension(np, size(z), size(z)) :: dlnphi_dn_l real(kind=pr), private, dimension(size(z), size(z)) :: dlnphi_dn_w real(kind=pr), private :: dlnphi_dp (size(z)) real(kind=pr), private, dimension(np, size(z)) :: dlnphi_dp_l real(kind=pr), private, dimension(size(z)) :: dlnphi_dp_w real(kind=pr), private :: dlnphi_dt (size(z)) real(kind=pr), private, dimension(np, size(z)) :: dlnphi_dt_l real(kind=pr), private, dimension(size(z)) :: dlnphi_dt_w real(kind=pr), private :: dwdb (np,size(z)) real(kind=pr), private :: dwdlnK (np,size(z)) real(kind=pr), private :: dx_l_dlnK (np,np,size(z)) integer, private :: i integer, private :: idx_1 integer, private :: idx_2 integer, private :: j integer, private :: l integer, private :: lb real(kind=pr), private :: lnphi (size(z)) real(kind=pr), private, dimension(np, size(z)) :: lnphi_l real(kind=pr), private, dimension(size(z)) :: lnphi_w real(kind=pr), private :: moles (size(z)) integer, private :: nc integer, private :: phase integer, private :: ub real(kind=pr), private, dimension(size(z)) :: w real(kind=pr), private, dimension(np, size(z)) :: x_l","tags":"","url":"proc/pt_f_np.html"},{"title":"detect_critical – yaeos","text":"private  subroutine detect_critical(nc, np, X, dXdS, ns, dS, S) detect_critical Detect if the system is close to a critical point. Description When the system is close to a critical point, the values\nare close to zero, since the composition of the incipient phase and the phase are similar (equal in the critical point). This can be used\nto detect if the system is close to a critical point and force a jump\nabove it. References Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. real(kind=pr), intent(inout) :: S Specification value. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: lb integer, private :: ub","tags":"","url":"proc/detect_critical~4.html"},{"title":"get_values_from_X – yaeos","text":"private  subroutine get_values_from_X(X, np, z, x_l, w, betas, P, T) get_values_from_X Extract the values of the variables from the vector X. Type Bound PTEnvelMP Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: z (:) Mixture composition. real(kind=pr), intent(out) :: x_l (np,size(z)) Mole fractions of the main phases. real(kind=pr), intent(out) :: w (size(z)) Mole fractions of the incipient phase. real(kind=pr), intent(out) :: betas (np) Fractions of the main phases. real(kind=pr), intent(out) :: P Pressure [bar]. real(kind=pr), intent(out) :: T Temperature [K]. Variables Type Visibility Attributes Name Initial integer, private :: i Loop index. integer, private :: lb Lower bound of each phase. integer, private :: nc Number of components. integer, private :: ub Upper bound of each phase.","tags":"","url":"proc/get_values_from_x~4.html"},{"title":"solve_point – yaeos","text":"private  subroutine solve_point(model, z, np, beta_w, X, ns, S, dXdS, F, df, iters, max_iterations) Uses iso_fortran_env yaeos__math Type Bound PTEnvelMP Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z (:) Mixture global composition. integer, intent(in) :: np Number of main phases real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(in) :: dXdS (size(X)) real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix integer, intent(out) :: iters Number of iterations to solve the current point integer, intent(in) :: max_iterations Maximum number of iterations to solve the point Variables Type Visibility Attributes Name Initial real(kind=pr), private :: X0 (size(X)) logical, private :: can_solve real(kind=pr), private :: dX (size(X)) integer, private :: i integer, private :: iBetas (np) integer, private :: iP integer, private :: iT integer, private :: nc","tags":"","url":"proc/solve_point~6.html"},{"title":"update_specification – yaeos","text":"private  subroutine update_specification(its, nc, np, X, dF, dXdS, ns, dS) update_specification Change the specified variable for the next step. Description Using the information of a converged point and the Jacobian matrix of\nthe function. It is possible to determine the sensitivity of the\nvariables with respect to the specification. This information is used\nto update the specification for the next point. Choosing the variable\nwith the highest sensitivity.\nThis can be done by solving the system of equations: for the vector. The variable with the highest value\nof is chosen as the new specification. References Arguments Type Intent Optional Attributes Name integer, intent(in) :: its Iterations to solve the current point. integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dF (:,:) Jacobian matrix. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. Variables Type Visibility Attributes Name Initial real(kind=pr), private :: dFdS (size(X)) Sensitivity of the functions wrt the specification. real(kind=pr), private :: dP real(kind=pr), private :: dT integer, private :: i integer, private :: iBetas (np) integer, private :: iP integer, private :: iT integer, private :: lb Lower bound of each phase integer, private :: ub Upper bound of each phase","tags":"","url":"proc/update_specification~4.html"},{"title":"write_envelope_PT_MP – yaeos","text":"private  subroutine write_envelope_PT_MP(env, unit) Type Bound PTEnvelMP Arguments Type Intent Optional Attributes Name class( PTEnvelMP ), intent(in) :: env integer, intent(in) :: unit Variables Type Visibility Attributes Name Initial real(kind=pr), private :: P real(kind=pr), private :: T real(kind=pr), private, allocatable :: betas (:) integer, private :: i integer, private :: j integer, private :: nc integer, private :: np real(kind=pr), private, allocatable :: w (:) real(kind=pr), private, allocatable :: x_l (:,:)","tags":"","url":"proc/write_envelope_pt_mp.html"},{"title":"residual_helmholtz – yaeos","text":"private  subroutine residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz model generic interface Type Bound ArModelTapenade Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: arval real(kind=pr), private :: arvalb real(kind=pr), private :: arvald real(kind=pr), private :: arvald0 real(kind=pr), private :: arvaldb real(kind=pr), private :: arvaldd real(kind=pr), private :: df (size(n)+2) real(kind=pr), private :: df2 (size(n)+2,size(n)+2) integer, private :: i real(kind=pr), private :: nb (size(n)) integer, private :: nc real(kind=pr), private :: nd (size(n)) real(kind=pr), private :: ndb (size(n)) real(kind=pr), private :: tb real(kind=pr), private :: td real(kind=pr), private :: td0 real(kind=pr), private :: tdb real(kind=pr), private :: vb real(kind=pr), private :: vd real(kind=pr), private :: vd0 real(kind=pr), private :: vdb Functions function get_ArnX (var) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Return Value real(kind=pr), (size(n)) function get_dArdX2 (var) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Return Value real(kind=pr) Subroutines subroutine reset_vars () Arguments None","tags":"","url":"proc/residual_helmholtz.html"},{"title":"excess_gibbs – yaeos","text":"private  subroutine excess_gibbs(self, n, t, Ge, GeT, GeT2, Gen, GeTn, Gen2) Excess Gibbs model generic interface Type Bound GeModelTapenade Arguments Type Intent Optional Attributes Name class( GeModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ge real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Gen real(kind=pr), intent(out), optional, dimension(size(n)) :: GeTn real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: geb real(kind=pr), private :: ged real(kind=pr), private :: ged0 real(kind=pr), private :: gedb real(kind=pr), private :: gedd integer, private :: i real(kind=pr), private :: nb (size(n)) integer, private :: nc real(kind=pr), private :: nd (size(n)) real(kind=pr), private :: ndb (size(n)) real(kind=pr), private :: tb real(kind=pr), private :: td real(kind=pr), private :: td0 real(kind=pr), private :: tdb Functions function get_GenT () Arguments None Return Value real(kind=pr), (size(n)) function get_dGedT () Arguments None Return Value real(kind=pr) function get_dGedT2 () Arguments None Return Value real(kind=pr) Subroutines subroutine reset_vars () Arguments None","tags":"","url":"proc/excess_gibbs~2.html"},{"title":"setup_unifac – yaeos","text":"public  function setup_unifac(molecules, parameters) Setup UNIFAC Instantiate a UNIFAC model Description Subroutine used to instantiate a UNIFAC model. Examples ! Instantiate an UNIFAC model with ethanol-water mix and calculate gammas use yaeos , only : pr , Groups , setup_unifac , UNIFAC type ( UNIFAC ) :: model type ( Groups ) :: molecules ( 2 ) real ( pr ) :: ln_gammas ( 2 ) ! Ethanol definition [CH3, CH2, OH] molecules ( 1 )% groups_ids = [ 1 , 2 , 14 ] ! Subgroups ids molecules ( 1 )% number_of_groups = [ 1 , 1 , 1 ] ! Subgroups occurrences ! Water definition [H2O] molecules ( 2 )% groups_ids = [ 16 ] molecules ( 2 )% number_of_groups = [ 1 ] ! Model setup model = setup_unifac ( molecules ) ! Calculate ln_gammas call model % ln_activity_coefficient ([ 0.5_pr , 0.5_pr ], 29 8.0_pr , ln_gammas ) print * , ln_gammas ! result: 0.18534142000449058    0.40331395945417559 References Dortmund Data Bank Software & Separation Technology Arguments Type Intent Optional Attributes Name type( Groups ), intent(in) :: molecules (:) Molecules (Group type) objects type( GeGCModelParameters ), intent(in), optional :: parameters UNIFAC parameters Return Value type( UNIFAC ) Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: Aij (:,:) integer, public :: gi integer, public :: i integer, public :: j integer, public :: k type( GeGCModelParameters ), public :: params type( UNIFACPsi ), public :: psi_function real(kind=pr), public, allocatable :: qks (:) type( Groups ), public :: soup integer, public, allocatable :: vij (:,:)","tags":"","url":"proc/setup_unifac.html"},{"title":"thetas_i – yaeos","text":"public  function thetas_i(nm, ng, parameters, stew, molecules) result(thetas_ij) calculation Calculate the area fraciton of each froup on each molecule. Description Calculate the area fraciton of each froup on each molecule. The values\nare obtained on the setup_unifac function and stored on the UNIFAC\ntype, since the values can be reused (no compositional or temperature\ndependence) References SINTEF - Thermopack Arguments Type Intent Optional Attributes Name integer, intent(in) :: nm Number of molecules integer, intent(in) :: ng Number of groups type( GeGCModelParameters ), intent(in) :: parameters UNIFAC parameters type( Groups ), intent(in) :: stew All the groups present in the system type( Groups ), intent(in) :: molecules (:) Molecules Return Value real(kind=pr), (nm,ng) Group j area fraction on molecule i Variables Type Visibility Attributes Name Initial integer, public :: gi integer, public :: i integer, public :: j integer, public :: k real(kind=pr), public :: qki_contribution real(kind=pr), public :: total_area_i (nm)","tags":"","url":"proc/thetas_i.html"},{"title":"Ge_combinatorial – yaeos","text":"public  subroutine Ge_combinatorial(self, n, T, Ge, dGe_dn, dGe_dn2) UNIFAC combinatorial term Calculate the UNIFAC combinatorial term of Gibbs excess energy Description Calculate the UNIFAC combinatorial term of reduced Gibbs excess \nenergy. The subroutine uses the Flory-Huggins and \nStaverman-Guggenheim. References SINTEF - Thermopack Type Bound UNIFAC Arguments Type Intent Optional Attributes Name class( UNIFAC ) :: self real(kind=pr), intent(in) :: n (self%nmolecules) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Combinatorial Gibbs excess energy real(kind=pr), intent(out), optional :: dGe_dn (self%nmolecules) real(kind=pr), intent(out), optional :: dGe_dn2 (self%nmolecules,self%nmolecules) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ge_fh real(kind=pr), public :: Ge_sg real(kind=pr), public :: dGe_fh_dn (self%nmolecules) real(kind=pr), public :: dGe_fh_dn2 (self%nmolecules,self%nmolecules) real(kind=pr), public :: dGe_sg_dn (self%nmolecules) real(kind=pr), public :: dGe_sg_dn2 (self%nmolecules,self%nmolecules) integer, public :: i integer, public :: j real(kind=pr), public :: n_t real(kind=pr), public :: nq real(kind=pr), public :: nr real(kind=pr), public :: nrp","tags":"","url":"proc/ge_combinatorial.html"},{"title":"Ge_residual – yaeos","text":"public  subroutine Ge_residual(self, n, T, Ge, dGe_dn, dGe_dn2, dGe_dT, dGe_dT2, dGe_dTn) UNIFAC residual term Evaluate the UNIFAC residual term References SINTEF - Thermopack Type Bound UNIFAC Arguments Type Intent Optional Attributes Name class( UNIFAC ) :: self real(kind=pr), intent(in) :: n (self%nmolecules) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Residual Gibbs excess energy real(kind=pr), intent(out), optional :: dGe_dn (self%nmolecules) real(kind=pr), intent(out), optional :: dGe_dn2 (self%nmolecules,self%nmolecules) real(kind=pr), intent(out), optional :: dGe_dT real(kind=pr), intent(out), optional :: dGe_dT2 real(kind=pr), intent(out), optional :: dGe_dTn (self%nmolecules) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ejk (self%ngroups,self%ngroups) real(kind=pr), public :: Ge_aux real(kind=pr), public :: aux_sum (self%nmolecules) real(kind=pr), public :: aux_sum2 real(kind=pr), public :: dEjk_dt (self%ngroups,self%ngroups) real(kind=pr), public :: dEjk_dt2 (self%ngroups,self%ngroups) real(kind=pr), public :: dGe_dT_aux real(kind=pr), public :: dGe_dn_aux (self%nmolecules) real(kind=pr), public :: dlambda_ik_dT (self%nmolecules,self%ngroups) real(kind=pr), public :: dlambda_ik_dT2 (self%nmolecules,self%ngroups) real(kind=pr), public :: dlambda_k_dT (self%ngroups) real(kind=pr), public :: dlambda_k_dT2 (self%ngroups) real(kind=pr), public :: dlambda_k_dn (self%nmolecules,self%ngroups) real(kind=pr), public :: dlambda_k_dn2 (self%nmolecules,self%nmolecules,self%ngroups) real(kind=pr), public :: dlambda_k_dndT (self%nmolecules,self%ngroups) logical, public :: dn logical, public :: dn2 logical, public :: dt logical, public :: dt2 logical, public :: dtn integer, public :: i integer, public :: j integer, public :: k integer, public :: l real(kind=pr), public :: lambda_ik (self%nmolecules,self%ngroups) real(kind=pr), public :: lambda_k (self%ngroups) logical, public :: pge real(kind=pr), public :: sum_Q_v_dlambda_k_dn (self%nmolecules,self%nmolecules) real(kind=pr), public :: sum_ni_vij_Qj_Ejk (self%ngroups) real(kind=pr), public :: sum_ni_vij_Qj_dEjk_dT (self%ngroups) real(kind=pr), public :: sum_ni_vik_Qk real(kind=pr), public :: sum_nl_vlj (self%ngroups) real(kind=pr), public :: sum_vQ_Lambda (self%nmolecules) real(kind=pr), public :: sum_vij_Qj_Ejk (self%nmolecules,self%ngroups) real(kind=pr), public :: sum_vij_Qj_dEjk_dT (self%nmolecules,self%ngroups) real(kind=pr), public :: sum_vij_Qj_dEjk_dT2 (self%nmolecules,self%ngroups) real(kind=pr), public :: sum_vij_Qj_dlambdas_dT (self%nmolecules) real(kind=pr), public :: sum_vij_Qj_dlambdas_dT2 (self%nmolecules) real(kind=pr), public :: sum_vik_Qk (self%nmolecules) real(kind=pr), public :: theta_j (self%ngroups)","tags":"","url":"proc/ge_residual.html"},{"title":"excess_gibbs – yaeos","text":"public  subroutine excess_gibbs(self, n, T, Ge, GeT, GeT2, Gen, GeTn, Gen2) Excess Gibbs energy Calculate the Gibbs excess energy of the UNIFAC model Description Calculate the Gibbs excess energy of the UNIFAC model and its\nderivatives. Examples ! Gibbs excess of ethane-ethanol-methyl amine mixture. use yaeos , only : R , pr , Groups , setup_unifac , UNIFAC type ( UNIFAC ) :: model integer , parameter :: nc = 3 , ng = 4 type ( Groups ) :: molecules ( nc ) real ( pr ) :: Ge , Gen ( nc ), GeT , GeT2 , GeTn ( nc ), Gen2 ( nc , nc ) real ( pr ) :: n ( nc ), ln_gammas ( nc ), T T = 15 0.0_pr n = [ 2.0_pr , 7.0_pr , 1.0_pr ] ! Ethane [CH3] molecules ( 1 )% groups_ids = [ 1 ] molecules ( 1 )% number_of_groups = [ 2 ] ! Ethanol [CH3, CH2, OH] molecules ( 2 )% groups_ids = [ 1 , 2 , 14 ] molecules ( 2 )% number_of_groups = [ 1 , 1 , 1 ] ! Methylamine [H3C-NH2] molecules ( 3 )% groups_ids = [ 28 ] molecules ( 3 )% number_of_groups = [ 1 ] ! setup UNIFAC model model = setup_unifac ( molecules ) ! Call all Ge and derivatives call model % excess_gibbs ( model , n , T , Ge , GeT , GeT2 , Gen , GeTn , Gen2 ) print * , \"Ge: \" , Ge print * , \"GeT: \" , GeT print * , \"GeT2: \" , GeT2 print * , \"Gen: \" , Gen print * , \"GeTn: \" , GeTn print * , \"Gen2:\" print * , Gen2 ( 1 ,:) print * , Gen2 ( 2 ,:) print * , Gen2 ( 3 ,:) ! If you want the ln_gammas from \"Gen\" derivative: print * , \"ln_gammas: \" , Gen / R / T ! Or call model % ln_activity_coefficient ( n , T , ln_gammas ) print * , \"ln_gammas: \" , ln_gammas Type Bound UNIFAC Arguments Type Intent Optional Attributes Name class( UNIFAC ), intent(in) :: self UNIFAC model real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Excess Gibbs energy real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional :: Gen (size(n)) real(kind=pr), intent(out), optional :: GeTn (size(n)) real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ge_c real(kind=pr), public :: dGe_c_dn (self%nmolecules) real(kind=pr), public :: dGe_c_dn2 (self%nmolecules,self%nmolecules) logical, public :: dn logical, public :: dn2 logical, public :: pge","tags":"","url":"proc/excess_gibbs~3.html"},{"title":"derivative_d2xk_dnidnj – yaeos","text":"public  function derivative_d2xk_dnidnj(n) result(d2xk_dnidnj) derivative_d2xk_dnidnj Description Calculate the mole fraction second derivatives respect to mole numbers Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) Return Value real(kind=pr), (size(n),size(n),size(n)) Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k real(kind=pr), public :: n_tot integer, public :: nc","tags":"","url":"proc/derivative_d2xk_dnidnj.html"},{"title":"derivative_dxk_dni – yaeos","text":"public  function derivative_dxk_dni(n) result(dxk_dni) derivative_dxk_dni Description Calculate the mole fraction first derivatives respect to mole numbers Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) Return Value real(kind=pr), (size(n),size(n)) Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k real(kind=pr), public :: n_tot integer, public :: nc","tags":"","url":"proc/derivative_dxk_dni.html"},{"title":"dx_to_dn – yaeos","text":"public  function dx_to_dn(x, dx) result(dn) Uses yaeos__constants dx_to_dn Description Convert the mole fraction derivatives of a quantity (calculated\nso they do not sum to 1) to mole number derivatives (where the mole\nfractions do sum to one). Requires the derivatives and the mole fractions\nof the mixture.\nFrom https://chemicals.readthedocs.io/chemicals.utils.html?highlight=dxs_to_dns#chemicals.utils.dxs_to_dns Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x (:) real(kind=pr), intent(in) :: dx (:) Return Value real(kind=pr), (size(x)) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: sum_xdx","tags":"","url":"proc/dx_to_dn.html"},{"title":"interpol – yaeos","text":"public elemental function interpol(x1, x2, y1, y2, x_obj) result(y) Linear interpolation. Calculates the linear interpolation between two points at a desired\nx value with the equation: Since this function is defined as elemental it will also interpolate\na set of vectors. Examples of usage: x1 = 2 x2 = 5 y1 = 2 y2 = 9 y = interpol ( x1 , x2 , y1 , y2 , 2.3 ) x1 = 2 x2 = 5 y1 = [ 2 , 6 ] y2 = [ 9 , 15 ] y = interpol ( x1 , x2 , y1 , y2 , 2.3 ) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x1 First point x value real(kind=pr), intent(in) :: x2 Second point x value real(kind=pr), intent(in) :: y1 First point y value real(kind=pr), intent(in) :: y2 Second point y value real(kind=pr), intent(in) :: x_obj Desired x value to interpolate Return Value real(kind=pr) y value at x_obj","tags":"","url":"proc/interpol.html"},{"title":"sq_error – yaeos","text":"public elemental function sq_error(exp, pred) Uses yaeos__constants Squared error between two values. Description … Examples error = sq_error ( true_value , model_value ) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: exp real(kind=pr), intent(in) :: pred Return Value real(kind=pr)","tags":"","url":"proc/sq_error.html"},{"title":"newton_1d – yaeos","text":"public  subroutine newton_1d(f, x, tol, max_iters) Arguments Type Intent Optional Attributes Name procedure( f_1d ) :: f real(kind=pr), intent(inout) :: x real(kind=pr), intent(in) :: tol integer, intent(in) :: max_iters Variables Type Visibility Attributes Name Initial real(kind=pr), public :: df real(kind=pr), public :: fval integer, public :: i real(kind=pr), public :: step","tags":"","url":"proc/newton_1d.html"},{"title":"newton – yaeos","text":"public interface newton Module Procedures public  subroutine newton_1d (f, x, tol, max_iters) Arguments Type Intent Optional Attributes Name procedure( f_1d ) :: f real(kind=pr), intent(inout) :: x real(kind=pr), intent(in) :: tol integer, intent(in) :: max_iters","tags":"","url":"interface/newton.html"},{"title":"find_llcl – yaeos","text":"public  subroutine find_llcl(model, z0, zi, P, a, V, T) find_llcl Find an initial guess for the critical L-L line of a binary mixture. Description Examples References [1] M. Cismondi, M.L. Michelsen, Global phase equilibrium\ncalculations:\nCritical lines, critical end points and liquid–liquid–vapour\nequilibrium in binary mixtures, The Journal of Supercritical Fluids 39\n (2007) 287–295. https://doi.org/10.1016/j.supflu.2006.03.011. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (2) Mole fractions of original fluid real(kind=pr), intent(in) :: zi (2) Mole fractions of new fluid real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(out) :: a Mole fraction of new fluid real(kind=pr), intent(out) :: V Volume [L/mol] real(kind=pr), intent(inout) :: T Temperature [K] Variables Type Visibility Attributes Name Initial real(kind=pr), private :: as (50) real(kind=pr), private :: dlnphidn (2,2) integer, private :: i real(kind=pr), private :: lambdas (50) real(kind=pr), private :: lnphi (2) integer, private :: tries real(kind=pr), private :: z (2)","tags":"","url":"proc/find_llcl.html"},{"title":"F_critical – yaeos","text":"public  function F_critical(model, X, ns, S, z0, zi, u) F_critical Description Function that should be equal to zero at a critical point is found.\nThe second criticality condition is calculated as a numerical\nderivative with eps=1e-4 . The vector of varibles is Including internally the extra equation: Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: X (4) Vector of variables integer, intent(in) :: ns Position of the specification variable real(kind=pr), intent(in) :: S Specification variable value real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid real(kind=pr), intent(inout) :: u (:) Eigen-vector Return Value real(kind=pr), (4) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: F1 (4) real(kind=pr), private :: F2 (4) real(kind=pr), private :: P real(kind=pr), private :: T real(kind=pr), private :: V real(kind=pr), private :: a real(kind=pr), private :: dx (4) real(kind=pr), private, parameter :: eps = 1e-4_pr real(kind=pr), private :: eps_df integer, private :: i real(kind=pr), private :: u_new (size(u)) real(kind=pr), private :: z (size(u))","tags":"","url":"proc/f_critical.html"},{"title":"critical_line – yaeos","text":"public  function critical_line(model, a0, z0, zi, ns0, S0, dS0, v0, t0, p0, max_points, maxP, first_point, stability_analysis) Uses yaeos__equilibria_equilibrium_state yaeos__math yaeos__math_continuation critical_line Description Calculates the critical line between two mixtures using the\ncontinuation method. The two mixtures compositions are restricted to\nthe relation between them, by a parameter , which represents\nthe molar fraction of the second fluid with respect to the whole\nmixture. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: a0 Initial value real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid integer, intent(in) :: ns0 Position of the specification variable real(kind=pr), intent(in) :: S0 Specified value real(kind=pr), intent(in) :: dS0 Initial step size real(kind=pr), intent(in), optional :: v0 Initial volume [L/mol] real(kind=pr), intent(in), optional :: t0 Initial temperature [K] real(kind=pr), intent(in), optional :: p0 Initial pressure [bar] integer, intent(in), optional :: max_points Maximum number of points real(kind=pr), intent(in), optional :: maxP Maximum pressure type( EquilibriumState ), intent(in), optional :: first_point logical, optional :: stability_analysis Return Value type( CriticalLine ) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: P real(kind=pr), private :: S real(kind=pr), private :: T real(kind=pr), private :: V real(kind=pr), private :: V_cep real(kind=pr), private :: X0 (4) real(kind=pr), private, allocatable :: XS (:,:) Full set of solved points real(kind=pr), private, allocatable :: XS_i (:) Full set of solved points real(kind=pr), private :: a logical, private :: found_cep integer, private :: i real(kind=pr), private :: max_P integer, private :: npoints integer, private :: ns logical, private :: stab_anal real(kind=pr), private :: u (size(z0)) eigen-vector real(kind=pr), private :: u_new (size(z0)) eigen-vector real(kind=pr), private :: y_cep (size(z0)) real(kind=pr), private :: z (size(z0))","tags":"","url":"proc/critical_line.html"},{"title":"critical_point – yaeos","text":"public  function critical_point(model, z0, zi, spec, S, max_iters, V0, T0, a0, P0) Uses yaeos__math critical_point Description Calculates a single critical point of a mixture using a Newton-Raphson\nmethod. It is possible to specify different variables to be fixed with\nthe spec argument, the spec_CP variable helps when selecting the\nspecified variable. Examples Default behaviour cp = critical_point (& model , z0 , zi , S = 0.5_pr , spec = spec_CP % a , max_iters = 1000 ) Specifiying another variable The natural variables are a, lnV, lnT and lnP. So it is important to\nspecify the variable in logaritmic scale if that is the case. cp = critical_point ( model , z0 , zi , S = log ( 20 0._pr ), spec = spec_CP % P , max_iters = 1000 ) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid integer, intent(in) :: spec Specification [1:\"z\", 2:\"V\", 3:\"T\", 4:\"P\"] real(kind=pr), intent(in) :: S Specification value integer, intent(in) :: max_iters Maxiumum number of iterations real(kind=pr), intent(in), optional :: V0 Initial volume [L/mol]. real(kind=pr), intent(in), optional :: T0 Initial temperature [K]. real(kind=pr), intent(in), optional :: a0 Initial value real(kind=pr), intent(in), optional :: P0 Initial Pressure [bar] Return Value type( EquilibriumState ) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: F (4) real(kind=pr), private :: Sin real(kind=pr), private :: X (4) real(kind=pr), private :: a real(kind=pr), private :: dX (4) real(kind=pr), private :: df (4,4) integer, private :: i real(kind=pr), private :: l integer, private :: ns real(kind=pr), private :: u (size(z0)) real(kind=pr), private :: u_new (size(z0)) real(kind=pr), private :: z (size(z0))","tags":"","url":"proc/critical_point.html"},{"title":"df_critical – yaeos","text":"public  function df_critical(model, X, ns, S, z0, zi, u) df_critical Description Calculates the Jacobian of the critical point function F_critical . Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: X (4) Vector of variables integer, intent(in) :: ns Position of the specification variable real(kind=pr), intent(in) :: S Specification variable value real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid real(kind=pr), intent(inout) :: u (:) Eigen-vector Return Value real(kind=pr), (4,4) Jacobian of the critical point function Variables Type Visibility Attributes Name Initial real(kind=pr), private :: F1 (4) real(kind=pr), private :: F2 (4) real(kind=pr), private :: a real(kind=pr), private :: dx (4) real(kind=pr), private :: eps integer, private :: i","tags":"","url":"proc/df_critical.html"},{"title":"lambda1 – yaeos","text":"public  function lambda1(model, X, s, z0, zi, u, u_new, P) Uses yaeos__math_linalg lambda1 Calculation of the first restriction of a critical point. is the smallest eigen-value for the matrix: Where And should be the eigen-vector corresponding to the\nsmallest eigen-value when Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: X (4) Vector of variables real(kind=pr), intent(in) :: s Distance between the two fluids compositions to the main composition real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid real(kind=pr), intent(in) :: u (:) Eigen-vector that defines the direction between the two compositions real(kind=pr), intent(out), optional :: u_new (:) Eigen-vector corresponding to the smallest eigenvalue of the matrix real(kind=pr), intent(out), optional :: P Pressure of the system [bar] Return Value real(kind=pr) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: M (size(z0),size(z0)) real(kind=pr), private :: Pin real(kind=pr), private :: T real(kind=pr), private :: V real(kind=pr), private :: a real(kind=pr), private :: dlnf_dn (size(z0),size(z0)) integer, private :: i integer, private :: j real(kind=pr), private :: lambda (size(z0)) real(kind=pr), private :: n (size(z0)) integer, private :: nc real(kind=pr), private :: vectors (size(z0),size(z0)) real(kind=pr), private :: z (size(z0))","tags":"","url":"proc/lambda1.html"},{"title":"F_cep – yaeos","text":"private  function F_cep(model, nc, X, z0, zi, u) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model integer, intent(in) :: nc real(kind=pr), intent(in) :: X (nc+4) Vector of variables real(kind=pr), intent(in) :: z0 (nc) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (nc) Molar fractions of the second fluid real(kind=pr), intent(inout) :: u (nc) Eigen-vector Return Value real(kind=pr), (nc+4) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: P real(kind=pr), private :: Pc real(kind=pr), private :: Py real(kind=pr), private :: T real(kind=pr), private :: V real(kind=pr), private :: Vc real(kind=pr), private :: Vy real(kind=pr), private :: Xcp (nc+4) real(kind=pr), private :: a real(kind=pr), private, parameter :: eps = 1e-5_pr real(kind=pr), private :: lnf_y (nc) real(kind=pr), private :: lnf_z (nc) real(kind=pr), private :: u_new (nc) real(kind=pr), private :: y (nc) real(kind=pr), private :: z (nc)","tags":"","url":"proc/f_cep.html"},{"title":"df_cep – yaeos","text":"private  function df_cep(model, nc, X, z0, zi, u) df_critical Description Calculates the Jacobian of the critical point function F_critical . Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model integer, intent(in) :: nc real(kind=pr), intent(in) :: X (nc+4) Vector of variables real(kind=pr), intent(in) :: z0 (nc) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (nc) Molar fractions of the second fluid real(kind=pr), intent(inout) :: u (nc) Eigen-vector Return Value real(kind=pr), (nc+4,nc+4) Jacobian of the critical point function Variables Type Visibility Attributes Name Initial real(kind=pr), private :: F1 (nc+4) real(kind=pr), private :: F2 (nc+4) real(kind=pr), private :: a real(kind=pr), private :: dx (nc+4) real(kind=pr), private :: eps integer, private :: i","tags":"","url":"proc/df_cep.html"},{"title":"get_a – yaeos","text":"private  function get_a(X) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X Return Value real(kind=pr)","tags":"","url":"proc/get_a.html"},{"title":"set_a – yaeos","text":"private  function set_a(a) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: a Return Value real(kind=pr)","tags":"","url":"proc/set_a.html"},{"title":"look_for_cep – yaeos","text":"private  subroutine look_for_cep(model, z0, zi, Pc, Vc, Tc, a, u, found, CEP) Uses yaeos__math Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid real(kind=pr), intent(in) :: Pc Pressure [bar] real(kind=pr), intent(in) :: Vc Volume [L/mol] real(kind=pr), intent(in) :: Tc Temperature [K] real(kind=pr), intent(in) :: a Molar fraction of the second fluid real(kind=pr), intent(inout) :: u (:) Eigen-vector logical, intent(out) :: found Found a Critical End Point type( EquilibriumState ), intent(out) :: CEP Critical End Point Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Fcep (size(z0)+4) real(kind=pr), private :: V_cep real(kind=pr), private :: Xcep (size(z0)+4) real(kind=pr), private :: dFcep (size(z0)+4,size(z0)+4) real(kind=pr), private :: dXcep (size(z0)+4) real(kind=pr), private :: y_cep (size(z0))","tags":"","url":"proc/look_for_cep.html"},{"title":"stability_check – yaeos","text":"private  subroutine stability_check(model, z0, zi, Pc, Vc, Tc, a, unstable, y_other, V_other) Uses yaeos__equilibria_stability stability_check Description Check the stability of a point in the critical line. The stability is\ndetermined by tpd analysis. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid real(kind=pr), intent(in) :: Pc Pressure [bar] real(kind=pr), intent(in) :: Vc Volume [L/mol] real(kind=pr), intent(in) :: Tc Temperature [K] real(kind=pr), intent(in) :: a Molar fraction of the second fluid logical, intent(out) :: unstable Stability of the point) real(kind=pr), intent(out) :: y_other (:) Molar fractions of the second fluid real(kind=pr), intent(out) :: V_other Volume [L/mol] Variables Type Visibility Attributes Name Initial real(kind=pr), private :: P real(kind=pr), private :: dy logical, private :: first real(kind=pr), private :: fug_y (2) real(kind=pr), private :: fug_z (2) integer, private :: istab integer, private :: istab0 logical, private :: possible real(kind=pr), private :: tpd real(kind=pr), private :: y (2) real(kind=pr), private :: z (2)","tags":"","url":"proc/stability_check.html"},{"title":"get_maingroup_index – yaeos","text":"public  function get_maingroup_index(self, maingroup_id) result(maingroup_idx) get_maingroup_index Get index of the maingoup with id: maingoup_id Description Get index of the maingoup with id: maingoup_id . Gets the index of the\nmaingoup in the self%maingoups_ids vector. Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters parameters = UNIFACParameters () ! Get index of the maingroup with id 55 (Sulfones: [118](CH2)2SU [119]CH2CHSU) print * , parameters % get_maingroup_index ( 55 ) ! Will print: 52 References Dortmund Data Bank Software & Separation Technology Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_id ID of the subgroup Return Value integer Index of the maingroup on the self%maingroups_ids vector","tags":"","url":"proc/get_maingroup_index.html"},{"title":"get_maingroups_aij – yaeos","text":"public  function get_maingroups_aij(self, maingroup_i_id, maingroup_j_id) result(aij) get_maingroups_aij Get the interaction parameter Description Get the interaction parameter of the maingroups i and j ids. Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters parameters = UNIFACParameters () ! Get the maingroups i:1, j:7 interaction parameter aij (CH2-H2O) print * , parameters % get_maingroups_aij ( 1 , 7 ) ! prints: 1318.0000 References Dortmund Data Bank Software & Separation Technology Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_i_id ID of the maingroup i integer, intent(in) :: maingroup_j_id ID of the maingroup j Return Value real(kind=pr) Interaction parameter Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","url":"proc/get_maingroups_aij.html"},{"title":"get_maingroups_bij – yaeos","text":"public  function get_maingroups_bij(self, maingroup_i_id, maingroup_j_id) result(bij) get_maingroups_bij Get the interaction parameter Description Get the interaction parameter of the maingroups i and j ids. Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters parameters = UNIFACParameters () ! Get the maingroups i:1, j:7 interaction parameter bij (CH2-H2O) print * , parameters % get_maingroups_bij ( 1 , 7 ) ! prints: 0.0 In the example we obtain 0.0 because UNIFAC only have parameters References Dortmund Data Bank Software & Separation Technology Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_i_id ID of the maingroup i integer, intent(in) :: maingroup_j_id ID of the maingroup j Return Value real(kind=pr) Interaction parameter Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","url":"proc/get_maingroups_bij.html"},{"title":"get_maingroups_cij – yaeos","text":"public  function get_maingroups_cij(self, maingroup_i_id, maingroup_j_id) result(cij) get_maingroups_cij Get the interaction parameter Description Get the interaction parameter of the maingroups i and j ids. Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters parameters = UNIFACParameters () ! Get the maingroups i:1, j:7 interaction parameter cij (CH2-H2O) print * , parameters % get_maingroups_cij ( 1 , 7 ) ! prints: 0.0 In the example we obtain 0.0 because UNIFAC only have parameters References Dortmund Data Bank Software & Separation Technology Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_i_id ID of the maingroup i integer, intent(in) :: maingroup_j_id ID of the maingroup j Return Value real(kind=pr) Interaction parameter Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","url":"proc/get_maingroups_cij.html"},{"title":"get_subgroup_Q – yaeos","text":"public  function get_subgroup_Q(self, subgroup_id) result(subgroup_Q) get_subgroup_Q Get the subgroup’s value Description Uses the self%subgroups_Qs attribute to locate the subgroup value. Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters parameters = UNIFACParameters () ! Get the subgroup, with id 1 (CH3), Q value print * , parameters % get_subgroup_Q ( 1 ) ! Will print: 0.8480 References Dortmund Data Bank Software & Separation Technology Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value real(kind=pr) value of the subgroup Variables Type Visibility Attributes Name Initial integer, public :: subgroup_idx","tags":"","url":"proc/get_subgroup_q.html"},{"title":"get_subgroup_R – yaeos","text":"public  function get_subgroup_R(self, subgroup_id) result(subgroup_R) get_subgroup_R Get the subgroup’s value Description Uses the self%subgroups_Rs attribute to locate the subgroup value. Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters parameters = UNIFACParameters () ! Get the subgroup, with id 1 (CH3), R value print * , parameters % get_subgroup_R ( 1 ) ! Will print: 0.9011 References Dortmund Data Bank Software & Separation Technology Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value real(kind=pr) value of the subgroup Variables Type Visibility Attributes Name Initial integer, public :: subgroup_idx","tags":"","url":"proc/get_subgroup_r.html"},{"title":"get_subgroup_index – yaeos","text":"public  function get_subgroup_index(self, subgroup_id) result(subgroup_idx) get_subgroup_index Get index of the subgroup with id: subgroup_id Description Get index of the subgroup with id: subgroup_id . Gets the index of the\nsubgroup in the self%subgroups_ids vector. Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters ! Default parameters of UNIFAC (ddbst) parameters = UNIFACParameters () ! Get index of the subgroup with id 178 (IMIDAZOL) print * , parameters % get_subgroup_index ( 178 ) ! Will print: 112 References Dortmund Data Bank Software & Separation Technology Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value integer Index of the subgroup on the self%subgroups_ids vector","tags":"","url":"proc/get_subgroup_index.html"},{"title":"get_subgroup_maingroup – yaeos","text":"public  function get_subgroup_maingroup(self, subgroup_id) result(subgroup_maingroup) get_subgroup_maingroup Get the subgroup’s maingroup Description Uses the self%subgroups_maingroups attribute to locate the maingroup\nwhere the subgroup with id subgroup_id belongs Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters parameters = UNIFACParameters () ! Get the maingroup of the subgroup with id 16 (H2O) print * , parameters % get_subgroup_maingroup ( 16 ) ! Will print: 7 References Dortmund Data Bank Software & Separation Technology Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value integer Maingroup of the subgroup Variables Type Visibility Attributes Name Initial integer, public :: subgroup_idx","tags":"","url":"proc/get_subgroup_maingroup.html"},{"title":"get_subgroups_aij – yaeos","text":"public  function get_subgroups_aij(self, subgroup_i_id, subgroup_j_id) result(aij) get_subgroups_aij Get the interaction parameter Description Get the interaction parameter of the subgroups i and j ids. Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters parameters = UNIFACParameters () ! Get the subgroups i:1, j:16 interaction parameter aij (CH3-H2O) ! with maingroups 1 and 7 respectively. print * , parameters % get_subgroups_aij ( 1 , 16 ) ! prints: 1318.0000 References Dortmund Data Bank Software & Separation Technology Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_i_id ID of the subgroup i integer, intent(in) :: subgroup_j_id ID of the subgroup j Return Value real(kind=pr) Interaction parameter Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: mi_id integer, public :: mj_id","tags":"","url":"proc/get_subgroups_aij.html"},{"title":"get_subgroups_bij – yaeos","text":"public  function get_subgroups_bij(self, subgroup_i_id, subgroup_j_id) result(bij) get_subgroups_bij Get the interaction parameter Description Get the interaction parameter of the subgroups i and j ids. Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters parameters = UNIFACParameters () ! Get the subgroups i:1, j:16 interaction parameter bij (CH3-H2O) ! with maingroups 1 and 7 respectively. print * , parameters % get_subgroups_bij ( 1 , 16 ) ! prints: 0.0000 In the example we obtain 0.0 because UNIFAC only have parameters References Dortmund Data Bank Software & Separation Technology Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_i_id ID of the subgroup i integer, intent(in) :: subgroup_j_id ID of the subgroup j Return Value real(kind=pr) Interaction parameter Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: mi_id integer, public :: mj_id","tags":"","url":"proc/get_subgroups_bij.html"},{"title":"get_subgroups_cij – yaeos","text":"public  function get_subgroups_cij(self, subgroup_i_id, subgroup_j_id) result(cij) get_subgroups_cij Get the interaction parameter Description Get the interaction parameter of the subgroups i and j ids. Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters parameters = UNIFACParameters () ! Get the subgroups i:1, j:16 interaction parameter cij (CH3-H2O) ! with maingroups 1 and 7 respectively. print * , parameters % get_subgroups_cij ( 1 , 16 ) ! prints: 0.0000 In the example we obtain 0.0 because UNIFAC only have parameters References Dortmund Data Bank Software & Separation Technology Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_i_id ID of the subgroup i integer, intent(in) :: subgroup_j_id ID of the subgroup j Return Value real(kind=pr) Interaction parameter Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: mi_id integer, public :: mj_id","tags":"","url":"proc/get_subgroups_cij.html"},{"title":"check_consistency – yaeos","text":"public  subroutine check_consistency(self) Type Bound GeGCModelParameters Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ), intent(in) :: self Variables Type Visibility Attributes Name Initial integer, public :: n_maingroups integer, public :: n_subgroups","tags":"","url":"proc/check_consistency.html"},{"title":"ge_consistency – yaeos","text":"public  subroutine ge_consistency(model, n, t, eq58, eq59, eq60, eq61) ge_consistency models consistency tests Description Evaluate the models consistency tests described in\nThermodynamic Models: Fundamentals & Computational Aspects 2 ed. by\nMichelsen and Mollerup (MM) Chapter 5 section 4. The “eq” are\nevaluations of the left hand side of the following expressions: Equation 58 Equation 59 Equation 60 Equation 61 Examples use yaeos , only : pr use yaeos , only : Groups , setup_unifac , UNIFAC use yaeos__consistency_gemodel , only : ge_consistency type ( UNIFAC ) :: model integer , parameter :: nc = 4 , ng = 4 type ( Groups ) :: molecules ( nc ) real ( pr ) :: n ( nc ), T real ( pr ) :: dt , dn real ( pr ) :: eq58 , eq59 ( nc ), eq60 ( nc , nc ), eq61 ( nc ) T = 30 3.15 n = [ 40 0.0 , 10 0.0 , 30 0.0 , 20 0.0 ] ! Hexane [CH3, CH2] molecules ( 1 )% groups_ids = [ 1 , 2 ] molecules ( 1 )% number_of_groups = [ 2 , 4 ] ! Ethanol [CH3, CH2, OH] molecules ( 2 )% groups_ids = [ 1 , 2 , 14 ] molecules ( 2 )% number_of_groups = [ 1 , 1 , 1 ] ! Toluene [ACH, ACCH3] molecules ( 3 )% groups_ids = [ 9 , 11 ] molecules ( 3 )% number_of_groups = [ 5 , 1 ] ! Cyclohexane [CH2] molecules ( 4 )% groups_ids = [ 2 ] molecules ( 4 )% number_of_groups = [ 6 ] model = setup_unifac ( molecules ) ! ==================================================================== ! Consistency tests ! -------------------------------------------------------------------- call ge_consistency ( model , n , t , eq58 , eq59 , eq60 , eq61 ) References Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models:\nFundamentals & computational aspects (2. ed). Tie-Line Publications. Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: model model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: eq58 MM Eq. 58 real(kind=pr), intent(out), optional :: eq59 (size(n)) MM Eq. 59 real(kind=pr), intent(out), optional :: eq60 (size(n),size(n)) MM Eq. 60 real(kind=pr), intent(out), optional :: eq61 (size(n)) MM Eq. 61 Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ge real(kind=pr), public :: Gen (size(n)) real(kind=pr), public :: Gen2 (size(n),size(n)) integer, public :: i integer, public :: j real(kind=pr), public :: ln_gammas (size(n))","tags":"","url":"proc/ge_consistency.html"},{"title":"numeric_ge_derivatives – yaeos","text":"public  subroutine numeric_ge_derivatives(model, n, t, d_n, d_t, Ge, GeT, Gen, GeT2, GeTn, Gen2) numeric_ge_derivatives Numeric model derivatives Description Tool to facilitate the development of new GeModel by testing\nthe implementation of analytic derivatives. Examples use yaeos , only : Groups , setup_unifac , UNIFAC use yaeos__consistency_gemodel , only : numeric_ge_derivatives type ( UNIFAC ) :: model integer , parameter :: nc = 4 , ng = 4 type ( Groups ) :: molecules ( nc ) real ( pr ) :: Ge , Gen ( nc ), GeT , GeT2 , GeTn ( nc ), Gen2 ( nc , nc ) real ( pr ) :: Ge_n , Gen_n ( nc ), GeT_n , GeT2_n , GeTn_n ( nc ), Gen2_n ( nc , nc ) real ( pr ) :: ln_gammas ( nc ) real ( pr ) :: n ( nc ), T real ( pr ) :: dt , dn T = 30 3.15 n = [ 40 0.0 , 10 0.0 , 30 0.0 , 20 0.0 ] ! always test with sum(n) > 1 dt = 0.1_pr dn = 0.1_pr ! Hexane [CH3, CH2] molecules ( 1 )% groups_ids = [ 1 , 2 ] molecules ( 1 )% number_of_groups = [ 2 , 4 ] ! Ethanol [CH3, CH2, OH] molecules ( 2 )% groups_ids = [ 1 , 2 , 14 ] molecules ( 2 )% number_of_groups = [ 1 , 1 , 1 ] ! Toluene [ACH, ACCH3] molecules ( 3 )% groups_ids = [ 9 , 11 ] molecules ( 3 )% number_of_groups = [ 5 , 1 ] ! Cyclohexane [CH2] molecules ( 4 )% groups_ids = [ 2 ] molecules ( 4 )% number_of_groups = [ 6 ] model = setup_unifac ( molecules ) ! ===================================================================== ! Call analytic derivatives ! --------------------------------------------------------------------- call model % excess_gibbs ( n , T , Ge , GeT , GeT2 , Gen , GeTn , Gen2 ) ! ===================================================================== ! Call numeric derivatives ! --------------------------------------------------------------------- call numeric_ge_derivatives ( model , n , T , dn , dt , Ge = Ge_n , GeT = GeT_n ) call numeric_ge_derivatives ( model , n , T , dn , dt , Ge = Ge_n , Gen = Gen_n ) call numeric_ge_derivatives ( model , n , T , dn , dt , Ge = Ge_n , GeT2 = GeT2_n ) call numeric_ge_derivatives ( model , n , T , dn , dt , Ge = Ge_n , GeTn = GeTn_n ) call numeric_ge_derivatives ( model , n , T , dn , dt , Ge = Ge_n , Gen2 = Gen2_n ) Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: model model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in) :: d_n Moles finite difference step real(kind=pr), intent(in) :: d_t Temperature finite difference step real(kind=pr), intent(out) :: Ge Residual Helmoltz energy real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: Gen (size(n)) real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional :: GeTn (size(n)) real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ge_aux1 real(kind=pr), public :: Ge_aux2 real(kind=pr), public :: Ge_aux3 real(kind=pr), public :: Ge_aux4 real(kind=pr), public :: dn_aux1 (size(n)) real(kind=pr), public :: dn_aux2 (size(n)) integer, public :: i integer, public :: j","tags":"","url":"proc/numeric_ge_derivatives.html"},{"title":"alpha – yaeos","text":"public  subroutine alpha(self, Tr, a, dadt, dadt2) Soave function and it’s derivatives. Type Bound AlphaSoave Arguments Type Intent Optional Attributes Name class( AlphaSoave ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) Reduced temperature real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","url":"proc/alpha.html"},{"title":"alpha_mc – yaeos","text":"public  subroutine alpha_mc(self, Tr, a, dadt, dadt2) MathiasCopeman alpha function definition Type Bound AlphaMathiasCopeman Arguments Type Intent Optional Attributes Name class( AlphaMathiasCopeman ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dudt (size(Tr)) real(kind=pr), public :: dudt2 (size(Tr)) real(kind=pr), public :: sqrt_Tr (size(Tr)) real(kind=pr), public :: u (size(Tr))","tags":"","url":"proc/alpha_mc.html"},{"title":"alpha_rkpr – yaeos","text":"public  subroutine alpha_rkpr(self, Tr, a, dadt, dadt2) Type Bound AlphaRKPR Arguments Type Intent Optional Attributes Name class( AlphaRKPR ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) Reduced temperature real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","url":"proc/alpha_rkpr.html"},{"title":"bmix_linear – yaeos","text":"public pure subroutine bmix_linear(n, bi, b, dbi, dbij) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: b real(kind=pr), intent(out) :: dbi (:) real(kind=pr), intent(out) :: dbij (:,:)","tags":"","url":"proc/bmix_linear.html"},{"title":"bmix_qmr – yaeos","text":"public pure subroutine bmix_qmr(n, bi, lij, b, dbi, dbij) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(in) :: lij (:,:) real(kind=pr), intent(out) :: b real(kind=pr), intent(out) :: dbi (:) real(kind=pr), intent(out) :: dbij (:,:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aux (size(n)) real(kind=pr), public :: bij (size(n),size(n)) integer, public :: i integer, public :: j integer, public :: nc real(kind=pr), public :: totn","tags":"","url":"proc/bmix_qmr.html"},{"title":"d1mix_rkpr – yaeos","text":"public pure subroutine d1mix_rkpr(n, d1i, D1, dD1i, dD1ij) RKPR parameter mixing rule. The RKPR EoS doesn’t have a constant value for each\ncomponent, so a proper mixing rule should be provided. A linear\ncombination is used. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:) Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: nc real(kind=pr), public :: totn","tags":"","url":"proc/d1mix_rkpr.html"},{"title":"lamdba_hv – yaeos","text":"public  subroutine lamdba_hv(d1, dd1i, dd1ij, L, dLi, dLij) Infinite pressure limit parameter Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: d1 real(kind=pr), intent(in) :: dd1i (:) real(kind=pr), intent(in) :: dd1ij (:,:) real(kind=pr), intent(out) :: L real(kind=pr), intent(out) :: dLi (:) real(kind=pr), intent(out) :: dLij (:,:) Variables Type Visibility Attributes Name Initial real(kind=pr), public, dimension(size(dd1i), size(dd1i)) :: d2f real(kind=pr), public, dimension(size(dd1i), size(dd1i)) :: d2g real(kind=pr), public, dimension(size(dd1i), size(dd1i)) :: d2h real(kind=pr), public, dimension(size(dd1i)) :: df real(kind=pr), public, dimension(size(dd1i)) :: dg real(kind=pr), public, dimension(size(dd1i)) :: dh real(kind=pr), public :: f real(kind=pr), public :: g real(kind=pr), public :: h integer, public :: i integer, public :: j integer, public :: nc","tags":"","url":"proc/lamdba_hv.html"},{"title":"saturation_pressure – yaeos","text":"public  function saturation_pressure(model, n, t, kind, p0, y0, max_iters) Uses yaeos__auxiliar yaeos__m_s_sp saturation_pressure Saturation pressure calculation function. Description Calculates the saturation pressure of a multicomponent mixture with\na given molar composition n .\nIt is possible to calculate: Bubble point: kind=\"bubble\" Dew point: kind=\"dew\" Liquid-Liquid point: kind=\"liquid-liquid\" It will first try to converge a solution using a Newton method to\nsolve the equation updating at each step as the ratio of fugacities of the phases.\nIf the solution does not converge, it will use a full Newton method to\nsolve the system of equations using the variables and . Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in), target :: model real(kind=pr), intent(in) :: n (:) Composition vector [moles / molar fraction] real(kind=pr), intent(in) :: t Temperature [K] character(len=*), intent(in) :: kind [bubble|dew|liquid-liquid] real(kind=pr), intent(in), optional :: p0 Initial pressure [bar] real(kind=pr), intent(in), optional :: y0 (:) Initial composition integer, intent(in), optional :: max_iters Maximum number of iterations Return Value type( EquilibriumState ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: P real(kind=pr), public :: Vy real(kind=pr), public :: Vz real(kind=pr), public :: dlnphi_dp_y (size(n)) real(kind=pr), public :: dlnphi_dp_z (size(n)) real(kind=pr), public :: f character(len=50), public :: incipient integer, public :: iterations integer, public :: its real(kind=pr), public :: k (size(n)) real(kind=pr), public :: lnfug_y (size(n)) real(kind=pr), public :: lnfug_z (size(n)) real(kind=pr), public :: lnk (size(n)) character(len=50), public :: main real(kind=pr), public :: step real(kind=pr), public :: y (size(n)) real(kind=pr), public :: z (size(n))","tags":"","url":"proc/saturation_pressure.html"},{"title":"saturation_temperature – yaeos","text":"public  function saturation_temperature(model, n, p, kind, t0, y0, max_iters) Uses yaeos__auxiliar yaeos__m_s_sp Saturation temperature calculation function. Calculates the saturation pressure of a multicomponent mixture with\na given molar composition n .\nIt is possible to calculate: Bubble point: kind=\"bubble\" Dew point: kind=\"dew\" Liquid-Liquid point: kind=\"liquid-liquid\" It will first try to converge a solution using a Newton method to\nsolve the equation updating at each step as the ratio of fugacities of the phases.\nIf the solution does not converge, it will use a full Newton method to\nsolve the system of equations using the variables and . Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in), target :: model real(kind=pr), intent(in) :: n (:) Composition vector [moles / molar fraction] real(kind=pr), intent(in) :: p Pressure [bar] character(len=*), intent(in) :: kind [bubble|dew|liquid-liquid] real(kind=pr), intent(in), optional :: t0 Initial temperature [K] real(kind=pr), intent(in), optional :: y0 (:) Initial composition integer, intent(in), optional :: max_iters Maximum number of iterations Return Value type( EquilibriumState ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dlnphi_dt_y (size(n)) real(kind=pr), public :: dlnphi_dt_z (size(n)) real(kind=pr), public :: f character(len=50), public :: incipient logical, public :: is_incipient (size(n)) integer, public :: iterations integer, public :: its real(kind=pr), public :: k (size(n)) real(kind=pr), public :: lnfug_y (size(n)) real(kind=pr), public :: lnfug_z (size(n)) real(kind=pr), public :: lnk (size(n)) character(len=50), public :: main real(kind=pr), public :: step real(kind=pr), public :: t real(kind=pr), public :: vy real(kind=pr), public :: vz real(kind=pr), public :: y (size(n)) real(kind=pr), public :: z (size(n))","tags":"","url":"proc/saturation_temperature.html"},{"title":"P_wilson – yaeos","text":"public  function P_wilson(model, z, T) result(P) P_wilson Description Calculate the pressure at a given T of a mixture using the Wilson\nequation. Arguments Type Intent Optional Attributes Name class( BaseModel ), intent(in) :: model Model of the mixture. real(kind=pr), intent(in) :: z (:) Mole fractions of the components. real(kind=pr), intent(in) :: T Temperature [K]. Return Value real(kind=pr)","tags":"","url":"proc/p_wilson.html"},{"title":"k_wilson – yaeos","text":"public  function k_wilson(model, T, P) result(K) K_wilson Description K-factors regression done by Wilson, used for initialization. Arguments Type Intent Optional Attributes Name class( BaseModel ), intent(in) :: model real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P Return Value real(kind=pr), (size(model%components%pc))","tags":"","url":"proc/k_wilson.html"},{"title":"pt_envelope_3ph – yaeos","text":"public  function pt_envelope_3ph(model, z, x0, y0, w0, beta0, P0, T0, ns0, dS0, points) result(envelope) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: x0 (:) real(kind=pr), intent(in) :: y0 (:) real(kind=pr), intent(in) :: w0 (:) real(kind=pr), intent(in) :: beta0 real(kind=pr), intent(in) :: P0 real(kind=pr), intent(in) :: T0 integer, intent(in) :: ns0 real(kind=pr), intent(in) :: dS0 integer, intent(in) :: points Return Value type( PTEnvel3 ) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: F (size(z)*2+3) real(kind=pr), private :: P (points) real(kind=pr), private :: S Specified value real(kind=pr), private :: T (points) real(kind=pr), private :: Xvars (size(z)*2+3) real(kind=pr), private :: beta (points) real(kind=pr), private :: dF (size(z)*2+3,size(z)*2+3) real(kind=pr), private :: dS Specified value step for next point extrapolation real(kind=pr), private :: dX (size(z)*2+3) real(kind=pr), private :: dXdS (size(z)*2+3) integer, private :: i integer, private :: iterations (points) integer, private :: its real(kind=pr), private :: kx (size(z)) real(kind=pr), private :: ky (size(z)) integer, private :: max_iterations integer, private :: nc integer, private :: ns Specified variable real(kind=pr), private :: w (points,size(z)) real(kind=pr), private :: wi (size(z)) real(kind=pr), private :: x (points,size(z)) real(kind=pr), private :: xi (size(z)) real(kind=pr), private :: y (points,size(z)) real(kind=pr), private :: yi (size(z))","tags":"","url":"proc/pt_envelope_3ph.html"},{"title":"critical_interpol – yaeos","text":"private  function critical_interpol(Xnew, Xold, idx) result(a) critical_interpol Critical point interpolation Description This function calculates the parameter to interpolate the\nvalues of the variables at the critical point. The interpolation\nis done using the equation: Where is the old value of the variables and is the new value of the variables. The critical point is the point\nwhere the variables change sign, so the interpolation is done to\nfind the value of the variables at the critical point. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xnew (:) New value of the variables real(kind=pr), intent(in) :: Xold (:) Old value of the variables integer, intent(in) :: idx (:) Index of the variables to interpolate Return Value real(kind=pr) Variables Type Visibility Attributes Name Initial integer, private :: ncomp","tags":"","url":"proc/critical_interpol~2.html"},{"title":"get_values_from_X – yaeos","text":"public  subroutine get_values_from_X(z, Xvars, x, y, w, P, T, beta) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: Xvars (size(z)*2+3) real(kind=pr), intent(out) :: x (size(z)) real(kind=pr), intent(out) :: y (size(z)) real(kind=pr), intent(out) :: w (size(z)) real(kind=pr), intent(out) :: P real(kind=pr), intent(out) :: T real(kind=pr), intent(out) :: beta Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Kx ((Size(Xvars)-3)/2) real(kind=pr), private :: Ky ((Size(Xvars)-3)/2) integer, private :: nc","tags":"","url":"proc/get_values_from_x~5.html"},{"title":"solve_point – yaeos","text":"public  subroutine solve_point(model, z, ns, S, X, F, dF, its, maxits) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(inout) :: X (:) real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out) :: dF (:,:) integer, intent(inout) :: its integer, intent(in) :: maxits Variables Type Visibility Attributes Name Initial real(kind=pr), private :: dX (size(X)) integer, private :: i integer, private :: nc","tags":"","url":"proc/solve_point~7.html"},{"title":"detect_critical – yaeos","text":"private  subroutine detect_critical(X, dXdS, ns, S, dS) detect_critical Critical point detection Description If the values of lnK (X[:nc]) change sign then a critical point\nHas passed, since for this to happen all variables should pass\nthrough zero. Near critical points (lnK < 0.05) points are harder\nto converge, so more steps in the extrapolation vector are made to\njump over the critical point.\nIf the critical point is detected then the kind of the point is\nchanged and the point is saved using an interpolation knowing that With is the variables at the critical point, is the new initialization point of the method and is the\nparameter to interpolate the values. This subroutine finds the\nvalue of to obtain . Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables real(kind=pr), intent(inout) :: dXdS (:) Variation of variables wrt S integer, intent(inout) :: ns Number of specified variable real(kind=pr), intent(inout) :: S Specification value real(kind=pr), intent(inout) :: dS Step in specification Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Xc (size(X)) Value at (near) critical point real(kind=pr), private :: Xnew (size(X)) Value of the next initialization real(kind=pr), private :: Xold (size(X)) Old value of X real(kind=pr), private :: a Parameter for interpolation integer, private :: critical_set ((size(X)-3)/2) integer, private :: first_set ((size(X)-3)/2) logical, private :: found_critical integer, private :: i integer, private :: idx ((size(X)-3)/2) integer, private :: nc integer, private :: second_set ((size(X)-3)/2) real(kind=pr), private :: step (size(X))","tags":"","url":"proc/detect_critical~5.html"},{"title":"pt_F_three_phases – yaeos","text":"private  subroutine pt_F_three_phases(model, z, Xvars, ns, S, F, df) Uses iso_fortran_env Function to solve at each point of a three phase envelope. The vector of variables X corresponds to: While the equations are: Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: Xvars (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(Xvars)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) Jacobian matrix Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Kx ((Size(Xvars)-3)/2) real(kind=pr), private :: Ky ((Size(Xvars)-3)/2) real(kind=pr), private :: P real(kind=pr), private :: T real(kind=pr), private :: Vw real(kind=pr), private :: Vx real(kind=pr), private :: Vy real(kind=pr), private :: beta real(kind=pr), private, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_w real(kind=pr), private, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_x real(kind=pr), private, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_y real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_w real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_x real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_y real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_w real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_x real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_y real(kind=pr), private :: dwdKx ((Size(Xvars)-3)/2) real(kind=pr), private :: dwdKy ((Size(Xvars)-3)/2) real(kind=pr), private :: dwdb ((Size(Xvars)-3)/2) real(kind=pr), private :: dxdKx ((Size(Xvars)-3)/2) real(kind=pr), private :: dxdKy ((Size(Xvars)-3)/2) real(kind=pr), private :: dydKx ((Size(Xvars)-3)/2) real(kind=pr), private :: dydKy ((Size(Xvars)-3)/2) integer, private :: i integer, private :: j real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: lnphi_w real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: lnphi_x real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: lnphi_y integer, private :: nc real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: w real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: x real(kind=pr), private, dimension((Size(Xvars)-3)/2) :: y","tags":"","url":"proc/pt_f_three_phases.html"},{"title":"update_specification – yaeos","text":"private  subroutine update_specification(its, X, dF, dXdS, ns, dS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: its real(kind=pr), intent(inout) :: X (:) real(kind=pr), intent(inout) :: dF (:,:) real(kind=pr), intent(inout) :: dXdS (:) integer, intent(inout) :: ns real(kind=pr), intent(inout) :: dS Variables Type Visibility Attributes Name Initial real(kind=pr), private :: dFdS (size(X)) integer, private :: first_set ((size(X)-3)/2) integer, private :: i integer, private :: idx ((size(X)-3)/2) integer, private :: nc integer, private :: second_set ((size(X)-3)/2)","tags":"","url":"proc/update_specification~5.html"},{"title":"find_hpl – yaeos","text":"public  function find_hpl(model, z, T0, P0, max_points) find_hpl Description Find a liquid-liquid phase boundary on the PT plane. At a specified\npressure.\nThe procedure consists in looking for the temperature at which the\nfugacity of a component in the mixture is higher than the fugacity\nof the same component in a pure phase. This is done for each component\nin the mixture. The component with the highest temperature is selected\nas it should be the first one appearing. If all components have a\nnegative difference then the mixture is probably stable at all\ntemperatures. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: z (:) Mole fractions real(kind=pr), intent(in) :: T0 Initial temperature [K] real(kind=pr), intent(in) :: P0 Search pressure [bar] integer, intent(in) :: max_points Return Value type( PTEnvel2 ) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: P real(kind=pr), private :: T real(kind=pr), private :: Ts (size(z)) real(kind=pr), private :: diffs (size(z)) type( EquilibriumState ), private :: fr integer, private :: i real(kind=pr), private :: lnphi_y (size(z)) real(kind=pr), private :: lnphi_z (size(z)) integer, private :: nc integer, private :: ncomp real(kind=pr), private :: y (size(z))","tags":"","url":"proc/find_hpl.html"},{"title":"pt_envelope_2ph – yaeos","text":"public  function pt_envelope_2ph(model, z, first_point, points, iterations, delta_0, specified_variable_0, solver, stop_conditions, maximum_pressure) result(envelopes) Uses yaeos__auxiliar PT two-phase envelope calculation procedure. Phase envelope calculation using the continuation method.\nDefaults to solving the saturation temperature and continues with\nan increment in it. The variable to specify can be changed by modifying specified_variable_0 with the corresponding variable number. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Thermodyanmic model real(kind=pr), intent(in) :: z (:) Vector of molar fractions type( EquilibriumState ), intent(in) :: first_point Initial point of the envelope integer, intent(in), optional :: points Maxmimum number of points, defaults to 500 integer, intent(in), optional :: iterations Point solver maximum iterations, defaults to 100 real(kind=pr), intent(in), optional :: delta_0 Initial extrapolation integer, intent(in), optional :: specified_variable_0 Position of specified variable, since the vector of variables is the values for specification\nwill be for the equilibria constants, for and for . procedure( continuation_solver ), optional :: solver Specify solver for each point, defaults to a full newton procedure procedure( continuation_stopper ), optional :: stop_conditions Function that returns true if the continuation method should stop real(kind=pr), intent(in), optional :: maximum_pressure Maximum pressure to calculate [bar] Return Value type( PTEnvel2 ) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: S0 Initial specification value real(kind=pr), private :: X (size(z)+2) Vector of variables used in the continuation method real(kind=pr), private, allocatable :: XS (:,:) All the calculated variables that are returned on the continuation\nmethod procedure (unused since each point is saved on the fly) real(kind=pr), private :: dS0 Initial specification step character(len=14), private :: kind integer, private :: max_iterations Maximum number of iterations integer, private :: max_points Maximum number of points integer, private :: nc Number of components integer, private :: ns Number of specified variable Subroutines subroutine detect_critical (X, dXdS, ns, S, dS) Critical point detection Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables real(kind=pr), intent(inout) :: dXdS (:) Variation of variables wrt S integer, intent(inout) :: ns Number of specified variable real(kind=pr), intent(inout) :: S Specification value real(kind=pr), intent(inout) :: dS Step in specification subroutine foo (X, ns, S, F, dF, dFdS) Function that needs to be solved at each envelope point Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out) :: dF (:,:) real(kind=pr), intent(out) :: dFdS (:) subroutine save_point (X, iters) Save the converged point Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: iters subroutine update_spec (X, ns, S, dS, dXdS, step_iters) Update the specification during continuation. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(inout) :: ns Number of specified variable in the vector real(kind=pr), intent(inout) :: S Variable specification value real(kind=pr), intent(inout) :: dS Step in specification real(kind=pr), intent(inout) :: dXdS (:) Variation of variables with respect to specification integer, intent(in) :: step_iters Iterations used in the solver","tags":"","url":"proc/pt_envelope_2ph.html"},{"title":"write_PTEnvel2 – yaeos","text":"private  subroutine write_PTEnvel2(pt2, unit, iotype, v_list, iostat, iomsg) Type Bound PTEnvel2 Arguments Type Intent Optional Attributes Name class( PTEnvel2 ), intent(in) :: pt2 integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Variables Type Visibility Attributes Name Initial integer, private :: cp integer, private, allocatable :: cps (:) integer, private :: i integer, private :: nc","tags":"","url":"proc/write_ptenvel2.html"},{"title":"allclose – yaeos","text":"public  function allclose(x, y, rtol) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x (:) real(kind=pr), intent(in) :: y (:) real(kind=pr), intent(in) :: rtol Return Value logical","tags":"","url":"proc/allclose.html"},{"title":"rel_error – yaeos","text":"public elemental function rel_error(x, y) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x real(kind=pr), intent(in) :: y Return Value real(kind=pr)","tags":"","url":"proc/rel_error.html"},{"title":"arfun – yaeos","text":"public  function arfun(self, n, v, t) result(arval) Type Bound Gerg2008 Arguments Type Intent Optional Attributes Name class( Gerg2008 ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Fij (size(n),size(n)) type( hyperdual ), public :: Tr type( hyperdual ), public :: Vr type( hyperdual ), public :: X (size(n)) type( hyperdual ), public :: aij type( hyperdual ), public :: ar_pures (size(n)) type( Gerg2008Binary ), public :: binary type( hyperdual ), public :: delta integer, public :: i integer, public :: j integer, public :: nc type( Gerg2008Pure ), public :: pures (size(n)) real(kind=pr), public :: rho_c (size(n)) type( hyperdual ), public :: rho_r type( hyperdual ), public :: tau","tags":"","url":"proc/arfun.html"},{"title":"gerg_2008 – yaeos","text":"public  function gerg_2008(ids) Uses yaeos__models_ar_multifluid_parameters_gerg2008 Arguments Type Intent Optional Attributes Name integer, intent(in) :: ids (:) Return Value type( Gerg2008 ) Variables Type Visibility Attributes Name Initial type( Gerg2008Binary ), public :: binaries (size(ids),size(ids)) type( Gerg2008Pure ), public :: pures (size(ids))","tags":"","url":"proc/gerg_2008.html"},{"title":"volume_initalizer – yaeos","text":"public  function volume_initalizer(self, n, p, t) result(v0) Type Bound Gerg2008 Arguments Type Intent Optional Attributes Name class( Gerg2008 ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr)","tags":"","url":"proc/volume_initalizer.html"},{"title":"ar_ij – yaeos","text":"public  subroutine ar_ij(delta, tau, binary, aij) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: delta type( hyperdual ), intent(in) :: tau type( Gerg2008Binary ), intent(in) :: binary type( hyperdual ), intent(out) :: aij Variables Type Visibility Attributes Name Initial real(kind=8), public :: beta (binary%Kexpij) real(kind=8), public :: d_exp (binary%Kexpij) real(kind=8), public :: d_pol (binary%Kpolij) real(kind=8), public :: eps (binary%Kexpij) real(kind=8), public :: etha (binary%Kexpij) real(kind=8), public :: gama (binary%Kexpij) integer, public :: idx_exp integer, public :: idx_poly real(kind=8), public :: n_exp (binary%Kexpij) real(kind=8), public :: n_pol (binary%Kpolij) real(kind=8), public :: t_exp (binary%Kexpij) real(kind=8), public :: t_pol (binary%Kpolij)","tags":"","url":"proc/ar_ij.html"},{"title":"ar_pure – yaeos","text":"public  subroutine ar_pure(pure, delta, tau, ar) Arguments Type Intent Optional Attributes Name type( Gerg2008Pure ), intent(in) :: pure type( hyperdual ), intent(in) :: delta type( hyperdual ), intent(in) :: tau type( hyperdual ), intent(out) :: ar Variables Type Visibility Attributes Name Initial integer, public :: Kexp integer, public :: Kpol real(kind=8), public :: c_exp (pure%Kexp) real(kind=8), public :: d_exp (pure%Kexp) real(kind=8), public :: d_pol (pure%Kpol) integer, public :: i real(kind=8), public :: n_exp (pure%Kexp) real(kind=8), public :: n_pol (pure%Kpol) real(kind=8), public :: t_exp (pure%Kexp) real(kind=8), public :: t_pol (pure%Kpol)","tags":"","url":"proc/ar_pure.html"},{"title":"reducing_functions – yaeos","text":"public  subroutine reducing_functions(self, n, Vr, Tr) Arguments Type Intent Optional Attributes Name class( Gerg2008 ), intent(in) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(out) :: Vr type( hyperdual ), intent(out) :: Tr Variables Type Visibility Attributes Name Initial real(kind=8), public :: Bt (size(n),size(n)) real(kind=8), public :: Bv (size(n),size(n)) real(kind=8), public :: Gt (size(n),size(n)) real(kind=8), public :: Gv (size(n),size(n)) real(kind=8), public :: Tc (size(n)) real(kind=8), public :: Vc (size(n)) type( hyperdual ), public :: X (size(n)) integer, public :: i integer, public :: j integer, public :: nc real(kind=8), public :: rho_c (size(n))","tags":"","url":"proc/reducing_functions.html"},{"title":"AddHyperDualHyperDual – yaeos","text":"public elemental function AddHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/addhyperdualhyperdual.html"},{"title":"AddHyperDualReal – yaeos","text":"public elemental function AddHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/addhyperdualreal.html"},{"title":"AddRealHyperDual – yaeos","text":"public elemental function AddRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/addrealhyperdual.html"},{"title":"DivideHyperDualHyperDual – yaeos","text":"public elemental function DivideHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/dividehyperdualhyperdual.html"},{"title":"DivideHyperDualReal – yaeos","text":"public elemental function DivideHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: invV2","tags":"","url":"proc/dividehyperdualreal.html"},{"title":"DivideRealHyperDual – yaeos","text":"public elemental function DivideRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: invV2","tags":"","url":"proc/dividerealhyperdual.html"},{"title":"MinusHyperDualHyperDual – yaeos","text":"public elemental function MinusHyperDualHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"proc/minushyperdualhyperdual.html"},{"title":"MultiplyHyperDualHyperDual – yaeos","text":"public elemental function MultiplyHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/multiplyhyperdualhyperdual.html"},{"title":"MultiplyHyperDualInt – yaeos","text":"public elemental function MultiplyHyperDualInt(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/multiplyhyperdualint.html"},{"title":"MultiplyHyperDualReal – yaeos","text":"public elemental function MultiplyHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/multiplyhyperdualreal.html"},{"title":"MultiplyIntHyperDual – yaeos","text":"public elemental function MultiplyIntHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/multiplyinthyperdual.html"},{"title":"MultiplyRealHyperDual – yaeos","text":"public elemental function MultiplyRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/multiplyrealhyperdual.html"},{"title":"PlusHyperDualHyperDual – yaeos","text":"public elemental function PlusHyperDualHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"proc/plushyperdualhyperdual.html"},{"title":"PowerHyperDualHyperDual – yaeos","text":"public elemental function PowerHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: v4","tags":"","url":"proc/powerhyperdualhyperdual.html"},{"title":"PowerHyperDualInt – yaeos","text":"public elemental function PowerHyperDualInt(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: vv2","tags":"","url":"proc/powerhyperdualint.html"},{"title":"PowerHyperDualReal – yaeos","text":"public elemental function PowerHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public, parameter :: tol = 1.0e-15_pr real(kind=pr), public :: xval","tags":"","url":"proc/powerhyperdualreal.html"},{"title":"SubtractHyperDualHyperDual – yaeos","text":"public elemental function SubtractHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/subtracthyperdualhyperdual.html"},{"title":"SubtractHyperDualReal – yaeos","text":"public elemental function SubtractHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/subtracthyperdualreal.html"},{"title":"SubtractRealHyperDual – yaeos","text":"public elemental function SubtractRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/subtractrealhyperdual.html"},{"title":"SumHyperDual – yaeos","text":"public pure function SumHyperDual(v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","url":"proc/sumhyperdual.html"},{"title":"SumHyperDual2 – yaeos","text":"public pure function SumHyperDual2(v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ), allocatable, (:) Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","url":"proc/sumhyperdual2.html"},{"title":"absHyperDual – yaeos","text":"public elemental function absHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"proc/abshyperdual.html"},{"title":"acosHyperDual – yaeos","text":"public elemental function acosHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public :: deriv1","tags":"","url":"proc/acoshyperdual.html"},{"title":"asinHyperDual – yaeos","text":"public elemental function asinHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public :: deriv1","tags":"","url":"proc/asinhyperdual.html"},{"title":"atan2HyperDual – yaeos","text":"public elemental function atan2HyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a real(kind=pr), public :: b real(kind=pr), public :: c real(kind=pr), public :: d","tags":"","url":"proc/atan2hyperdual.html"},{"title":"atanHyperDual – yaeos","text":"public elemental function atanHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public :: deriv1","tags":"","url":"proc/atanhyperdual.html"},{"title":"cosHyperDual – yaeos","text":"public elemental function cosHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx real(kind=pr), public :: f","tags":"","url":"proc/coshyperdual.html"},{"title":"coshHyperDual – yaeos","text":"public elemental function coshHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: t1 type( hyperdual ), public :: t2","tags":"","url":"proc/coshhyperdual.html"},{"title":"eq_dd – yaeos","text":"public  function eq_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/eq_dd.html"},{"title":"eq_di – yaeos","text":"public  function eq_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical","tags":"","url":"proc/eq_di.html"},{"title":"eq_dr – yaeos","text":"public elemental function eq_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical","tags":"","url":"proc/eq_dr.html"},{"title":"eq_id – yaeos","text":"public  function eq_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/eq_id.html"},{"title":"eq_rd – yaeos","text":"public elemental function eq_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/eq_rd.html"},{"title":"expHyperDual – yaeos","text":"public elemental function expHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx","tags":"","url":"proc/exphyperdual.html"},{"title":"ge_dd – yaeos","text":"public  function ge_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/ge_dd.html"},{"title":"ge_di – yaeos","text":"public  function ge_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical","tags":"","url":"proc/ge_di.html"},{"title":"ge_dr – yaeos","text":"public  function ge_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical","tags":"","url":"proc/ge_dr.html"},{"title":"ge_id – yaeos","text":"public  function ge_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/ge_id.html"},{"title":"ge_rd – yaeos","text":"public  function ge_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/ge_rd.html"},{"title":"gt_dd – yaeos","text":"public  function gt_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/gt_dd.html"},{"title":"gt_di – yaeos","text":"public  function gt_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical","tags":"","url":"proc/gt_di.html"},{"title":"gt_dr – yaeos","text":"public  function gt_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical","tags":"","url":"proc/gt_dr.html"},{"title":"gt_id – yaeos","text":"public  function gt_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/gt_id.html"},{"title":"gt_rd – yaeos","text":"public  function gt_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/gt_rd.html"},{"title":"intHyperDual – yaeos","text":"public elemental function intHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer","tags":"","url":"proc/inthyperdual.html"},{"title":"le_dd – yaeos","text":"public  function le_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/le_dd.html"},{"title":"le_di – yaeos","text":"public  function le_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical","tags":"","url":"proc/le_di.html"},{"title":"le_dr – yaeos","text":"public  function le_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical","tags":"","url":"proc/le_dr.html"},{"title":"le_id – yaeos","text":"public  function le_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/le_id.html"},{"title":"le_rd – yaeos","text":"public  function le_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/le_rd.html"},{"title":"log10HyperDual – yaeos","text":"public elemental function log10HyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"proc/log10hyperdual.html"},{"title":"logHyperDual – yaeos","text":"public elemental function logHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx1 real(kind=pr), public :: dx2","tags":"","url":"proc/loghyperdual.html"},{"title":"lt_dd – yaeos","text":"public  function lt_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/lt_dd.html"},{"title":"lt_di – yaeos","text":"public  function lt_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical","tags":"","url":"proc/lt_di.html"},{"title":"lt_dr – yaeos","text":"public  function lt_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical","tags":"","url":"proc/lt_dr.html"},{"title":"lt_id – yaeos","text":"public  function lt_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/lt_id.html"},{"title":"lt_rd – yaeos","text":"public  function lt_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/lt_rd.html"},{"title":"max_dd – yaeos","text":"public elemental function max_dd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/max_dd.html"},{"title":"max_ddd – yaeos","text":"public elemental function max_ddd(v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual )","tags":"","url":"proc/max_ddd.html"},{"title":"max_dr – yaeos","text":"public elemental function max_dr(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/max_dr.html"},{"title":"max_rd – yaeos","text":"public elemental function max_rd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/max_rd.html"},{"title":"min_dd – yaeos","text":"public elemental function min_dd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/min_dd.html"},{"title":"min_dr – yaeos","text":"public elemental function min_dr(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/min_dr.html"},{"title":"min_rd – yaeos","text":"public elemental function min_rd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"proc/min_rd.html"},{"title":"ne_dd – yaeos","text":"public  function ne_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/ne_dd.html"},{"title":"ne_di – yaeos","text":"public  function ne_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical","tags":"","url":"proc/ne_di.html"},{"title":"ne_dr – yaeos","text":"public  function ne_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical","tags":"","url":"proc/ne_dr.html"},{"title":"ne_id – yaeos","text":"public  function ne_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/ne_id.html"},{"title":"ne_rd – yaeos","text":"public  function ne_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"proc/ne_rd.html"},{"title":"nintHyperDual – yaeos","text":"public elemental function nintHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer","tags":"","url":"proc/ninthyperdual.html"},{"title":"realHyperDual – yaeos","text":"public elemental function realHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr)","tags":"","url":"proc/realhyperdual.html"},{"title":"sign_dd – yaeos","text":"public elemental function sign_dd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ssign","tags":"","url":"proc/sign_dd.html"},{"title":"sign_dr – yaeos","text":"public elemental function sign_dr(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ssign","tags":"","url":"proc/sign_dr.html"},{"title":"sign_rd – yaeos","text":"public elemental function sign_rd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ssign","tags":"","url":"proc/sign_rd.html"},{"title":"sinHyperDual – yaeos","text":"public elemental function sinHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx real(kind=pr), public :: f","tags":"","url":"proc/sinhyperdual.html"},{"title":"sinhHyperDual – yaeos","text":"public elemental function sinhHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: t1 type( hyperdual ), public :: t2","tags":"","url":"proc/sinhhyperdual.html"},{"title":"sqrtHyperDual – yaeos","text":"public elemental function sqrtHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public, parameter :: expo = 3.0_pr/2.0_pr real(kind=pr), public :: square","tags":"","url":"proc/sqrthyperdual.html"},{"title":"tanHyperDual – yaeos","text":"public elemental function tanHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx real(kind=pr), public :: f","tags":"","url":"proc/tanhyperdual.html"},{"title":"tanhHyperDual – yaeos","text":"public elemental function tanhHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: t1 type( hyperdual ), public :: t2","tags":"","url":"proc/tanhhyperdual.html"},{"title":"EqualHyperDualHyperDual – yaeos","text":"public elemental subroutine EqualHyperDualHyperDual(res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp","tags":"","url":"proc/equalhyperdualhyperdual.html"},{"title":"EqualHyperDualReal – yaeos","text":"public elemental subroutine EqualHyperDualReal(res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp","tags":"","url":"proc/equalhyperdualreal.html"},{"title":"abs – yaeos","text":"public interface abs Module Procedures public elemental function absHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/abs.html"},{"title":"acos – yaeos","text":"public interface acos Module Procedures public elemental function acosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/acos.html"},{"title":"asin – yaeos","text":"public interface asin Module Procedures public elemental function asinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/asin.html"},{"title":"assignment (=) – yaeos","text":"public interface assignment (=) Module Procedures public elemental subroutine EqualHyperDualHyperDual (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp public elemental subroutine EqualHyperDualReal (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp","tags":"","url":"interface/assignment (=).html"},{"title":"atan – yaeos","text":"public interface atan Module Procedures public elemental function atanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/atan.html"},{"title":"atan2 – yaeos","text":"public interface atan2 Module Procedures public elemental function atan2HyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"interface/atan2.html"},{"title":"cos – yaeos","text":"public interface cos Module Procedures public elemental function cosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/cos.html"},{"title":"cosh – yaeos","text":"public interface cosh Module Procedures public elemental function coshHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/cosh.html"},{"title":"exp – yaeos","text":"public interface exp Module Procedures public elemental function expHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/exp.html"},{"title":"int – yaeos","text":"public interface int Module Procedures public elemental function intHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer","tags":"","url":"interface/int.html"},{"title":"log – yaeos","text":"public interface log Module Procedures public elemental function logHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/log.html"},{"title":"log10 – yaeos","text":"public interface log10 Module Procedures public elemental function log10HyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/log10.html"},{"title":"max – yaeos","text":"public interface max Module Procedures public elemental function max_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_ddd (v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual ) public elemental function max_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"interface/max.html"},{"title":"min – yaeos","text":"public interface min Module Procedures public elemental function min_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"interface/min.html"},{"title":"nint – yaeos","text":"public interface nint Module Procedures public elemental function nintHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer","tags":"","url":"interface/nint.html"},{"title":"operator (*) – yaeos","text":"public interface operator (*) Module Procedures public elemental function MultiplyHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyIntHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"interface/operator (ASTERISK).html"},{"title":"operator (**) – yaeos","text":"public interface operator (**) Module Procedures public elemental function PowerHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"interface/operator (ASTERISKASTERISK).html"},{"title":"operator (+) – yaeos","text":"public interface operator (+) Module Procedures public elemental function PlusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/operator (+).html"},{"title":"operator (+) – yaeos","text":"public interface operator (+) Module Procedures public elemental function AddHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"interface/operator (+)~2.html"},{"title":"operator (-) – yaeos","text":"public interface operator (-) Module Procedures public elemental function MinusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/operator (-).html"},{"title":"operator (-) – yaeos","text":"public interface operator (-) Module Procedures public elemental function SubtractHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"interface/operator (-)~2.html"},{"title":"operator (.eq.) – yaeos","text":"public interface operator (.eq.) Module Procedures public  function eq_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function eq_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public elemental function eq_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function eq_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function eq_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator (.eq.).html"},{"title":"operator (.ge.) – yaeos","text":"public interface operator (.ge.) Module Procedures public  function ge_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ge_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ge_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator (.ge.).html"},{"title":"operator (.gt.) – yaeos","text":"public interface operator (.gt.) Module Procedures public  function gt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function gt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function gt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator (.gt.).html"},{"title":"operator (.le.) – yaeos","text":"public interface operator (.le.) Module Procedures public  function le_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function le_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function le_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator (.le.).html"},{"title":"operator (.lt.) – yaeos","text":"public interface operator (.lt.) Module Procedures public  function lt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function lt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function lt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator (.lt.).html"},{"title":"operator (.ne.) – yaeos","text":"public interface operator (.ne.) Module Procedures public  function ne_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ne_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ne_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator (.ne.).html"},{"title":"operator (/) – yaeos","text":"public interface operator (/) Module Procedures public elemental function DivideHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"interface/operator (SLASH).html"},{"title":"real – yaeos","text":"public interface real Module Procedures public elemental function realHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr)","tags":"","url":"interface/real.html"},{"title":"sign – yaeos","text":"public interface sign Module Procedures public elemental function sign_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","url":"interface/sign.html"},{"title":"sin – yaeos","text":"public interface sin Module Procedures public elemental function sinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/sin.html"},{"title":"sinh – yaeos","text":"public interface sinh Module Procedures public elemental function sinhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/sinh.html"},{"title":"sqrt – yaeos","text":"public interface sqrt Module Procedures public elemental function sqrtHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/sqrt.html"},{"title":"sum – yaeos","text":"public interface sum Module Procedures public pure function SumHyperDual (v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) public pure function SumHyperDual2 (v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ), allocatable, (:)","tags":"","url":"interface/sum.html"},{"title":"tan – yaeos","text":"public interface tan Module Procedures public elemental function tanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/tan.html"},{"title":"tanh – yaeos","text":"public interface tanh Module Procedures public elemental function tanhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","url":"interface/tanh.html"},{"title":"setup_dortmund – yaeos","text":"public  function setup_dortmund(molecules, parameters) Uses yaeos__models_ge_group_contribution_unifac_parameters Arguments Type Intent Optional Attributes Name type( Groups ), intent(in) :: molecules (:) type( GeGCModelParameters ), intent(in), optional :: parameters Return Value type( UNIFAC ) Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: Aij (:,:) real(kind=pr), public, allocatable :: Bij (:,:) real(kind=pr), public, allocatable :: Cij (:,:) integer, public :: i integer, public :: j integer, public :: ng type( GeGCModelParameters ), public :: params type( QuadraticPsi ), public :: psi_function type( Groups ), public :: soup","tags":"","url":"proc/setup_dortmund.html"},{"title":"flash – yaeos","text":"public  function flash(model, z, t, v_spec, p_spec, k0, iters) Uses yaeos__auxiliar Flash algorithm using sucessive substitutions. Available specifications: TP (with T and P_spec variables) TV (with T and V_spec variables) This algorithm assumes that the specified T and P/V correspond to\nvapor-liquid separation predicted by the provided model (0<beta<1) and\nsolves the equilibria and mass-balance equations with a fixed-point\nmethod. Arguments Type Intent Optional Attributes Name class( BaseModel ), intent(in) :: model Thermodynamic model real(kind=pr), intent(in) :: z (:) Global composition (molar fractions) real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in), optional :: v_spec Specified Volume [L/mol] real(kind=pr), intent(in), optional :: p_spec Specified Pressure [bar] real(kind=pr), intent(in), optional :: k0 (:) Initial K factors (y/x) integer, intent(out), optional :: iters Number of iterations Return Value type( EquilibriumState ) Variables Type Visibility Attributes Name Initial real(kind=pr), public, dimension(size(z)) :: K real(kind=pr), public :: P real(kind=pr), public :: V real(kind=pr), public :: Vx real(kind=pr), public :: Vy real(kind=pr), public :: beta real(kind=pr), public :: bmax real(kind=pr), public :: bmin real(kind=pr), public, dimension(size(z)) :: dK real(kind=pr), public, dimension(size(z)) :: dKold real(kind=pr), public :: g0 real(kind=pr), public :: g1 real(kind=pr), public, dimension(size(z)) :: lnK real(kind=pr), public, dimension(size(z)) :: lnKold real(kind=pr), public, dimension(size(z)) :: lnfug_x real(kind=pr), public, dimension(size(z)) :: lnfug_y character(len=2), public :: spec Flash specification [PT | VT] real(kind=pr), public, dimension(size(z)) :: x real(kind=pr), public, dimension(size(z)) :: y","tags":"","url":"proc/flash.html"},{"title":"excess_gibbs – yaeos","text":"public  subroutine excess_gibbs(self, n, t, Ge, GeT, GeT2, Gen, GeTn, Gen2) Type Bound GeModelAdiff Arguments Type Intent Optional Attributes Name class( GeModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ge real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Gen real(kind=pr), intent(out), optional, dimension(size(n)) :: GeTn real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) Variables Type Visibility Attributes Name Initial logical, public :: any_deriv real(kind=pr), public :: dGe (size(n)+1,size(n)+1) type( hyperdual ), public :: d_Ge type( hyperdual ), public :: d_n (size(n)) type( hyperdual ), public :: d_t integer, public :: nc Subroutines subroutine get_dgedn () Arguments None subroutine get_dgedn2 () Arguments None subroutine get_dgedt () Arguments None subroutine get_dgedt2 () Arguments None subroutine get_dgedtn () Arguments None subroutine reset_vars () Arguments None","tags":"","url":"proc/excess_gibbs~4.html"},{"title":"write_EquilibriumState – yaeos","text":"public  subroutine write_EquilibriumState(eq, unit, iotype, v_list, iostat, iomsg) Type Bound EquilibriumState Arguments Type Intent Optional Attributes Name class( EquilibriumState ), intent(in) :: eq integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: nl = new_line(\"G\")","tags":"","url":"proc/write_equilibriumstate.html"},{"title":"Bmix – yaeos","text":"public  subroutine Bmix(self, n, bi, B, dBi, dBij) Mixture repulsive parameter. Calculate the mixture’s repulsive parameter and it’s derivatives\nwith respect to composition: Type Bound QMR Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector. real(kind=pr), intent(in) :: bi (:) Pure components repulsive parameters. real(kind=pr), intent(out) :: B Mixture repulsive parameter. real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:)","tags":"","url":"proc/bmix.html"},{"title":"Dmix – yaeos","text":"public  subroutine Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Attractive parameter mixing rule with quadratic mix. Takes the all the pure components attractive parameters and their\nderivatives with respect to temperature and mix them with the\nVan der Waals quadratic mixing rule: Inside the routine the matrix is calculated using the\nprocedure contained in the QMR object, this procedures defaults\nto the common combining rule: The procedure can be overloaded by a common one that respects the\ninterface get_aij type ( QMR ) :: my_mixing_rule my_mixing_rule % aij => new_aij_procedure Type Bound QMR Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: ai (:) Pure components attractive parameters real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D Mixture attractive parameter real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aij (size(ai),size(ai)) real(kind=pr), public :: aux real(kind=pr), public :: aux2 real(kind=pr), public :: daijdt (size(ai),size(ai)) real(kind=pr), public :: daijdt2 (size(ai),size(ai)) integer, public :: i integer, public :: j integer, public :: nc","tags":"","url":"proc/dmix.html"},{"title":"RKPR_D1mix – yaeos","text":"public  subroutine RKPR_D1mix(self, n, d1i, D1, dD1i, dD1ij) Uses yaeos__models_ar_cubic_mixing_base RKPR parameter mixing rule. The RKPR EoS doesn’t have a constant value for each\ncomponent, so a proper mixing rule should be provided. A linear\ncombination is used. Type Bound QMR Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:)","tags":"","url":"proc/rkpr_d1mix.html"},{"title":"kij_constant – yaeos","text":"public  subroutine kij_constant(self, T, a, dadt, dadt2, aij, daijdt, daijdt2) Combining rule that uses constant values. [\n a_{ij} = \\sqrt{a_i a_j} (1 - k_{ij})\n] Type Bound QMR Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: a (:) Pure components attractive parameters (\\a_i) real(kind=pr), intent(in) :: dadt (:) real(kind=pr), intent(in) :: dadt2 (:) real(kind=pr), intent(out) :: aij (:,:) Matrix real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:) Variables Type Visibility Attributes Name Initial integer, public :: i real(kind=pr), public :: inner_sum integer, public :: j real(kind=pr), public :: sqrt_aii_ajj","tags":"","url":"proc/kij_constant.html"},{"title":"kij_exp_tdep – yaeos","text":"public  subroutine kij_exp_tdep(self, T, a, dadt, dadt2, aij, daijdt, daijdt2) Uses hyperdual_mod kij_exp_tdep Combining rule that uses temperature dependant values.\nWith the following expression: [\n a_{ij} = \\sqrt{a_i a_j} (1 - k_{ij})\n] Type Bound QMRTD Arguments Type Intent Optional Attributes Name class( QMRTD ), intent(in) :: self real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: a (:) Pure components attractive parameters (\\a_i) real(kind=pr), intent(in) :: dadt (:) real(kind=pr), intent(in) :: dadt2 (:) real(kind=pr), intent(out) :: aij (:,:) Matrix real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:) Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: T_hd real(kind=pr), public :: Tstar (size(a),size(a)) type( hyperdual ), public :: a_hd (size(a)) type( hyperdual ), public :: aij_hd (size(a),size(a)) integer, public :: i integer, public :: j real(kind=pr), public :: k0 (size(a),size(a)) type( hyperdual ), public :: kij_hd (size(a),size(a)) real(kind=pr), public :: kinf (size(a),size(a)) integer, public :: nc","tags":"","url":"proc/kij_exp_tdep.html"},{"title":"saturation_F – yaeos","text":"public  subroutine saturation_F(model, z, X, ns, S, F, dF, dPdVz, dPdVy) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr) :: z (size(model)) real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out), optional :: dF (:,:) real(kind=pr), intent(out) :: dPdVz real(kind=pr), intent(out) :: dPdVy Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Py real(kind=pr), public :: Pz real(kind=pr), public :: T real(kind=pr), public :: Vy real(kind=pr), public :: Vz real(kind=pr), public :: dPdTy real(kind=pr), public :: dPdTz real(kind=pr), public :: dPdn_y (size(z)) real(kind=pr), public :: dPdn_z (size(z)) real(kind=pr), public :: dlnfug_dP_y (size(model)) real(kind=pr), public :: dlnfug_dP_z (size(model)) real(kind=pr), public :: dlnfug_dT_y (size(model)) real(kind=pr), public :: dlnfug_dT_z (size(model)) real(kind=pr), public :: dlnfug_dV_y (size(model)) real(kind=pr), public :: dlnfug_dV_z (size(model)) real(kind=pr), public :: dlnfug_dn_y (size(model),size(model)) real(kind=pr), public :: dlnfug_dn_z (size(model),size(model)) integer, public :: j real(kind=pr), public :: lnPspec real(kind=pr), public :: lnfug_y (size(model)) real(kind=pr), public :: lnfug_z (size(model)) integer, public :: nc real(kind=pr), public :: y (size(z))","tags":"","url":"proc/saturation_f.html"},{"title":"saturation_TP – yaeos","text":"public  subroutine saturation_TP(model, kind, z, X, ns, S, F, dF, dFdS) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model character(len=*), intent(in) :: kind real(kind=pr), intent(in) :: z (size(model)) real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out) :: dF (:,:) real(kind=pr), intent(out) :: dFdS (:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: K (size(X)-2) real(kind=pr), public :: P real(kind=pr), public :: T real(kind=pr), public :: Vy real(kind=pr), public :: Vz real(kind=pr), public :: dlnphi_dn_y (size(X)-2,size(X)-2) real(kind=pr), public :: dlnphi_dn_z (size(X)-2,size(X)-2) real(kind=pr), public :: dlnphi_dp_y (size(X)-2) real(kind=pr), public :: dlnphi_dp_z (size(X)-2) real(kind=pr), public :: dlnphi_dt_y (size(X)-2) real(kind=pr), public :: dlnphi_dt_z (size(X)-2) integer, public :: i integer, public :: j character(len=14), public :: kind_y character(len=14), public :: kind_z real(kind=pr), public :: lnPhi_y (size(X)-2) real(kind=pr), public :: lnPhi_z (size(X)-2) integer, public :: nc real(kind=pr), public :: y (size(X)-2)","tags":"","url":"proc/saturation_tp.html"},{"title":"solve_TP – yaeos","text":"public  subroutine solve_TP(model, kind, z, X, ns, S, tol, max_iterations, its) Uses yaeos__math Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model character(len=*), intent(in) :: kind real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(inout) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(in) :: tol integer, intent(in) :: max_iterations integer, intent(out) :: its Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F (size(X)) real(kind=pr), public :: dF (size(X),size(X)) real(kind=pr), public :: dFdS (size(X)) real(kind=pr), public :: dx (size(X)) integer, public :: nc","tags":"","url":"proc/solve_tp.html"},{"title":"solve_VxVyT – yaeos","text":"public  subroutine solve_VxVyT(model, z, X, ns, S, tol, max_iterations, its) Uses yaeos__math Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(inout) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(in) :: tol integer, intent(in) :: max_iterations integer, intent(out) :: its Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F (size(X)) real(kind=pr), public :: Xold (size(X)) real(kind=pr), public :: dF (size(X),size(X)) real(kind=pr), public :: dFdS (size(X)) real(kind=pr), public :: dPdVy real(kind=pr), public :: dPdVz real(kind=pr), public :: dx (size(X)) real(kind=pr), public :: dx_old (size(x)) integer, public :: nc","tags":"","url":"proc/solve_vxvyt.html"},{"title":"get_original_parameters – yaeos","text":"public  subroutine get_original_parameters(ids, pures, binaries, components) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ids (:) type( Gerg2008Pure ), intent(out) :: pures (:) type( Gerg2008Binary ), intent(out) :: binaries (:,:) type( Substances ), intent(out) :: components Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Pc (size(ids)) real(kind=pr), public :: Tc (size(ids)) real(kind=pr), public :: Vc (size(ids)) integer, public :: i integer, public :: ikexp integer, public :: ikpol integer, public :: j integer, public :: nc real(kind=pr), public :: w (size(ids))","tags":"","url":"proc/get_original_parameters.html"},{"title":"original_parameters – yaeos","text":"public  subroutine original_parameters() Parameter table of the original GERG 2008 model Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k","tags":"","url":"proc/original_parameters.html"},{"title":"init_mhv – yaeos","text":"private  function init_mhv(Ge, b, q, lij) result(mixrule) Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: Ge real(kind=pr), intent(in) :: b (:) real(kind=pr), intent(in) :: q real(kind=pr), intent(in), optional :: lij (:,:) Return Value type( MHV ) Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: nc","tags":"","url":"proc/init_mhv.html"},{"title":"DmixMHV – yaeos","text":"public  subroutine DmixMHV(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Uses hyperdual_mod Michelsen Modified Huron-Vidal mixing rule. Mixing rule at infinite pressure as defined in the book of Michelsen and\nMøllerup. Description At the infinite pressure limit of a cubic equation of state it is possible to\nrelate teh mixing rule for the attractive term with a excess Gibbs energy\nmodel like NRTL with the expression: Examples type ( CubicEoS ) References Autodiff injection until we can decipher this derivative Type Bound MHV Arguments Type Intent Optional Attributes Name class( MHV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Ge real(kind=pr), private :: GeT real(kind=pr), private :: GeT2 real(kind=pr), private :: GeTn (size(n)) real(kind=pr), private :: Gen (size(n)) real(kind=pr), private :: Gen2 (size(n),size(n)) real(kind=pr), private :: b real(kind=pr), private :: bi (size(n)) real(kind=pr), private :: d2logBi_nbi (size(n),size(n)) real(kind=pr), private :: dbi (size(n)) real(kind=pr), private :: dbij (size(n),size(n)) real(kind=pr), private :: dlogBi_nbi (size(n)) real(kind=pr), private :: dot_n_logB_nbi real(kind=pr), private :: f real(kind=pr), private :: fdi (size(n)) real(kind=pr), private :: fdij (size(n),size(n)) real(kind=pr), private :: fdit (size(n)) real(kind=pr), private :: fdt real(kind=pr), private :: fdt2 integer, private :: i integer, private :: j integer, private :: l real(kind=pr), private :: logB_nbi (size(n)) integer, private :: nc real(kind=pr), private :: q real(kind=pr), private :: totn Total number of moles","tags":"","url":"proc/dmixmhv.html"},{"title":"BmixHV – yaeos","text":"private  subroutine BmixHV(self, n, bi, B, dBi, dBij) Uses yaeos__models_ar_cubic_mixing_base Repulsive parameter mixing rule Quadratinc mixing rule for the repulsive parameter. Description Type Bound HV Arguments Type Intent Optional Attributes Name class( HV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:)","tags":"","url":"proc/bmixhv.html"},{"title":"BmixMHV – yaeos","text":"private  subroutine BmixMHV(self, n, bi, B, dBi, dBij) Uses yaeos__models_ar_cubic_mixing_base Repulsive parameter mixing rule Quadratinc mixing rule for the repulsive parameter, using as a combining rule. Description Michelsen’s modified Huron-Vidal mixing rule assumes a linear mix of\nthe repulsive parameter. In this implementation the most known crossed combining rule is used: to provide versatility to the used model. Warning This mixing rule is intended to use only with a linear combining\nrule, using could negatively affect the thermodynamic\nconsistency of the model. Examples A basic code example References Type Bound MHV Arguments Type Intent Optional Attributes Name class( MHV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:)","tags":"","url":"proc/bmixmhv.html"},{"title":"D1MixHV – yaeos","text":"private  subroutine D1MixHV(self, n, d1i, D1, dD1i, dD1ij) Uses yaeos__models_ar_cubic_mixing_base Type Bound HV Arguments Type Intent Optional Attributes Name class( HV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:)","tags":"","url":"proc/d1mixhv.html"},{"title":"D1MixMHV – yaeos","text":"private  subroutine D1MixMHV(self, n, d1i, D1, dD1i, dD1ij) Uses yaeos__models_ar_cubic_mixing_base Type Bound MHV Arguments Type Intent Optional Attributes Name class( MHV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:)","tags":"","url":"proc/d1mixmhv.html"},{"title":"DmixHV – yaeos","text":"private  subroutine DmixHV(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Uses yaeos__models_ar_cubic_mixing_base Type Bound HV Arguments Type Intent Optional Attributes Name class( HV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Ge real(kind=pr), private :: GeT real(kind=pr), private :: GeT2 real(kind=pr), private :: GeTn (size(n)) real(kind=pr), private :: Gen (size(n)) real(kind=pr), private :: Gen2 (size(n),size(n)) real(kind=pr), private :: L real(kind=pr), private :: b real(kind=pr), private :: bi (size(n)) real(kind=pr), private :: d1 real(kind=pr), private :: d1i (size(n)) real(kind=pr), private :: dL (size(n)) real(kind=pr), private :: dL2 (size(n),size(n)) real(kind=pr), private :: dbi (size(n)) real(kind=pr), private :: dbij (size(n),size(n)) real(kind=pr), private :: dd1i (size(n)) real(kind=pr), private :: dd1ij (size(n),size(n)) real(kind=pr), private :: del1 (size(n)) real(kind=pr), private :: del2 (size(n)) real(kind=pr), private :: f real(kind=pr), private :: fdi (size(n)) real(kind=pr), private :: fdij (size(n),size(n)) real(kind=pr), private :: fdit (size(n)) real(kind=pr), private :: fdt real(kind=pr), private :: fdt2 integer, private :: i integer, private :: j integer, private :: nc real(kind=pr), private :: totn Total number of moles","tags":"","url":"proc/dmixhv.html"},{"title":"MHV – yaeos","text":"public interface MHV Module Procedures private  function init_mhv (Ge, b, q, lij) result(mixrule) Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: Ge real(kind=pr), intent(in) :: b (:) real(kind=pr), intent(in) :: q real(kind=pr), intent(in), optional :: lij (:,:) Return Value type( MHV )","tags":"","url":"interface/mhv.html"},{"title":"get_z – yaeos","text":"public  subroutine get_z(alpha, z_0, z_inj, z, dzda) Calculate the fluid composition based on an amount of addition\nof second fluid. The injection can be considered as two kinds of injection:\n- Displacement: - Addition: Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: alpha Addition percentaje real(kind=pr), intent(in) :: z_0 (:) real(kind=pr), intent(in) :: z_inj (:) real(kind=pr), intent(out) :: z (size(z_0)) New composition real(kind=pr), intent(out), optional :: dzda (size(z_0)) Derivative wrt","tags":"","url":"proc/get_z.html"},{"title":"cubic_v0 – yaeos","text":"public  function cubic_v0(z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dbi (nc) real(kind=pr), public :: dbij (nc,nc)","tags":"","url":"proc/cubic_v0.html"},{"title":"ArVnder – yaeos","text":"public  subroutine ArVnder(nc, nder, ntemp, z, V, T, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: nder integer, intent(in) :: ntemp real(kind=pr), intent(in) :: z (nc) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z))","tags":"","url":"proc/arvnder.html"},{"title":"Bnder – yaeos","text":"public  subroutine Bnder(nc, rn, Bmix, dBi, dBij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: Bmix real(kind=pr), intent(out) :: dBi (nc) real(kind=pr), intent(out) :: dBij (nc,nc) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aux (nc) integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","url":"proc/bnder.html"},{"title":"DELTAnder – yaeos","text":"public  subroutine DELTAnder(nc, rn, D1m, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D1m real(kind=pr), intent(out) :: dD1i (nc) real(kind=pr), intent(out) :: dD1ij (nc,nc) Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","url":"proc/deltander.html"},{"title":"DandTnder – yaeos","text":"public  subroutine DandTnder(ntd, nc, T, rn, D, dDi, dDiT, dDij, dDdT, dDdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDi (nc) real(kind=pr), intent(out) :: dDiT (nc) real(kind=pr), intent(out) :: dDij (nc,nc) real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aij (nc,nc) real(kind=pr), public :: aux real(kind=pr), public :: aux2 real(kind=pr), public :: daijdT (nc,nc) real(kind=pr), public :: daijdT2 (nc,nc) integer, public :: i integer, public :: j","tags":"","url":"proc/dandtnder.html"},{"title":"HelmRKPR – yaeos","text":"public  subroutine HelmRKPR(nco, NDE, NTD, rn, V, T, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Calculate the reduced residual Helmholtz Energy and it’s derivatives with the RKPR EOS Arguments Type Intent Optional Attributes Name integer, intent(in) :: nco integer, intent(in) :: NDE integer, intent(in) :: NTD real(kind=pr), intent(in) :: rn (nco) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out) :: Arn (nco) real(kind=pr), intent(out) :: ArVn (nco) real(kind=pr), intent(out) :: ArTn (nco) real(kind=pr), intent(out) :: Arn2 (nco,nco) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AUX real(kind=pr), public :: ArT real(kind=pr), public :: ArTT real(kind=pr), public :: Bmix real(kind=pr), public :: D real(kind=pr), public :: D1 real(kind=pr), public :: D2 real(kind=pr), public :: FFB real(kind=pr), public :: FFBB real(kind=pr), public :: FFBV real(kind=pr), public :: auxD2 real(kind=pr), public :: dBi (nco) real(kind=pr), public :: dBij (nco,nco) real(kind=pr), public :: dD1i (nco) real(kind=pr), public :: dD1ij (nco,nco) real(kind=pr), public :: dDdT real(kind=pr), public :: dDdT2 real(kind=pr), public :: dDi (nco) real(kind=pr), public :: dDiT (nco) real(kind=pr), public :: dDij (nco,nco) real(kind=pr), public :: f real(kind=pr), public :: fB real(kind=pr), public :: fBD1 real(kind=pr), public :: fD1 real(kind=pr), public :: fD1D1 real(kind=pr), public :: fVD1 real(kind=pr), public :: fv real(kind=pr), public :: fv2 real(kind=pr), public :: g real(kind=pr), public :: gv real(kind=pr), public :: gv2 integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","url":"proc/helmrkpr.html"},{"title":"HelmSRKPR – yaeos","text":"public  subroutine HelmSRKPR(nc, nd, nt, rn, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components integer, intent(in) :: nd Compositional derivatives integer, intent(in) :: nt Temperature derivatives real(kind=pr), intent(in) :: rn (nc) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (nc) dAr/dn real(kind=pr), intent(out) :: ArVn (nc) dAr2/dVn real(kind=pr), intent(out) :: ArTn (nc) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (nc,nc) dAr2/dn2 Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AUX real(kind=pr), public :: ArT real(kind=pr), public :: ArTT real(kind=pr), public :: Bmix real(kind=pr), public :: D real(kind=pr), public :: FFB real(kind=pr), public :: FFBB real(kind=pr), public :: FFBV real(kind=pr), public :: a real(kind=pr), public :: b_v real(kind=pr), public :: d1 real(kind=pr), public :: d2 real(kind=pr), public :: dBi (nc) real(kind=pr), public :: dBij (nc,nc) real(kind=pr), public :: dDdT real(kind=pr), public :: dDdT2 real(kind=pr), public :: dDi (nc) real(kind=pr), public :: dDiT (nc) real(kind=pr), public :: dDij (nc,nc) real(kind=pr), public :: f real(kind=pr), public :: fB real(kind=pr), public :: fv real(kind=pr), public :: fv2 real(kind=pr), public :: g real(kind=pr), public :: gv real(kind=pr), public :: gv2 integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","url":"proc/helmsrkpr.html"},{"title":"PR76_factory – yaeos","text":"public  subroutine PR76_factory(moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) PengRobinson 76 factory Takes either the critical parameters or the fitted model parameters\nand gets ones in base of the others Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: RTc (nc) real(kind=pr), public :: al real(kind=pr), public :: be logical, public :: critical_spec real(kind=pr), public :: ga (nc) integer, public :: i real(kind=pr), public :: oma (nc) real(kind=pr), public :: omb (nc) logical, public :: params_spec real(kind=pr), public :: vceos (nc) real(kind=pr), public :: zc (nc)","tags":"","url":"proc/pr76_factory.html"},{"title":"PR78_factory – yaeos","text":"public  subroutine PR78_factory(moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) PengRobinson 78 factory Takes either the critical parameters or the fitted model parameters\nand gets ones in base of the others Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: RTc (nc) real(kind=pr), public :: al real(kind=pr), public :: be logical, public :: critical_spec real(kind=pr), public :: ga (nc) integer, public :: i real(kind=pr), public :: oma (nc) real(kind=pr), public :: omb (nc) logical, public :: params_spec real(kind=pr), public :: vceos (nc) real(kind=pr), public :: zc (nc)","tags":"","url":"proc/pr78_factory.html"},{"title":"SRK_factory – yaeos","text":"public  subroutine SRK_factory(moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) SoaveRedlichKwong factory Takes either the critical parameters or the fitted model parameters\nand gets ones in base of the others Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: RTc (nc) real(kind=pr), public :: al real(kind=pr), public :: be logical, public :: critical_spec real(kind=pr), public :: ga (nc) integer, public :: i integer, public :: j real(kind=pr), public :: oma (nc) real(kind=pr), public :: omb (nc) logical, public :: params_spec real(kind=pr), public :: vceos (nc) real(kind=pr), public :: zc (nc)","tags":"","url":"proc/srk_factory.html"},{"title":"aTder – yaeos","text":"public  subroutine aTder(ac, Tc, k, T, a, dadT, dadT2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: ac real(kind=pr), intent(in) :: Tc real(kind=pr), intent(in) :: k real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: a real(kind=pr), intent(out) :: dadT real(kind=pr), intent(out) :: dadT2 Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Tr","tags":"","url":"proc/atder.html"},{"title":"aijTder – yaeos","text":"public  subroutine aijTder(ntd, nc, T, aij, daijdT, daijdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: aij (nc,nc) real(kind=pr), intent(out) :: daijdT (nc,nc) real(kind=pr), intent(out) :: daijdT2 (nc,nc) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ai (nc) real(kind=pr), public :: aux (nc,nc) real(kind=pr), public :: daidT (nc) real(kind=pr), public :: daidT2 (nc) integer, public :: i integer, public :: j real(kind=pr), public :: ratK (nc,nc)","tags":"","url":"proc/aijtder.html"},{"title":"ar_rkpr – yaeos","text":"public  subroutine ar_rkpr(z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (size(z)) dAr/dn real(kind=pr), intent(out) :: ArVn (size(z)) dAr2/dVn real(kind=pr), intent(out) :: ArTn (size(z)) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) dAr2/dn2 Variables Type Visibility Attributes Name Initial integer, public :: nd Compositional derivatives integer, public :: nt Temperature derivatives","tags":"","url":"proc/ar_rkpr.html"},{"title":"ar_srkpr – yaeos","text":"public  subroutine ar_srkpr(z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Wrapper subroutine to the SRK/PR Residula Helmholtz function to\nuse the general interface Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (size(z)) dAr/dn real(kind=pr), intent(out) :: ArVn (size(z)) dAr2/dVn real(kind=pr), intent(out) :: ArTn (size(z)) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) dAr2/dn2 Variables Type Visibility Attributes Name Initial integer, public :: nd Compositional derivatives integer, public :: nt Temperature derivatives","tags":"","url":"proc/ar_srkpr.html"},{"title":"get_Zc_OMa_OMb – yaeos","text":"public  subroutine get_Zc_OMa_OMb(del1, Zc, OMa, OMb) Calculate Zc, OMa and OMb from the delta_1 parameter. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: del1 (:) delta_1 parameter real(kind=pr), intent(out) :: Zc (:) Critical compressibility factor real(kind=pr), intent(out) :: OMa (:) OMa real(kind=pr), intent(out) :: OMb (:) OMb Variables Type Visibility Attributes Name Initial real(kind=pr), public :: d1 (size(del1)) real(kind=pr), public :: y (size(del1))","tags":"","url":"proc/get_zc_oma_omb.html"},{"title":"setup – yaeos","text":"public  subroutine setup(n, nmodel, ntdep, ncomb) Setup the basics variables that describe the model. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Number of components integer, intent(in) :: nmodel Number of model integer, intent(in) :: ntdep Kij dependant of temperature integer, intent(in) :: ncomb Combining rule","tags":"","url":"proc/setup.html"},{"title":"PUREFUG_CALC – yaeos","text":"public  subroutine PUREFUG_CALC(nc, icomp, T, P, V, phi) Fugacity of a pure component Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: icomp real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: V real(kind=pr), intent(out) :: phi Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ar real(kind=pr), public :: ArTV real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArV2 real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: Arv real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: philog real(kind=pr), public :: rn (nc)","tags":"","url":"proc/purefug_calc.html"},{"title":"TERMO – yaeos","text":"public  subroutine TERMO(nc, mtyp, indic, t, p, rn, v, PHILOG, DLPHIP, DLPHIT, FUGN) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components integer, intent(in) :: mtyp Type of root desired (-1 vapor, 1 liquid, 0 lower Gr) integer, intent(in) :: indic Desired element, this should be setted with optionals real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: rn (nc) Mixture mole numbers real(kind=pr), intent(out) :: v Volume [L] real(kind=pr), intent(out) :: PHILOG (nc) ln(phi*p) vector real(kind=pr), intent(out), optional :: DLPHIP (nc) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: DLPHIT (nc) ln(phi) Temp derivative real(kind=pr), intent(out), optional :: FUGN (nc,nc) ln(phi) compositional derivative Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: DPDN (nc) real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: ar real(kind=pr), public :: artv real(kind=pr), public :: arv real(kind=pr), public :: arv2 real(kind=pr), public :: dpdt real(kind=pr), public :: dpv integer, public :: i integer, public :: igz integer, public :: k integer, public :: nder integer, public :: ntemp real(kind=pr), public :: totn","tags":"","url":"proc/termo.html"},{"title":"VCALC – yaeos","text":"public recursive subroutine VCALC(ITYP, nc, ntemp, rn, T, P, V) ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP TYPE OF ROOT DESIRED (-1 vapor, 1 liquid, 0 lower Gibbs energy phase) integer, intent(in) :: nc NO. OF COMPONENTS integer, intent(in) :: ntemp 1 if T-derivatives are required real(kind=pr), intent(in) :: rn (nc) FEED MOELS real(kind=pr), intent(in) :: T TEMPERATURE real(kind=pr), intent(in) :: P PRESURE real(kind=pr), intent(out) :: V VOLUME Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AT real(kind=pr), public :: AVAP real(kind=pr), public :: Ar real(kind=pr), public :: ArTV real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArV real(kind=pr), public :: ArV2 real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: B real(kind=pr), public :: CPV logical, public :: FIRST_RUN real(kind=pr), public :: S3R real(kind=pr), public :: VVAP real(kind=pr), public :: ZETA real(kind=pr), public :: ZETMAX real(kind=pr), public :: ZETMIN real(kind=pr), public :: del real(kind=pr), public :: der integer, public :: iter integer, public :: nder real(kind=pr), public :: pcalc real(kind=pr), public :: totn","tags":"","url":"proc/vcalc.html"},{"title":"zTVTERMO – yaeos","text":"public  subroutine zTVTERMO(nc, indic, t, rn, v, p, dpv, PHILOG, DLPHIP, DLPHIT, FUGN) Calculation of lnphi P and derivatives\n rn        mixture mole numbers                       (input)\n t         temperature (k)                            (input)\n v         volume      (L)                            (input)\n p         pressure    (bar)                          (output)\n PHILOG    vector of ln(phi(i) P)                     (output)  0 < INDIC < 5\n DLPHIT    t-derivative of ln(phi(i)) (const P, n)    (output)  0 < INDIC = 2 or 4\n DLPHIP    P-derivative of ln(phi(i)) (const T, n)    (output)  0 < INDIC < 5\n FUGN      comp-derivative of ln(phi(i)) (const t & P)(output)  2 < INDIC Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: indic real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: v real(kind=pr), intent(out) :: p real(kind=pr), intent(out) :: dpv real(kind=pr), intent(out) :: PHILOG (nc) real(kind=pr), intent(out) :: DLPHIP (nc) real(kind=pr), intent(out) :: DLPHIT (nc) real(kind=pr), intent(out) :: FUGN (nc,nc) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: DPDN (nc) real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: ar real(kind=pr), public :: artv real(kind=pr), public :: arv real(kind=pr), public :: arv2 real(kind=pr), public :: dpdt integer, public :: i integer, public :: igz integer, public :: k integer, public :: nder integer, public :: ntemp real(kind=pr), public :: totn","tags":"","url":"proc/ztvtermo.html"},{"title":"setup_psrk – yaeos","text":"public  function setup_psrk(molecules, parameters) Uses yaeos__models_ge_group_contribution_unifac_parameters Arguments Type Intent Optional Attributes Name type( Groups ), intent(in) :: molecules (:) type( GeGCModelParameters ), intent(in), optional :: parameters Return Value type( UNIFAC ) Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: Aij (:,:) real(kind=pr), public, allocatable :: Bij (:,:) real(kind=pr), public, allocatable :: Cij (:,:) integer, public :: i integer, public :: j integer, public :: ng type( GeGCModelParameters ), public :: params type( QuadraticPsi ), public :: psi_function type( Groups ), public :: soup","tags":"","url":"proc/setup_psrk.html"},{"title":"residual_helmholtz – yaeos","text":"public  subroutine residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Type Bound ArModelAdiff Arguments Type Intent Optional Attributes Name class( ArModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Variables Type Visibility Attributes Name Initial logical, public :: any_deriv type( hyperdual ), public :: d_Ar type( hyperdual ), public :: d_n (size(n)) type( hyperdual ), public :: d_t type( hyperdual ), public :: d_v Subroutines subroutine get_dardn () Arguments None subroutine get_dardn2 () Arguments None subroutine get_dardt () Arguments None subroutine get_dardt2 () Arguments None subroutine get_dardtn () Arguments None subroutine get_dardv () Arguments None subroutine get_dardv2 () Arguments None subroutine get_dardvn () Arguments None subroutine get_dardvt () Arguments None subroutine reset_vars () Arguments None","tags":"","url":"proc/residual_helmholtz~2.html"},{"title":"optval_character – yaeos","text":"public  function optval_character(val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: val character(len=*), intent(in) :: default Return Value character(len=:), allocatable","tags":"","url":"proc/optval_character.html"},{"title":"optval_integer – yaeos","text":"public  function optval_integer(val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: val integer, intent(in) :: default Return Value integer","tags":"","url":"proc/optval_integer.html"},{"title":"optval_real – yaeos","text":"public  function optval_real(val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in), optional :: val real(kind=pr), intent(in) :: default Return Value real(kind=pr)","tags":"","url":"proc/optval_real.html"},{"title":"sort – yaeos","text":"public  subroutine sort(array, idx) Uses stdlib_sorting Sort an array and return the indexes Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: array (:) integer, intent(out), optional :: idx (:)","tags":"","url":"proc/sort.html"},{"title":"optval – yaeos","text":"public interface optval Module Procedures public  function optval_integer (val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: val integer, intent(in) :: default Return Value integer public  function optval_real (val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in), optional :: val real(kind=pr), intent(in) :: default Return Value real(kind=pr) public  function optval_character (val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: val character(len=*), intent(in) :: default Return Value character(len=:), allocatable","tags":"","url":"interface/optval.html"},{"title":"yaeos__solvers_pressure_equality – yaeos","text":"Solve the pressure equality of a Uses yaeos__constants yaeos__models_ar Subroutines public  subroutine pressure_equality_V_beta_xy (model, T, V, beta, x, y, Vx, Vy, P) Solve pressure equality between two phases at a given temperature,\ntotal volume, vapor molar fractions and compositions. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: V Total volume [L/mol] real(kind=pr), intent(in) :: beta Molar fraction of light-phase real(kind=pr), intent(in) :: x (:) Molar fractions of heavy-phase real(kind=pr), intent(in) :: y (:) Molar fractions of light-phase real(kind=pr), intent(inout) :: Vx Heavy-phase molar volume [L/mol] real(kind=pr), intent(inout) :: Vy Light-Phase molar volume [L/mol] real(kind=pr), intent(out) :: P Pressure [bar]","tags":"","url":"module/yaeos__solvers_pressure_equality.html"},{"title":"yaeos__models_ge_group_contribution_unifac_parameters – yaeos","text":"UNIFAC parameters UNIFAC parameters module Description Instances of the yaeos GeGCModelParameters with the classic liquid-vapor\nUNIFAC parameters. Examples use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters type ( GeGCModelParameters ) :: parameters parameters = UNIFACParameters () ! Get the maingroups i:1, j:7 interaction parameter aij (CH2-H2O) print * , parameters % get_maingroups_aij ( 1 , 7 ) ! prints: 1318.0000 References Dortmund Data Bank Software & Separation Technology Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975).\nGroup‐contribution estimation of activity coefficients in nonideal liquid\nmixtures. AIChE Journal, 21(6), 1086–1099. https://doi.org/10.1002/aic.690210607 Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979).\nVapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and\nExtension. Industrial & Engineering Chemistry Process Design and\nDevelopment, 18(4), 714–722. https://doi.org/10.1021/i260072a024 Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid\nequilibriums by UNIFAC group contribution. Revision and extension. 2.\nIndustrial & Engineering Chemistry Process Design and Development, 21(1),\n118–127. https://doi.org/10.1021/i200016a021 Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983).\nVapor-liquid equilibriums by UNIFAC group contribution. Revision and\nextension. 3. Industrial & Engineering Chemistry Process Design and\nDevelopment, 22(4), 676–678. https://doi.org/10.1021/i200023a023 Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987).\nVapor-liquid equilibria by UNIFAC group contribution. 4. Revision and\nextension. Industrial & Engineering Chemistry Research, 26(1), 159–161. https://doi.org/10.1021/ie00061a030 Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., &\nGmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group\ncontribution. 5. Revision and extension. Industrial & Engineering\nChemistry Research, 30 (10), 2352–2355. https://doi.org/10.1021/ie00058a017 Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria\nby UNIFAC Group Contribution. 6. Revision and Extension. Industrial &\nEngineering Chemistry Research, 42(1), 183–188. https://doi.org/10.1021/ie020506l Uses yaeos__constants yaeos__models_ge_group_contribution_model_parameters Functions public  function UNIFACParameters () UNIFAC parameters Read more… Arguments None Return Value type( GeGCModelParameters )","tags":"","url":"module/yaeos__models_ge_group_contribution_unifac_parameters.html"},{"title":"yaeos__models_ge_implementations – yaeos","text":"Uses yaeos__models_ge_group_contribution_dortmund yaeos__models_ge_uniquac yaeos__models_ge_NRTL yaeos__models_ge_group_contribution_psrk yaeos__models_ge_group_contribution_unifac","tags":"","url":"module/yaeos__models_ge_implementations.html"},{"title":"yaeos – yaeos","text":"Yet Another Equation-Of-State (library) Library to use EoS-based calculations. This main module imports all the\nrelevant constants, procedures and objects to have better access to them\nThe main submodules that it uses are: yaeos__constants : All the relevant costants and also the used precision (default=double precision). yaeos__consistency : Tools to evalaute the consistency of Ar and Ge models. yaeos__substance : Derived type that holds the important data (for example, critical constants) from a mixture. yaeos__models : All the implemented models, also their base types for making extensions. yaeos__equilibria : Phase equilibria related procedures. Uses yaeos__substance yaeos__models yaeos__equilibria yaeos__consistency yaeos__constants Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: version = \"3.1.0\" This version.","tags":"","url":"module/yaeos.html"},{"title":"yaeos__models_ge_NRTL – yaeos","text":"Uses yaeos__tapenade_interfaces yaeos__constants yaeos__tapenade_ge_api Interfaces public        interface NRTL public  function init (a, b, c) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: a (:,:) real(kind=pr), intent(in) :: b (:,:) real(kind=pr), intent(in) :: c (:,:) Return Value type( NRTL ) Derived Types type, public, extends( GeModelTapenade ) :: NRTL Non-Random-Two-Liquid model Read more… Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: a (:,:) A_{ij} matrix real(kind=pr), public, allocatable :: b (:,:) B_{ij} matrix real(kind=pr), public, allocatable :: c (:,:) C_{ij} matrix type( Substances ), public :: components Substances contained in the module Constructor public\n\n                    \n                    function init (a, b, c) Type-Bound Procedures procedure, public :: excess_enthalpy procedure, public :: excess_entropy procedure, public :: excess_gibbs procedure, public :: ge => EXCESS_GIBBS procedure, public :: ge_b => EXCESS_GIBBS_B procedure, public :: ge_d => EXCESS_GIBBS_D procedure, public :: ge_d_b => EXCESS_GIBBS_D_B procedure, public :: ge_d_d => EXCESS_GIBBS_D_D procedure, public :: ln_activity_coefficient Functions public  function init (a, b, c) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: a (:,:) real(kind=pr), intent(in) :: b (:,:) real(kind=pr), intent(in) :: c (:,:) Return Value type( NRTL ) Subroutines public  subroutine EXCESS_GIBBS (model, n, t, ge) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ge public  subroutine EXCESS_GIBBS_B (model, n, nb, t, tb, ge, geb) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: ge real(kind=pr) :: geb public  subroutine EXCESS_GIBBS_D (model, n, nd, t, td, ge, ged) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged public  subroutine EXCESS_GIBBS_D_B (model, n, nb, nd, ndb, t, tb, td, tdb, ge, geb, ged, gedb) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr) :: ndb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr), intent(in) :: td real(kind=pr) :: tdb real(kind=pr) :: ge real(kind=pr) :: geb real(kind=pr) :: ged real(kind=pr) :: gedb public  subroutine EXCESS_GIBBS_D_D (model, n, nd, t, td0, td, ge, ged0, ged, gedd) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged0 real(kind=pr), intent(out) :: ged real(kind=pr), intent(out) :: gedd public  subroutine EXCESS_GIBBS_D_D_D (model, n, nd, t, td1, td0, td, ge, ged1, ged0, ged0d, ged, gedd0, gedd, geddd) Arguments Type Intent Optional Attributes Name class( NRTL ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td1 real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged1 real(kind=pr), intent(out) :: ged0 real(kind=pr), intent(out) :: ged0d real(kind=pr), intent(out) :: ged real(kind=pr), intent(out) :: gedd0 real(kind=pr), intent(out) :: gedd real(kind=pr), intent(out) :: geddd","tags":"","url":"module/yaeos__models_ge_nrtl.html"},{"title":"yaeos__models_ge_group_contribution_dortmund_parameters – yaeos","text":"Uses yaeos__constants yaeos__models_ge_group_contribution_model_parameters Functions public  function DortmundParameters () Arguments None Return Value type( GeGCModelParameters )","tags":"","url":"module/yaeos__models_ge_group_contribution_dortmund_parameters.html"},{"title":"yaeos__equilibria_rachford_rice – yaeos","text":"Uses yaeos__constants Subroutines public  subroutine betalimits (z, K, bmin, bmax) Define beta limits to avoid overshooting when solving the Rachford-Rice\nequation. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Molar fractions vector real(kind=pr), intent(in) :: K (:) K-factors real(kind=pr), intent(out) :: bmin Minimum beta value real(kind=pr), intent(out) :: bmax Maximum beta value public  subroutine betato01 (z, K) Modify K-factor values to assure that lies between (0,1) Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Molar fractions of the system real(kind=pr) :: K (:) K factors public  subroutine rachford_rice (z, K, beta, rr, drrdb) Rachford-Rice equation for a two phase system. This equation is used to\ncalculate the value that satisfies the mass balance\nbetween two phases. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Mole fractions vector real(kind=pr), intent(in) :: K (:) K-factors real(kind=pr), intent(in) :: beta value real(kind=pr), intent(out) :: rr Rachford-Rice function value real(kind=pr), intent(out) :: drrdb Derivative of the Rachford-Rice function public  subroutine solve_rr (z, K, beta, beta_min, beta_max) Solve the Rachford-Rice Equation using the Newton method. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Mole fractions vector real(kind=pr), intent(in) :: K (:) K-factors real(kind=pr), intent(out) :: beta value real(kind=pr), intent(out) :: beta_min Lower limit for real(kind=pr), intent(out) :: beta_max Upper limit for","tags":"","url":"module/yaeos__equilibria_rachford_rice.html"},{"title":"yaeos__math_linalg – yaeos","text":"Wrapper module around LAPACK’s dgesv Uses yaeos__constants Functions public  function solve_system (a, b) result(x) Solve a linear sytem AX = b Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: a (size(b),size(b)) real(kind=pr), intent(in) :: b (:) Return Value real(kind=pr), (size(b)) Subroutines public  subroutine cubic_roots (parameters, real_roots, complex_roots, flag) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: parameters (4) real(kind=pr), intent(out) :: real_roots (3) complex(kind=pr), intent(out) :: complex_roots (3) integer, intent(out) :: flag flag that identifies which case the solution is\n- 0 : 3 real rotos, one of them repeated (use real_roots(1) and real_roots(2))\n- 1 : 1 real root, 2 complex roots.\n  Use real_roots(1) and complex_roots(1) and complex_roots(2)\n- -1 : 3 real roots, all different public  subroutine cubic_roots_rosendo (parameters, real_roots, complex_roots, flag) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: parameters (4) real(kind=pr), intent(out) :: real_roots (3) complex(kind=pr), intent(out) :: complex_roots (3) integer, intent(out) :: flag public  subroutine eigen (A, eigenvalues, eigenvectors) Calculate the eigenvalues and eigenvectors of a real symmetric matrix A using LAPACK’s dsyev . The eigenvectors are stored in the columns\nof eigenvectors . The eigenvalues are stored in eigenvalues . Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: A (:,:) real(kind=pr), intent(out) :: eigenvalues (:) real(kind=pr), intent(out), optional :: eigenvectors (:,:)","tags":"","url":"module/yaeos__math_linalg.html"},{"title":"yaeos__models_ge_gc_td – yaeos","text":"Uses yaeos__constants yaeos__models_ge_group_contribution_groups Abstract Interfaces abstract interface public  subroutine temperature_dependence(self, systems_groups, T, psi, dpsi_dt, dpsi_dt2) temperature_dependence interface Interface subroutine for UNIFAC models temperature dependent\nfunctions Arguments Type Intent Optional Attributes Name class( PsiFunction ) :: self PsiFunction type variable class( Groups ) :: systems_groups Groups type variable containig all the system’s groups. See the groups_stew variable on the UNIFAC documentation. real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: psi (:,:) real(kind=pr), intent(out), optional :: dpsi_dt (:,:) real(kind=pr), intent(out), optional :: dpsi_dt2 (:,:) Derived Types type, public, abstract :: PsiFunction UNIFAC functions abstract type Read more… Type-Bound Procedures procedure( temperature_dependence ), public, deferred :: psi type, public, extends( PsiFunction ) :: QuadraticPsi Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: Aij (:,:) real(kind=pr), public, allocatable :: Bij (:,:) real(kind=pr), public, allocatable :: Cij (:,:) Type-Bound Procedures procedure, public :: psi => Quadratic_temperature_dependence type, public, extends( PsiFunction ) :: UNIFACPsi Read more… Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: Aij (:,:) Type-Bound Procedures procedure, public :: psi => UNIFAC_temperature_dependence Subroutines public  subroutine Quadratic_temperature_dependence (self, systems_groups, T, psi, dpsi_dt, dpsi_dt2) Read more… Arguments Type Intent Optional Attributes Name class( QuadraticPsi ) :: self function class( Groups ) :: systems_groups Groups in the system real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: psi (:,:) real(kind=pr), intent(out), optional :: dpsi_dt (:,:) real(kind=pr), intent(out), optional :: dpsi_dt2 (:,:) public  subroutine UNIFAC_temperature_dependence (self, systems_groups, T, psi, dpsi_dt, dpsi_dt2) Implementation of the function of the UNIFAC model. Read more… Arguments Type Intent Optional Attributes Name class( UNIFACPsi ) :: self function class( Groups ) :: systems_groups Groups in the system real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: psi (:,:) real(kind=pr), intent(out), optional :: dpsi_dt (:,:) real(kind=pr), intent(out), optional :: dpsi_dt2 (:,:)","tags":"","url":"module/yaeos__models_ge_gc_td.html"},{"title":"yaeos__models_ar_genericcubic_base – yaeos","text":"Uses yaeos__constants Subroutines public  subroutine GenericCubic_Ar (n, v, t, B, dBi, dBij, D, dDi, dDij, dDidT, dDdT, dDdT2, D1, dD1i, dD1ij, ar, arv, ArT, artv, arv2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz Energy for a generic Cubic Equation of State. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in) :: B Repulsive parameter [L] real(kind=pr), intent(in) :: dBi (size(n)) real(kind=pr), intent(in) :: dBij (size(n),size(n)) real(kind=pr), intent(in) :: D Attractive parameter real(kind=pr), intent(in) :: dDi (size(n)) real(kind=pr), intent(in) :: dDij (size(n),size(n)) real(kind=pr), intent(in) :: dDidT (size(n)) real(kind=pr), intent(in) :: dDdT real(kind=pr), intent(in) :: dDdT2 real(kind=pr), intent(in) :: D1 parameter real(kind=pr), intent(in) :: dD1i (size(n)) real(kind=pr), intent(in) :: dD1ij (size(n),size(n)) real(kind=pr), intent(out), optional :: ar Residual Helmholtz real(kind=pr), intent(out), optional :: arv real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: artv real(kind=pr), intent(out), optional :: arv2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","url":"module/yaeos__models_ar_genericcubic_base.html"},{"title":"yaeos__equilibria_boundaries_phase_envelopes_mp_tx – yaeos","text":"Multiphase Px envelope calculation module. This module contains the functions to calculate the PT envelope of a\nmixture with multiple phases. Uses yaeos__equilibria_boundaries_auxiliar yaeos__models_ar yaeos__equilibria_equilibrium_state yaeos__constants yaeos__math Derived Types type, public :: TXEnvelMP Multiphase PT envelope. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) type( MPPoint ), public, allocatable :: points (:) Array of converged points. real(kind=pr), public, allocatable :: z0 (:) real(kind=pr), public, allocatable :: zi (:) Type-Bound Procedures procedure, public, nopass :: get_values_from_X procedure, public, nopass :: solve_point procedure, public :: write => write_envelope_TX_MP type, private :: MPPoint Multiphase equilibria point. Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: T Temperature [K] real(kind=pr), public :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), public, allocatable :: betas (:) Fractions of the main phases. integer, public :: iters Number of iterations needed to converge the point. integer, public :: nc Number of components integer, public :: np Number of phases integer, public :: ns Number of the specified variable. real(kind=pr), public, allocatable :: w (:) Mole fractions of the incipient phase. real(kind=pr), public, allocatable :: x_l (:,:) Mole fractions of the main phases. Functions public  function tx_envelope (model, z0, zi, np, P, x_l0, w0, betas0, T0, alpha0, ns0, dS0, beta_w, points) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) integer, intent(in) :: np real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: x_l0 (np,size(z0)) real(kind=pr), intent(in) :: w0 (size(z0)) real(kind=pr), intent(in) :: betas0 (np) real(kind=pr), intent(in) :: T0 real(kind=pr), intent(in) :: alpha0 integer, intent(in) :: ns0 real(kind=pr), intent(in) :: dS0 real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. integer, intent(in), optional :: points Return Value type( TXEnvelMP ) Subroutines public  subroutine tx_F_NP (model, z0, zi, np, P, beta_w, X, ns, S, F, df) Function to solve at each point of a multi-phase envelope. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: ns Number of specification. real(kind=pr), intent(in) :: S Specification value. real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated. real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix. private  subroutine detect_critical (nc, np, X, dXdS, ns, dS, S) Detect if the system is close to a critical point. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. real(kind=pr), intent(inout) :: S Specification value. private  subroutine get_values_from_X (X, np, z0, zi, beta_w, x_l, w, betas, T, alpha) Extract the values of the variables from the vector X. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: z0 (:) Initial mixture composition. real(kind=pr), intent(in) :: zi (:) Second mixture composition. real(kind=pr), intent(in) :: beta_w Reference phase beta. real(kind=pr), intent(out) :: x_l (np,size(z0)) Mole fractions of the main phases. real(kind=pr), intent(out) :: w (size(z0)) Mole fractions of the incipient phase. real(kind=pr), intent(out) :: betas (np) Fractions of the main phases. real(kind=pr), intent(out) :: T Pressure [bar]. real(kind=pr), intent(out) :: alpha . private  subroutine solve_point (model, z0, zi, np, P, beta_w, X, ns, S, dXdS, F, df, iters, max_iterations) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) integer, intent(in) :: np Number of main phases real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(in) :: dXdS (size(X)) real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix integer, intent(out) :: iters integer, intent(in) :: max_iterations private  subroutine update_specification (its, nc, np, X, dF, dXdS, ns, dS) Change the specified variable for the next step. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: its Iterations to solve the current point. integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dF (:,:) Jacobian matrix. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. private  subroutine write_envelope_TX_MP (env, unit) Arguments Type Intent Optional Attributes Name class( TXEnvelMP ), intent(in) :: env integer, intent(in) :: unit","tags":"","url":"module/yaeos__equilibria_boundaries_phase_envelopes_mp_tx.html"},{"title":"yaeos__consistency – yaeos","text":"yaeos__consistency Subroutine to evaluate the consistency of thermodynamic models. Description Tools to evaluate the consistency of and models. This\nmodule also provides subroutines for numerical evaluations of and derivatives using central finite differences. The purpose of the\nmodule is to assist in the development of new models and ensure the\naccuracy of the derivatives implementation. Examples For detailed explanations and examples of each consistency test, please\nrefer to the API documentation of each submodule. consistency tests: yaeos__consistency_armodel consistency tests: yaeos__consistency_gemodel References Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models:\nFundamentals & computational aspects (2. ed). Tie-Line Publications. Uses yaeos__consistency_gemodel yaeos__consistency_armodel","tags":"","url":"module/yaeos__consistency.html"},{"title":"yaeos__math_continuation – yaeos","text":"Implementation of Algower’s numerical continuation method. Uses yaeos__constants yaeos__math_linalg Abstract Interfaces abstract interface public  subroutine continuation_function(X, ns, S, F, dF, dFdS) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out) :: dF (:,:) real(kind=pr), intent(out) :: dFdS (:) abstract interface public  subroutine continuation_solver(fun, iters, X, ns, S, dS, dXdS, point, max_iters, F, df, dfds, tol) Solver to solve a point during numerical contination. Arguments Type Intent Optional Attributes Name procedure( continuation_function ) :: fun Function to solve integer, intent(out) :: iters Number of iterations needed real(kind=pr), intent(inout) :: X (:) Variables vector integer, intent(in) :: ns Specification number real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(in) :: dS Delta spec real(kind=pr), intent(in) :: dXdS (:) integer, intent(in) :: point Point number integer, intent(in) :: max_iters Maximum iterations real(kind=pr), intent(out) :: F (:) Function values at solved point real(kind=pr), intent(out) :: df (:,:) Jacobian values real(kind=pr), intent(out) :: dfds (:) dFdS real(kind=pr), intent(in) :: tol Solver tolerance abstract interface public  function continuation_stopper(X, ns, S, dS, dXdS, iterations) Function that returns true if the method should stop Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(inout) :: ns Position of specified variable real(kind=pr), intent(inout) :: S Specification variable value real(kind=pr), intent(inout) :: dS Step of specification in the method real(kind=pr), intent(inout) :: dXdS (:) integer, intent(in) :: iterations Iterations needed to converge point Return Value logical abstract interface public  subroutine process(X, ns, S, dS, dXdS, iterations) Subroutine to make variation in the method after a point converged Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(inout) :: ns Position of specified variable real(kind=pr), intent(inout) :: S Specification variable value real(kind=pr), intent(inout) :: dS Step of specification in the method real(kind=pr), intent(inout) :: dXdS (:) integer, intent(in) :: iterations Iterations needed to converge point Derived Types type, public :: ContinuationVariable Components Type Visibility Attributes Name Initial real(kind=pr), public :: S real(kind=pr), public, allocatable :: X (:) real(kind=pr), public :: dS integer, public :: ns Functions public  function continuation (f, X0, ns0, S0, dS0, max_points, solver_tol, update_specification, postprocess, solver, stop) result(XS) Numerical continuation of a function. Read more… Arguments Type Intent Optional Attributes Name procedure( continuation_function ) :: f Function to trace real(kind=pr), intent(in) :: X0 (:) Initial point integer, intent(in) :: ns0 Initial specification real(kind=pr), intent(in) :: S0 Initial specification value real(kind=pr), intent(in) :: dS0 Initial integer, intent(in) :: max_points Maximum number of points to trace real(kind=pr), intent(in) :: solver_tol Point solver tolerance procedure( process ), optional :: update_specification Procedure to select the new specification and define the next step\n(\\DeltaS)\\, defaults to: Read more… procedure( process ), optional :: postprocess Any kind of postprocess that could be done after defining the\nnext step procedure( continuation_solver ), optional :: solver Solver procedures, uses Newton-Raphson by default procedure( continuation_stopper ), optional :: stop Stopping procedure Return Value real(kind=pr), (max_points,size(X0)) Subroutines public  subroutine full_newton (fun, iters, X, ns, S, dS, dXdS, point, max_iters, F, df, dfds, tol) Subroutine to solve a point. Read more… Arguments Type Intent Optional Attributes Name procedure( continuation_function ) :: fun Function to solve integer, intent(out) :: iters Number of iterations needed real(kind=pr), intent(inout) :: X (:) Variables vector integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(in) :: dS real(kind=pr), intent(in) :: dXdS (:) integer, intent(in) :: point integer, intent(in) :: max_iters Maximum iterations real(kind=pr), intent(out) :: F (:) Function values at solved point real(kind=pr), intent(out) :: df (:,:) Jacobian values real(kind=pr), intent(out) :: dfds (:) dFdS real(kind=pr), intent(in) :: tol","tags":"","url":"module/yaeos__math_continuation.html"},{"title":"yaeos__models_ge_uniquac – yaeos","text":"UNIQUAC module UNIQUAC ( uni versal qua si c hemical) Excess Gibbs free energy\nmodel. References Maurer, G., & Prausnitz, J. M. (1978). On the derivation and extension\nof the UNIQUAC equation. Fluid Phase Equilibria, 2(2), 91-99. Gmehling, Jurgen, Barbel Kolbe, Michael Kleiber, and Jurgen Rarey.\nChemical Thermodynamics for Process Simulation. 1st edition. Weinheim:\nWiley-VCH, 2012. Caleb Bell and Contributors (2016-2024). Thermo: Chemical properties\ncomponent of Chemical Engineering Design Library (ChEDL)\nhttps://github.com/CalebBell/thermo. Uses yaeos__models_ge yaeos__constants yaeos__math Derived Types type, public, extends( GeModel ) :: UNIQUAC UNIQUAC ( uni versal qua si c hemical) Excess Gibbs free energy\nmodel. Read more… Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: aij (:,:) Interaction parameters matrix real(kind=pr), public, allocatable :: bij (:,:) Interaction parameters matrix real(kind=pr), public, allocatable :: cij (:,:) Interaction parameters matrix type( Substances ), public :: components Substances contained in the module real(kind=pr), public, allocatable :: dij (:,:) Interaction parameters matrix real(kind=pr), public, allocatable :: eij (:,:) Interaction parameters matrix real(kind=pr), public, allocatable :: qs (:) Molecule’s relative areas real(kind=pr), public, allocatable :: rs (:) Molecule’s relative volumes real(kind=pr), public :: z = 10.0_pr Model coordination number Type-Bound Procedures procedure, public :: excess_enthalpy procedure, public :: excess_entropy procedure, public :: excess_gibbs procedure, public :: ln_activity_coefficient procedure, public :: taus Functions public  function setup_uniquac (qs, rs, aij, bij, cij, dij, eij) Instantiate a UNIQUAC model. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: qs (:) Molecule’s relative volumes real(kind=pr), intent(in) :: rs (size(qs)) Molecule’s relative areas real(kind=pr), intent(in), optional :: aij (size(qs),size(qs)) Interaction parameters matrix , zero matrix if no provided. real(kind=pr), intent(in), optional :: bij (size(qs),size(qs)) Interaction parameters matrix , zero matrix if no provided. real(kind=pr), intent(in), optional :: cij (size(qs),size(qs)) Interaction parameters matrix , zero matrix if no provided. real(kind=pr), intent(in), optional :: dij (size(qs),size(qs)) Interaction parameters matrix , zero matrix if no provided. real(kind=pr), intent(in), optional :: eij (size(qs),size(qs)) Interaction parameters matrix , zero matrix if no provided. Return Value type( UNIQUAC ) Subroutines public  subroutine excess_gibbs (self, n, T, Ge, GeT, GeT2, Gen, GeTn, Gen2) Calculate the excess Gibbs free energy and its derivatives of the\nUNIQUAC model. Arguments Type Intent Optional Attributes Name class( UNIQUAC ), intent(in) :: self UNIQUAC model real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Excess Gibbs energy real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional :: Gen (size(n)) real(kind=pr), intent(out), optional :: GeTn (size(n)) real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) public  subroutine taus (self, T, tau, tauT, tauT2) Calculate the temperature dependence term of the UNIQUAC model. Arguments Type Intent Optional Attributes Name class( UNIQUAC ), intent(in) :: self UNIQUAC model real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: tau (size(self%qs),size(self%qs)) UNIQUAC temperature dependence term real(kind=pr), intent(out), optional :: tauT (size(self%qs),size(self%qs)) real(kind=pr), intent(out), optional :: tauT2 (size(self%qs),size(self%qs))","tags":"","url":"module/yaeos__models_ge_uniquac.html"},{"title":"yaeos__equilibria_boundaries_phase_envelopes_mp_px – yaeos","text":"Multiphase Px envelope calculation module. This module contains the functions to calculate the PT envelope of a\nmixture with multiple phases. Uses yaeos__equilibria_boundaries_auxiliar yaeos__models_ar yaeos__equilibria_equilibrium_state yaeos__constants yaeos__math Derived Types type, public :: PXEnvelMP Multiphase PX envelope. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) Molar relation between two mixtures. type( MPPoint ), public, allocatable :: points (:) Array of converged points. real(kind=pr), public, allocatable :: z0 (:) Original mixture mole fractions. real(kind=pr), public, allocatable :: zi (:) Other mixture mole fractions Type-Bound Procedures procedure, public, nopass :: get_values_from_X procedure, public, nopass :: solve_point procedure, public :: write => write_envelope_PX_MP type, private :: MPPoint Multiphase equilibria point. Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: T Temperature [K] real(kind=pr), public :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), public, allocatable :: betas (:) Fractions of the main phases. integer, public :: iters Number of iterations needed to converge the point. integer, public :: nc Number of components integer, public :: np Number of phases integer, public :: ns Number of the specified variable. real(kind=pr), public, allocatable :: w (:) Mole fractions of the incipient phase. real(kind=pr), public, allocatable :: x_l (:,:) Mole fractions of the main phases. Functions public  function px_envelope (model, z0, zi, np, T, x_l0, w0, betas0, P0, alpha0, ns0, dS0, beta_w, points) Calculation of a multiphase Px envelope. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z0 (:) Original fluid composition. real(kind=pr), intent(in) :: zi (:) Other fluid compostion. integer, intent(in) :: np Number of phases, without including the reference phaes real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: x_l0 (np,size(z0)) Initial guess for composition of phases. real(kind=pr), intent(in) :: w0 (size(z0)) Initial guess for composition of reference phase. real(kind=pr), intent(in) :: betas0 (np) Mole fractions of each phase. Excluding the reference phase. real(kind=pr), intent(in) :: P0 Initial guess for pressure [bar] real(kind=pr), intent(in) :: alpha0 Initial guess for relation between two fluids integer, intent(in) :: ns0 First specified variable. Read more… real(kind=pr), intent(in) :: dS0 First step to extrapolate for next point calculation. After that\nIt will use an adaptive algorithm. real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. integer, intent(in), optional :: points Maximum number of points to calculate. Return Value type( PXEnvelMP ) Subroutines public  subroutine px_F_NP (model, z0, zi, np, T, beta_w, X, ns, S, F, df) System of equations to solve a multiphase-point at constant \ntemperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z0 (:) First mixture composition. real(kind=pr), intent(in) :: zi (:) Second mixture composition. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: T Temperature [K]. real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: ns Number of specification. real(kind=pr), intent(in) :: S Specification value. real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated. real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix. private  subroutine detect_critical (nc, np, X, dXdS, ns, dS, S) Detect if the system is close to a critical point. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. real(kind=pr), intent(inout) :: S Specification value. private  subroutine get_values_from_X (X, np, z0, zi, beta_w, x_l, w, betas, P, alpha) Extract the values of the variables from the vector X. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: z0 (:) Initial mixture composition. real(kind=pr), intent(in) :: zi (:) Second mixture composition. real(kind=pr), intent(in) :: beta_w Reference phase beta. real(kind=pr), intent(out) :: x_l (np,size(z0)) Mole fractions of the main phases. real(kind=pr), intent(out) :: w (size(z0)) Mole fractions of the incipient phase. real(kind=pr), intent(out) :: betas (np) Fractions of the main phases. real(kind=pr), intent(out) :: P Pressure [bar]. real(kind=pr), intent(out) :: alpha . private  subroutine solve_point (model, z0, zi, np, T, beta_w, X, ns, S, dXdS, F, df, iters, max_iterations) Solve the system of equations for a multiphase point. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z0 (:) First mixture composition. real(kind=pr), intent(in) :: zi (:) Second mixture composition. integer, intent(in) :: np Number of main phases real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(in) :: dXdS (size(X)) Sensitivity of the variables wrt the specification real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix integer, intent(out) :: iters Number of iterations needed to converge the point integer, intent(in) :: max_iterations Maximum number of iterations to solve the point private  subroutine update_specification (its, nc, np, X, dF, dXdS, ns, dS) Change the specified variable for the next step. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: its Iterations to solve the current point. integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dF (:,:) Jacobian matrix. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. private  subroutine write_envelope_PX_MP (env, unit) Arguments Type Intent Optional Attributes Name class( PXEnvelMP ), intent(in) :: env integer, intent(in) :: unit","tags":"","url":"module/yaeos__equilibria_boundaries_phase_envelopes_mp_px.html"},{"title":"yaeos__models_ge – yaeos","text":"Excess Gibbs Models. Uses yaeos__constants yaeos__models_base Abstract Interfaces abstract interface public  subroutine excess_gibbs(self, n, T, Ge, GeT, GeT2, Gen, GeTn, Gen2) Calculate Excess Gibbs and its derivatives. Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Excess Gibbs free energy real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional :: Gen (size(n)) real(kind=pr), intent(out), optional :: GeTn (size(n)) real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n)) Derived Types type, public, abstract, extends( BaseModel ) :: GeModel Excess Gibbs energy model. Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module Type-Bound Procedures procedure, public :: excess_enthalpy procedure, public :: excess_entropy procedure( excess_gibbs ), public, deferred :: excess_gibbs procedure, public :: ln_activity_coefficient Subroutines public  subroutine excess_enthalpy (self, n, T, He, HeT, Hen) Calculate Excess enthalpy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: He Excess enthalpy real(kind=pr), intent(out), optional :: HeT real(kind=pr), intent(out), optional :: Hen (:) public  subroutine excess_entropy (self, n, T, Se, SeT, Sen) Calculate Excess entropy and its derivatives. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Se Excess entropy real(kind=pr), intent(out), optional :: SeT real(kind=pr), intent(out), optional :: Sen (:) public  subroutine ln_activity_coefficient (self, n, T, lngamma, dlngammadT, dlngammadn) Calculate natural logarithm of activity coefficients. Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: lngamma (:) Natural logarithm of activity coefficients real(kind=pr), intent(out), optional :: dlngammadT (size(n)) real(kind=pr), intent(out), optional :: dlngammadn (size(n),size(n))","tags":"","url":"module/yaeos__models_ge.html"},{"title":"yaeos__models_ar_genericcubic – yaeos","text":"Uses yaeos__substance yaeos__constants yaeos__models_ar Abstract Interfaces abstract interface public  subroutine abs_Bmix(self, n, bi, B, dBi, dBij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) abstract interface public  subroutine abs_D1mix(self, n, d1i, D1, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:) abstract interface public  subroutine abs_Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) abstract interface public  subroutine abs_alpha(self, Tr, a, dadt, dadt2) Arguments Type Intent Optional Attributes Name class( AlphaFunction ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:) Derived Types type, public, abstract :: AlphaFunction Abstract derived type that describe the required\nprocedure for an alpha function. Type-Bound Procedures procedure( abs_alpha ), public, deferred :: alpha type, public, extends( ArModel ) :: CubicEoS Generic Cubic Equation of State as defined by Michelsen and Mollerup\nwith a parameter that is not constant,\nand a parameter that depends on it. In the case of a\ntwo parameter EoS like PengRobinson the is the same for\nall components so it can be considered as a constant instead of a\nvariable. The expression of the Equation is: Read more… Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: ac (:) Attractive critical parameter class( AlphaFunction ), public, allocatable :: alpha Uses the abstract derived type AlphaFunction to define the\nAlpha function that the CubicEoS will use. The Alpha function\nreceives the reduced temperature and returns the values of alpha\nand its derivatives, named a , dadt and dadt2 respectively. Read more… real(kind=pr), public, allocatable :: b (:) Repulsive parameter type( Substances ), public :: components Substances contained in the module real(kind=pr), public, allocatable :: del1 (:) paramter real(kind=pr), public, allocatable :: del2 (:) paramter class( CubicMixRule ), public, allocatable :: mixrule Uses the abstract derived type CubicMixRule to define the\nmixing rule that the CubicEoS will use. It includes internally\nthree methods to calculate the corresponding parameters for the\nCubic EoS: Dmix , Bmix and D1mix . Read more… character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure, public :: Cp_residual_vt procedure, public :: Cv_residual_vt procedure, public :: Psat_pure procedure, public :: enthalpy_residual_vt procedure, public :: entropy_residual_vt procedure, public :: get_v0 => v0 procedure, public :: gibbs_residual_vt procedure, public :: internal_energy_residual_vt procedure, public :: lnfug_vt procedure, public :: lnphi_pt procedure, public :: lnphi_vt procedure, public :: pressure procedure, public :: residual_helmholtz => GenericCubic_Ar procedure, public :: set_delta1 procedure, public :: set_mixrule procedure, public :: volume type, public, abstract :: CubicMixRule Abstract derived type that describe the required\nprocedure for a mixing rule on a Cubic EoS Components Type Visibility Attributes Name Initial logical, public :: dn2 = .false. Calculate second order derivatives Type-Bound Procedures procedure( abs_Bmix ), public, deferred :: Bmix procedure( abs_D1mix ), public, deferred :: D1mix procedure( abs_Dmix ), public, deferred :: Dmix Functions public  function v0 (self, n, p, t) Cubic EoS volume initializer.\nFor a Cubic Equation of State, the covolume calculated with the mixing\nrule is a good estimate for the initial volume solver on the liquid\nregion. Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) Subroutines public  subroutine GenericCubic_Ar (self, n, v, t, ar, arv, ArT, artv, arv2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz Energy for a generic Cubic Equation of State. Read more… Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: ar Residual Helmholtz real(kind=pr), intent(out), optional :: arv real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: artv real(kind=pr), intent(out), optional :: arv2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) public  subroutine set_delta1 (self, delta1) Arguments Type Intent Optional Attributes Name class( CubicEoS ) :: self real(kind=pr), intent(in) :: delta1 (:) public  subroutine set_mixrule (self, mixrule) Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(inout) :: self class( CubicMixRule ), intent(in) :: mixrule public  subroutine volume (eos, n, P, T, V, root_type) Volume solver optimized for Cubic Equations of State. Read more… Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: eos real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: V character(len=*), intent(in) :: root_type","tags":"","url":"module/yaeos__models_ar_genericcubic.html"},{"title":"yaeos__equilibria_boundaries_phase_envelopes_px – yaeos","text":"Phase boundaries line on the plane calculation procedures. Uses yaeos__equilibria_boundaries_auxiliar yaeos__models yaeos__math_continuation yaeos__equilibria_equilibrium_state yaeos__constants Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Vy Incipient phase volume [L/mol] real(kind=pr), private :: Vz Main phase volume [L/mol] Derived Types type, public :: PXEnvel2 Two-phase PX envelope.\nPhase boundary line of a fluid at constant temperature\nwith variation in composition. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) Second fluid molar fraction type( CriticalPoint ), public, allocatable :: cps (:) Critical points found along the line. type( EquilibriumState ), public, allocatable :: points (:) Each point through the line. real(kind=pr), public, allocatable :: z0 (:) Original fluid composition real(kind=pr), public, allocatable :: z_inj (:) Second fluid composition type, private :: CriticalPoint Critical point Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: alpha Functions public  function px_envelope_2ph (model, z0, alpha0, z_injection, first_point, points, iterations, delta_0, specified_variable_0, solver, stop_conditions) result(envelopes) PX two-phase envelope calculation procedure. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Thermodyanmic model real(kind=pr), intent(in) :: z0 (:) Vector of molar fractions of the global composition (main phase) real(kind=pr), intent(in) :: alpha0 First point of real(kind=pr), intent(in) :: z_injection (:) Vector of molar fractions of the injection fluid type( EquilibriumState ) :: first_point integer, intent(in), optional :: points Maxmimum number of points, defaults to 500 integer, intent(in), optional :: iterations Point solver maximum iterations, defaults to 100 real(kind=pr), intent(in), optional :: delta_0 Initial extrapolation integer, intent(in), optional :: specified_variable_0 Position of specified variable, since the vector of variables is the values for specification\nwill be for the equilibria constants, for and for . procedure( continuation_solver ), optional :: solver Specify solver for each point, defaults to a full newton procedure procedure( continuation_stopper ), optional :: stop_conditions Function that returns true if the continuation method should stop Return Value type( PXEnvel2 )","tags":"","url":"module/yaeos__equilibria_boundaries_phase_envelopes_px.html"},{"title":"yaeos__models_ar_cubic_implementations – yaeos","text":"Implemented Cubic Equations of State. PengRobinson76 PengRobinson78 SoaveRedlichKwong RKPR Uses yaeos__substance yaeos__constants yaeos__models_ar_genericcubic Functions public  function PSRK (tc, pc, w, molecules, c1, c2, c3) result(model) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical temperature [K] real(kind=pr), intent(in) :: pc (:) Critical pressure [bar] real(kind=pr), intent(in) :: w (:) Acentric factor type( Groups ), intent(in) :: molecules (:) real(kind=pr), intent(in), optional :: c1 (:) real(kind=pr), intent(in), optional :: c2 (:) real(kind=pr), intent(in), optional :: c3 (:) Return Value type( CubicEoS ) public  function PengRobinson76 (tc, pc, w, kij, lij) result(model) PengRobinson76. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical Temperatures [K] real(kind=pr), intent(in) :: pc (:) Critical Pressures [bar] real(kind=pr), intent(in) :: w (:) Acentric Factors real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS ) public  function PengRobinson78 (tc, pc, w, kij, lij) result(model) PengRobinson78. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical Temperatures [K] real(kind=pr), intent(in) :: pc (:) Critical Pressures [bar] real(kind=pr), intent(in) :: w (:) Acentric Factors real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS ) public  function RKPR (tc, pc, w, zc, kij, lij, delta_1, k) result(model) RKPR Equation of State Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical Temperature [K] real(kind=pr), intent(in) :: pc (:) Critical Pressure [bar] real(kind=pr), intent(in) :: w (:) Acentric Factor real(kind=pr), intent(in) :: zc (:) Critical compressibility real(kind=pr), intent(in), optional :: kij (:,:) k_{ij} matrix real(kind=pr), intent(in), optional :: lij (:,:) l_{ij} matrix real(kind=pr), intent(in), optional :: delta_1 (:) real(kind=pr), intent(in), optional :: k (:) Return Value type( CubicEoS ) public  function SoaveRedlichKwong (tc, pc, w, kij, lij) result(model) SoaveRedlichKwong. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical temperature [K] real(kind=pr), intent(in) :: pc (:) Critical pressure [bar] real(kind=pr), intent(in) :: w (:) Acentric factor real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS ) Subroutines public  subroutine refit_rkpr_k (model, component) Refit the parameter of the RKPR EoS to match the acentric\nfactor Read more… Arguments Type Intent Optional Attributes Name type( CubicEoS ), intent(inout) :: model The model to be refitted integer, intent(in) :: component Component index to refit private  subroutine get_OMa_OMb (del1, OMa, OMb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: del1 (:) real(kind=pr), intent(out) :: OMa (size(del1)) real(kind=pr), intent(out) :: OMb (size(del1))","tags":"","url":"module/yaeos__models_ar_cubic_implementations.html"},{"title":"yaeos__equilibria_boundaries_phase_envelopes_px3 – yaeos","text":"Uses yaeos__equilibria_boundaries_auxiliar yaeos__models_ar yaeos__equilibria_equilibrium_state yaeos__constants yaeos__math Variables Type Visibility Attributes Name Initial real(kind=pr), private, parameter :: lnK_min = 2.0_pr Derived Types type, public :: PXEnvel3 Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: P (:) Pressure [bar] real(kind=pr), public, allocatable :: S (:) Specified value to solve point i real(kind=pr), public :: T Temperature [K] real(kind=pr), public, allocatable :: alpha (:) Mole fraction of other fluid real(kind=pr), public, allocatable :: beta (:) Mole fraction between phase x and phase y integer, public, allocatable :: ns (:) Specified variable to solve point i real(kind=pr), public, allocatable :: w (:,:) Mole fraction of phase x real(kind=pr), public, allocatable :: x (:,:) Mole fraction of phase x real(kind=pr), public, allocatable :: y (:,:) Mole fraction of phase x Functions public  function px_envelope_3ph (model, z0, zi, T, x0, y0, w0, beta0, P0, a0, ns0, dS0, points) result(envelope) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: x0 (:) real(kind=pr), intent(in) :: y0 (:) real(kind=pr), intent(in) :: w0 (:) real(kind=pr), intent(in) :: beta0 real(kind=pr), intent(in) :: P0 real(kind=pr), intent(in) :: a0 integer, intent(in) :: ns0 real(kind=pr), intent(in) :: dS0 integer, intent(in) :: points Return Value type( PXEnvel3 ) private  function critical_interpol (Xnew, Xold, idx) result(a) Critical point interpolation Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xnew (:) New value of the variables real(kind=pr), intent(in) :: Xold (:) Old value of the variables integer, intent(in) :: idx (:) Index of the variables to interpolate Return Value real(kind=pr) Subroutines public  subroutine get_values_from_X (z0, zi, Xvars, x, y, w, P, alpha, beta) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) real(kind=pr), intent(in) :: Xvars (size(z0)*2+3) real(kind=pr), intent(out) :: x (size(z0)) real(kind=pr), intent(out) :: y (size(z0)) real(kind=pr), intent(out) :: w (size(z0)) real(kind=pr), intent(out) :: P real(kind=pr), intent(out) :: alpha real(kind=pr), intent(out) :: beta public  subroutine solve_point (model, z0, zi, T, ns, S, X, F, dF, its, maxits) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) real(kind=pr), intent(in) :: T integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(inout) :: X (:) real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out) :: dF (:,:) integer, intent(inout) :: its integer, intent(in) :: maxits private  subroutine detect_critical (X, dXdS, ns, S, dS) Critical point detection Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables real(kind=pr), intent(inout) :: dXdS (:) Variation of variables wrt S integer, intent(inout) :: ns Number of specified variable real(kind=pr), intent(inout) :: S Specification value real(kind=pr), intent(inout) :: dS Step in specification private  subroutine px_F_three_phases (model, z0, zi, T, Xvars, ns, S, F, df) Function to solve at each point of a three phase envelope. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (:) real(kind=pr), intent(in) :: zi (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: Xvars (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(Xvars)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) Jacobian matrix private  subroutine update_specification (its, X, dF, dXdS, ns, dS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: its real(kind=pr), intent(inout) :: X (:) real(kind=pr), intent(inout) :: dF (:,:) real(kind=pr), intent(inout) :: dXdS (:) integer, intent(inout) :: ns real(kind=pr), intent(inout) :: dS","tags":"","url":"module/yaeos__equilibria_boundaries_phase_envelopes_px3.html"},{"title":"yaeos__models_ge_group_contribution_psrk_parameters – yaeos","text":"Uses yaeos__constants yaeos__models_ge_group_contribution_model_parameters Functions public  function PSRKParameters () Arguments None Return Value type( GeGCModelParameters )","tags":"","url":"module/yaeos__models_ge_group_contribution_psrk_parameters.html"},{"title":"yaeos__models_ar – yaeos","text":"Module that defines the basics of a residual Helmholtz energy. All the residual properties that are calculated in this library are\nbased on residual Helmholtz Equations of State. Following the book by\nMichelsen and Mollerup. In this library up to second derivatives of residual Helmholtz energy\nare used. Because they’re the fundamentals for phase equilibria\ncalculation. Note Later on, third derivative with respect to volume will be included\nsince it’s importance on calculation of critical points. Properties Available properties: pressure(n, V, T) fugacity(n, V, T) fugacity(n, P, T, root=[vapor, liquid, stable]) volume Calculate thermodynamic properties using Helmholtz energy as a basis.\nAll the routines in this module work with the logic: call foo ( x , V , T , [ dfoodv , dfoodT , ...]) Where the user can call the routine of the desired property. And include\nas optional values the desired derivatives of said properties. Uses yaeos__constants yaeos__models_base Interfaces public        interface size private pure function size_ar_model (eos) Get the size of the model. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Return Value integer Abstract Interfaces abstract interface private  subroutine abs_residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz model generic interface. This interface represents how an Ar model should be implemented.\nBy our standard, a Resiudal Helmholtz model takes as input: The mixture’s number of moles vector. Volume, by default in liters. Temperature, by default in Kelvin. All the output arguments are optional. While this keeps a long\nsignature for the implementation, this is done this way to take\nadvantage of any inner optimizations to calculate derivatives\ninside the procedure. Once the model is implemented, the signature can be short like model%residual_helmholtz(n, v, t, ArT2=dArdT2) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self ArModel real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: Ar Residual Helmoltz energy real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) abstract interface private  function abs_volume_initializer(self, n, p, t) Function that provides an initializer value for the liquid-root\nof newton solver of volume. In the case the model will use the volume_michelsen routine this value should provide the co-volume\nof the model. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Ar Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: t Temperature [K] Return Value real(kind=pr) Initial volume [L] Derived Types type, public, abstract, extends( BaseModel ) :: ArModel Abstract residual Helmholtz model. Read more… Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure, public :: Cp_residual_vt procedure, public :: Cv_residual_vt procedure, public :: Psat_pure procedure, public :: enthalpy_residual_vt procedure, public :: entropy_residual_vt procedure( abs_volume_initializer ), public, deferred :: get_v0 procedure, public :: gibbs_residual_vt procedure, public :: internal_energy_residual_vt procedure, public :: lnfug_vt procedure, public :: lnphi_pt procedure, public :: lnphi_vt procedure, public :: pressure procedure( abs_residual_helmholtz ), public, deferred :: residual_helmholtz procedure, public :: volume Functions private  function Psat_pure (eos, ncomp, T) Calculation of saturation pressure of a pure component using the\nsecant method. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model that will be used integer, intent(in) :: ncomp Number of component in the mixture from which the saturation pressure\nwill be calculated real(kind=pr), intent(in) :: T Temperature [K] Return Value real(kind=pr) private pure function size_ar_model (eos) Get the size of the model. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Return Value integer Subroutines public  subroutine volume (eos, n, P, T, V, root_type) Volume solver routine for residual Helmholtz models. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: V Volume [L] character(len=*), intent(in) :: root_type Desired root-type to solve. Options are: [\"liquid\", \"vapor\", \"stable\"] private  subroutine Cp_residual_vt (eos, n, V, T, Cp) Calculate residual heat capacity pressure constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cp heat capacity P constant [bar L / K] private  subroutine Cv_residual_vt (eos, n, V, T, Cv) Calculate residual heat capacity volume constant given V and T. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: Cv heat capacity V constant [bar L / K] private  subroutine enthalpy_residual_vt (eos, n, V, T, Hr, HrV, HrT, Hrn) Calculate residual enthalpy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Hr Residual enthalpy [bar L] real(kind=pr), intent(out), optional :: HrV real(kind=pr), intent(out), optional :: HrT real(kind=pr), intent(out), optional :: Hrn (size(n)) private  subroutine entropy_residual_vt (eos, n, V, T, Sr, SrV, SrT, Srn) Calculate residual entropy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Sr Entropy [bar L / K] real(kind=pr), intent(out), optional :: SrV real(kind=pr), intent(out), optional :: SrT real(kind=pr), intent(out), optional :: Srn (size(n)) private  subroutine gibbs_residual_vt (eos, n, V, T, Gr, GrV, GrT, Grn) Calculate residual Gibbs energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Gr Gibbs energy [bar L] real(kind=pr), intent(out), optional :: GrV real(kind=pr), intent(out), optional :: GrT real(kind=pr), intent(out), optional :: Grn (size(n)) private  subroutine internal_energy_residual_vt (eos, n, V, T, Ur, UrV, UrT, Urn) Calculate residual internal energy given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ur Internal energy [bar L] real(kind=pr), intent(out), optional :: UrV real(kind=pr), intent(out), optional :: UrT real(kind=pr), intent(out), optional :: Urn (size(n)) private  subroutine lnfug_vt (eos, n, V, T, P, lnf, dlnfdV, dlnfdT, dlnfdn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnf (size(n)) vector real(kind=pr), intent(out), optional :: dlnfdV (size(n)) Volume derivative real(kind=pr), intent(out), optional :: dlnfdT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnfdn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) private  subroutine lnphi_pt (eos, n, P, T, V, root_type, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity given pressure and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: V Volume [L] character(len=*), intent(in) :: root_type Type of root desired [“liquid”, “vapor”, “stable”] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) ln(phi) Temperature derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) ln(phi) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (size(n)) private  subroutine lnphi_vt (eos, n, V, T, P, lnPhi, dlnPhidP, dlnPhidT, dlnPhidn, dPdV, dPdT, dPdn) Calculate natural logarithm of fugacity coefficent. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: eos Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: P Pressure [bar] real(kind=pr), intent(out), optional :: lnPhi (size(n)) vector real(kind=pr), intent(out), optional :: dlnPhidP (size(n)) Presssure derivative real(kind=pr), intent(out), optional :: dlnPhidT (size(n)) Temp derivative real(kind=pr), intent(out), optional :: dlnPhidn (size(n),size(n)) compositional derivative real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:) private  subroutine pressure (eos, n, V, T, P, dPdV, dPdT, dPdn) Calculate pressure. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: P Pressure [bar] real(kind=pr), intent(out), optional :: dPdV real(kind=pr), intent(out), optional :: dPdT real(kind=pr), intent(out), optional :: dPdn (:)","tags":"","url":"module/yaeos__models_ar.html"},{"title":"yaeos__equilibria_boundaries_phase_envelopes_tx – yaeos","text":"Phase boundaries line on the plane calculation procedures. Uses yaeos__equilibria_boundaries_auxiliar yaeos__models yaeos__math_continuation yaeos__equilibria_equilibrium_state yaeos__constants Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Vy Incipient phase volume [L/mol] real(kind=pr), private :: Vz Main phase volume [L/mol] Derived Types type, public :: TXEnvel2 Two-phase TX envelope.\nPhase boundary line of a fluid at constant temperature\nwith variation in composition. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) Second fluid molar fraction type( CriticalPoint ), public, allocatable :: cps (:) Critical points found along the line. type( EquilibriumState ), public, allocatable :: points (:) Each point through the line. real(kind=pr), public, allocatable :: z0 (:) Original fluid composition real(kind=pr), public, allocatable :: z_inj (:) Second fluid composition type, private :: CriticalPoint Critical point Components Type Visibility Attributes Name Initial real(kind=pr), public :: T Temperature [K] real(kind=pr), public :: alpha Functions public  function tx_envelope_2ph (model, z0, alpha0, z_injection, first_point, points, iterations, delta_0, specified_variable_0, solver, stop_conditions) result(envelopes) TX two-phase envelope calculation procedure. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Thermodyanmic model real(kind=pr), intent(in) :: z0 (:) Vector of molar fractions of the global composition (main phase) real(kind=pr), intent(in) :: alpha0 First point of real(kind=pr), intent(in) :: z_injection (:) Vector of molar fractions of the injection fluid type( EquilibriumState ) :: first_point integer, intent(in), optional :: points Maxmimum number of points, defaults to 500 integer, intent(in), optional :: iterations Point solver maximum iterations, defaults to 100 real(kind=pr), intent(in), optional :: delta_0 Initial extrapolation integer, intent(in), optional :: specified_variable_0 Position of specified variable, since the vector of variables is the values for specification\nwill be for the equilibria constants, for and for . procedure( continuation_solver ), optional :: solver Specify solver for each point, defaults to a full newton procedure procedure( continuation_stopper ), optional :: stop_conditions Function that returns true if the continuation method should stop Return Value type( TXEnvel2 )","tags":"","url":"module/yaeos__equilibria_boundaries_phase_envelopes_tx.html"},{"title":"yaeos__consistency_armodel – yaeos","text":"yaeos__consistency_armodel Consistency checks of Helmholtz free energy models ( ArModel ). Description This module contains tools to validate the analityc derivatives of\nimplmented Helmholtz free energy models ( ArModel ). Also, allows to\nevaluate the consistency tests described in Thermodynamic Models:\nFundamentals & Computational Aspects 2 ed. by Michelsen and Mollerup\nChapter 2 section 3. Available tools: numeric_ar_derivatives : From an instantiated ArModel evaluate\nall the Helmholtz free energy derivatives from the central finite\ndifference method. ar_consistency : From an instantiated ArModel evaluate all the\nMichelsen and Mollerup consistency tests. References Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models:\nFundamentals & computational aspects (2. ed). Tie-Line Publications. Uses yaeos__constants yaeos__models_ar Subroutines public  subroutine ar_consistency (eos, n, V, T, eq31, eq33, eq34, eq36, eq37) models consistency tests. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Equation of state real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: eq31 MM Eq. 31 real(kind=pr), intent(out), optional :: eq33 (size(n),size(n)) MM Eq. 33 real(kind=pr), intent(out), optional :: eq34 (size(n)) MM Eq. 34 real(kind=pr), intent(out), optional :: eq36 MM Eq. 36 real(kind=pr), intent(out), optional :: eq37 MM Eq. 37 public  subroutine numeric_ar_derivatives (eos, n, V, T, d_n, d_v, d_t, Ar, ArV, ArT, Arn, ArV2, ArT2, ArTV, ArVn, ArTn, Arn2) Evaluate the Helmholtz derivatives with central finite difference. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos Equation of state real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: d_n Moles finite difference step real(kind=pr), intent(in) :: d_v Volume finite difference step real(kind=pr), intent(in) :: d_t Temperature finite difference step real(kind=pr), intent(out) :: Ar Residual Helmoltz energy real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","url":"module/yaeos__consistency_armodel.html"},{"title":"ADMM_TAPENADE_INTERFACE – yaeos","text":"Interfaces public        interface ADMM_REBASE public  subroutine ADMM_REBASE(base) bind(c, name='ADMM_rebase') Arguments Type Intent Optional Attributes Name type(C_PTR) :: base public        interface ADMM_REBASESHADOWED public  subroutine ADMM_REBASESHADOWED(base, baseb) bind(c, name=     'ADMM_rebaseShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR) :: base type(C_PTR) :: baseb public        interface ADMM_REGISTER public  subroutine ADMM_REGISTER(base, obase, size, nbelem) bind(c, name=     'ADMM_register') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size integer, VALUE :: nbelem public        interface ADMM_REGISTERSHADOWED public  subroutine ADMM_REGISTERSHADOWED(base, obase, size, baseb, obaseb, sizeb, nbelem) bind(c, name='ADMM_registerShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size type(C_PTR), VALUE :: baseb type(C_PTR), VALUE :: obaseb integer, VALUE :: sizeb integer, VALUE :: nbelem public        interface ADMM_UNREGISTER public  subroutine ADMM_UNREGISTER(base, nbelem) bind(c, name=     'ADMM_unregister') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base integer :: nbelem public        interface ADMM_UNREGISTERSHADOWED public  subroutine ADMM_UNREGISTERSHADOWED(base, baseb, nbelem) bind(c,      name='ADMM_unregisterShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: baseb integer :: nbelem public        interface POPPOINTER8 public  subroutine POPPOINTER8(pp) bind(c, name='popPointer8') Arguments Type Intent Optional Attributes Name type(C_PTR) :: pp public        interface PUSHPOINTER8 public  subroutine PUSHPOINTER8(pp) bind(c, name='pushPointer8') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: pp","tags":"","url":"module/admm_tapenade_interface.html"},{"title":"yaeos__equilibria_stability – yaeos","text":"Phase Stability module Phase stability related calculations. Description Contains the basics rotuines to make phase stability analysis for\nphase-equilibria detection. tpd(model, z, w, P, T) : reduced Tangent-Plane-Distance min_tpd(model, z, P, T, mintpd, w) : Find minimal tpd for a multicomponent mixture Examples ! Obtain the minimal tpd for a binary mixture at z_1 = 0.13 model = PengRobinson76 ( tc , pc , ac , kij , lij ) z = [ 0.13 , 1 - 0.13 ] w = [ 0.1 , 0.9 ] P = 4 5.6_pr T = 19 0._pr z = z / sum ( z ) ----------------------------------------------- References Thermodynamic Models: Fundamental and Computational Aspects, Michael L.\nMichelsen, Jørgen M. Mollerup. Tie-Line Publications, Denmark (2004) doi Uses yaeos__constants yaeos__models Functions public  function tm (model, z, w, P, T, d, dtpd) Michelsen’s modified function, . Read more… Arguments Type Intent Optional Attributes Name class( BaseModel ), intent(in) :: model Thermodynamic model real(kind=pr), intent(in) :: z (:) Feed composition real(kind=pr), intent(in) :: w (:) Test-phase mole numbers vector real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in), optional :: d (:) vector real(kind=pr), intent(out), optional :: dtpd (:) Return Value real(kind=pr) Subroutines public  subroutine min_tpd (model, z, P, T, mintpd, w, all_minima) Arguments Type Intent Optional Attributes Name class( BaseModel ), target :: model Thermodynamic model real(kind=pr), intent(in) :: z (:) Feed composition real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: mintpd Minimal value of real(kind=pr), intent(out) :: w (:) Trial composition real(kind=pr), intent(out), optional :: all_minima (:,:) All the found minima","tags":"","url":"module/yaeos__equilibria_stability.html"},{"title":"yaeos__tapenade_interfaces – yaeos","text":"Uses yaeos__constants Interfaces interface public  subroutine POPREAL8(a) Arguments Type Intent Optional Attributes Name real(kind=pr) :: a interface public  subroutine POPREAL8ARRAY(a, n) Arguments Type Intent Optional Attributes Name real(kind=pr), dimension(n) :: a integer :: n interface public  subroutine popinteger4(i) Arguments Type Intent Optional Attributes Name integer :: i interface public  subroutine pushinteger4(i) Arguments Type Intent Optional Attributes Name integer :: i interface public  subroutine pushreal8(a) Arguments Type Intent Optional Attributes Name real(kind=pr) :: a interface public  subroutine pushreal8array(a, n) Arguments Type Intent Optional Attributes Name real(kind=pr), dimension(n) :: a integer :: n","tags":"","url":"module/yaeos__tapenade_interfaces.html"},{"title":"yaeos__models_solvers – yaeos","text":"models solvers Set of different specialized solvers for different models Description This module holds specialized solvers for different kind of applications\nand models. Volume solving This module holds the routine volume_michelsen which is a solver for\nvolume that takes advantage over a simple newton on the function of\npressure by solving the function of pressure over the covolume instead,\nwhich solution is limited in the range [0, 1]. This solver requires that\nthe EoS uses the method get_v0 to return the covolume. Examples A basic code example References Uses yaeos__constants yaeos__models_ar Subroutines public  subroutine solve_point (eos, n, P, T, V, Pcalc, ZETA, ZETMIN, ZETMAX, AT, iter) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: P Objective pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: V Obtained volume [L] real(kind=pr), intent(out) :: Pcalc Calculated pressure at V [bar] real(kind=pr), intent(inout) :: ZETA real(kind=pr), intent(inout) :: ZETMIN real(kind=pr), intent(inout) :: ZETMAX real(kind=pr), intent(out) :: AT integer, intent(out) :: iter public  subroutine volume_michelsen (eos, n, P, T, V, root_type, max_iters, V0) Volume solver at a given pressure. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: eos real(kind=pr), intent(in) :: n (:) Mixture moles real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out) :: V Volume [L] character(len=*), intent(in), optional :: root_type Type of root [“vapor” | “liquid” | “stable”] integer, intent(in), optional :: max_iters Maxiumum number of iterations, defaults to 100 real(kind=pr), intent(in), optional :: V0 Specified initial volume","tags":"","url":"module/yaeos__models_solvers.html"},{"title":"yaeos__equilibria_boundaries_pure_saturation – yaeos","text":"Uses linear_interpolation_module yaeos__models_ar yaeos__math_linalg yaeos__math_continuation yaeos__constants Derived Types type, public :: PurePsat Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: P (:) Pressure [Pa] real(kind=pr), public, allocatable :: T (:) Temperature [K] real(kind=pr), public, allocatable :: Vx (:) Molar volume [L/mol] in the liquid phase real(kind=pr), public, allocatable :: Vy (:) Molar volume [L/mol] in the vapor phase type(linear_interp_1d), private :: interpolator_get_P type(linear_interp_1d), private :: interpolator_get_T Type-Bound Procedures procedure, public :: get_P procedure, public :: get_T Functions public  function get_P (pt, T) result(P) Get the saturation pressure for a given temperature. Read more… Arguments Type Intent Optional Attributes Name class( PurePsat ), intent(inout) :: pt real(kind=pr), intent(in) :: T Return Value real(kind=pr) public  function get_T (pt, P) result(T) Get the saturation temperature for a given pressure. Read more… Arguments Type Intent Optional Attributes Name class( PurePsat ), intent(inout) :: pt real(kind=pr), intent(in) :: P Return Value real(kind=pr) public  function pure_saturation_line (model, component, minP, minT) result(pt) Saturation pressures and temperatures for a pure component. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Thermodyanmic model integer, intent(in) :: component Component index to calculate the line real(kind=pr), intent(in) :: minP Minimum pressure [bar] real(kind=pr), intent(in) :: minT Minimum temperature [K] Return Value type( PurePsat ) Subroutines public  subroutine solve_point (model, ncomp, nc, X, ns, S, F, dF, dFdS, its) Solve a saturation point for a pure component. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Thermodynamic model integer, intent(in) :: ncomp Component index integer, intent(in) :: nc Total number of components real(kind=pr), intent(inout) :: X (4) Variables integer, intent(in) :: ns Variable index to solve. If the real(kind=pr), intent(in) :: S Variable value specified to solve real(kind=pr), intent(out) :: F (4) Function real(kind=pr), intent(out) :: dF (4,4) Jacobian real(kind=pr), intent(out) :: dFdS (4) Derivative of the function with respect to S integer, intent(out) :: its Number of iterations","tags":"","url":"module/yaeos__equilibria_boundaries_pure_saturation.html"},{"title":"yaeos__equilibria_boundaries_phase_envelopes_mp – yaeos","text":"Multiphase PT envelope calculation module. This module contains the functions to calculate the PT envelope of a\nmixture with multiple phases. Uses yaeos__equilibria_equilibrium_state yaeos__constants yaeos__math yaeos__models_ar Derived Types type, public :: PTEnvelMP Multiphase PT envelope. Components Type Visibility Attributes Name Initial type( MPPoint ), public, allocatable :: points (:) Array of converged points. Type-Bound Procedures procedure, public, nopass :: get_values_from_X procedure, public, nopass :: solve_point procedure, public :: write => write_envelope_PT_MP type, private :: MPPoint Multiphase equilibria point. Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: T Temperature [K] real(kind=pr), public :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), public, allocatable :: betas (:) Fractions of the main phases. integer, public :: iters Number of iterations needed to converge the point. integer, public :: nc Number of components integer, public :: np Number of phases integer, public :: ns Number of the specified variable. real(kind=pr), public, allocatable :: w (:) Mole fractions of the incipient phase. real(kind=pr), public, allocatable :: x_l (:,:) Mole fractions of the main phases. Functions public  function pt_envelope (model, z, np, x_l0, w0, betas0, P0, T0, ns0, dS0, beta_w, points, max_pressure) Calculation of a multiphase PT envelope. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z (:) Mixture global composition. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: x_l0 (np,size(z)) Initial guess for the mole fractions of each phase. arranged as\nan array of size (np, nc) , where nc is the number of components\nand np the number of main phases. Each row correspond to the\ncomposition of each main phaase. real(kind=pr), intent(in) :: w0 (size(z)) Initial guess for the mole fractions of the\nreference/incipient phase. real(kind=pr), intent(in) :: betas0 (np) Initial guess for the fractions of the main phases. arranged as\nan array of size (np) , where np is the number of main phases. real(kind=pr), intent(in) :: P0 Initial guess for the pressure [bar]. real(kind=pr), intent(in) :: T0 Initial guess for the temperature [K]. integer, intent(in) :: ns0 Number of the specified variable.\nThe variable to be specified. This is the variable that will be\nused to calculate the first point of the envelope. The variable\ncan be any of the variables in the vector X, but it is recommended\nto use the temperature or pressure. The variables are aranged as\nfollows: Read more… real(kind=pr), intent(in) :: dS0 Step size of the specification for the next point.\nThis is the step size that will be used to calculate the next point.\nInside the algorithm this value is modified to adapt the step size\nto facilitate the convergence of each point. real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. integer, intent(in), optional :: points Number of points to calculate. real(kind=pr), intent(in), optional :: max_pressure Maximum pressure [bar] to calculate.\nIf the pressure of the point is greater than this value, the\ncalculation is stopped.\nThis is useful to avoid calculating envelopes that go to infinite\nvalues of pressure. Return Value type( PTEnvelMP ) Subroutines public  subroutine pt_F_NP (model, z, np, beta_w, X, ns, S, F, df) Function to solve at each point of a multi-phase envelope. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z (:) Mixture global composition. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase. real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: ns Number of specification. real(kind=pr), intent(in) :: S Specification value. real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated. real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix. private  subroutine detect_critical (nc, np, X, dXdS, ns, dS, S) Detect if the system is close to a critical point. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. real(kind=pr), intent(inout) :: S Specification value. private  subroutine get_values_from_X (X, np, z, x_l, w, betas, P, T) Extract the values of the variables from the vector X. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) Vector of variables. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(in) :: z (:) Mixture composition. real(kind=pr), intent(out) :: x_l (np,size(z)) Mole fractions of the main phases. real(kind=pr), intent(out) :: w (size(z)) Mole fractions of the incipient phase. real(kind=pr), intent(out) :: betas (np) Fractions of the main phases. real(kind=pr), intent(out) :: P Pressure [bar]. real(kind=pr), intent(out) :: T Temperature [K]. private  subroutine solve_point (model, z, np, beta_w, X, ns, S, dXdS, F, df, iters, max_iterations) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Model to use. real(kind=pr), intent(in) :: z (:) Mixture global composition. integer, intent(in) :: np Number of main phases real(kind=pr), intent(in) :: beta_w Fraction of the reference (incipient) phase real(kind=pr), intent(inout) :: X (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(in) :: dXdS (size(X)) real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian matrix integer, intent(out) :: iters Number of iterations to solve the current point integer, intent(in) :: max_iterations Maximum number of iterations to solve the point private  subroutine update_specification (its, nc, np, X, dF, dXdS, ns, dS) Change the specified variable for the next step. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: its Iterations to solve the current point. integer, intent(in) :: nc Number of components in the mixture. integer, intent(in) :: np Number of main phases. real(kind=pr), intent(inout) :: X (:) Vector of variables. real(kind=pr), intent(inout) :: dF (:,:) Jacobian matrix. real(kind=pr), intent(inout) :: dXdS (:) Sensitivity of the variables wrt the specification. integer, intent(inout) :: ns Number of the specified variable. real(kind=pr), intent(inout) :: dS Step size of the specification for the next point. private  subroutine write_envelope_PT_MP (env, unit) Arguments Type Intent Optional Attributes Name class( PTEnvelMP ), intent(in) :: env integer, intent(in) :: unit","tags":"","url":"module/yaeos__equilibria_boundaries_phase_envelopes_mp.html"},{"title":"yaeos__models_base – yaeos","text":"Basic element of a thermodynamic model. Uses yaeos__substance Derived Types type, public, abstract :: BaseModel Base model type. Read more… Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module","tags":"","url":"module/yaeos__models_base.html"},{"title":"yaeos__tapenade_ar_api – yaeos","text":"Module that wraps tapenade generated routines to calculate !\nAr and derivatives. Uses yaeos__constants yaeos__models_ar Abstract Interfaces abstract interface private  subroutine tapenade_ar(model, n, v, t, arval) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: arval abstract interface private  subroutine tapenade_ar_b(model, n, nb, v, vb, t, tb, arval, arvalb) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: arval real(kind=pr) :: arvalb abstract interface private  subroutine tapenade_ar_d(model, n, nd, v, vd, t, td, arval, arvald) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald abstract interface private  subroutine tapenade_ar_d_b(model, n, nb, nd, ndb, v, vb, vd, vdb, t, tb, td, tdb, arval, arvalb, arvald, arvaldb) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr) :: ndb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: vd real(kind=pr) :: vdb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr), intent(in) :: td real(kind=pr) :: tdb real(kind=pr) :: arval real(kind=pr) :: arvalb real(kind=pr) :: arvald real(kind=pr) :: arvaldb abstract interface private  subroutine tapenade_ar_d_d(model, n, nd, v, vd0, vd, t, td0, td, arval, arvald0, arvald, arvaldd) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd0 real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald0 real(kind=pr), intent(out) :: arvald real(kind=pr), intent(out) :: arvaldd Derived Types type, public, abstract, extends( ArModel ) :: ArModelTapenade Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure, public :: Cp_residual_vt procedure, public :: Cv_residual_vt procedure, public :: Psat_pure procedure( tapenade_ar ), public, deferred :: ar procedure( tapenade_ar_b ), public, deferred :: ar_b procedure( tapenade_ar_d ), public, deferred :: ar_d procedure( tapenade_ar_d_b ), public, deferred :: ar_d_b procedure( tapenade_ar_d_d ), public, deferred :: ar_d_d procedure, public :: enthalpy_residual_vt procedure, public :: entropy_residual_vt procedure( abs_volume_initializer ), public, deferred :: get_v0 procedure, public :: gibbs_residual_vt procedure, public :: internal_energy_residual_vt procedure, public :: lnfug_vt procedure, public :: lnphi_pt procedure, public :: lnphi_vt procedure, public :: pressure procedure, public :: residual_helmholtz procedure, public :: volume Subroutines private  subroutine residual_helmholtz (self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz model generic interface Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","url":"module/yaeos__tapenade_ar_api.html"},{"title":"yaeos__models – yaeos","text":"yaeos thermodynamic models On yaeos there are implemented a series of both residual Helmholtz\nenergy ( ) and excess Gibbs energy ( ) models. This module takes all the relevant procedures and derived types\nrelated to them. Residual Helmholtz model base type ArModel base derived type\n  that provides the basic structure that a residual Helmholtz model\n  should provide. Cubic Equations of state : AlphaFunction type CubicEos type that extends ArModel to use a generic\n     two-parameter EoS. Implemented models that use this type can be\n     seen at yaeos__models_ar_cubic_implementations QMR (Quadratic Mixing Rule) type: extensible derived type that\n      defaults to classic vdW mixing rules. MHV (Modified Huron-Vidal) type: Michelsens first order modified\n      Huron-Vidal mixing rule. GERG2008 Equation of State : GERG2008 multifluid equation of state Uses yaeos__models_cubic_mixing_rules_huron_vidal yaeos__models_ar_gerg2008 yaeos__models_ge yaeos__models_ge_implementations yaeos__models_ar yaeos__models_ar_cubic_quadratic_mixing yaeos__models_base yaeos__models_ar_cubic_implementations yaeos__models_ar_cubic_alphas yaeos__models_ar_genericcubic","tags":"","url":"module/yaeos__models.html"},{"title":"yaeos__tapenade_ge_api – yaeos","text":"Module that wraps tapenade generated routines to calculate !\nGe and derivatives. Uses yaeos__models_ge yaeos__constants Abstract Interfaces abstract interface private  subroutine tapenade_ge(model, n, t, ge) Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ge abstract interface private  subroutine tapenade_ge_b(model, n, nb, t, tb, ge, geb) Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: ge real(kind=pr) :: geb abstract interface private  subroutine tapenade_ge_d(model, n, nd, t, td, ge, ged) Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged abstract interface private  subroutine tapenade_ge_d_b(model, n, nb, nd, ndb, t, tb, td, tdb, ge, geb, ged, gedb) Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr) :: ndb (:) real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr), intent(in) :: td real(kind=pr) :: tdb real(kind=pr) :: ge real(kind=pr) :: geb real(kind=pr) :: ged real(kind=pr) :: gedb abstract interface private  subroutine tapenade_ge_d_d(model, n, nd, t, td0, td, ge, ged0, ged, gedd) Arguments Type Intent Optional Attributes Name class( GeModelTapenade ) :: model real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: ge real(kind=pr), intent(out) :: ged0 real(kind=pr), intent(out) :: ged real(kind=pr), intent(out) :: gedd Derived Types type, public, abstract, extends( GeModel ) :: GeModelTapenade Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module Type-Bound Procedures procedure, public :: excess_enthalpy procedure, public :: excess_entropy procedure, public :: excess_gibbs procedure( tapenade_ge ), public, deferred :: ge procedure( tapenade_ge_b ), public, deferred :: ge_b procedure( tapenade_ge_d ), public, deferred :: ge_d procedure( tapenade_ge_d_b ), public, deferred :: ge_d_b procedure( tapenade_ge_d_d ), public, deferred :: ge_d_d procedure, public :: ln_activity_coefficient Subroutines private  subroutine excess_gibbs (self, n, t, Ge, GeT, GeT2, Gen, GeTn, Gen2) Excess Gibbs model generic interface Arguments Type Intent Optional Attributes Name class( GeModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ge real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Gen real(kind=pr), intent(out), optional, dimension(size(n)) :: GeTn real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n))","tags":"","url":"module/yaeos__tapenade_ge_api.html"},{"title":"yaeos__models_ge_group_contribution_unifac – yaeos","text":"UNIFAC module Classic liquid-vapor UNIFAC model implementation module. Description Classic liquid-vapor UNIFAC model implementation module. The\nimplementation is based on the Thermopack library (SINTEF) implementation. Examples ! Instantiate an UNIFAC model with ethanol-water mix and calculate gammas use yaeos , only : pr , Groups , setup_unifac , UNIFAC type ( UNIFAC ) :: model type ( Groups ) :: molecules ( 2 ) real ( pr ) :: ln_gammas ( 2 ) ! Ethanol definition [CH3, CH2, OH] molecules ( 1 )% groups_ids = [ 1 , 2 , 14 ] ! Subgroups ids molecules ( 1 )% number_of_groups = [ 1 , 1 , 1 ] ! Subgroups occurrences ! Water definition [H2O] molecules ( 2 )% groups_ids = [ 16 ] molecules ( 2 )% number_of_groups = [ 1 ] ! Model setup model = setup_unifac ( molecules ) ! Calculate ln_gammas call model % ln_activity_coefficient ([ 0.5_pr , 0.5_pr ], 29 8.0_pr , ln_gammas ) print * , ln_gammas ! result: 0.18534142000449058    0.40331395945417559 References Dortmund Data Bank Software & Separation Technology Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975).\nGroup‐contribution estimation of activity coefficients in nonideal liquid\nmixtures. AIChE Journal, 21(6), 1086–1099. https://doi.org/10.1002/aic.690210607 Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979).\nVapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and\nExtension. Industrial & Engineering Chemistry Process Design and\nDevelopment, 18(4), 714–722. https://doi.org/10.1021/i260072a024 Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid\nequilibriums by UNIFAC group contribution. Revision and extension. 2.\nIndustrial & Engineering Chemistry Process Design and Development, 21(1),\n118–127. https://doi.org/10.1021/i200016a021 Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983).\nVapor-liquid equilibriums by UNIFAC group contribution. Revision and\nextension. 3. Industrial & Engineering Chemistry Process Design and\nDevelopment, 22(4), 676–678. https://doi.org/10.1021/i200023a023 Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987).\nVapor-liquid equilibria by UNIFAC group contribution. 4. Revision and\nextension. Industrial & Engineering Chemistry Research, 26(1), 159–161. https://doi.org/10.1021/ie00061a030 Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., &\nGmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group\ncontribution. 5. Revision and extension. Industrial & Engineering\nChemistry Research, 30 (10), 2352–2355. https://doi.org/10.1021/ie00058a017 Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria\nby UNIFAC Group Contribution. 6. Revision and Extension. Industrial &\nEngineering Chemistry Research, 42(1), 183–188. https://doi.org/10.1021/ie020506l SINTEF - Thermopack Uses yaeos__models_ge_group_contribution_unifac_parameters yaeos__models_ge yaeos__models_ge_group_contribution_model_parameters yaeos__constants yaeos__models_ge_group_contribution_groups yaeos__models_ge_gc_td Derived Types type, public, extends( GeModel ) :: UNIFAC Classic liquid-vapor UNIFAC model derived type Read more… Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module real(kind=pr), public :: d = 1.0_pr Model constant d, exponent of the group volume in Flory-Huggins real(kind=pr), public, allocatable :: group_area (:) Group areas real(kind=pr), public, allocatable :: group_volume (:) Group volumes type( Groups ), public :: groups_stew All the groups present in the system type( Groups ), public, allocatable :: molecules (:) Substances present in the system integer, public :: ngroups Total number of individual groups in the mixture integer, public :: nmolecules Total number of molecules in the mixture class( PsiFunction ), public, allocatable :: psi_function Temperature dependance function of the model real(kind=pr), public, allocatable :: qk (:) Area of each group k real(kind=pr), public, allocatable :: thetas_ij (:,:) Area fractions of the groups j on molecules i real(kind=pr), public, allocatable :: vij (:,:) Ocurrences of each group j on each molecule i real(kind=pr), public :: z = 10.0_pr Model constant z Type-Bound Procedures procedure, public :: Ge_combinatorial procedure, public :: Ge_residual procedure, public :: excess_enthalpy procedure, public :: excess_entropy procedure, public :: excess_gibbs procedure, public :: ln_activity_coefficient Functions public  function setup_unifac (molecules, parameters) Instantiate a UNIFAC model Read more… Arguments Type Intent Optional Attributes Name type( Groups ), intent(in) :: molecules (:) Molecules (Group type) objects type( GeGCModelParameters ), intent(in), optional :: parameters UNIFAC parameters Return Value type( UNIFAC ) public  function thetas_i (nm, ng, parameters, stew, molecules) result(thetas_ij) Calculate the area fraciton of each froup on each molecule. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nm Number of molecules integer, intent(in) :: ng Number of groups type( GeGCModelParameters ), intent(in) :: parameters UNIFAC parameters type( Groups ), intent(in) :: stew All the groups present in the system type( Groups ), intent(in) :: molecules (:) Molecules Return Value real(kind=pr), (nm,ng) Group j area fraction on molecule i Subroutines public  subroutine Ge_combinatorial (self, n, T, Ge, dGe_dn, dGe_dn2) Calculate the UNIFAC combinatorial term of Gibbs excess energy Read more… Arguments Type Intent Optional Attributes Name class( UNIFAC ) :: self real(kind=pr), intent(in) :: n (self%nmolecules) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Combinatorial Gibbs excess energy real(kind=pr), intent(out), optional :: dGe_dn (self%nmolecules) real(kind=pr), intent(out), optional :: dGe_dn2 (self%nmolecules,self%nmolecules) public  subroutine Ge_residual (self, n, T, Ge, dGe_dn, dGe_dn2, dGe_dT, dGe_dT2, dGe_dTn) Evaluate the UNIFAC residual term Read more… Arguments Type Intent Optional Attributes Name class( UNIFAC ) :: self real(kind=pr), intent(in) :: n (self%nmolecules) Moles vector real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Residual Gibbs excess energy real(kind=pr), intent(out), optional :: dGe_dn (self%nmolecules) real(kind=pr), intent(out), optional :: dGe_dn2 (self%nmolecules,self%nmolecules) real(kind=pr), intent(out), optional :: dGe_dT real(kind=pr), intent(out), optional :: dGe_dT2 real(kind=pr), intent(out), optional :: dGe_dTn (self%nmolecules) public  subroutine excess_gibbs (self, n, T, Ge, GeT, GeT2, Gen, GeTn, Gen2) Calculate the Gibbs excess energy of the UNIFAC model Read more… Arguments Type Intent Optional Attributes Name class( UNIFAC ), intent(in) :: self UNIFAC model real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(out), optional :: Ge Excess Gibbs energy real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional :: Gen (size(n)) real(kind=pr), intent(out), optional :: GeTn (size(n)) real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n))","tags":"","url":"module/yaeos__models_ge_group_contribution_unifac.html"},{"title":"ar_interface – yaeos","text":"Uses yaeos__constants iso_fortran_env Variables Type Visibility Attributes Name Initial procedure( Ares ), public, pointer :: ar_fun procedure( initial_volume ), public, pointer :: vinit Abstract Interfaces abstract interface public  subroutine Ares(z, v, t, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) abstract interface public  function initial_volume(z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr)","tags":"","url":"module/ar_interface.html"},{"title":"yaeos__math – yaeos","text":"Mathematical methods for yaeos Description This module provides all the relevant mathematical functions used in this\nlibrary. Most important ones are: newton: Newton solving method solve_system: Solving linear system Ax = b continuation: Continuation method for line tracing Examples Squared error calculation use yaeos__math , only : sq_error real ( pr ) :: x = 2.5 , y = 3.0 , error print * , sq_error ( 2.5 , 3.0 ) ------------------------------------ use yaeos__math , only : sq_error real ( pr ) :: x = [ 2.5 , 5.0 ], y = [ 3.0 , 4.5 ], error ! It also works with arrays print * , sq_error ( x , y ) Uses yaeos__constants yaeos__math_linalg yaeos__math_continuation Interfaces public        interface newton public  subroutine newton_1d (f, x, tol, max_iters) Arguments Type Intent Optional Attributes Name procedure( f_1d ) :: f real(kind=pr), intent(inout) :: x real(kind=pr), intent(in) :: tol integer, intent(in) :: max_iters Abstract Interfaces abstract interface public  subroutine f_1d(x, f, df) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x real(kind=pr), intent(out) :: f real(kind=pr), intent(out) :: df Functions public  function derivative_d2xk_dnidnj (n) result(d2xk_dnidnj) Calculate the mole fraction second derivatives respect to mole numbers Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) Return Value real(kind=pr), (size(n),size(n),size(n)) public  function derivative_dxk_dni (n) result(dxk_dni) Calculate the mole fraction first derivatives respect to mole numbers Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) Return Value real(kind=pr), (size(n),size(n)) public  function dx_to_dn (x, dx) result(dn) Convert the mole fraction derivatives of a quantity (calculated\nso they do not sum to 1) to mole number derivatives (where the mole\nfractions do sum to one). Requires the derivatives and the mole fractions\nof the mixture.\nFrom https://chemicals.readthedocs.io/chemicals.utils.html?highlight=dxs_to_dns#chemicals.utils.dxs_to_dns Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x (:) real(kind=pr), intent(in) :: dx (:) Return Value real(kind=pr), (size(x)) public elemental function interpol (x1, x2, y1, y2, x_obj) result(y) Linear interpolation. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x1 First point x value real(kind=pr), intent(in) :: x2 Second point x value real(kind=pr), intent(in) :: y1 First point y value real(kind=pr), intent(in) :: y2 Second point y value real(kind=pr), intent(in) :: x_obj Desired x value to interpolate Return Value real(kind=pr) y value at x_obj public elemental function sq_error (exp, pred) … Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: exp real(kind=pr), intent(in) :: pred Return Value real(kind=pr) Subroutines public  subroutine newton_1d (f, x, tol, max_iters) Arguments Type Intent Optional Attributes Name procedure( f_1d ) :: f real(kind=pr), intent(inout) :: x real(kind=pr), intent(in) :: tol integer, intent(in) :: max_iters","tags":"","url":"module/yaeos__math.html"},{"title":"yaeos__equilibria_binaries – yaeos","text":"Module with routines particular to binary mixtures. Uses yaeos__constants yaeos__models Subroutines public  subroutine find_llcl (model, z0, zi, P, a, V, T) Find an initial guess for the critical L-L line of a binary mixture. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z0 (2) Mole fractions of original fluid real(kind=pr), intent(in) :: zi (2) Mole fractions of new fluid real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(out) :: a Mole fraction of new fluid real(kind=pr), intent(out) :: V Volume [L/mol] real(kind=pr), intent(inout) :: T Temperature [K]","tags":"","url":"module/yaeos__equilibria_binaries.html"},{"title":"yaeos__equilibria_critical – yaeos","text":"Uses yaeos__equilibria_equilibrium_state yaeos__constants yaeos__models Variables Type Visibility Attributes Name Initial type( CPSpecs ), public, parameter :: spec_CP = CPSpecs() Specification variables for a critical point or critical line\ncalculation. Derived Types type, public :: CriticalLine This derived type is used to store a critical line between two fluids.\nThe critical line is calculated using the critical_line function. It\nuses the continuation method. Read more… Components Type Visibility Attributes Name Initial type( EquilibriumState ), public :: CEP Critical End Point real(kind=pr), public, allocatable :: P (:) Pressure [bar] real(kind=pr), public, allocatable :: T (:) Temperature [K] real(kind=pr), public, allocatable :: V (:) Volume [L/mol] real(kind=pr), public, allocatable :: a (:) Molar fraction of the second fluid integer, public, allocatable :: iters (:) Iterations needed for this point integer, public, allocatable :: ns (:) Specified variable real(kind=pr), public, allocatable :: z0 (:) Molar fractions of the first fluid real(kind=pr), public, allocatable :: zi (:) Molar fractions of the second fluid type, private :: CPSpecs Enumerator to handle the possible specifications for a critical point. Components Type Visibility Attributes Name Initial integer, public :: P = 4 Specify integer, public :: T = 3 Specify integer, public :: V = 2 Specify integer, public :: a = 1 Specify Functions public  function F_critical (model, X, ns, S, z0, zi, u) Function that should be equal to zero at a critical point is found.\nThe second criticality condition is calculated as a numerical\nderivative with eps=1e-4 . Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: X (4) Vector of variables integer, intent(in) :: ns Position of the specification variable real(kind=pr), intent(in) :: S Specification variable value real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid real(kind=pr), intent(inout) :: u (:) Eigen-vector Return Value real(kind=pr), (4) public  function critical_line (model, a0, z0, zi, ns0, S0, dS0, v0, t0, p0, max_points, maxP, first_point, stability_analysis) Calculates the critical line between two mixtures using the\ncontinuation method. The two mixtures compositions are restricted to\nthe relation between them, by a parameter , which represents\nthe molar fraction of the second fluid with respect to the whole\nmixture. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: a0 Initial value real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid integer, intent(in) :: ns0 Position of the specification variable real(kind=pr), intent(in) :: S0 Specified value real(kind=pr), intent(in) :: dS0 Initial step size real(kind=pr), intent(in), optional :: v0 Initial volume [L/mol] real(kind=pr), intent(in), optional :: t0 Initial temperature [K] real(kind=pr), intent(in), optional :: p0 Initial pressure [bar] integer, intent(in), optional :: max_points Maximum number of points real(kind=pr), intent(in), optional :: maxP Maximum pressure type( EquilibriumState ), intent(in), optional :: first_point logical, optional :: stability_analysis Return Value type( CriticalLine ) public  function critical_point (model, z0, zi, spec, S, max_iters, V0, T0, a0, P0) Calculates a single critical point of a mixture using a Newton-Raphson\nmethod. It is possible to specify different variables to be fixed with\nthe spec argument, the spec_CP variable helps when selecting the\nspecified variable. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid integer, intent(in) :: spec Specification [1:\"z\", 2:\"V\", 3:\"T\", 4:\"P\"] real(kind=pr), intent(in) :: S Specification value integer, intent(in) :: max_iters Maxiumum number of iterations real(kind=pr), intent(in), optional :: V0 Initial volume [L/mol]. real(kind=pr), intent(in), optional :: T0 Initial temperature [K]. real(kind=pr), intent(in), optional :: a0 Initial value real(kind=pr), intent(in), optional :: P0 Initial Pressure [bar] Return Value type( EquilibriumState ) public  function df_critical (model, X, ns, S, z0, zi, u) Calculates the Jacobian of the critical point function F_critical . Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: X (4) Vector of variables integer, intent(in) :: ns Position of the specification variable real(kind=pr), intent(in) :: S Specification variable value real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid real(kind=pr), intent(inout) :: u (:) Eigen-vector Return Value real(kind=pr), (4,4) Jacobian of the critical point function public  function lambda1 (model, X, s, z0, zi, u, u_new, P) Calculation of the first restriction of a critical point. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: X (4) Vector of variables real(kind=pr), intent(in) :: s Distance between the two fluids compositions to the main composition real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid real(kind=pr), intent(in) :: u (:) Eigen-vector that defines the direction between the two compositions real(kind=pr), intent(out), optional :: u_new (:) Eigen-vector corresponding to the smallest eigenvalue of the matrix real(kind=pr), intent(out), optional :: P Pressure of the system [bar] Return Value real(kind=pr) private  function F_cep (model, nc, X, z0, zi, u) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model integer, intent(in) :: nc real(kind=pr), intent(in) :: X (nc+4) Vector of variables real(kind=pr), intent(in) :: z0 (nc) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (nc) Molar fractions of the second fluid real(kind=pr), intent(inout) :: u (nc) Eigen-vector Return Value real(kind=pr), (nc+4) private  function df_cep (model, nc, X, z0, zi, u) Calculates the Jacobian of the critical point function F_critical . Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model integer, intent(in) :: nc real(kind=pr), intent(in) :: X (nc+4) Vector of variables real(kind=pr), intent(in) :: z0 (nc) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (nc) Molar fractions of the second fluid real(kind=pr), intent(inout) :: u (nc) Eigen-vector Return Value real(kind=pr), (nc+4,nc+4) Jacobian of the critical point function private  function get_a (X) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X Return Value real(kind=pr) private  function set_a (a) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: a Return Value real(kind=pr) Subroutines private  subroutine look_for_cep (model, z0, zi, Pc, Vc, Tc, a, u, found, CEP) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid real(kind=pr), intent(in) :: Pc Pressure [bar] real(kind=pr), intent(in) :: Vc Volume [L/mol] real(kind=pr), intent(in) :: Tc Temperature [K] real(kind=pr), intent(in) :: a Molar fraction of the second fluid real(kind=pr), intent(inout) :: u (:) Eigen-vector logical, intent(out) :: found Found a Critical End Point type( EquilibriumState ), intent(out) :: CEP Critical End Point private  subroutine stability_check (model, z0, zi, Pc, Vc, Tc, a, unstable, y_other, V_other) Check the stability of a point in the critical line. The stability is\ndetermined by tpd analysis. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: z0 (:) Molar fractions of the first fluid real(kind=pr), intent(in) :: zi (:) Molar fractions of the second fluid real(kind=pr), intent(in) :: Pc Pressure [bar] real(kind=pr), intent(in) :: Vc Volume [L/mol] real(kind=pr), intent(in) :: Tc Temperature [K] real(kind=pr), intent(in) :: a Molar fraction of the second fluid logical, intent(out) :: unstable Stability of the point) real(kind=pr), intent(out) :: y_other (:) Molar fractions of the second fluid real(kind=pr), intent(out) :: V_other Volume [L/mol]","tags":"","url":"module/yaeos__equilibria_critical.html"},{"title":"yaeos__models_ge_group_contribution_model_parameters – yaeos","text":"group contribution model parameters group contribution model parameters module. Description This module contrains the GeGCModelParameters type that allows to store\nthe subgroups ids, maingroups ids, subgroups Rs, subgroups Qs,\nsubgroups maingroups, and maingroups interaction parameters for UNIFAC\nlike models (UNIFAC, LL-UNIFAC, Dortmund UNIFAC, PSRK, etc) Uses yaeos__constants Derived Types type, public :: GeGCModelParameters group contribution model parameters container Read more… Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: maingroups_aij (:,:) Maingroup interaction parameters matrix real(kind=pr), public, allocatable :: maingroups_bij (:,:) Maingroup interaction parameters matrix real(kind=pr), public, allocatable :: maingroups_cij (:,:) Maingroup interaction parameters matrix integer, public, allocatable :: maingroups_ids (:) ID of each model’s maingroup real(kind=pr), public, allocatable :: subgroups_Qs (:) value of each subgroup real(kind=pr), public, allocatable :: subgroups_Rs (:) value of each subgroup integer, public, allocatable :: subgroups_ids (:) ID of each model’s subgroup integer, public, allocatable :: subgroups_maingroups (:) Maingroup of each subgroup Type-Bound Procedures procedure, public :: check_consistency procedure, public :: get_maingroup_index procedure, public :: get_maingroups_aij procedure, public :: get_maingroups_bij procedure, public :: get_maingroups_cij procedure, public :: get_subgroup_Q procedure, public :: get_subgroup_R procedure, public :: get_subgroup_index procedure, public :: get_subgroup_maingroup procedure, public :: get_subgroups_aij procedure, public :: get_subgroups_bij procedure, public :: get_subgroups_cij Functions public  function get_maingroup_index (self, maingroup_id) result(maingroup_idx) Get index of the maingoup with id: maingoup_id Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_id ID of the subgroup Return Value integer Index of the maingroup on the self%maingroups_ids vector public  function get_maingroups_aij (self, maingroup_i_id, maingroup_j_id) result(aij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_i_id ID of the maingroup i integer, intent(in) :: maingroup_j_id ID of the maingroup j Return Value real(kind=pr) Interaction parameter public  function get_maingroups_bij (self, maingroup_i_id, maingroup_j_id) result(bij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_i_id ID of the maingroup i integer, intent(in) :: maingroup_j_id ID of the maingroup j Return Value real(kind=pr) Interaction parameter public  function get_maingroups_cij (self, maingroup_i_id, maingroup_j_id) result(cij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: maingroup_i_id ID of the maingroup i integer, intent(in) :: maingroup_j_id ID of the maingroup j Return Value real(kind=pr) Interaction parameter public  function get_subgroup_Q (self, subgroup_id) result(subgroup_Q) Get the subgroup’s value Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value real(kind=pr) value of the subgroup public  function get_subgroup_R (self, subgroup_id) result(subgroup_R) Get the subgroup’s value Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value real(kind=pr) value of the subgroup public  function get_subgroup_index (self, subgroup_id) result(subgroup_idx) Get index of the subgroup with id: subgroup_id Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value integer Index of the subgroup on the self%subgroups_ids vector public  function get_subgroup_maingroup (self, subgroup_id) result(subgroup_maingroup) Get the subgroup’s maingroup Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_id ID of the subgroup Return Value integer Maingroup of the subgroup public  function get_subgroups_aij (self, subgroup_i_id, subgroup_j_id) result(aij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_i_id ID of the subgroup i integer, intent(in) :: subgroup_j_id ID of the subgroup j Return Value real(kind=pr) Interaction parameter public  function get_subgroups_bij (self, subgroup_i_id, subgroup_j_id) result(bij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_i_id ID of the subgroup i integer, intent(in) :: subgroup_j_id ID of the subgroup j Return Value real(kind=pr) Interaction parameter public  function get_subgroups_cij (self, subgroup_i_id, subgroup_j_id) result(cij) Get the interaction parameter Read more… Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ) :: self integer, intent(in) :: subgroup_i_id ID of the subgroup i integer, intent(in) :: subgroup_j_id ID of the subgroup j Return Value real(kind=pr) Interaction parameter Subroutines public  subroutine check_consistency (self) Arguments Type Intent Optional Attributes Name class( GeGCModelParameters ), intent(in) :: self","tags":"","url":"module/yaeos__models_ge_group_contribution_model_parameters.html"},{"title":"yaeos__consistency_gemodel – yaeos","text":"yaeos__consistency_gemodel Consistency checks of Helmholtz free energy models ( GeModel ). Description This module contains tools to validate the analityc derivatives of\nimplmented excess Gibbs free energy models ( GeModel ). Also, allows to\nevaluate the consistency tests described in Thermodynamic Models:\nFundamentals & Computational Aspects 2 ed. by Michelsen and Mollerup\nChapter 5 section 4. Available tools: numeric_ge_derivatives : From an instantiated GeModel evaluate\nall the excess Gibbs free energy derivatives from the central finite\ndifference method. ge_consistency : From an instantiated GeModel evaluate all the\nMichelsen and Mollerup consistency tests References Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models:\nFundamentals & computational aspects (2. ed). Tie-Line Publications. Uses yaeos__models_ge yaeos__constants Subroutines public  subroutine ge_consistency (model, n, t, eq58, eq59, eq60, eq61) models consistency tests Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: model model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: eq58 MM Eq. 58 real(kind=pr), intent(out), optional :: eq59 (size(n)) MM Eq. 59 real(kind=pr), intent(out), optional :: eq60 (size(n),size(n)) MM Eq. 60 real(kind=pr), intent(out), optional :: eq61 (size(n)) MM Eq. 61 public  subroutine numeric_ge_derivatives (model, n, t, d_n, d_t, Ge, GeT, Gen, GeT2, GeTn, Gen2) Numeric model derivatives Read more… Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: model model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in) :: d_n Moles finite difference step real(kind=pr), intent(in) :: d_t Temperature finite difference step real(kind=pr), intent(out) :: Ge Residual Helmoltz energy real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: Gen (size(n)) real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional :: GeTn (size(n)) real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n))","tags":"","url":"module/yaeos__consistency_gemodel.html"},{"title":"yaeos__equilibria – yaeos","text":"Module to handle phase equilibria calculations. Uses yaeos__equilibria_boundaries_phase_envelopes_mp yaeos__equilibria_boundaries_phase_envelopes_pt yaeos__equilibria_boundaries_pure_saturation yaeos__equilibria_flash yaeos__equilibria_critical yaeos__equilibria_saturation_points yaeos__equilibria_boundaries_phase_envelopes_px yaeos__equilibria_binaries yaeos__equilibria_boundaries_phase_envelopes_mp_px yaeos__equilibria_auxiliar yaeos__equilibria_boundaries_phase_envelopes_mp_tx yaeos__equilibria_boundaries_phase_envelopes_px3 yaeos__equilibria_boundaries_phase_envelopes_pt3 yaeos__equilibria_equilibrium_state yaeos__equilibria_stability yaeos__equilibria_boundaries_phase_envelopes_tx","tags":"","url":"module/yaeos__equilibria.html"},{"title":"yaeos__models_ar_cubic_alphas – yaeos","text":"functions defined in the library. Uses yaeos__substance yaeos__constants yaeos__models_ar_genericcubic Derived Types type, public, extends( AlphaFunction ) :: AlphaMathiasCopeman Mathias Copeman function. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: c1 (:) real(kind=pr), public, allocatable :: c2 (:) real(kind=pr), public, allocatable :: c3 (:) Type-Bound Procedures procedure, public :: alpha => alpha_mc type, public, extends( AlphaFunction ) :: AlphaRKPR RKPR function Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: k (:) parameter. Type-Bound Procedures procedure, public :: alpha => alpha_rkpr type, public, extends( AlphaFunction ) :: AlphaSoave Soave function. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: k (:) parameter. Type-Bound Procedures procedure, public :: alpha Alpha function Subroutines public  subroutine alpha (self, Tr, a, dadt, dadt2) Soave function and it’s derivatives. Arguments Type Intent Optional Attributes Name class( AlphaSoave ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) Reduced temperature real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:) public  subroutine alpha_mc (self, Tr, a, dadt, dadt2) MathiasCopeman alpha function definition Arguments Type Intent Optional Attributes Name class( AlphaMathiasCopeman ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:) public  subroutine alpha_rkpr (self, Tr, a, dadt, dadt2) Arguments Type Intent Optional Attributes Name class( AlphaRKPR ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) Reduced temperature real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","url":"module/yaeos__models_ar_cubic_alphas.html"},{"title":"yaeos__models_ar_cubic_mixing_base – yaeos","text":"Mixing rules core math Procedures of the core calculations of CubicEoS mixing rules. Description This module holds all the basic math to use mixing rules in other codes.\nKeeping it simple and accesible. Examples bi = [ 0.2 , 0.3 ] lij = reshape ([ 0.0 , 0.2 , 0.2 , 0 ], [ 2 , 2 ]) ! Calculate B parameter with Quadratric Mixing Rules. call bmix_qmr ( n , bi , lij , b , dbi , dbij ) References Uses yaeos__constants Subroutines public pure subroutine bmix_linear (n, bi, b, dbi, dbij) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: b real(kind=pr), intent(out) :: dbi (:) real(kind=pr), intent(out) :: dbij (:,:) public pure subroutine bmix_qmr (n, bi, lij, b, dbi, dbij) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(in) :: lij (:,:) real(kind=pr), intent(out) :: b real(kind=pr), intent(out) :: dbi (:) real(kind=pr), intent(out) :: dbij (:,:) public pure subroutine d1mix_rkpr (n, d1i, D1, dD1i, dD1ij) RKPR parameter mixing rule. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:) public  subroutine lamdba_hv (d1, dd1i, dd1ij, L, dLi, dLij) Infinite pressure limit parameter Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: d1 real(kind=pr), intent(in) :: dd1i (:) real(kind=pr), intent(in) :: dd1ij (:,:) real(kind=pr), intent(out) :: L real(kind=pr), intent(out) :: dLi (:) real(kind=pr), intent(out) :: dLij (:,:)","tags":"","url":"module/yaeos__models_ar_cubic_mixing_base.html"},{"title":"yaeos__equilibria_saturation_points – yaeos","text":"Uses yaeos__models yaeos__equilibria_auxiliar yaeos__equilibria_equilibrium_state yaeos__constants ieee_arithmetic Variables Type Visibility Attributes Name Initial integer, public :: iters_first_step = 15 integer, public :: max_iterations = 2000 real(kind=pr), public :: step_tol = 0.1_pr real(kind=pr), public :: tol = 1e-6_pr Functions public  function saturation_pressure (model, n, t, kind, p0, y0, max_iters) Saturation pressure calculation function. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in), target :: model real(kind=pr), intent(in) :: n (:) Composition vector [moles / molar fraction] real(kind=pr), intent(in) :: t Temperature [K] character(len=*), intent(in) :: kind [bubble|dew|liquid-liquid] real(kind=pr), intent(in), optional :: p0 Initial pressure [bar] real(kind=pr), intent(in), optional :: y0 (:) Initial composition integer, intent(in), optional :: max_iters Maximum number of iterations Return Value type( EquilibriumState ) public  function saturation_temperature (model, n, p, kind, t0, y0, max_iters) Saturation temperature calculation function. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in), target :: model real(kind=pr), intent(in) :: n (:) Composition vector [moles / molar fraction] real(kind=pr), intent(in) :: p Pressure [bar] character(len=*), intent(in) :: kind [bubble|dew|liquid-liquid] real(kind=pr), intent(in), optional :: t0 Initial temperature [K] real(kind=pr), intent(in), optional :: y0 (:) Initial composition integer, intent(in), optional :: max_iters Maximum number of iterations Return Value type( EquilibriumState )","tags":"","url":"module/yaeos__equilibria_saturation_points.html"},{"title":"yaeos__equilibria_auxiliar – yaeos","text":"Auxiliar functions used for phase-equilibria calculation. Uses yaeos__constants yaeos__models_base Functions public  function P_wilson (model, z, T) result(P) Calculate the pressure at a given T of a mixture using the Wilson\nequation. Read more… Arguments Type Intent Optional Attributes Name class( BaseModel ), intent(in) :: model Model of the mixture. real(kind=pr), intent(in) :: z (:) Mole fractions of the components. real(kind=pr), intent(in) :: T Temperature [K]. Return Value real(kind=pr) public  function k_wilson (model, T, P) result(K) K-factors regression done by Wilson, used for initialization. Read more… Arguments Type Intent Optional Attributes Name class( BaseModel ), intent(in) :: model real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P Return Value real(kind=pr), (size(model%components%pc))","tags":"","url":"module/yaeos__equilibria_auxiliar.html"},{"title":"yaeos__constants – yaeos","text":"Constants used on the whole package Uses iso_fortran_env Variables Type Visibility Attributes Name Initial real(kind=pr), public, parameter :: NOT_IMPLEMENTED = huge(R) real(kind=pr), public, parameter :: R = 0.08314462618_pr Ideal Gas constant [bar L / (mol K)] character(len=254), public :: database_path = \"database\" Path to find database character(len=1), public :: path_sep = \"/\" File separator (to preprocess on Win or Mac/linux) integer, public, parameter :: pr = real64 Used precision logical, public :: solving_volume = .false.","tags":"","url":"module/yaeos__constants.html"},{"title":"yaeos__equilibria_boundaries_phase_envelopes_pt3 – yaeos","text":"Uses yaeos__equilibria_equilibrium_state yaeos__constants yaeos__math yaeos__models_ar Variables Type Visibility Attributes Name Initial real(kind=pr), private, parameter :: lnK_min = 2.0_pr Derived Types type, public :: PTEnvel3 Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: P (:) Pressures [bar] real(kind=pr), public, allocatable :: S (:) Value of specification real(kind=pr), public, allocatable :: T (:) Temperatures [K] real(kind=pr), public, allocatable :: beta (:) Mole fraction between phase x and phase y integer, public, allocatable :: its (:) Number of needed iterations integer, public, allocatable :: ns (:) Number of specified variable real(kind=pr), public, allocatable :: w (:,:) Mole fraction of phase x real(kind=pr), public, allocatable :: x (:,:) Mole fraction of phase x real(kind=pr), public, allocatable :: y (:,:) Mole fraction of phase x Functions public  function pt_envelope_3ph (model, z, x0, y0, w0, beta0, P0, T0, ns0, dS0, points) result(envelope) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: x0 (:) real(kind=pr), intent(in) :: y0 (:) real(kind=pr), intent(in) :: w0 (:) real(kind=pr), intent(in) :: beta0 real(kind=pr), intent(in) :: P0 real(kind=pr), intent(in) :: T0 integer, intent(in) :: ns0 real(kind=pr), intent(in) :: dS0 integer, intent(in) :: points Return Value type( PTEnvel3 ) private  function critical_interpol (Xnew, Xold, idx) result(a) Critical point interpolation Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xnew (:) New value of the variables real(kind=pr), intent(in) :: Xold (:) Old value of the variables integer, intent(in) :: idx (:) Index of the variables to interpolate Return Value real(kind=pr) Subroutines public  subroutine get_values_from_X (z, Xvars, x, y, w, P, T, beta) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: Xvars (size(z)*2+3) real(kind=pr), intent(out) :: x (size(z)) real(kind=pr), intent(out) :: y (size(z)) real(kind=pr), intent(out) :: w (size(z)) real(kind=pr), intent(out) :: P real(kind=pr), intent(out) :: T real(kind=pr), intent(out) :: beta public  subroutine solve_point (model, z, ns, S, X, F, dF, its, maxits) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(inout) :: X (:) real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out) :: dF (:,:) integer, intent(inout) :: its integer, intent(in) :: maxits private  subroutine detect_critical (X, dXdS, ns, S, dS) Critical point detection Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: X (:) Vector of variables real(kind=pr), intent(inout) :: dXdS (:) Variation of variables wrt S integer, intent(inout) :: ns Number of specified variable real(kind=pr), intent(inout) :: S Specification value real(kind=pr), intent(inout) :: dS Step in specification private  subroutine pt_F_three_phases (model, z, Xvars, ns, S, F, df) Function to solve at each point of a three phase envelope. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: Xvars (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(Xvars)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) Jacobian matrix private  subroutine update_specification (its, X, dF, dXdS, ns, dS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: its real(kind=pr), intent(inout) :: X (:) real(kind=pr), intent(inout) :: dF (:,:) real(kind=pr), intent(inout) :: dXdS (:) integer, intent(inout) :: ns real(kind=pr), intent(inout) :: dS","tags":"","url":"module/yaeos__equilibria_boundaries_phase_envelopes_pt3.html"},{"title":"yaeos__equilibria_boundaries_phase_envelopes_pt – yaeos","text":"Phase boundaries line on the plane calculation procedures. Uses yaeos__models yaeos__equilibria_auxiliar yaeos__math_continuation yaeos__equilibria_equilibrium_state yaeos__constants Variables Type Visibility Attributes Name Initial real(kind=pr), private :: Vy real(kind=pr), private :: Vz real(kind=pr), private, parameter :: near_critical_K = 0.01 Derived Types type, public :: PTEnvel2 Two-phase isopleth.\nPhase boundary line of a fluid at constant composition. Components Type Visibility Attributes Name Initial type( CriticalPoint ), public, allocatable :: cps (:) Critical points found along the line. type( EquilibriumState ), public, allocatable :: points (:) Each point through the line. Type-Bound Procedures procedure, public, pass :: write => write_PTEnvel2 generic, public :: write (FORMATTED) => write type, private :: CriticalPoint Critical point Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: T Temperature [K] Functions public  function find_hpl (model, z, T0, P0, max_points) Find a liquid-liquid phase boundary on the PT plane. At a specified\npressure.\nThe procedure consists in looking for the temperature at which the\nfugacity of a component in the mixture is higher than the fugacity\nof the same component in a pure phase. This is done for each component\nin the mixture. The component with the highest temperature is selected\nas it should be the first one appearing. If all components have a\nnegative difference then the mixture is probably stable at all\ntemperatures. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Equation of state model real(kind=pr), intent(in) :: z (:) Mole fractions real(kind=pr), intent(in) :: T0 Initial temperature [K] real(kind=pr), intent(in) :: P0 Search pressure [bar] integer, intent(in) :: max_points Return Value type( PTEnvel2 ) public  function pt_envelope_2ph (model, z, first_point, points, iterations, delta_0, specified_variable_0, solver, stop_conditions, maximum_pressure) result(envelopes) PT two-phase envelope calculation procedure. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model Thermodyanmic model real(kind=pr), intent(in) :: z (:) Vector of molar fractions type( EquilibriumState ), intent(in) :: first_point Initial point of the envelope integer, intent(in), optional :: points Maxmimum number of points, defaults to 500 integer, intent(in), optional :: iterations Point solver maximum iterations, defaults to 100 real(kind=pr), intent(in), optional :: delta_0 Initial extrapolation integer, intent(in), optional :: specified_variable_0 Position of specified variable, since the vector of variables is the values for specification\nwill be for the equilibria constants, for and for . procedure( continuation_solver ), optional :: solver Specify solver for each point, defaults to a full newton procedure procedure( continuation_stopper ), optional :: stop_conditions Function that returns true if the continuation method should stop real(kind=pr), intent(in), optional :: maximum_pressure Maximum pressure to calculate [bar] Return Value type( PTEnvel2 ) Subroutines private  subroutine write_PTEnvel2 (pt2, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( PTEnvel2 ), intent(in) :: pt2 integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","url":"module/yaeos__equilibria_boundaries_phase_envelopes_pt.html"},{"title":"auxiliar_functions – yaeos","text":"Uses yaeos__constants Functions public  function allclose (x, y, rtol) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x (:) real(kind=pr), intent(in) :: y (:) real(kind=pr), intent(in) :: rtol Return Value logical public elemental function rel_error (x, y) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x real(kind=pr), intent(in) :: y Return Value real(kind=pr)","tags":"","url":"module/auxiliar_functions.html"},{"title":"yaeos__autodiff – yaeos","text":"This module holds the diferent ways of automatic differentiation Uses hyperdual_mod yaeos__adiff_hyperdual_ar_api","tags":"","url":"module/yaeos__autodiff.html"},{"title":"yaeos__models_ar_gerg2008 – yaeos","text":"Ideal gas constants used on yaeos Uses yaeos__models_ar_multifluid_parameters_gerg2008 hyperdual_mod yaeos__adiff_hyperdual_ar_api yaeos__models_ar_genericcubic yaeos__models_ar_cubic_implementations yaeos__constants Variables Type Visibility Attributes Name Initial type( GERG2008Selector ), public :: G2008Components Derived Types type, public, extends( ArModelAdiff ) :: Gerg2008 Components Type Visibility Attributes Name Initial type( Gerg2008Binary ), public, allocatable :: binaries (:,:) type( Substances ), public :: components Substances contained in the module character(len=:), public, allocatable :: name Name of the model type( Gerg2008Pure ), public, allocatable :: pures (:) type( CubicEoS ), public :: srk Type-Bound Procedures procedure, public :: Cp_residual_vt procedure, public :: Cv_residual_vt procedure, public :: Psat_pure procedure, public :: ar => arfun procedure, public :: enthalpy_residual_vt procedure, public :: entropy_residual_vt procedure, public :: get_v0 => volume_initalizer procedure, public :: gibbs_residual_vt procedure, public :: internal_energy_residual_vt procedure, public :: lnfug_vt procedure, public :: lnphi_pt procedure, public :: lnphi_vt procedure, public :: pressure procedure, public :: residual_helmholtz procedure, public :: volume type, private :: GERG2008Selector Components Type Visibility Attributes Name Initial integer, public :: argon = 21 integer, public :: carbon_dioxide = 3 integer, public :: carbon_monoxide = 17 integer, public :: decane = 14 integer, public :: ethane = 4 integer, public :: helium = 20 integer, public :: hydrogen = 15 integer, public :: hydrogen_sulfide = 19 integer, public :: isobutane = 7 integer, public :: isopentane = 9 integer, public :: methane = 1 integer, public :: nbutane = 6 integer, public :: nheptane = 11 integer, public :: nhexane = 10 integer, public :: nitrogen = 2 integer, public :: noctane = 12 integer, public :: nonane = 13 integer, public :: npentane = 8 integer, public :: oxygen = 16 integer, public :: propane = 5 integer, public :: water = 18 Functions public  function arfun (self, n, v, t) result(arval) Arguments Type Intent Optional Attributes Name class( Gerg2008 ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual ) public  function gerg_2008 (ids) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ids (:) Return Value type( Gerg2008 ) public  function volume_initalizer (self, n, p, t) result(v0) Arguments Type Intent Optional Attributes Name class( Gerg2008 ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) Subroutines public  subroutine ar_ij (delta, tau, binary, aij) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: delta type( hyperdual ), intent(in) :: tau type( Gerg2008Binary ), intent(in) :: binary type( hyperdual ), intent(out) :: aij public  subroutine ar_pure (pure, delta, tau, ar) Arguments Type Intent Optional Attributes Name type( Gerg2008Pure ), intent(in) :: pure type( hyperdual ), intent(in) :: delta type( hyperdual ), intent(in) :: tau type( hyperdual ), intent(out) :: ar public  subroutine reducing_functions (self, n, Vr, Tr) Arguments Type Intent Optional Attributes Name class( Gerg2008 ), intent(in) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(out) :: Vr type( hyperdual ), intent(out) :: Tr","tags":"","url":"module/yaeos__models_ar_gerg2008.html"},{"title":"hyperdual_mod – yaeos","text":"Hyperdual number definition & type declaration Uses yaeos__constants Interfaces public        interface abs public elemental function absHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface acos public elemental function acosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface asin public elemental function asinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface assignment (=) public elemental subroutine EqualHyperDualHyperDual (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp public elemental subroutine EqualHyperDualReal (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp public        interface atan public elemental function atanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface atan2 public elemental function atan2HyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface cos public elemental function cosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface cosh public elemental function coshHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface exp public elemental function expHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface int public elemental function intHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public        interface log public elemental function logHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface log10 public elemental function log10HyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface max public elemental function max_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_ddd (v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual ) public elemental function max_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface min public elemental function min_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface nint public elemental function nintHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public        interface operator (*) public elemental function MultiplyHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyIntHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface operator (**) public elemental function PowerHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public        interface operator (+) public elemental function PlusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface operator (+) public elemental function AddHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface operator (-) public elemental function MinusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface operator (-) public elemental function SubtractHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface operator (.eq.) public  function eq_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function eq_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public elemental function eq_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function eq_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function eq_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (.ge.) public  function ge_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ge_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ge_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (.gt.) public  function gt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function gt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function gt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (.le.) public  function le_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function le_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function le_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (.lt.) public  function lt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function lt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function lt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (.ne.) public  function ne_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ne_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ne_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (/) public elemental function DivideHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface real public elemental function realHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr) public        interface sign public elemental function sign_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface sin public elemental function sinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface sinh public elemental function sinhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface sqrt public elemental function sqrtHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface sum public pure function SumHyperDual (v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) public pure function SumHyperDual2 (v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ), allocatable, (:) public        interface tan public elemental function tanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface tanh public elemental function tanhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Derived Types type, public, bind(c) :: hyperdual Components Type Visibility Attributes Name Initial real(kind=pr), public :: f0 = 0 real part of the hyperdual number real(kind=pr), public :: f1 = 0 \\f$\\varepsilon_1\\f$-part of  the hyperdual number real(kind=pr), public :: f12 = 0 \\f$\\varepsilon_1\\varepsilon_2\\f$-part of the real(kind=pr), public :: f2 = 0 \\f$\\varepsilon_2\\f$-part of  the hyperdual number Functions public elemental function AddHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MinusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function MultiplyHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyIntHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PlusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function PowerHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public pure function SumHyperDual (v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) public pure function SumHyperDual2 (v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ), allocatable, (:) public elemental function absHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function acosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function asinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function atan2HyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function atanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function cosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function coshHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public  function eq_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function eq_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public elemental function eq_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function eq_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function eq_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function expHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public  function ge_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ge_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ge_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function gt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function gt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function intHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public  function le_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function le_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function le_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function log10HyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function logHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public  function lt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function lt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function lt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function max_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_ddd (v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual ) public elemental function max_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public  function ne_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ne_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ne_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function nintHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public elemental function realHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr) public elemental function sign_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function sinhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function sqrtHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function tanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function tanhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Subroutines public elemental subroutine EqualHyperDualHyperDual (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp public elemental subroutine EqualHyperDualReal (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp","tags":"","url":"module/hyperdual_mod.html"},{"title":"yaeos__models_ge_group_contribution_dortmund – yaeos","text":"Uses yaeos__models_ge_group_contribution_model_parameters yaeos__models_ge_group_contribution_dortmund_parameters yaeos__constants yaeos__models_ge_group_contribution_groups yaeos__models_ge_gc_td yaeos__models_ge_group_contribution_unifac Functions public  function setup_dortmund (molecules, parameters) Arguments Type Intent Optional Attributes Name type( Groups ), intent(in) :: molecules (:) type( GeGCModelParameters ), intent(in), optional :: parameters Return Value type( UNIFAC )","tags":"","url":"module/yaeos__models_ge_group_contribution_dortmund.html"},{"title":"yaeos__equilibria_flash – yaeos","text":"Uses yaeos__models yaeos__equilibria_auxiliar yaeos__equilibria_rachford_rice yaeos__equilibria_equilibrium_state yaeos__constants yaeos__solvers_pressure_equality Functions public  function flash (model, z, t, v_spec, p_spec, k0, iters) Flash algorithm using sucessive substitutions. Read more… Arguments Type Intent Optional Attributes Name class( BaseModel ), intent(in) :: model Thermodynamic model real(kind=pr), intent(in) :: z (:) Global composition (molar fractions) real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in), optional :: v_spec Specified Volume [L/mol] real(kind=pr), intent(in), optional :: p_spec Specified Pressure [bar] real(kind=pr), intent(in), optional :: k0 (:) Initial K factors (y/x) integer, intent(out), optional :: iters Number of iterations Return Value type( EquilibriumState )","tags":"","url":"module/yaeos__equilibria_flash.html"},{"title":"yaeos__adiff_hyperdual_ge_api – yaeos","text":"Module that contains the automatic differentiation logic for an Ge model. All that is needed to define an Ge model that uses automatic\ndifferentiation with hyperdual numbers is to define a new derived type\nthat overloads the method to the Ge function that you want to use. Uses yaeos__models_ge yaeos__constants hyperdual_mod Abstract Interfaces abstract interface public  function hyperdual_Ge(self, n, t) Arguments Type Intent Optional Attributes Name class( GeModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: t Return Value type( hyperdual ) Derived Types type, public, abstract, extends( GeModel ) :: GeModelAdiff Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module Type-Bound Procedures procedure( hyperdual_Ge ), public, deferred :: Ge procedure, public :: excess_enthalpy procedure, public :: excess_entropy procedure, public :: excess_gibbs procedure, public :: ln_activity_coefficient Subroutines public  subroutine excess_gibbs (self, n, t, Ge, GeT, GeT2, Gen, GeTn, Gen2) Arguments Type Intent Optional Attributes Name class( GeModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ge real(kind=pr), intent(out), optional :: GeT real(kind=pr), intent(out), optional :: GeT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Gen real(kind=pr), intent(out), optional, dimension(size(n)) :: GeTn real(kind=pr), intent(out), optional :: Gen2 (size(n),size(n))","tags":"","url":"module/yaeos__adiff_hyperdual_ge_api.html"},{"title":"yaeos__substance – yaeos","text":"yaeos Subtance module. Module containing pure components properties and parameters. Uses yaeos__constants Derived Types type, public :: Substances Set of pure components Components Type Visibility Attributes Name Initial character(len=50), public, allocatable :: names (:) Composition names. real(kind=pr), public, allocatable :: pc (:) Critical Pressure [bar] real(kind=pr), public, allocatable :: tc (:) Critical Temperature [K] real(kind=pr), public, allocatable :: vc (:) Critical Volume [L/mol] real(kind=pr), public, allocatable :: w (:) Acentric factor","tags":"","url":"module/yaeos__substance.html"},{"title":"yaeos__models_ge_group_contribution_groups – yaeos","text":"Uses yaeos__constants Derived Types type, public :: Groups Derived type used to represent a molecule and its UNIFAC groups. Read more… Components Type Visibility Attributes Name Initial integer, public, allocatable :: groups_ids (:) Indexes (ids) of each subgroup in the main group matrix integer, public, allocatable :: number_of_groups (:) Occurrences of each subgroup in the molecule real(kind=pr), public :: surface_area Molecule surface area real(kind=pr), public :: volume Molecule volume","tags":"","url":"module/yaeos__models_ge_group_contribution_groups.html"},{"title":"yaeos__equilibria_equilibrium_state – yaeos","text":"Uses yaeos__constants Derived Types type, public :: EquilibriumState Description of a two-phase equilibria state. Read more… Components Type Visibility Attributes Name Initial real(kind=pr), public :: P Pressure [bar] real(kind=pr), public :: T Temperature [K] real(kind=pr), public :: Vx Heavy-phase volume [L/mol] real(kind=pr), public :: Vy Light-phase volume [L/mol] real(kind=pr), public :: beta Mole fraction of light-phase integer, public :: iters = 0 Iterations needed to reach the state character(len=14), public :: kind Kind of point [“bubble”, “dew”, “liquid-liquid”, “split”] real(kind=pr), public, allocatable :: x (:) Heavy-phase molar fractions real(kind=pr), public, allocatable :: y (:) Light-phase molar fractions Type-Bound Procedures generic, public :: write (FORMATTED) => write procedure, private, pass :: write => write_EquilibriumState Subroutines public  subroutine write_EquilibriumState (eq, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( EquilibriumState ), intent(in) :: eq integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","url":"module/yaeos__equilibria_equilibrium_state.html"},{"title":"yaeos__models_ar_cubic_quadratic_mixing – yaeos","text":"Quadratic Mixing Rules for Cubic EoS. Uses yaeos__models_ar_cubic_mixing_base yaeos__substance yaeos__constants yaeos__models_ar_genericcubic Abstract Interfaces abstract interface public  subroutine get_aij(self, T, ai, daidt, daidt2, aij, daijdt, daijdt2) Combining rule for the attractive parameter. From previously calculated attractive parameters calculate the matrix and it’s corresponding derivatives. Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: aij (:,:) real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:) Derived Types type, public, extends( CubicMixRule ) :: QMR Quadratic Mixing Rule (QMR) derived type. Classic Van der Waals mixing\nrules. Read more… Components Type Visibility Attributes Name Initial logical, public :: dn2 = .false. Calculate second order derivatives real(kind=pr), public, allocatable :: k (:,:) Attractive Binary Interatction parameter matrix real(kind=pr), public, allocatable :: l (:,:) Repulsive Binary Interatction parameter matrix Type-Bound Procedures procedure, public :: Bmix Repulsive parameter mixing rule procedure, public :: D1mix => RKPR_D1mix procedure, public :: Dmix Attractive parameter mixing rule procedure, public :: aij => kij_constant Default attractive parameter combining rule type, public, extends( QMR ) :: QMRTD Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: Tref (:,:) logical, public :: dn2 = .false. Calculate second order derivatives real(kind=pr), public, allocatable :: k (:,:) Attractive Binary Interatction parameter matrix real(kind=pr), public, allocatable :: k0 (:,:) real(kind=pr), public, allocatable :: l (:,:) Repulsive Binary Interatction parameter matrix Type-Bound Procedures procedure, public :: Bmix Repulsive parameter mixing rule procedure, public :: D1mix => RKPR_D1mix procedure, public :: Dmix Attractive parameter mixing rule procedure, public :: aij => kij_exp_tdep Subroutines public  subroutine Bmix (self, n, bi, B, dBi, dBij) Mixture repulsive parameter. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector. real(kind=pr), intent(in) :: bi (:) Pure components repulsive parameters. real(kind=pr), intent(out) :: B Mixture repulsive parameter. real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) public  subroutine Dmix (self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Attractive parameter mixing rule with quadratic mix. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: ai (:) Pure components attractive parameters real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D Mixture attractive parameter real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) public  subroutine RKPR_D1mix (self, n, d1i, D1, dD1i, dD1ij) RKPR parameter mixing rule. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:) public  subroutine kij_constant (self, T, a, dadt, dadt2, aij, daijdt, daijdt2) Combining rule that uses constant values. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: a (:) Pure components attractive parameters (\\a_i) real(kind=pr), intent(in) :: dadt (:) real(kind=pr), intent(in) :: dadt2 (:) real(kind=pr), intent(out) :: aij (:,:) Matrix real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:) public  subroutine kij_exp_tdep (self, T, a, dadt, dadt2, aij, daijdt, daijdt2) Combining rule that uses temperature dependant values.\nWith the following expression: Read more… Arguments Type Intent Optional Attributes Name class( QMRTD ), intent(in) :: self real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: a (:) Pure components attractive parameters (\\a_i) real(kind=pr), intent(in) :: dadt (:) real(kind=pr), intent(in) :: dadt2 (:) real(kind=pr), intent(out) :: aij (:,:) Matrix real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:)","tags":"","url":"module/yaeos__models_ar_cubic_quadratic_mixing.html"},{"title":"yaeos__m_s_sp – yaeos","text":"Module to calculate saturation points Uses yaeos__constants yaeos__models_ar Subroutines public  subroutine saturation_F (model, z, X, ns, S, F, dF, dPdVz, dPdVy) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr) :: z (size(model)) real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out), optional :: dF (:,:) real(kind=pr), intent(out) :: dPdVz real(kind=pr), intent(out) :: dPdVy public  subroutine saturation_TP (model, kind, z, X, ns, S, F, dF, dFdS) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model character(len=*), intent(in) :: kind real(kind=pr), intent(in) :: z (size(model)) real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (:) real(kind=pr), intent(out) :: dF (:,:) real(kind=pr), intent(out) :: dFdS (:) public  subroutine solve_TP (model, kind, z, X, ns, S, tol, max_iterations, its) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model character(len=*), intent(in) :: kind real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(inout) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(in) :: tol integer, intent(in) :: max_iterations integer, intent(out) :: its public  subroutine solve_VxVyT (model, z, X, ns, S, tol, max_iterations, its) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: model real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(inout) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(in) :: tol integer, intent(in) :: max_iterations integer, intent(out) :: its","tags":"","url":"module/yaeos__m_s_sp.html"},{"title":"yaeos__models_ar_multifluid_parameters_gerg2008 – yaeos","text":"Uses yaeos__constants yaeos__models_base Variables Type Visibility Attributes Name Initial real(kind=8), public, dimension(21, 21) :: Bt = 0 real(kind=8), public, dimension(21, 21) :: Bv = 0 real(kind=8), public, dimension(21, 21) :: Fij = 0 real(kind=8), public, dimension(21, 21) :: Gt = 0 real(kind=8), public, dimension(21, 21) :: Gv = 0 integer, public, dimension(21) :: Kexp = 0 integer, public, dimension(21, 21) :: Kexpij = 0 integer, public, dimension(21) :: Kpol = 0 integer, public, dimension(21, 21) :: Kpolij = 0 real(kind=8), public, dimension(21) :: M = 0 integer, public, parameter :: N = 21 real(kind=8), public, dimension(21) :: P_c = 0 real(kind=8), public :: R = 0 real(kind=8), public, dimension(21) :: T_c = 0 real(kind=8), public, dimension(21) :: acentric_factor = 0 real(kind=8), public, dimension(21, 21, 12) :: betaij = 0 integer, public, dimension(21, 24) :: coik = 0 integer, public, dimension(21, 21, 12) :: dij = 0 integer, public, dimension(21, 24) :: doik = 0 real(kind=8), public :: eps = 1d-10 real(kind=8), public, dimension(21, 21, 12) :: epsij = 0 real(kind=8), public, dimension(21, 21, 12) :: ethaij = 0 real(kind=8), public, dimension(21, 21, 12) :: gammaij = 0 integer, public :: generalized_departure (8,2) integer, public :: max_residual_terms = 24 real(kind=8), public, dimension(21, 7) :: n0i = 0 real(kind=8), public, dimension(21, 21, 12) :: nij = 0 real(kind=8), public, dimension(21, 24) :: noik = 0 real(kind=8), public, dimension(21, 21, 4) :: red_params real(kind=8), public, dimension(21) :: rho_c = 0 real(kind=8), public, dimension(21, 7) :: th0i = 0 real(kind=8), public, dimension(21, 21, 12) :: tij = 0 integer, public :: tmp1 (3) = 0 integer, public :: tmp2 (14) = 0 real(kind=8), public, dimension(21, 24) :: toik = 0 Derived Types type, public :: Gerg2008Binary Components Type Visibility Attributes Name Initial real(kind=8), public :: Bt Binary temperature interaction parameters real(kind=8), public :: Bv Binary volume interaction parameters real(kind=8), public :: Fij real(kind=8), public :: Gt Binary temperature interaction parameters real(kind=8), public :: Gv Binary volume interaction parameters integer, public :: Kexpij integer, public :: Kpolij real(kind=8), public, allocatable :: betaij (:) real(kind=8), public, allocatable :: dij (:) real(kind=8), public, allocatable :: epsij (:) real(kind=8), public, allocatable :: ethaij (:) real(kind=8), public, allocatable :: gammaij (:) integer, public :: i Component i integer, public :: j Component j real(kind=8), public, allocatable :: nij (:) real(kind=8), public, allocatable :: tij (:) type, public :: Gerg2008Pure Components Type Visibility Attributes Name Initial integer, public :: Kexp integer, public :: Kpol real(kind=8), public, allocatable :: c (:) real(kind=8), public, allocatable :: d (:) real(kind=8), public, allocatable :: n (:) real(kind=8), public, allocatable :: t (:) Subroutines public  subroutine get_original_parameters (ids, pures, binaries, components) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ids (:) type( Gerg2008Pure ), intent(out) :: pures (:) type( Gerg2008Binary ), intent(out) :: binaries (:,:) type( Substances ), intent(out) :: components public  subroutine original_parameters () Parameter table of the original GERG 2008 model Arguments None","tags":"","url":"module/yaeos__models_ar_multifluid_parameters_gerg2008.html"},{"title":"yaeos__models_cubic_mixing_rules_huron_vidal – yaeos","text":"Huron-Vidal (like) mixing rules module This module contains the mixing rules that are based/similar to the\nmixing rules defined by Huron-Vidal Description Huron-Vidal presented a way to link a model with a Cubic EoS\nmixing rule. This makes it possible to make good predictions on\npolar compounds containing mixtures. Examples A basic code example References Uses yaeos__models_ar_cubic_mixing_base yaeos__models_ge yaeos__constants yaeos__models_ar_genericcubic Interfaces public        interface MHV private  function init_mhv (Ge, b, q, lij) result(mixrule) Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: Ge real(kind=pr), intent(in) :: b (:) real(kind=pr), intent(in) :: q real(kind=pr), intent(in), optional :: lij (:,:) Return Value type( MHV ) Derived Types type, public, extends( CubicMixRule ) :: HV Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: bi (:) real(kind=pr), public, allocatable :: del1 (:) logical, public :: dn2 = .false. Calculate second order derivatives class( GeModel ), public, allocatable :: ge Type-Bound Procedures procedure, public :: Bmix => BmixHV procedure, public :: D1Mix => D1MixHV procedure, public :: Dmix => DmixHV type, public, extends( CubicMixRule ) :: MHV Mixing rule at zero-pressure which allows for the inclusion of an\nexcess-gibbs model. Read more… Components Type Visibility Attributes Name Initial logical, public :: dn2 = .false. Calculate second order derivatives class( GeModel ), public, allocatable :: ge real(kind=pr), public, allocatable :: l (:,:) real(kind=pr), public :: q real(kind=pr), private, allocatable :: B real(kind=pr), private, allocatable :: bi (:) real(kind=pr), private, allocatable :: dBi (:) real(kind=pr), private, allocatable :: dBij (:,:) Constructor private\n\n                    \n                    function init_mhv (Ge, b, q, lij) Type-Bound Procedures procedure, public :: Bmix => BmixMHV procedure, public :: D1Mix => D1MixMHV procedure, public :: Dmix => DmixMHV Functions private  function init_mhv (Ge, b, q, lij) result(mixrule) Arguments Type Intent Optional Attributes Name class( GeModel ), intent(in) :: Ge real(kind=pr), intent(in) :: b (:) real(kind=pr), intent(in) :: q real(kind=pr), intent(in), optional :: lij (:,:) Return Value type( MHV ) Subroutines public  subroutine DmixMHV (self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Mixing rule at infinite pressure as defined in the book of Michelsen and\nMøllerup. Read more… Arguments Type Intent Optional Attributes Name class( MHV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) private  subroutine BmixHV (self, n, bi, B, dBi, dBij) Quadratinc mixing rule for the repulsive parameter. Read more… Arguments Type Intent Optional Attributes Name class( HV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) private  subroutine BmixMHV (self, n, bi, B, dBi, dBij) Quadratinc mixing rule for the repulsive parameter, using as a combining rule. Read more… Arguments Type Intent Optional Attributes Name class( MHV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) private  subroutine D1MixHV (self, n, d1i, D1, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name class( HV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:) private  subroutine D1MixMHV (self, n, d1i, D1, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name class( MHV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: d1i (:) real(kind=pr), intent(out) :: D1 real(kind=pr), intent(out) :: dD1i (:) real(kind=pr), intent(out) :: dD1ij (:,:) private  subroutine DmixHV (self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Arguments Type Intent Optional Attributes Name class( HV ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:)","tags":"","url":"module/yaeos__models_cubic_mixing_rules_huron_vidal.html"},{"title":"yaeos__equilibria_boundaries_auxiliar – yaeos","text":"Equilibria boundaries auxiliar module\nThis module contains the auxiliar functions and subroutines\nused in the phase-boundaries calculations. Uses yaeos__constants Subroutines public  subroutine get_z (alpha, z_0, z_inj, z, dzda) Calculate the fluid composition based on an amount of addition\nof second fluid. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: alpha Addition percentaje real(kind=pr), intent(in) :: z_0 (:) real(kind=pr), intent(in) :: z_inj (:) real(kind=pr), intent(out) :: z (size(z_0)) New composition real(kind=pr), intent(out), optional :: dzda (size(z_0)) Derivative wrt","tags":"","url":"module/yaeos__equilibria_boundaries_auxiliar.html"},{"title":"legacy_ar_models – yaeos","text":"Legacy Thermodynamic routines\nModule for a cubic eos system, made with the intention to keep\ncompatiblity with legacy codes but with a better structure.\nthis should be later adapted into a simple oop system where an eos object\nstores the relevant parameters (or some functional oriented approach) Uses ar_interface yaeos__constants Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: ac (:) Critical attractive parameter [bar (L/mol)&#94;2] real(kind=pr), public, allocatable :: b (:) repulsive parameter [L] real(kind=pr), public, allocatable :: bij (:,:) real(kind=pr), public, allocatable :: dc (:) Critical density [mol/L] real(kind=pr), public, allocatable :: del1 (:) parameter real(kind=pr), public, allocatable :: k (:) Attractive parameter constant real(kind=pr), public, allocatable :: kij (:,:) Attractive BIP real(kind=pr), public, allocatable :: kij0 (:,:) real(kind=pr), public, allocatable :: kinf (:,:) real(kind=pr), public, allocatable :: lij (:,:) Repulsive BIP integer, public :: mixing_rule What mixing rule to use integer, public :: nc Number of components real(kind=pr), public, allocatable :: pc (:) Critical pressure [bar] real(kind=pr), public, allocatable :: tc (:) Critical temperature [K] integer, public :: tdep Temperature dependance of kij integer, public :: thermo_model Which thermodynamic model to use real(kind=pr), public, allocatable :: tstar (:,:) real(kind=pr), public, allocatable :: w (:) Acentric factor real(kind=pr), public, allocatable :: z (:) Mole fractions vector Functions public  function cubic_v0 (z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr) Subroutines public  subroutine ArVnder (nc, nder, ntemp, z, V, T, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: nder integer, intent(in) :: ntemp real(kind=pr), intent(in) :: z (nc) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) public  subroutine Bnder (nc, rn, Bmix, dBi, dBij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: Bmix real(kind=pr), intent(out) :: dBi (nc) real(kind=pr), intent(out) :: dBij (nc,nc) public  subroutine DELTAnder (nc, rn, D1m, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D1m real(kind=pr), intent(out) :: dD1i (nc) real(kind=pr), intent(out) :: dD1ij (nc,nc) public  subroutine DandTnder (ntd, nc, T, rn, D, dDi, dDiT, dDij, dDdT, dDdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDi (nc) real(kind=pr), intent(out) :: dDiT (nc) real(kind=pr), intent(out) :: dDij (nc,nc) real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 public  subroutine HelmRKPR (nco, NDE, NTD, rn, V, T, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Calculate the reduced residual Helmholtz Energy and it’s derivatives with the RKPR EOS Arguments Type Intent Optional Attributes Name integer, intent(in) :: nco integer, intent(in) :: NDE integer, intent(in) :: NTD real(kind=pr), intent(in) :: rn (nco) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out) :: Arn (nco) real(kind=pr), intent(out) :: ArVn (nco) real(kind=pr), intent(out) :: ArTn (nco) real(kind=pr), intent(out) :: Arn2 (nco,nco) public  subroutine HelmSRKPR (nc, nd, nt, rn, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components integer, intent(in) :: nd Compositional derivatives integer, intent(in) :: nt Temperature derivatives real(kind=pr), intent(in) :: rn (nc) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (nc) dAr/dn real(kind=pr), intent(out) :: ArVn (nc) dAr2/dVn real(kind=pr), intent(out) :: ArTn (nc) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (nc,nc) dAr2/dn2 public  subroutine PR76_factory (moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) PengRobinson 76 factory Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) public  subroutine PR78_factory (moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) PengRobinson 78 factory Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) public  subroutine SRK_factory (moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) SoaveRedlichKwong factory Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) public  subroutine aTder (ac, Tc, k, T, a, dadT, dadT2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: ac real(kind=pr), intent(in) :: Tc real(kind=pr), intent(in) :: k real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: a real(kind=pr), intent(out) :: dadT real(kind=pr), intent(out) :: dadT2 public  subroutine aijTder (ntd, nc, T, aij, daijdT, daijdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: aij (nc,nc) real(kind=pr), intent(out) :: daijdT (nc,nc) real(kind=pr), intent(out) :: daijdT2 (nc,nc) public  subroutine ar_rkpr (z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (size(z)) dAr/dn real(kind=pr), intent(out) :: ArVn (size(z)) dAr2/dVn real(kind=pr), intent(out) :: ArTn (size(z)) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) dAr2/dn2 public  subroutine ar_srkpr (z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Wrapper subroutine to the SRK/PR Residula Helmholtz function to\nuse the general interface Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (size(z)) dAr/dn real(kind=pr), intent(out) :: ArVn (size(z)) dAr2/dVn real(kind=pr), intent(out) :: ArTn (size(z)) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) dAr2/dn2 public  subroutine get_Zc_OMa_OMb (del1, Zc, OMa, OMb) Calculate Zc, OMa and OMb from the delta_1 parameter. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: del1 (:) delta_1 parameter real(kind=pr), intent(out) :: Zc (:) Critical compressibility factor real(kind=pr), intent(out) :: OMa (:) OMa real(kind=pr), intent(out) :: OMb (:) OMb public  subroutine setup (n, nmodel, ntdep, ncomb) Setup the basics variables that describe the model. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Number of components integer, intent(in) :: nmodel Number of model integer, intent(in) :: ntdep Kij dependant of temperature integer, intent(in) :: ncomb Combining rule","tags":"","url":"module/legacy_ar_models.html"},{"title":"legacy_thermo_properties – yaeos","text":"Uses yaeos__constants legacy_ar_models Subroutines public  subroutine PUREFUG_CALC (nc, icomp, T, P, V, phi) Fugacity of a pure component Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: icomp real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: V real(kind=pr), intent(out) :: phi public  subroutine TERMO (nc, mtyp, indic, t, p, rn, v, PHILOG, DLPHIP, DLPHIT, FUGN) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components integer, intent(in) :: mtyp Type of root desired (-1 vapor, 1 liquid, 0 lower Gr) integer, intent(in) :: indic Desired element, this should be setted with optionals real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: rn (nc) Mixture mole numbers real(kind=pr), intent(out) :: v Volume [L] real(kind=pr), intent(out) :: PHILOG (nc) ln(phi*p) vector real(kind=pr), intent(out), optional :: DLPHIP (nc) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: DLPHIT (nc) ln(phi) Temp derivative real(kind=pr), intent(out), optional :: FUGN (nc,nc) ln(phi) compositional derivative public recursive subroutine VCALC (ITYP, nc, ntemp, rn, T, P, V) ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP TYPE OF ROOT DESIRED (-1 vapor, 1 liquid, 0 lower Gibbs energy phase) integer, intent(in) :: nc NO. OF COMPONENTS integer, intent(in) :: ntemp 1 if T-derivatives are required real(kind=pr), intent(in) :: rn (nc) FEED MOELS real(kind=pr), intent(in) :: T TEMPERATURE real(kind=pr), intent(in) :: P PRESURE real(kind=pr), intent(out) :: V VOLUME public  subroutine zTVTERMO (nc, indic, t, rn, v, p, dpv, PHILOG, DLPHIP, DLPHIT, FUGN) Calculation of lnphi P and derivatives\n rn        mixture mole numbers                       (input)\n t         temperature (k)                            (input)\n v         volume      (L)                            (input)\n p         pressure    (bar)                          (output)\n PHILOG    vector of ln(phi(i) P)                     (output)  0 < INDIC < 5\n DLPHIT    t-derivative of ln(phi(i)) (const P, n)    (output)  0 < INDIC = 2 or 4\n DLPHIP    P-derivative of ln(phi(i)) (const T, n)    (output)  0 < INDIC < 5\n FUGN      comp-derivative of ln(phi(i)) (const t & P)(output)  2 < INDIC Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: indic real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: v real(kind=pr), intent(out) :: p real(kind=pr), intent(out) :: dpv real(kind=pr), intent(out) :: PHILOG (nc) real(kind=pr), intent(out) :: DLPHIP (nc) real(kind=pr), intent(out) :: DLPHIT (nc) real(kind=pr), intent(out) :: FUGN (nc,nc)","tags":"","url":"module/legacy_thermo_properties.html"},{"title":"yaeos__models_ge_group_contribution_psrk – yaeos","text":"Uses yaeos__models_ge_group_contribution_psrk_parameters yaeos__constants yaeos__models_ge_group_contribution_groups yaeos__models_ge_gc_td yaeos__models_ge_group_contribution_unifac Functions public  function setup_psrk (molecules, parameters) Arguments Type Intent Optional Attributes Name type( Groups ), intent(in) :: molecules (:) type( GeGCModelParameters ), intent(in), optional :: parameters Return Value type( UNIFAC )","tags":"","url":"module/yaeos__models_ge_group_contribution_psrk.html"},{"title":"yaeos__adiff_hyperdual_ar_api – yaeos","text":"Module that contains the automatic differentiation logic for an Ar model. All that is needed to define an Ar model that uses automatic\ndifferentiation with hyperdual numbers is to define a new derived type\nthat overloads the method to the Ar function that you want to use.\nA minimal example follows: module newmodel use yaeos__adiff_hyperdual_ar_api , only : ArModelAdiff type , extends ( ArModelAdiff ) :: YourNewModel type ( Substances ) :: composition real ( 8 ) :: parameters (:) contains procedure :: Ar => arfun procedure :: get_v0 => v0 end type contains subroutine arfun ( self , n , v , t , Ar ) class ( YourNewModel ), intent ( in ) :: self type ( hyperdual ), intent ( in ) :: n (:) ! Number of moles type ( hyperdual ), intent ( in ) :: v ! Volume [L] type ( hyperdual ), intent ( in ) :: t ! Temperature [K] type ( hyperdual ), intent ( out ) :: ar_value ! Residual Helmholtz Energy ! A very complicated residual helmholtz function of a mixture Ar = sum ( n ) * v * t end subroutine function v0 ( self , n , p , t ) class ( YourNewModel ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) ! Number of moles real ( pr ), intent ( in ) :: p ! Pressure [bar] real ( pr ), intent ( in ) :: t ! Temperature [K] real ( pr ) :: v0 v0 = self % parameters ( 3 ) end function A complete implementation of the PR76 Equation of State can me found in example/adiff/adiff_pr76.f90 Uses hyperdual_mod yaeos__constants yaeos__models_ar Abstract Interfaces abstract interface public  function hyperdual_Ar(self, n, v, t) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual ) Derived Types type, public, abstract, extends( ArModel ) :: ArModelAdiff Components Type Visibility Attributes Name Initial type( Substances ), public :: components Substances contained in the module character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure( hyperdual_Ar ), public, deferred :: Ar procedure, public :: Cp_residual_vt procedure, public :: Cv_residual_vt procedure, public :: Psat_pure procedure, public :: enthalpy_residual_vt procedure, public :: entropy_residual_vt procedure( abs_volume_initializer ), public, deferred :: get_v0 procedure, public :: gibbs_residual_vt procedure, public :: internal_energy_residual_vt procedure, public :: lnfug_vt procedure, public :: lnphi_pt procedure, public :: lnphi_vt procedure, public :: pressure procedure, public :: residual_helmholtz procedure, public :: volume Subroutines public  subroutine residual_helmholtz (self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","url":"module/yaeos__adiff_hyperdual_ar_api.html"},{"title":"yaeos__auxiliar – yaeos","text":"Uses yaeos__constants Interfaces public        interface optval public  function optval_integer (val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: val integer, intent(in) :: default Return Value integer public  function optval_real (val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in), optional :: val real(kind=pr), intent(in) :: default Return Value real(kind=pr) public  function optval_character (val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: val character(len=*), intent(in) :: default Return Value character(len=:), allocatable Functions public  function optval_character (val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: val character(len=*), intent(in) :: default Return Value character(len=:), allocatable public  function optval_integer (val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: val integer, intent(in) :: default Return Value integer public  function optval_real (val, default) Set a value to a default if it is not defined Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in), optional :: val real(kind=pr), intent(in) :: default Return Value real(kind=pr) Subroutines public  subroutine sort (array, idx) Sort an array and return the indexes Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: array (:) integer, intent(out), optional :: idx (:)","tags":"","url":"module/yaeos__auxiliar.html"},{"title":"pressure_equality.f90 – yaeos","text":"Source Code module yaeos__solvers_pressure_equality !! Solve the pressure equality of a use yaeos__constants , only : pr , R use yaeos__models_ar , only : ArModel implicit none contains subroutine pressure_equality_V_beta_xy ( model , T , V , beta , x , y , vx , vy , P ) !! Solve pressure equality between two phases at a given temperature, !! total volume, vapor molar fractions and compositions. use iso_fortran_env , only : error_unit class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: V !! Total volume [L/mol] real ( pr ), intent ( in ) :: beta !! Molar fraction of light-phase real ( pr ), intent ( in ) :: x (:) !! Molar fractions of heavy-phase real ( pr ), intent ( in ) :: y (:) !! Molar fractions of light-phase real ( pr ), intent ( in out ) :: Vx !! Heavy-phase molar volume [L/mol] real ( pr ), intent ( in out ) :: Vy !! Light-Phase molar volume [L/mol] real ( pr ), intent ( out ) :: P !! Pressure [bar] real ( pr ) :: Bx !! Liquid phase covolume real ( pr ) :: dVydVx !! Derivative of Vy wrt Vx ! Pressure equality newton functions real ( pr ) :: h !! Pressure equality real ( pr ) :: dh !! dh/ real ( pr ) :: stepv real ( pr ) :: dPxdV , dPydV real ( pr ) :: Px , Py integer :: its dVydVx = - ( 1 - beta ) / beta Bx = model % get_v0 ( x , 0.1_pr , T ) ! First evaluation will be with Vx = 1.5*Bx if ( Vx < Bx ) Vx = 1.625_pr * Bx call model % pressure ( x , Vx , T , Px , dpdv = dPxdV ) do while ( Px < 0 . or . dPxdV >= 0 ) Vx = Vx - 0.2 * ( Vx - Bx ) call model % pressure ( x , Vx , T , Px , dpdv = dPxdV ) end do Vy = ( V - ( 1 - beta ) * Vx ) / beta h = 1.0 its = 0 do while ( abs ( h ) > 1.d-4 ) ! Newton for solving P equality, with Vx as independent variable its = its + 1 call model % pressure ( x , Vx , T , Px , dpdv = dPxdV ) call model % pressure ( y , Vy , T , Py , dpdv = dPydV ) h = Py - Px dh = - dPydV * dVydVx - dPxdV stepv = - h / dh if ( its >= 10 ) stepv = stepv / 2 Vx = Vx + stepv do while ( Vx < 1.001 * Bx ) stepv = stepv / 2 Vx = Vx - stepv end do Vy = ( v - ( 1 - beta ) * Vx ) / beta if ( its >= 100 ) then write ( error_unit , * ) \"WARN(FLASH_VT): volume convergence problems\" , Px , Py P = - 1.0 return end if end do call model % pressure ( x , Vx , T , Px ) call model % pressure ( y , Vy , T , Py ) P = ( Px + Py ) * 0.5_pr end subroutine pressure_equality_V_beta_xy end module yaeos__solvers_pressure_equality","tags":"","url":"sourcefile/pressure_equality.f90.html"},{"title":"unifac_parameters.f90 – yaeos","text":"Source Code module yaeos__models_ge_group_contribution_unifac_parameters !! # UNIFAC parameters !! UNIFAC parameters module !! !! # Description !! Instances of the yaeos GeGCModelParameters with the classic liquid-vapor !! UNIFAC parameters. !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  parameters = UNIFACParameters() !! !!  ! Get the maingroups i:1, j:7 interaction parameter aij (CH2-H2O) !!  print *, parameters%get_maingroups_aij(1, 7) ! prints: 1318.0000 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.ddbst !! .com/published-parameters-unifac.html) !! 2. Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975). !! Group‐contribution estimation of activity coefficients in nonideal liquid !! mixtures. AIChE Journal, 21(6), 1086–1099. !! [https://doi.org/10.1002/aic.690210607](https://doi.org/10.1002/aic.690210607) !! 3. Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979). !! Vapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and !! Extension. Industrial & Engineering Chemistry Process Design and !! Development, 18(4), 714–722. !! [https://doi.org/10.1021/i260072a024](https://doi.org/10.1021/i260072a024) !! 4. Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid !! equilibriums by UNIFAC group contribution. Revision and extension. 2. !! Industrial & Engineering Chemistry Process Design and Development, 21(1), !! 118–127. !! [https://doi.org/10.1021/i200016a021](https://doi.org/10.1021/i200016a021) !! 5. Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983). !! Vapor-liquid equilibriums by UNIFAC group contribution. Revision and !! extension. 3. Industrial & Engineering Chemistry Process Design and !! Development, 22(4), 676–678. !! [https://doi.org/10.1021/i200023a023](https://doi.org/10.1021/i200023a023) !! 6. Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987). !! Vapor-liquid equilibria by UNIFAC group contribution. 4. Revision and !! extension. Industrial & Engineering Chemistry Research, 26(1), 159–161. !! [https://doi.org/10.1021/ie00061a030](https://doi.org/10.1021/ie00061a030) !! 7. Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., & !! Gmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group !! contribution. 5. Revision and extension. Industrial & Engineering !! Chemistry Research, 30 (10), 2352–2355. !! [https://doi.org/10.1021/ie00058a017](https://doi.org/10.1021/ie00058a017) !! 8. Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria !! by UNIFAC Group Contribution. 6. Revision and Extension. Industrial & !! Engineering Chemistry Research, 42(1), 183–188. !! [https://doi.org/10.1021/ie020506l](https://doi.org/10.1021/ie020506l) !! use yaeos__constants , only : pr use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters implicit none contains type ( GeGCModelParameters ) function UNIFACParameters () !! # UNIFACParameters !! UNIFAC parameters !! !! # Description !! Create a Instance of the yaeos GeGCModelParameters with the classic !! liquid-vapor UNIFAC parameters. !! !! # Examples !! !! ```fortran !!  ! Instantiate an UNIFAC model with ethanol-water mix and calculate gammas !!  use yaeos, only: pr, Groups, setup_unifac, UNIFAC !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(UNIFAC) :: model !!  type(Groups) :: molecules(2) !!  real(pr) :: ln_gammas(2) !! !!  type(GeGCModelParameters) :: parameters !! !!  ! Ethanol definition [CH3, CH2, OH] !!  molecules(1)%groups_ids = [1, 2, 14] ! Subgroups ids !!  molecules(1)%number_of_groups = [1, 1, 1] ! Subgroups occurrences !! !!  ! Water definition [H2O] !!  molecules(2)%groups_ids = [16] !!  molecules(2)%number_of_groups = [1] !! !!  parameters = UNIFACParameters() !! !!  ! Model setup !!  ! Disclaimer: the default parameters object can be ommited in the !!  ! setup_unifac call, because if the parameters argument is not !!  ! provided, the return of the constructor UNIFACParameters() will be !!  ! used either way. This is just a demostration. !!  model = setup_unifac(molecules, parameters) !! !!  ! Calculate ln_gammas !!  call model%ln_activity_coefficient([0.5_pr, 0.5_pr], 298.0_pr, ln_gammas) !! !!  print *, ln_gammas ! result: 0.18534142000449058    0.40331395945417559 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.ddbst !! .com/published-parameters-unifac.html) !! 2. Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975). !! Group‐contribution estimation of activity coefficients in nonideal liquid !! mixtures. AIChE Journal, 21(6), 1086–1099. !! [https://doi.org/10.1002/aic.690210607](https://doi.org/10.1002/aic.690210607) !! 3. Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979). !! Vapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and !! Extension. Industrial & Engineering Chemistry Process Design and !! Development, 18(4), 714–722. !! [https://doi.org/10.1021/i260072a024](https://doi.org/10.1021/i260072a024) !! 4. Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid !! equilibriums by UNIFAC group contribution. Revision and extension. 2. !! Industrial & Engineering Chemistry Process Design and Development, 21(1), !! 118–127. !! [https://doi.org/10.1021/i200016a021](https://doi.org/10.1021/i200016a021) !! 5. Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983). !! Vapor-liquid equilibriums by UNIFAC group contribution. Revision and !! extension. 3. Industrial & Engineering Chemistry Process Design and !! Development, 22(4), 676–678. !! [https://doi.org/10.1021/i200023a023](https://doi.org/10.1021/i200023a023) !! 6. Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987). !! Vapor-liquid equilibria by UNIFAC group contribution. 4. Revision and !! extension. Industrial & Engineering Chemistry Research, 26(1), 159–161. !! [https://doi.org/10.1021/ie00061a030](https://doi.org/10.1021/ie00061a030) !! 7. Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., & !! Gmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group !! contribution. 5. Revision and extension. Industrial & Engineering !! Chemistry Research, 30 (10), 2352–2355. !! [https://doi.org/10.1021/ie00058a017](https://doi.org/10.1021/ie00058a017) !! 8. Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria !! by UNIFAC Group Contribution. 6. Revision and Extension. Industrial & !! Engineering Chemistry Research, 42(1), 183–188. !! [https://doi.org/10.1021/ie020506l](https://doi.org/10.1021/ie020506l) !! ! ======================================================================== ! UNIFAC subgroups ids definition ! ------------------------------------------------------------------------ UNIFACParameters % subgroups_ids = [& 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , & 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , & 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , & 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , & 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , & 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , & 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , & 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , & 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , & 109 , 118 , 119 , 178 , 179 & ] ! ======================================================================== ! UNIFAC maingroups ids definition ! ------------------------------------------------------------------------ UNIFACParameters % maingroups_ids = [& 1 , 2 , 3 , 4 , 5 , 6 , & 7 , 8 , 9 , 10 , 11 , 12 , & 13 , 14 , 15 , 16 , 17 , 18 , & 19 , 20 , 21 , 22 , 23 , 24 , & 25 , 26 , 27 , 28 , 29 , 30 , & 31 , 32 , 33 , 34 , 35 , 36 , & 37 , 38 , 39 , 40 , 41 , 42 , & 43 , 44 , 45 , 46 , 47 , 48 , & 49 , 50 , 51 , 55 , 84 , 85 & ] ! ======================================================================== ! UNIFAC subgroups maingroups ! ------------------------------------------------------------------------ UNIFACParameters % subgroups_maingroups = [& 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , & 4 , 5 , 6 , 7 , 8 , 9 , 9 , 10 , 11 , 11 , 12 , 13 , & 13 , 13 , 13 , 14 , 14 , 14 , 15 , 15 , 15 , 16 , 16 , 17 , & 18 , 18 , 18 , 19 , 19 , 20 , 20 , 21 , 21 , 21 , 22 , 22 , & 22 , 23 , 23 , 24 , 25 , 26 , 26 , 26 , 27 , 28 , 29 , 29 , & 30 , 31 , 32 , 33 , 34 , 34 , 35 , 36 , 37 , 2 , 38 , 39 , & 39 , 40 , 40 , 40 , 41 , 42 , 42 , 42 , 42 , 43 , 43 , 43 , & 44 , 45 , 45 , 45 , 45 , 45 , 45 , 45 , 45 , 46 , 46 , 46 , & 46 , 46 , 46 , 47 , 47 , 48 , 48 , 48 , 49 , 50 , 50 , 50 , & 51 , 55 , 55 , 84 , 85 & ] ! ======================================================================== ! UNIFAC subgroups Rs ! ------------------------------------------------------------------------ UNIFACParameters % subgroups_Rs = [& 0.90110_pr , 0.67440_pr , 0.44690_pr , 0.21950_pr , 1.34540_pr , & 1.11670_pr , 1.11730_pr , 0.88860_pr , 0.53130_pr , 0.36520_pr , & 1.26630_pr , 1.03960_pr , 0.81210_pr , 1.00000_pr , 1.43110_pr , & 0.92000_pr , 0.89520_pr , 1.67240_pr , 1.44570_pr , 0.99800_pr , & 1.90310_pr , 1.67640_pr , 1.24200_pr , 1.14500_pr , 0.91830_pr , & 0.69080_pr , 0.91830_pr , 1.59590_pr , 1.36920_pr , 1.14170_pr , & 1.43370_pr , 1.20700_pr , 0.97950_pr , 1.18650_pr , 0.95970_pr , & 1.06000_pr , 2.99930_pr , 2.83320_pr , 2.66700_pr , 1.87010_pr , & 1.64340_pr , 1.30130_pr , 1.52800_pr , 1.46540_pr , 1.23800_pr , & 1.01060_pr , 2.25640_pr , 2.06060_pr , 1.80160_pr , 2.87000_pr , & 2.64010_pr , 3.39000_pr , 1.15620_pr , 2.00860_pr , 1.78180_pr , & 1.55440_pr , 1.41990_pr , 2.05700_pr , 1.87700_pr , 1.65100_pr , & 3.16800_pr , 2.40880_pr , 1.26400_pr , 0.94920_pr , 1.29200_pr , & 1.06130_pr , 2.82660_pr , 2.31440_pr , 0.79100_pr , 0.66050_pr , & 0.69480_pr , 3.08560_pr , 2.63220_pr , 1.40600_pr , 1.01050_pr , & 0.61500_pr , 1.38000_pr , 1.60350_pr , 1.44430_pr , 1.28530_pr , & 1.04700_pr , 1.48380_pr , 1.30300_pr , 1.10440_pr , 3.98100_pr , & 3.03560_pr , 2.22870_pr , 2.40600_pr , 1.64930_pr , 1.81740_pr , & 1.96700_pr , 2.17210_pr , 2.62430_pr , 1.45150_pr , 2.19050_pr , & 1.96370_pr , 2.85890_pr , 2.63220_pr , 2.40540_pr , 2.12260_pr , & 1.89520_pr , 1.61300_pr , 1.38630_pr , 1.15890_pr , 3.47400_pr , & 2.85690_pr , 2.69080_pr , 2.52470_pr , 1.05670_pr , 2.68690_pr , & 2.45950_pr , 2.02600_pr , 5.77400_pr & ] ! ======================================================================== ! UNIFAC subgroups Qs ! ------------------------------------------------------------------------ UNIFACParameters % subgroups_Qs = [& 0.84800_pr , 0.54000_pr , 0.22800_pr , 0.00000_pr , 1.17600_pr , & 0.86700_pr , 0.98800_pr , 0.67600_pr , 0.40000_pr , 0.12000_pr , & 0.96800_pr , 0.66000_pr , 0.34800_pr , 1.20000_pr , 1.43200_pr , & 1.40000_pr , 0.68000_pr , 1.48800_pr , 1.18000_pr , 0.94800_pr , & 1.72800_pr , 1.42000_pr , 1.18800_pr , 1.08800_pr , 0.78000_pr , & 0.46800_pr , 1.10000_pr , 1.54400_pr , 1.23600_pr , 0.92400_pr , & 1.24400_pr , 0.93600_pr , 0.62400_pr , 0.94000_pr , 0.63200_pr , & 0.81600_pr , 2.11300_pr , 1.83300_pr , 1.55300_pr , 1.72400_pr , & 1.41600_pr , 1.22400_pr , 1.53200_pr , 1.26400_pr , 0.95200_pr , & 0.72400_pr , 1.98800_pr , 1.68400_pr , 1.44800_pr , 2.41000_pr , & 2.18400_pr , 2.91000_pr , 0.84400_pr , 1.86800_pr , 1.56000_pr , & 1.24800_pr , 1.10400_pr , 1.65000_pr , 1.67600_pr , 1.36800_pr , & 2.48400_pr , 2.24800_pr , 0.99200_pr , 0.83200_pr , 1.08800_pr , & 0.78400_pr , 2.47200_pr , 2.05200_pr , 0.72400_pr , 0.48500_pr , & 0.52400_pr , 2.73600_pr , 2.12000_pr , 1.38000_pr , 0.92000_pr , & 0.46000_pr , 1.20000_pr , 1.26320_pr , 1.00630_pr , 0.74940_pr , & 0.40990_pr , 1.06210_pr , 0.76390_pr , 0.46570_pr , 3.20000_pr , & 2.64400_pr , 1.91600_pr , 2.11600_pr , 1.41600_pr , 1.64800_pr , & 1.82800_pr , 2.10000_pr , 2.37600_pr , 1.24800_pr , 1.79600_pr , & 1.48800_pr , 2.42800_pr , 2.12000_pr , 1.81200_pr , 1.90400_pr , & 1.59200_pr , 1.36800_pr , 1.06000_pr , 0.74800_pr , 2.79600_pr , & 2.14000_pr , 1.86000_pr , 1.58000_pr , 0.73200_pr , 2.12000_pr , & 1.80800_pr , 0.86800_pr , 4.93200_pr & ] ! ======================================================================== ! UNIFAC aij ! ------------------------------------------------------------------------ UNIFACParameters % maingroups_aij = reshape ([& 0.00000_pr , - 3 5.36000_pr , - 1 1.12000_pr , - 6 9.70000_pr , 15 6.40000_pr , & 1 6.51000_pr , 30 0.00000_pr , 27 5.80000_pr , 2 6.76000_pr , 50 5.70000_pr , & 11 4.80000_pr , 32 9.30000_pr , 8 3.36000_pr , - 3 0.48000_pr , 6 5.33000_pr , & - 8 3.98000_pr , 113 9.00000_pr , - 10 1.56000_pr , 2 4.82000_pr , 31 5.30000_pr , & 9 1.46000_pr , 3 4.01000_pr , 3 6.70000_pr , - 7 8.45000_pr , 10 6.80000_pr , & - 3 2.69000_pr , 554 1.00000_pr , - 5 2.65000_pr , - 7.48100_pr , - 2 5.31000_pr , & 13 9.93000_pr , 12 8.00000_pr , - 3 1.52000_pr , - 7 2.88000_pr , 5 0.49000_pr , & - 16 5.90000_pr , 4 7.41000_pr , - 5.13200_pr , - 3 1.95000_pr , 14 7.30000_pr , & 52 9.00000_pr , - 3 4.36000_pr , 11 0.20000_pr , 1 3.89000_pr , 3 0.74000_pr , & 2 7.97000_pr , - 1 1.92000_pr , 3 9.93000_pr , - 2 3.61000_pr , - 8.47900_pr , & 45 6.19000_pr , 24 5.21000_pr , 12 5.36000_pr , 22 1.56000_pr , 8 6.02000_pr , & 0.00000_pr , 3.44600_pr , - 11 3.60000_pr , 45 7.00000_pr , - 1 2.52000_pr , & 49 6.10000_pr , 21 7.50000_pr , 4 2.92000_pr , 5 6.30000_pr , 13 2.10000_pr , & 11 0.40000_pr , 2 6.51000_pr , 1.16300_pr , - 2 8.70000_pr , - 2 5.38000_pr , & 200 0.00000_pr , - 4 7.63000_pr , - 4 0.62000_pr , 126 4.00000_pr , 4 0.25000_pr , & - 2 3.50000_pr , 5 1.06000_pr , 16 0.90000_pr , 7 0.32000_pr , - 1.99600_pr , & 0.00000_pr , 1 6.62300_pr , 0.00000_pr , 8 2.64000_pr , 0.00000_pr , & 0.00000_pr , 17 4.60000_pr , 4 1.38000_pr , 6 4.07000_pr , 57 3.00000_pr , & 12 4.20000_pr , - 13 1.70000_pr , 24 9.00000_pr , 6 2.40000_pr , 139 7.00000_pr , & 0.00000_pr , 0.00000_pr , - 1 6.11000_pr , 0.00000_pr , 9.75500_pr , & 13 2.40000_pr , 54 3.60000_pr , 16 1.10000_pr , 0.00000_pr , 0.00000_pr , & 38 4.45000_pr , - 39 1.81000_pr , 62 9.96000_pr , 6 1.13000_pr , 3 8.81000_pr , & 0.00000_pr , - 14 6.80000_pr , 8 9.60000_pr , - 5 0.00000_pr , 36 2.30000_pr , & 2 5.34000_pr , 14 0.10000_pr , 2 3.39000_pr , 8 5.84000_pr , 1 8.12000_pr , & 5 2.13000_pr , - 4 4.85000_pr , - 2 2.31000_pr , - 22 3.90000_pr , 24 7.50000_pr , & 3 1.87000_pr , - 2 2.97000_pr , 6 2.32000_pr , 4.68000_pr , 12 1.30000_pr , & 28 8.50000_pr , - 4.70000_pr , - 9 7.27000_pr , 1 0.38000_pr , 182 4.00000_pr , & 2 1.49700_pr , 2 8.41000_pr , 15 7.29000_pr , 22 1.40000_pr , 5 8.68000_pr , & - 15 4.20000_pr , - 10 1.12000_pr , - 2.50400_pr , - 12 3.60000_pr , 39 5.80000_pr , & - 23 7.20000_pr , - 13 3.90000_pr , 14 0.60000_pr , 31 7.60000_pr , 78 7.90000_pr , & 23 4.40000_pr , - 2 3.88000_pr , 16 7.90000_pr , 0.00000_pr , - 8 6.88000_pr , & 0.00000_pr , 14 2.90000_pr , 2 3.93000_pr , 0.00000_pr , 4 7.05000_pr , & 0.00000_pr , 0.00000_pr , 7 6.50000_pr , 7 4.15000_pr , 16 7.00000_pr , & 0.00000_pr , 2 5.82000_pr , - 4 4.50000_pr , 37 7.60000_pr , 24 4.20000_pr , & 36 5.80000_pr , 10 6.00000_pr , - 17 0.00000_pr , 42 8.00000_pr , 6 5.69000_pr , & 29 6.40000_pr , 22 3.00000_pr , 10 9.90000_pr , 76 2.80000_pr , 4 9.80000_pr , & - 13 8.40000_pr , 8 9.86000_pr , 12 2.91000_pr , 14 0.78000_pr , 6 9.90000_pr , & 13 4.70000_pr , 40 2.50000_pr , - 9 7.05000_pr , - 12 7.80000_pr , 4 0.67500_pr , & 1 9.56000_pr , 12 8.80000_pr , 15 0.64000_pr , 2 6.41000_pr , 111 2.00000_pr , & 61 4.52000_pr , - 14 3.20000_pr , 39 7.40000_pr , 41 9.10000_pr , - 15 7.30000_pr , & - 24 0.20000_pr , 83 9.83000_pr , 61 5.80000_pr , 0.00000_pr , 0.00000_pr , & 6.21400_pr , 0.00000_pr , 0.00000_pr , - 1 9.45000_pr , 0.00000_pr , & 27 4.10000_pr , 2.84500_pr , 0.00000_pr , 34 7.13000_pr , 0.00000_pr , & 0.00000_pr , 98 6.50000_pr , 52 4.10000_pr , 63 6.10000_pr , 80 3.20000_pr , & 0.00000_pr , 24 9.10000_pr , - 22 9.10000_pr , - 45 1.60000_pr , 16 4.50000_pr , & 52 9.00000_pr , 24 5.40000_pr , 13 9.40000_pr , 23 7.70000_pr , - 24 2.80000_pr , & - 15 0.00000_pr , 2 8.60000_pr , - 1 7.40000_pr , - 13 2.30000_pr , 18 5.40000_pr , & - 15 1.00000_pr , 56 2.20000_pr , 52 7.60000_pr , 74 2.10000_pr , 85 6.30000_pr , & 32 5.70000_pr , 26 1.60000_pr , 56 1.60000_pr , 60 9.80000_pr , 46 1.60000_pr , & 52 1.63000_pr , 26 7.60000_pr , 50 1.30000_pr , 52 4.90000_pr , 6 8.95000_pr , & - 2 5.87000_pr , 38 9.30000_pr , 73 8.90000_pr , 64 9.70000_pr , 6 4.16000_pr , & 0.00000_pr , 8 8.63000_pr , 191 3.00000_pr , 43 0.06000_pr , 79 6.90000_pr , & 79 4.40000_pr , 39 4.80000_pr , 51 7.50000_pr , 0.00000_pr , - 6 1.20000_pr , & 68 2.50000_pr , 0.00000_pr , 7 2.19000_pr , 11 1.65000_pr , 12 2.19000_pr , & 69 7.20000_pr , 78 7.60000_pr , 63 7.35000_pr , 60 3.25000_pr , - 13 7.10000_pr , & 0.00000_pr , 28 9.60000_pr , - 26 5.20000_pr , 10 8.65000_pr , - 34 0.18000_pr , & 24 9.63000_pr , 22 7.80000_pr , 23 8.40000_pr , - 48 1.65000_pr , - 37 0.30000_pr , & - 40 6.80000_pr , - 11 8.10000_pr , - 37 8.24000_pr , 16 2.60000_pr , 33 9.80000_pr , & 52 9.00000_pr , 66 9.90000_pr , 64 9.10000_pr , 70 9.60000_pr , 61 2.80000_pr , & 25 2.56000_pr , 51 1.29000_pr , 91 4.20000_pr , 44 8.60000_pr , 28 7.00000_pr , & 24 0.80000_pr , 43 1.30000_pr , 49 4.70000_pr , 96 7.71000_pr , 69 5.00000_pr , & 21 8.80000_pr , 52 8.00000_pr , 64 5.90000_pr , 17 2.20000_pr , 0.00000_pr , & 17 1.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 76 2.70000_pr , & 0.00000_pr , 0.00000_pr , 42 0.00000_pr , - 8 9.24000_pr , 59 7.80000_pr , & 0.00000_pr , 26 5.75000_pr , 0.00000_pr , 0.00000_pr , 131 8.00000_pr , & 27 0.60000_pr , 90 3.80000_pr , 569 5.00000_pr , 35 3.50000_pr , - 18 0.95000_pr , & 0.00000_pr , - 60 1.80000_pr , 47 2.50000_pr , 48 0.80000_pr , 20 0.80000_pr , & 12 4.63000_pr , - 31 4.70000_pr , - 33 0.40000_pr , - 44 8.20000_pr , - 59 8.80000_pr , & - 34 1.60000_pr , - 33 2.90000_pr , 24 2.80000_pr , - 6 6.17000_pr , 69 8.24000_pr , & 70 8.69000_pr , 82 6.76000_pr , 120 1.00000_pr , - 27 4.50000_pr , 41 7.90000_pr , & 36 0.70000_pr , 108 1.00000_pr , 0.00000_pr , 2 3.48400_pr , - 13 7.40000_pr , & 0.00000_pr , 7 9.18000_pr , 0.00000_pr , - 24 0.00000_pr , 38 6.60000_pr , & 0.00000_pr , 0.00000_pr , - 28 7.10000_pr , 0.00000_pr , 28 4.40000_pr , & 18 0.20000_pr , 0.00000_pr , 83 2.20000_pr , 0.00000_pr , - 50 9.30000_pr , & - 20 5.70000_pr , 0.00000_pr , - 38 4.30000_pr , 0.00000_pr , 0.00000_pr , & 62 7.39000_pr , 0.00000_pr , 0.00000_pr , 133 3.00000_pr , 52 6.10000_pr , & 132 9.00000_pr , 88 4.90000_pr , - 25 9.70000_pr , - 10 1.70000_pr , 32 4.50000_pr , & 0.00000_pr , - 13 3.10000_pr , - 15 5.60000_pr , - 3 6.72000_pr , - 23 4.25000_pr , & - 17 8.54610_pr , - 87 0.80000_pr , 0.00000_pr , 0.00000_pr , - 25 3.10000_pr , & - 34 1.60000_pr , 0.00000_pr , - 1 1.00000_pr , 0.00000_pr , 163 3.50000_pr , & 0.00000_pr , 1000 0.00000_pr , 62 2.30000_pr , 0.00000_pr , 81 5.12000_pr , & 142 1.30000_pr , 0.00000_pr , 0.00000_pr , 83 8.40000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 16 7.30000_pr , 0.00000_pr , & 0.00000_pr , - 23 4.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 81 0.50000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 47 6.40000_pr , 18 2.60000_pr , 2 5.77000_pr , & - 5 2.10000_pr , 8 4.00000_pr , 2 3.39000_pr , - 19 5.40000_pr , - 35 6.10000_pr , & 0.00000_pr , 12 8.00000_pr , 37 2.20000_pr , 38 5.40000_pr , 19 1.10000_pr , & 0.00000_pr , 39 4.60000_pr , 22 5.30000_pr , - 45 0.30000_pr , 2 9.10000_pr , & - 28 7.50000_pr , - 29 7.80000_pr , 28 6.28000_pr , 8 2.86000_pr , 55 2.10000_pr , & 37 2.00000_pr , 51 8.40000_pr , - 14 2.61000_pr , - 10 1.50000_pr , 30 3.65700_pr , & 16 0.60000_pr , 31 7.50000_pr , 13 5.40000_pr , 13 8.00000_pr , - 14 2.60000_pr , & 44 3.61500_pr , 11 0.40000_pr , 11 4.55000_pr , - 4 0.90000_pr , 0.00000_pr , & 9 7.04000_pr , 0.00000_pr , 12 3.40000_pr , 99 2.40000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 15 6.40000_pr , 0.00000_pr , & 0.00000_pr , 27 8.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 67 7.00000_pr , 44 8.75000_pr , 34 7.30000_pr , 58 6.80000_pr , & - 20 3.60000_pr , 30 6.42000_pr , - 11 6.00000_pr , - 27 1.10000_pr , - 3 7.36000_pr , & 0.00000_pr , 18 5.10000_pr , - 23 6.50000_pr , - 7.83800_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 22 4.66000_pr , & - 16 5.50000_pr , - 4 7.51000_pr , 19 0.60000_pr , 24 2.80000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 24 5.90000_pr , 0.00000_pr , - 5 5.87000_pr , & 0.00000_pr , 35 4.00000_pr , 18 3.80000_pr , 0.00000_pr , 1 3.89000_pr , & 0.00000_pr , 57 7.50000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 23 2.10000_pr , 3 7.85000_pr , 5.99400_pr , 568 8.00000_pr , 10 1.10000_pr , & - 1 0.72000_pr , 7 2.87000_pr , - 44 9.40000_pr , - 21 3.70000_pr , - 11 0.30000_pr , & 0.00000_pr , 116 7.00000_pr , 46 1.30000_pr , 0.00000_pr , 13 6.00000_pr , & 288 8.60010_pr , - 29 4.80000_pr , 8.87000_pr , - 26 6.60000_pr , - 25 6.30000_pr , & 3 5.38000_pr , - 13 2.95000_pr , 17 6.45000_pr , 12 9.49000_pr , - 17 1.10000_pr , & 12 9.30000_pr , 0.00000_pr , 24 3.77500_pr , 0.00000_pr , - 14 6.31000_pr , & 15 2.00000_pr , 2 1.92000_pr , 2 4.37000_pr , - 11 1.45000_pr , 4 1.57000_pr , & 17 5.53000_pr , 61 1.30000_pr , 0.00000_pr , - 8 2.12000_pr , 0.00000_pr , & - 23 4.90000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 3.44400_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 50 7.00000_pr , & 33 3.50000_pr , 28 7.10000_pr , 19 7.80000_pr , 26 7.80000_pr , 17 9.70000_pr , & 23 3.87000_pr , - 3 2.52000_pr , - 19 0.40000_pr , 76 6.00000_pr , - 24 1.80000_pr , & 0.00000_pr , 45 7.30000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 55 4.40000_pr , 9 9.37000_pr , 19 3.90000_pr , 0.00000_pr , & 8 0.99000_pr , 23 5.60000_pr , 35 1.90000_pr , 38 3.30000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 20 1.50000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 9 2.26000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 13 4.50000_pr , 0.00000_pr , - 11 6.70000_pr , 0.00000_pr , 14 5.40000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 25 1.50000_pr , 21 4.50000_pr , & 3 2.14000_pr , 21 3.10000_pr , 2 8.06000_pr , - 12 8.60000_pr , 54 0.50000_pr , & - 16 2.87420_pr , - 10 3.60000_pr , 30 4.10000_pr , - 23 5.70000_pr , - 23 4.00000_pr , & 0.00000_pr , 22 2.10000_pr , - 5 6.08000_pr , - 19 4.10000_pr , 28 5.36000_pr , & - 15 6.10000_pr , 3 8.81000_pr , - 33 8.50000_pr , 22 5.39000_pr , - 19 7.71000_pr , & - 2 0.93000_pr , 11 3.90000_pr , - 2 5.15000_pr , - 9 4.49000_pr , 22 0.66000_pr , & 11 2.38200_pr , 6 3.71000_pr , - 8 7.31000_pr , 9.20700_pr , 47 6.60000_pr , & 73 6.40000_pr , 17 3.77000_pr , - 9 3.51000_pr , 0.00000_pr , - 21 7.90000_pr , & 16 7.30000_pr , - 15 8.20000_pr , 27 8.15000_pr , - 24 7.80000_pr , 44 8.50000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 39 1.50000_pr , 24 0.90000_pr , 16 1.70000_pr , & 1 9.02000_pr , 8.64200_pr , 35 9.30000_pr , 4 8.89000_pr , - 83 2.97000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 7 8.36000_pr , & 0.00000_pr , 12 7.40000_pr , 3 8.89000_pr , - 1 5.07000_pr , 0.00000_pr , & - 15 7.30000_pr , 0.00000_pr , 13 1.20000_pr , 0.00000_pr , 0.00000_pr , & 26 1.10000_pr , 10 8.50000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 10 6.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 36 6.51000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 4 9.70000_pr , 0.00000_pr , 0.00000_pr , 96 1.80000_pr , - 12 5.20000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 25 5.70000_pr , 16 3.90000_pr , 12 2.80000_pr , - 4 9.29000_pr , & 4 2.70000_pr , - 2 0.98000_pr , 16 8.00000_pr , 0.00000_pr , - 17 4.20000_pr , & 0.00000_pr , - 7 3.50000_pr , 0.00000_pr , 25 1.50000_pr , - 10 7.20000_pr , & 0.00000_pr , 86 5.90000_pr , 6 4.30000_pr , - 20 7.66000_pr , - 10 8.50000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 9 1.13000_pr , & 10 2.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 21 3.74000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 19 8.80000_pr , 1 0.03000_pr , & 0.00000_pr , 28 4.50000_pr , 146 4.20000_pr , 160 3.80000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 20 6.60000_pr , 6 1.11000_pr , 9 0.49000_pr , 2 3.50000_pr , - 32 3.00000_pr , & 5 3.90000_pr , 30 4.00000_pr , 0.00000_pr , - 16 9.00000_pr , 0.00000_pr , & - 19 6.70000_pr , 0.00000_pr , 542 2.29980_pr , - 4 1.11000_pr , - 18 9.20000_pr , & 0.00000_pr , - 2 4.46000_pr , 0.00000_pr , - 44 6.86000_pr , 0.00000_pr , & 15 1.38000_pr , - 14 1.40000_pr , - 29 3.70000_pr , 31 6.90000_pr , 295 1.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 25 7.20000_pr , & 0.00000_pr , 0.00000_pr , 11 6.47800_pr , - 18 5.20000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 92 0.70000_pr , & 74 9.30000_pr , 64 8.20000_pr , 66 4.20000_pr , - 5 2.39000_pr , 48 9.70000_pr , & 24 3.20000_pr , 11 9.90000_pr , 620 1.00000_pr , 0.00000_pr , 47 5.50000_pr , & 0.00000_pr , - 4 6.39000_pr , - 20 0.70000_pr , 13 8.54000_pr , 28 7.43000_pr , & 0.00000_pr , 11 7.40000_pr , 77 7.40000_pr , 49 3.80000_pr , 42 9.70000_pr , & 14 0.80000_pr , 0.00000_pr , 89 8.20000_pr , 33 4.90000_pr , 0.00000_pr , & 13 4.90000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 19 2.30000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 34 3.70000_pr , 0.00000_pr , - 2 2.10000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 28 7.77000_pr , 28 0.50000_pr , & - 4.44900_pr , 5 2.80000_pr , 17 0.02900_pr , 58 0.48000_pr , 45 9.00000_pr , & - 30 5.50000_pr , 7.34100_pr , 0.00000_pr , - 0.13000_pr , - 23 3.40000_pr , & 21 3.20000_pr , 0.00000_pr , 43 1.49000_pr , 0.00000_pr , 8 9.70000_pr , & 0.00000_pr , 13 4.28000_pr , - 31 3.50000_pr , 0.00000_pr , 58 7.30000_pr , & 1 8.98000_pr , 36 8.50000_pr , 2 0.18000_pr , 0.00000_pr , 247 5.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 4 2.71000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 28 1.60000_pr , & 15 9.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 22 1.40000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 59 7.00000_pr , 33 6.90000_pr , 21 2.50000_pr , & 609 6.00000_pr , 6.71200_pr , 5 3.28000_pr , 11 2.60000_pr , 0.00000_pr , & 48 1.70000_pr , - 10 6.40000_pr , 49 4.60000_pr , - 4 7.25000_pr , - 1 8.51000_pr , & 35 8.90000_pr , 14 7.10000_pr , 125 5.10000_pr , - 28 1.60000_pr , - 16 9.67000_pr , & 0.00000_pr , 9 2.07000_pr , 5 4.32000_pr , 25 8.60000_pr , 7 4.04000_pr , & 49 1.95000_pr , 36 3.50000_pr , 0.28300_pr , 0.00000_pr , 33 5.74300_pr , & 16 1.00000_pr , 0.00000_pr , 16 9.60000_pr , 0.00000_pr , 13 6.90000_pr , & 32 9.12000_pr , 0.00000_pr , - 4 2.31000_pr , 33 5.20000_pr , 0.00000_pr , & 15 0.60000_pr , 0.00000_pr , - 6 1.60000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 11 9.20000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 66 3.50000_pr , 31 8.90000_pr , 53 7.40000_pr , 87 2.30000_pr , & 19 9.00000_pr , - 20 2.00000_pr , - 1 4.09000_pr , 40 8.90000_pr , 66 9.40000_pr , & 49 7.50000_pr , 66 0.20000_pr , - 26 8.10000_pr , 66 4.60000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 39 6.00000_pr , - 15 3.70000_pr , 20 5.27000_pr , & 0.00000_pr , 51 9.10000_pr , 54 3.30000_pr , 50 4.20000_pr , 63 1.00000_pr , & 99 3.40000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 57 0.60000_pr , 0.00000_pr , 61 6.60000_pr , 525 6.00000_pr , 0.00000_pr , & - 18 0.20000_pr , 0.00000_pr , 89 8.20000_pr , 0.00000_pr , - 9 7.77000_pr , & 0.00000_pr , 117 9.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 7 0.25000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 3 5.93000_pr , - 3 6.87000_pr , - 1 8.81000_pr , - 11 4.14000_pr , 7 5.62000_pr , & - 3 8.32000_pr , 32 5.44000_pr , 0.00000_pr , - 19 1.69000_pr , 75 1.90000_pr , & - 3 4.74000_pr , 0.00000_pr , 30 1.14000_pr , - 8 2.92000_pr , 0.00000_pr , & - 18 2.91000_pr , 28 7.00000_pr , 0.00000_pr , 4.93300_pr , 1 3.41000_pr , & 0.00000_pr , - 8 4.53000_pr , - 15 7.10000_pr , 1 1.80000_pr , - 12 9.70000_pr , & 11 3.00000_pr , 197 1.00000_pr , - 7 3.09200_pr , - 2 7.94000_pr , - 3 9.46000_pr , & 0.00000_pr , 17 9.25000_pr , - 26 2.30000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 38 3.20000_pr , 0.00000_pr , - 5 5.21000_pr , 0.00000_pr , & 18 2.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 5 3.76000_pr , & 5 8.55000_pr , - 14 4.40000_pr , - 11 1.00000_pr , 6 5.28000_pr , - 10 2.54000_pr , & 37 0.40000_pr , 51 7.27000_pr , - 13 0.30000_pr , 6 7.52000_pr , 10 8.85000_pr , & 3 1.00000_pr , 13 7.77000_pr , 0.00000_pr , 0.00000_pr , - 7 3.85000_pr , & - 11 1.00000_pr , - 35 1.60000_pr , - 15 2.70000_pr , - 4 4.70000_pr , 10 8.31000_pr , & 0.00000_pr , 0.00000_pr , 1 7.97000_pr , - 8.30900_pr , - 9.63900_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 11 6.21000_pr , 0.00000_pr , & - 4 0.82000_pr , - 17 4.50000_pr , 0.00000_pr , - 21 5.00000_pr , 0.00000_pr , & 30 1.90000_pr , 0.00000_pr , 39 7.24000_pr , 0.00000_pr , 30 5.40000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 19 4.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 2 4.90000_pr , - 1 3.99000_pr , & - 23 1.90000_pr , - 8 0.25000_pr , - 9 8.12000_pr , - 13 9.35000_pr , 35 3.68000_pr , & 0.00000_pr , - 35 4.55000_pr , - 48 3.70000_pr , - 20 9.66000_pr , - 12 6.20000_pr , & - 15 4.30000_pr , 0.00000_pr , 0.00000_pr , - 35 2.90000_pr , 0.00000_pr , & - 11 4.73000_pr , - 1 5.62000_pr , 3 9.63000_pr , 24 9.15000_pr , 0.00000_pr , & 0.00000_pr , 5 1.90000_pr , - 0.22660_pr , 0.00000_pr , 0.00000_pr , & - 2 6.05800_pr , 0.00000_pr , 4 8.48400_pr , 0.00000_pr , 2 1.76000_pr , & - 4 6.80000_pr , 0.00000_pr , - 34 3.60000_pr , 0.00000_pr , - 14 9.80000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 19 3.00000_pr , 0.00000_pr , & 0.00000_pr , - 19 6.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 36 3.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 10 4.30000_pr , - 10 9.70000_pr , 3.00000_pr , & - 14 1.30000_pr , 14 3.10000_pr , - 4 4.76000_pr , 49 7.54000_pr , 182 7.00000_pr , & - 3 9.20000_pr , 0.00000_pr , 5 4.57000_pr , 17 9.70000_pr , 4 7.67000_pr , & - 9 9.81000_pr , 7 1.23000_pr , - 26 2.00000_pr , 88 2.00000_pr , - 20 5.30000_pr , & - 5 4.86000_pr , 18 3.40000_pr , 6 2.42000_pr , 5 6.33000_pr , - 3 0.10000_pr , & 0.00000_pr , 24 8.40000_pr , - 3 4.68000_pr , 51 4.60000_pr , - 6 0.71000_pr , & 0.00000_pr , - 13 3.16000_pr , 0.00000_pr , 4 8.49000_pr , 7 7.55000_pr , & 0.00000_pr , - 5 8.43000_pr , - 8 5.14800_pr , - 13 4.20000_pr , - 12 4.60000_pr , & - 18 6.70000_pr , 0.00000_pr , 33 5.70000_pr , 0.00000_pr , 7 0.81000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 3.16300_pr , - 1 1.30000_pr , & 0.00000_pr , - 7 9.34000_pr , 0.00000_pr , 7 5.04000_pr , 0.00000_pr , & 0.00000_pr , 1 1.44000_pr , 10 0.10000_pr , 18 7.00000_pr , - 21 1.00000_pr , & 12 3.50000_pr , - 2 8.25000_pr , 13 3.90000_pr , 691 5.00000_pr , - 11 9.80000_pr , & 0.00000_pr , 44 2.40000_pr , 2 4.28000_pr , 13 4.80000_pr , 3 0.05000_pr , & - 1 8.93000_pr , - 18 1.90000_pr , 61 7.50000_pr , - 2.17000_pr , - 4.62400_pr , & - 7 9.08000_pr , 15 3.00000_pr , 22 3.10000_pr , 19 2.10000_pr , - 7 5.97000_pr , & 0.00000_pr , 13 2.90000_pr , - 12 3.10000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 18 5.30000_pr , 0.00000_pr , & - 33 4.12000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 37 4.16000_pr , & 3 3.95000_pr , 95 6.10000_pr , 0.00000_pr , 0.00000_pr , 16 1.50000_pr , & 0.00000_pr , 0.00000_pr , 7.08200_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 66 1.50000_pr , 35 7.50000_pr , 16 8.04000_pr , 362 9.00000_pr , 25 6.50000_pr , & 7 5.14000_pr , 22 0.60000_pr , 0.00000_pr , 13 7.50000_pr , 0.00000_pr , & - 8 1.13000_pr , 0.00000_pr , 9 5.18000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.51500_pr , 0.00000_pr , & 3 2.73000_pr , 10 8.90000_pr , 0.00000_pr , 49 0.88000_pr , 13 2.70000_pr , & 0.00000_pr , - 8 5.12000_pr , 27 7.80000_pr , 0.00000_pr , 0.00000_pr , & 48 1.34800_pr , 6 4.28000_pr , 12 5.30000_pr , 17 4.43300_pr , 0.00000_pr , & 0.00000_pr , 37 9.40000_pr , 0.00000_pr , 22 3.60000_pr , 0.00000_pr , & - 12 4.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 84 4.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 17 6.30000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 54 3.00000_pr , & 0.00000_pr , 19 4.90000_pr , 444 8.00000_pr , 15 7.10000_pr , 45 7.88000_pr , & 39 9.50000_pr , - 41 3.48000_pr , 54 8.50000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 15 5.11000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 13 9.30000_pr , 284 5.00000_pr , 0.00000_pr , 0.00000_pr , 8 6.20000_pr , & 0.00000_pr , 0.00000_pr , 53 4.70000_pr , 221 3.00000_pr , 53 3.20000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 244 8.00000_pr , 428 8.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 15 3.60000_pr , 7 6.30000_pr , & 5 2.06800_pr , - 9.45100_pr , 48 8.90000_pr , - 3 1.09000_pr , 88 7.10000_pr , & 848 3.50000_pr , 21 6.13800_pr , 0.00000_pr , 18 3.04600_pr , 0.00000_pr , & 14 0.89600_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 23 0.85200_pr , 0.00000_pr , 45 0.08800_pr , 0.00000_pr , & 11 6.61200_pr , 13 2.20000_pr , 0.00000_pr , 32 0.20000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 2 7.45000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 16 7.90000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 88 5.50000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 18 4.40000_pr , 0.00000_pr , - 1 0.43000_pr , & 39 3.60000_pr , 14 7.50000_pr , 1 7.50000_pr , 0.00000_pr , 0.00000_pr , & - 4 6.28000_pr , 0.00000_pr , 0.00000_pr , 10 3.90000_pr , - 8.53800_pr , & - 7 0.14000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.46040_pr , 0.00000_pr , 5 9.02000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 8 5.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 7 1.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 27 4.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 6.97100_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 35 4.55000_pr , 26 2.90000_pr , - 6 4.69000_pr , 4 8.49000_pr , & - 12 0.46000_pr , - 6 1.76000_pr , 18 8.02600_pr , 0.00000_pr , - 16 3.70000_pr , & 0.00000_pr , 20 2.25000_pr , 0.00000_pr , 17 0.10000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 20 8.90000_pr , 6 5.56000_pr , 14 9.56000_pr , - 6 4.38000_pr , 54 6.68000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 6 4.28000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 302 5.00000_pr , 0.00000_pr , 21 0.36600_pr , 497 5.00000_pr , - 31 8.93000_pr , & - 11 9.20000_pr , 1 2.72000_pr , - 68 7.10000_pr , 7 1.46000_pr , 0.00000_pr , & - 10 1.70000_pr , 0.00000_pr , - 2 0.11000_pr , 0.00000_pr , 93 9.07000_pr , & 0.00000_pr , 0.10040_pr , 0.00000_pr , 17 7.50000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 13 9.82200_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 53 5.80000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 19 1.70000_pr , 0.00000_pr , & - 26 4.30000_pr , 0.00000_pr , 0.00000_pr , 26 2.00000_pr , 0.00000_pr , & 0.00000_pr , 51 5.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 33 5.80000_pr , & 0.00000_pr , 11 3.30000_pr , 25 9.00000_pr , 31 3.50000_pr , 21 2.10000_pr , & 0.00000_pr , 0.00000_pr , 5 3.59000_pr , 11 7.00000_pr , 14 8.30000_pr , & 0.00000_pr , - 14 9.50000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 22 8.40000_pr , 2.22000_pr , & 17 7.60000_pr , 8 6.40000_pr , 24 7.80000_pr , 0.00000_pr , 30 4.30000_pr , & 299 0.00000_pr , 29 2.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 3 7.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 28 8.10000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 47 9.50000_pr , 18 3.80000_pr , & 26 1.30000_pr , 21 0.00000_pr , 20 2.10000_pr , 10 6.30000_pr , 77 7.10000_pr , & 0.00000_pr , 24 5.20000_pr , 0.00000_pr , 1 8.88000_pr , 29 8.13000_pr , & - 20 2.30000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 6 0.78000_pr , - 6 2.17000_pr , - 9 5.00000_pr , 34 4.40000_pr , 31 5.90000_pr , & 16 8.80000_pr , 14 6.60000_pr , 59 3.40000_pr , 1 0.17000_pr , - 12 4.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 6.37000_pr , & 0.00000_pr , 0.00000_pr , - 11 1.20000_pr , 0.00000_pr , 32 2.42000_pr , & 0.00000_pr , - 17 6.26000_pr , 0.00000_pr , 62 7.70000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 29 8.90000_pr , 3 1.14000_pr , 15 4.26000_pr , & - 15 2.55000_pr , 72 7.80000_pr , - 11 9.10000_pr , 0.00000_pr , 0.00000_pr , & - 24 6.60000_pr , 2.21000_pr , 7 1.48000_pr , 0.00000_pr , - 15 6.57000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 20 3.02000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 2 7.70100_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 63 1.50000_pr , 0.00000_pr , & 6.69900_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 52 6.50000_pr , 17 9.00000_pr , 16 9.90000_pr , 428 4.00000_pr , & - 20 2.10000_pr , - 39 9.30000_pr , - 13 9.00000_pr , 0.00000_pr , - 4 4.58000_pr , & 0.00000_pr , 5 2.08000_pr , 0.00000_pr , 12 8.80000_pr , 87 4.19000_pr , & 0.00000_pr , 24 3.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 46 3.60000_pr , 0.00000_pr , 21 5.00000_pr , 36 3.70000_pr , 33 7.70000_pr , & 133 7.37000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 3 1.66000_pr , & 0.00000_pr , - 41 7.20000_pr , 0.00000_pr , 3 2.90000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 13 6.60000_pr , & 0.00000_pr , - 2 9.34000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 68 9.00000_pr , - 5 2.87000_pr , 38 3.90000_pr , - 11 9.20000_pr , 7 4.27000_pr , & - 5.22400_pr , 16 0.80000_pr , 0.00000_pr , - 6 3.50000_pr , - 33 9.20000_pr , & - 2 8.61000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 8 1.57000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 36 9.49000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 83 7.20000_pr , 0.00000_pr , 5.15000_pr , 0.00000_pr , & - 5 3.91000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 4.18900_pr , & - 6 6.46000_pr , - 25 9.10000_pr , - 28 2.50000_pr , 22 5.80000_pr , 3 3.47000_pr , & 0.00000_pr , 0.00000_pr , - 3 4.57000_pr , 17 2.40000_pr , - 27 5.20000_pr , & - 1 1.40000_pr , 24 0.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 16 0.70000_pr , - 5 5.77000_pr , - 1 1.16000_pr , - 16 8.20000_pr , & - 9 1.80000_pr , 11 1.20000_pr , 18 7.10000_pr , 0.00000_pr , 1 0.76000_pr , & 0.00000_pr , - 4 7.37000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 4 8.33000_pr , 207 3.20000_pr , 0.00000_pr , - 20 8.80000_pr , & 0.00000_pr , 0.00000_pr , - 13 7.70000_pr , 0.00000_pr , - 19 8.00000_pr , & 0.00000_pr , 0.00000_pr , - 6 6.31000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 14 8.90000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 12 5.80000_pr , 35 9.30000_pr , & 38 9.30000_pr , 10 1.40000_pr , 4 4.78000_pr , - 4 8.25000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 27 3.95000_pr , 0.00000_pr , 57 0.90000_pr , - 19 6.31200_pr , 0.00000_pr , & - 15 8.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 21 5.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 5 0.06000_pr , 18 5.60000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 48 5.30000_pr , - 7 0.45000_pr , 24 5.60000_pr , & 562 9.00000_pr , - 14 3.90000_pr , - 17 2.40000_pr , 31 9.00000_pr , 0.00000_pr , & - 6 1.70000_pr , - 26 8.80000_pr , 8 5.33000_pr , 30 8.90000_pr , 25 4.80000_pr , & - 16 4.00000_pr , - 25 5.22000_pr , 2 2.05000_pr , - 33 4.40000_pr , 0.00000_pr , & - 15 1.50000_pr , - 22 8.00000_pr , 6.57000_pr , - 16 0.28000_pr , 0.00000_pr , & 49 8.60000_pr , 514 3.14010_pr , - 22 3.10000_pr , 0.00000_pr , 0.00000_pr , & 7 8.92000_pr , 0.00000_pr , 30 2.20000_pr , 0.00000_pr , 33 6.25000_pr , & - 11 9.80000_pr , - 9 7.71000_pr , - 8.80400_pr , 25 5.00000_pr , - 11 0.65000_pr , & 0.00000_pr , 5 5.80000_pr , - 2 8.65000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 2.85900_pr , 44 9.40000_pr , 2 2.67000_pr , - 24 5.39000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 17 2.51000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 30 9.58000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 11 7.17000_pr , - 5.57900_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 3 2.17000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 38 7.10000_pr , 4 8.33000_pr , 10 3.50000_pr , 6 9.26000_pr , 19 0.30000_pr , & 16 5.70000_pr , - 19 7.50000_pr , - 49 4.20000_pr , - 1 8.80000_pr , - 27 5.50000_pr , & 56 0.20000_pr , - 12 2.30000_pr , 41 7.00000_pr , 0.00000_pr , - 3 8.77000_pr , & 0.00000_pr , - 8 9.42000_pr , 0.00000_pr , 12 0.30000_pr , - 33 7.00000_pr , & 6 3.67000_pr , - 9 6.87000_pr , 25 5.80000_pr , 25 6.50000_pr , - 7 1.18000_pr , & 24 8.40000_pr , 0.00000_pr , 46 9.80000_pr , 0.00000_pr , 4 3.37000_pr , & 34 7.80000_pr , 6 8.55000_pr , - 19 5.10000_pr , 0.00000_pr , 15 3.70000_pr , & 42 3.40000_pr , 73 0.80000_pr , 0.00000_pr , 7 2.31000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 10 1.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 45 0.40000_pr , & 0.00000_pr , - 43 2.30000_pr , 0.00000_pr , - 81 7.70000_pr , 0.00000_pr , & - 36 3.80000_pr , 0.00000_pr , - 58 8.90000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 133 8.00000_pr , - 66 4.40000_pr , 44 8.10000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 74 5.30000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 25 2.70000_pr , 0.00000_pr , & 23 8.90000_pr , 0.00000_pr , - 171 2.80000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 27 5.90000_pr , - 132 7.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 23 3.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 216 6.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 22 0.30000_pr , 8 6.46000_pr , 3 0.04000_pr , & 4 6.38000_pr , - 50 4.20000_pr , 0.00000_pr , - 45 2.20000_pr , - 65 9.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 3 5.68000_pr , & 0.00000_pr , - 20 9.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 100 4.20000_pr , 0.00000_pr , - 26 2.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 2 6.35000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 5.86900_pr , 0.00000_pr , - 8 8.11000_pr , 0.00000_pr , & 7 2.96000_pr , - 5 2.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 21 8.90000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 11 1.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 39 0.90000_pr , 20 0.20000_pr , 0.00000_pr , 0.00000_pr , - 38 2.70000_pr , & 0.00000_pr , 83 5.60000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 32 2.30000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 55 3.30000_pr , & 26 8.10000_pr , 33 3.30000_pr , 42 1.90000_pr , - 24 8.30000_pr , 0.00000_pr , & 13 9.60000_pr , 0.00000_pr , 3 7.54000_pr , 0.00000_pr , 15 1.80000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 1 6.23000_pr , 0.00000_pr , 0.00000_pr , & 36 1.10000_pr , 0.00000_pr , 42 3.10000_pr , 43 4.10000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 35 3.50000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 12 2.40000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 18 7.00000_pr , - 61 7.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 3 7.63000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 56 5.90000_pr , 6 3.95000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 1 8.27000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 242 9.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 21 6.10000_pr , 6 2.56000_pr , - 5 9.58000_pr , & - 20 3.60000_pr , 10 4.70000_pr , - 5 9.40000_pr , 40 7.90000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 9 2.99000_pr , 0.00000_pr , - 3 9.16000_pr , 18 4.90000_pr , & 5 7.65000_pr , - 4 6.01000_pr , 0.00000_pr , 100 5.00000_pr , - 16 2.60000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 13 6.60000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 10 8.50000_pr , & 0.00000_pr , - 4.56500_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 69 9.13000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 80 8.59000_pr , & 20 0.94000_pr , 36 0.82000_pr , 23 3.51000_pr , 21 5.81000_pr , 15 0.02000_pr , & - 25 5.63000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 58 5.19000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 124 3.00000_pr , - 86 1.46000_pr , & 0.00000_pr , 0.00000_pr , - 184 0.80000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 186 9.90000_pr , 63 7.65000_pr , 42 4.93000_pr , 0.00000_pr , & 0.00000_pr , 5 6.29800_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 151 7.50000_pr , & 0.00000_pr ], [ 54 , 54 ]) ! ======================================================================== ! UNIFAC bij ! ------------------------------------------------------------------------ allocate ( UNIFACParameters % maingroups_bij ( 54 , 54 )) UNIFACParameters % maingroups_bij = 0.0_pr ! ======================================================================== ! UNIFAC cij ! ------------------------------------------------------------------------ allocate ( UNIFACParameters % maingroups_cij ( 54 , 54 )) UNIFACParameters % maingroups_cij = 0.0_pr end function UNIFACParameters end module yaeos__models_ge_group_contribution_unifac_parameters","tags":"","url":"sourcefile/unifac_parameters.f90.html"},{"title":"implementations.f90 – yaeos","text":"Source Code module yaeos__models_ge_implementations use yaeos__models_ge_NRTL , only : NRTL use yaeos__models_ge_group_contribution_dortmund , only : setup_dortmund use yaeos__models_ge_group_contribution_unifac , only : & Groups , setup_unifac , UNIFAC , excess_gibbs use yaeos__models_ge_uniquac , only : setup_uniquac , UNIQUAC use yaeos__models_ge_group_contribution_psrk , only : setup_psrk implicit none end module yaeos__models_ge_implementations","tags":"","url":"sourcefile/implementations.f90.html"},{"title":"yaeos.f90 – yaeos","text":"Source Code module yaeos !! Yet Another Equation-Of-State (library) !! !! Library to use EoS-based calculations. This main module imports all the !! relevant constants, procedures and objects to have better access to them !! The main submodules that it uses are: !! !! - [[yaeos__constants(module)]]: All the relevant costants and also the used precision (default=double precision). !! - [[yaeos__consistency(module)]]: Tools to evalaute the consistency of Ar and Ge models. !! - [[yaeos__substance(module)]]: Derived type that holds the important data (for example, critical constants) from a mixture. !! - [[yaeos__models(module)]]: All the implemented models, also their base types for making extensions. !! - [[yaeos__equilibria(module)]]: Phase equilibria related procedures. use yaeos__constants use yaeos__consistency use yaeos__substance use yaeos__models use yaeos__equilibria character ( len =* ), parameter :: version = \"3.1.0\" !! This version. end module","tags":"","url":"sourcefile/yaeos.f90.html"},{"title":"nrtl.f90 – yaeos","text":"Source Code module yaeos__models_ge_NRTL use yaeos__tapenade_ge_api , only : gemodeltapenade use yaeos__tapenade_interfaces use yaeos__constants , only : pr , R implicit none type , extends ( GeModelTapenade ) :: NRTL !! Non-Random-Two-Liquid model !! !!  !!    G&#94;E = nRT \\cdot \\sum_i x_i \\frac{\\sum_j x_j \\tau_{ji} G_{ji}}{\\sum_j x_j G_{ji}} !!  !! !! with: !! !! \\tau_{ij} = A_{ij} + \\frac{B_{ij}}{T} !! !! G_{ij} = exp(-\\frac{C_{ij}}{\\tau_{ij}}) real ( pr ), allocatable :: a (:, :) !! A_{ij} matrix real ( pr ), allocatable :: b (:, :) !! B_{ij} matrix real ( pr ), allocatable :: c (:, :) !! C_{ij} matrix contains procedure :: ge => excess_gibbs procedure :: ge_b => excess_gibbs_b procedure :: ge_d => excess_gibbs_d procedure :: ge_d_b => excess_gibbs_d_b procedure :: ge_d_d => excess_gibbs_d_d end type NRTL interface NRTL module procedure :: init end interface contains type ( NRTL ) function init ( a , b , c ) real ( pr ), intent ( in ) :: a (:, :) real ( pr ), intent ( in ) :: b (:, :) real ( pr ), intent ( in ) :: c (:, :) init % a = a init % b = b init % c = c end function subroutine EXCESS_GIBBS_D_D_D ( model , n , nd , t , td1 , td0 , td , ge , ged1 & & , ged0 , ged0d , ged , gedd0 , gedd , geddd ) implicit none class ( NRTL ) :: model real ( pr ), intent ( IN ) :: n (:) real ( pr ), intent ( IN ) :: nd (:) real ( pr ), intent ( IN ) :: t real ( pr ), intent ( IN ) :: td1 real ( pr ), intent ( IN ) :: td0 real ( pr ), intent ( IN ) :: td real ( pr ), intent ( OUT ) :: ge real ( pr ), intent ( OUT ) :: ged1 real ( pr ), intent ( OUT ) :: ged0 real ( pr ), intent ( OUT ) :: ged0d real ( pr ), intent ( OUT ) :: ged real ( pr ), intent ( OUT ) :: gedd0 real ( pr ), intent ( OUT ) :: gedd real ( pr ), intent ( OUT ) :: geddd real ( pr ) :: x ( size ( n )), g ( size ( n ), size ( n )), tau ( size ( n ), size ( n )) real ( pr ) :: gd1 ( size ( n ), size ( n )), taud1 ( size ( n ), size ( n )) real ( pr ) :: gd0 ( size ( n ), size ( n )), taud0 ( size ( n ), size ( n )) real ( pr ) :: gd0d ( size ( n ), size ( n )), taud0d ( size ( n ), size ( n )) real ( pr ) :: xd ( size ( n )), gd ( size ( n ), size ( n )), taud ( size ( n ), size ( n )) real ( pr ) :: gdd0 ( size ( n ), size ( n )), taudd0 ( size ( n ), size ( n )) real ( pr ) :: gdd ( size ( n ), size ( n )), taudd ( size ( n ), size ( n )) real ( pr ) :: gddd ( size ( n ), size ( n )), tauddd ( size ( n ), size ( n )) real ( pr ) :: a ( size ( n ), size ( n )), b ( size ( n ), size ( n )), c ( size ( n ), size (& & n )) real ( pr ) :: down integer :: i , j intrinsic SUM intrinsic EXP intrinsic SIZE real ( pr ), dimension ( size ( n )) :: arg1 real ( pr ), dimension ( size ( n )) :: arg1d1 real ( pr ), dimension ( size ( n )) :: arg1d0 real ( pr ), dimension ( size ( n )) :: arg1d0d real ( pr ), dimension ( size ( n )) :: arg1d real ( pr ), dimension ( size ( n )) :: arg1dd0 real ( pr ), dimension ( size ( n )) :: arg1dd real ( pr ), dimension ( size ( n )) :: arg1ddd real ( pr ), dimension ( size ( n )) :: arg2 real ( pr ), dimension ( size ( n )) :: arg2d1 real ( pr ), dimension ( size ( n )) :: arg2d0 real ( pr ), dimension ( size ( n )) :: arg2d0d real ( pr ), dimension ( size ( n )) :: arg2d real ( pr ), dimension ( size ( n )) :: arg2dd0 real ( pr ), dimension ( size ( n )) :: arg2dd real ( pr ), dimension ( size ( n )) :: arg2ddd real ( pr ) :: temp real ( pr ) :: tempd0 real ( pr ) :: tempd real ( pr ) :: tempdd real ( pr ) :: temp0 real ( pr ) :: temp0d0 real ( pr ) :: temp0d real ( pr ) :: temp0dd real ( pr ) :: temp1 real ( pr ) :: temp1d0 real ( pr ) :: temp1d real ( pr ) :: temp1dd real ( pr ), dimension ( size ( b , 1 ), size ( b , 2 )) :: temp2 real ( pr ), dimension ( size ( b , 1 ), size ( b , 2 )) :: temp2d real ( pr ), dimension ( size ( n ), size ( n )) :: temp3 real ( pr ), dimension ( size ( n ), size ( n )) :: temp3d real ( pr ), dimension ( size ( n )) :: temp4 real ( pr ), dimension ( size ( n )) :: temp4d real ( pr ) :: temp5 real ( pr ) :: temp5d real ( pr ) :: temp6 real ( pr ) :: temp6d real ( pr ), dimension ( size ( b , 1 ), size ( b , 2 )) :: temp7 real ( pr ), dimension ( size ( n ), size ( n )) :: temp8 real ( pr ), dimension ( size ( n )) :: temp9 real ( pr ) :: temp10 real ( pr ) :: temp11 temp = sum ( n ) xd = ( nd - n * sum ( nd ) / temp ) / temp x = n / temp temp7 = model % b (:, :) * td / ( t * t ) temp2d = - ( temp7 * 2 * td1 / t ) temp2 = temp7 tauddd = td0 * 2 * ( temp2d - temp2 * td1 / t ) / t taudd = temp2 * 2 * td0 / t taudd0 = - temp2d taud = - temp2 temp7 = model % b (:, :) * td0 / ( t * t ) taud0d = temp7 * 2 * td1 / t taud0 = - temp7 taud1 = - ( model % b (:, :) * td1 / t ** 2 ) tau = model % a (:, :) + model % b (:, :) / t temp3d = - ( exp ( - ( model % c * tau )) * model % c * taud1 ) temp3 = exp ( - ( model % c * tau )) temp8 = exp ( - ( model % c * tau )) gddd = - ( model % c * ( taudd * temp3d + temp3 * tauddd - model % c * ( temp8 * ( taud0 * & & taudd0 + taud * taud0d ) - taud * taud0 * exp ( - ( model % c * tau )) * model % c * taud1 ))& & ) gdd = - ( model % c * ( temp3 * taudd - model % c * ( temp8 * ( taud * taud0 )))) gdd0 = - ( model % c * ( taud * temp3d + temp3 * taudd0 )) gd = - ( model % c * ( temp3 * taud )) temp8 = exp ( - ( model % c * tau )) gd0d = - ( model % c * ( temp8 * taud0d - taud0 * exp ( - ( model % c * tau )) * model % c * & & taud1 )) gd0 = - ( model % c * ( temp8 * taud0 )) gd1 = - ( exp ( - ( model % c * tau )) * model % c * taud1 ) g = exp ( - ( model % c * tau )) ge = 0 ged = 0.0_pr gedd = 0.0_pr ged0 = 0.0_pr gedd0 = 0.0_pr geddd = 0.0_pr ged0d = 0.0_pr ged1 = 0.0_pr do i = 1 , size ( n ) temp4d = xd (:) * taud1 (:, i ) + x (:) * taudd0 (:, i ) temp4 = xd (:) * tau (:, i ) + x (:) * taud (:, i ) temp9 = xd (:) * taud0 (:, i ) + x (:) * taudd (:, i ) arg1ddd (:) = gd0 (:, i ) * temp4d + temp4 * gd0d (:, i ) + temp9 * gd1 (:, i )& & + g (:, i ) * ( xd (:) * taud0d (:, i ) + x (:) * tauddd (:, i )) + x (:) * ( taud0 (:& & , i ) * gdd0 (:, i ) + gd (:, i ) * taud0d (:, i ) + gdd (:, i ) * taud1 (:, i ) + tau (& & :, i ) * gddd (:, i )) arg1dd (:) = temp4 * gd0 (:, i ) + g (:, i ) * temp9 + x (:) * ( gd (:, i ) * taud0 & & (:, i ) + tau (:, i ) * gdd (:, i )) arg1dd0 (:) = temp4 * gd1 (:, i ) + g (:, i ) * temp4d + x (:) * ( gd (:, i ) * & & taud1 (:, i ) + tau (:, i ) * gdd0 (:, i )) arg1d (:) = g (:, i ) * temp4 + x (:) * ( tau (:, i ) * gd (:, i )) arg1d0d (:) = x (:) * ( taud0 (:, i ) * gd1 (:, i ) + g (:, i ) * taud0d (:, i ) + gd0 (& & :, i ) * taud1 (:, i ) + tau (:, i ) * gd0d (:, i )) arg1d0 (:) = x (:) * ( g (:, i ) * taud0 (:, i ) + tau (:, i ) * gd0 (:, i )) arg1d1 (:) = x (:) * ( g (:, i ) * taud1 (:, i ) + tau (:, i ) * gd1 (:, i )) arg1 (:) = x (:) * tau (:, i ) * g (:, i ) arg2ddd (:) = xd (:) * gd0d (:, i ) + x (:) * gddd (:, i ) arg2dd (:) = xd (:) * gd0 (:, i ) + x (:) * gdd (:, i ) arg2dd0 (:) = xd (:) * gd1 (:, i ) + x (:) * gdd0 (:, i ) arg2d (:) = g (:, i ) * xd (:) + x (:) * gd (:, i ) arg2d0d (:) = x (:) * gd0d (:, i ) arg2d0 (:) = x (:) * gd0 (:, i ) arg2d1 (:) = x (:) * gd1 (:, i ) arg2 (:) = x (:) * g (:, i ) tempdd = sum ( arg2d0d (:)) tempd = sum ( arg2d0 (:)) tempd0 = sum ( arg2d1 (:)) temp = sum ( arg2 (:)) temp0dd = sum ( arg1d0d (:)) temp0d = sum ( arg1d0 (:)) temp0d0 = sum ( arg1d1 (:)) temp0 = sum ( arg1 (:)) temp10 = temp0 * tempd / temp temp11 = ( temp0d - temp10 ) / temp temp1dd = x ( i ) * ( temp0dd - ( tempd * temp0d0 + temp0 * tempdd - temp10 * tempd0 )& & / temp - temp11 * tempd0 ) / temp temp1d = x ( i ) * temp11 temp1d0 = x ( i ) * ( temp0d0 - temp0 * tempd0 / temp ) / temp temp1 = x ( i ) * temp0 / temp temp5d = sum ( arg2dd0 (:)) temp5 = sum ( arg2d (:)) temp11 = ( xd ( i ) * temp0 + x ( i ) * sum ( arg1d (:)) - temp1 * temp5 ) / temp temp6d = ( xd ( i ) * temp0d0 + x ( i ) * sum ( arg1dd0 (:)) - temp5 * temp1d0 - temp1 * & & temp5d - temp11 * tempd0 ) / temp temp6 = temp11 temp11 = sum ( arg2dd (:)) temp10 = ( xd ( i ) * temp0d + x ( i ) * sum ( arg1dd (:)) - temp5 * temp1d - temp1 * & & temp11 - temp6 * tempd ) / temp geddd = geddd + ( xd ( i ) * temp0dd + x ( i ) * sum ( arg1ddd (:)) - temp1d * temp5d - & & temp5 * temp1dd - temp11 * temp1d0 - temp1 * sum ( arg2ddd (:)) - tempd * temp6d - & & temp6 * tempdd - temp10 * tempd0 ) / temp gedd = gedd + temp10 gedd0 = gedd0 + temp6d ged = ged + temp6 ged0d = ged0d + temp1dd ged0 = ged0 + temp1d ged1 = ged1 + temp1d0 ge = ge + temp1 end do temp1 = sum ( n ) temp6 = sum ( nd ) geddd = r * ( temp6 * ( td0 * ged1 + ged0 * td1 + t * ged0d ) + temp1 * ( td * ged0d + td0 * & & gedd0 + gedd * td1 + t * geddd )) gedd = r * ( temp6 * ( ge * td0 + t * ged0 ) + temp1 * ( td * ged0 + ged * td0 + t * gedd )) gedd0 = r * ( temp6 * ( ge * td1 + t * ged1 ) + temp1 * ( td * ged1 + ged * td1 + t * gedd0 )) ged = r * ( temp6 * ( t * ge ) + temp1 * ( td * ge + t * ged )) ged0d = r * temp1 * ( td0 * ged1 + ged0 * td1 + t * ged0d ) ged0 = r * temp1 * ( ge * td0 + t * ged0 ) ged1 = r * temp1 * ( ge * td1 + t * ged1 ) ge = r * ( temp1 * ( t * ge )) end subroutine EXCESS_GIBBS_D_D_D subroutine EXCESS_GIBBS_D_D ( model , n , nd , t , td0 , td , ge , ged0 , ged , & & gedd ) implicit none class ( NRTL ) :: model real ( pr ), intent ( IN ) :: n (:) real ( pr ), intent ( IN ) :: nd (:) real ( pr ), intent ( IN ) :: t real ( pr ), intent ( IN ) :: td0 real ( pr ), intent ( IN ) :: td real ( pr ), intent ( OUT ) :: ge real ( pr ), intent ( OUT ) :: ged0 real ( pr ), intent ( OUT ) :: ged real ( pr ), intent ( OUT ) :: gedd real ( pr ) :: x ( size ( n )), g ( size ( n ), size ( n )), tau ( size ( n ), size ( n )) real ( pr ) :: gd0 ( size ( n ), size ( n )), taud0 ( size ( n ), size ( n )) real ( pr ) :: xd ( size ( n )), gd ( size ( n ), size ( n )), taud ( size ( n ), size ( n )) real ( pr ) :: gdd ( size ( n ), size ( n )), taudd ( size ( n ), size ( n )) real ( pr ) :: a ( size ( n ), size ( n )), b ( size ( n ), size ( n )), c ( size ( n ), size (& & n )) real ( pr ) :: down integer :: i , j intrinsic SUM intrinsic EXP intrinsic SIZE real ( pr ), dimension ( size ( n )) :: arg1 real ( pr ), dimension ( size ( n )) :: arg1d0 real ( pr ), dimension ( size ( n )) :: arg1d real ( pr ), dimension ( size ( n )) :: arg1dd real ( pr ), dimension ( size ( n )) :: arg2 real ( pr ), dimension ( size ( n )) :: arg2d0 real ( pr ), dimension ( size ( n )) :: arg2d real ( pr ), dimension ( size ( n )) :: arg2dd real ( pr ) :: temp real ( pr ) :: tempd real ( pr ) :: temp0 real ( pr ) :: temp0d real ( pr ) :: temp1 real ( pr ) :: temp1d real ( pr ), dimension ( size ( b , 1 ), size ( b , 2 )) :: temp2 real ( pr ), dimension ( size ( n ), size ( n )) :: temp3 real ( pr ), dimension ( size ( n )) :: temp4 real ( pr ) :: temp5 real ( pr ) :: temp6 temp = sum ( n ) xd = ( nd - n * sum ( nd ) / temp ) / temp x = n / temp temp2 = model % b (:, :) * td / ( t * t ) taudd = temp2 * 2 * td0 / t taud = - temp2 taud0 = - ( model % b (:, :) * td0 / t ** 2 ) tau = model % a (:, :) + model % b (:, :) / t temp3 = exp ( - ( model % c * tau )) gdd = - ( model % c * ( temp3 * taudd - taud * exp ( - ( model % c * tau )) * model % c * taud0 )& & ) gd = - ( model % c * ( temp3 * taud )) gd0 = - ( exp ( - ( model % c * tau )) * model % c * taud0 ) g = exp ( - ( model % c * tau )) ge = 0 ged = 0.0_pr gedd = 0.0_pr ged0 = 0.0_pr do i = 1 , size ( n ) temp4 = xd (:) * tau (:, i ) + x (:) * taud (:, i ) arg1dd (:) = temp4 * gd0 (:, i ) + g (:, i ) * ( xd (:) * taud0 (:, i ) + x (:) * & & taudd (:, i )) + x (:) * ( gd (:, i ) * taud0 (:, i ) + tau (:, i ) * gdd (:, i )) arg1d (:) = g (:, i ) * temp4 + x (:) * ( tau (:, i ) * gd (:, i )) arg1d0 (:) = x (:) * ( g (:, i ) * taud0 (:, i ) + tau (:, i ) * gd0 (:, i )) arg1 (:) = x (:) * tau (:, i ) * g (:, i ) arg2dd (:) = xd (:) * gd0 (:, i ) + x (:) * gdd (:, i ) arg2d (:) = g (:, i ) * xd (:) + x (:) * gd (:, i ) arg2d0 (:) = x (:) * gd0 (:, i ) arg2 (:) = x (:) * g (:, i ) tempd = sum ( arg2d0 (:)) temp = sum ( arg2 (:)) temp0d = sum ( arg1d0 (:)) temp0 = sum ( arg1 (:)) temp1d = x ( i ) * ( temp0d - temp0 * tempd / temp ) / temp temp1 = x ( i ) * temp0 / temp temp5 = sum ( arg2d (:)) temp6 = ( xd ( i ) * temp0 + x ( i ) * sum ( arg1d (:)) - temp1 * temp5 ) / temp gedd = gedd + ( xd ( i ) * temp0d + x ( i ) * sum ( arg1dd (:)) - temp5 * temp1d - temp1 & & * sum ( arg2dd (:)) - temp6 * tempd ) / temp ged = ged + temp6 ged0 = ged0 + temp1d ge = ge + temp1 end do temp1 = sum ( n ) temp6 = sum ( nd ) gedd = r * ( temp6 * ( ge * td0 + t * ged0 ) + temp1 * ( td * ged0 + ged * td0 + t * gedd )) ged = r * ( temp6 * ( t * ge ) + temp1 * ( td * ge + t * ged )) ged0 = r * temp1 * ( ge * td0 + t * ged0 ) ge = r * ( temp1 * ( t * ge )) end subroutine EXCESS_GIBBS_D_D subroutine EXCESS_GIBBS_D_B ( model , n , nb , nd , ndb , t , tb , td , tdb , ge & & , geb , ged , gedb ) implicit none class ( NRTL ) :: model real ( pr ), intent ( IN ) :: n (:) real ( pr ) :: nb (:) real ( pr ), intent ( IN ) :: nd (:) real ( pr ) :: ndb (:) real ( pr ), intent ( IN ) :: t real ( pr ) :: tb real ( pr ), intent ( IN ) :: td real ( pr ) :: tdb real ( pr ) :: ge real ( pr ) :: geb real ( pr ) :: ged real ( pr ) :: gedb real ( pr ) :: x ( size ( n )), g ( size ( n ), size ( n )), tau ( size ( n ), size ( n )) real ( pr ) :: xb ( size ( n )), gb ( size ( n ), size ( n )), taub ( size ( n ), size ( n )) real ( pr ) :: xd ( size ( n )), gd ( size ( n ), size ( n )), taud ( size ( n ), size ( n )) real ( pr ) :: xdb ( size ( n )), gdb ( size ( n ), size ( n )), taudb ( size ( n ), size ( n & & )) real ( pr ) :: a ( size ( n ), size ( n )), b ( size ( n ), size ( n )), c ( size ( n ), size (& & n )) real ( pr ) :: down integer :: i , j intrinsic SUM intrinsic EXP intrinsic SIZE real ( pr ), dimension ( size ( n )) :: arg1 real ( pr ), dimension ( size ( n )) :: arg1b real ( pr ), dimension ( size ( n )) :: arg1d real ( pr ), dimension ( size ( n )) :: arg1db real ( pr ), dimension ( size ( n )) :: arg2 real ( pr ), dimension ( size ( n )) :: arg2b real ( pr ), dimension ( size ( n )) :: arg2d real ( pr ), dimension ( size ( n )) :: arg2db real ( pr ) :: temp real ( pr ) :: tempb real ( pr ) :: temp0 real ( pr ) :: temp0b real ( pr ) :: temp1 real ( pr ) :: temp1b real ( pr ), dimension ( size ( n , 1 )) :: tempb0 real ( pr ), dimension ( size ( n , 1 )) :: temp2 real ( pr ) :: temp3 real ( pr ), dimension ( size ( n , 1 )) :: tempb1 real ( pr ) :: tempb2 real ( pr ), dimension ( size ( n )) :: tempb3 real ( pr ) :: temp4 real ( pr ) :: temp5 real ( pr ) :: tempb4 real ( pr ) :: tempb5 integer :: ad_to integer :: arg10 real ( pr ) :: result1 temp = sum ( n ) xd = ( nd - n * sum ( nd ) / temp ) / temp x = n / temp taud = - ( model % b (:, :) * td / t ** 2 ) tau = model % a (:, :) + model % b (:, :) / t gd = - ( exp ( - ( model % c * tau )) * model % c * taud ) g = exp ( - ( model % c * tau )) ge = 0 ged = 0.0_pr do i = 1 , size ( n ) arg10 = size ( n ) call PUSHREAL8ARRAY ( arg1d , arg10 ) arg1d (:) = g (:, i ) * ( tau (:, i ) * xd (:) + x (:) * taud (:, i )) + x (:) * tau (:& & , i ) * gd (:, i ) arg1 (:) = x (:) * tau (:, i ) * g (:, i ) arg2d (:) = g (:, i ) * xd (:) + x (:) * gd (:, i ) arg2 (:) = x (:) * g (:, i ) call PUSHREAL8 ( temp ) temp = sum ( arg2 (:)) call PUSHREAL8 ( temp0 ) temp0 = sum ( arg1 (:)) temp1 = x ( i ) * temp0 / temp ged = ged + ( temp0 * xd ( i ) + x ( i ) * sum ( arg1d (:)) - temp1 * sum ( arg2d (:))) / & & temp ge = ge + temp1 end do call PUSHINTEGER4 ( i - 1 ) temp1 = sum ( n ) tempb4 = r * geb geb = temp1 * t * tempb4 temp1b = t * ge * tempb4 tb = tb + temp1 * ge * tempb4 tempb4 = r * gedb tempb5 = sum ( nd ) * tempb4 ndb = ndb + t * ge * tempb4 temp1b = temp1b + ( ge * td + t * ged ) * tempb4 tempb2 = temp1 * tempb4 gedb = t * tempb2 geb = geb + td * tempb2 + t * tempb5 tdb = tdb + ge * tempb2 tb = tb + ged * tempb2 + ge * tempb5 nb = nb + temp1b taudb = 0.0_pr taub = 0.0_pr gb = 0.0_pr xdb = 0.0_pr xb = 0.0_pr gdb = 0.0_pr call POPINTEGER4 ( ad_to ) do i = ad_to , 1 , - 1 tempb2 = gedb / temp arg2d (:) = g (:, i ) * xd (:) + x (:) * gd (:, i ) temp5 = sum ( arg2d (:)) temp1 = x ( i ) * temp0 / temp temp1b = geb - temp5 * tempb2 arg1db = 0.0_pr arg2db = 0.0_pr temp4 = sum ( arg1d (:)) temp0b = xd ( i ) * tempb2 xdb ( i ) = xdb ( i ) + temp0 * tempb2 xb ( i ) = xb ( i ) + temp4 * tempb2 + temp0 * temp1b / temp arg1db = x ( i ) * tempb2 arg2db = - ( temp1 * tempb2 ) tempb = - (( temp0 * xd ( i ) + x ( i ) * temp4 - temp1 * temp5 ) * tempb2 / temp ) tempb2 = x ( i ) * temp1b / temp temp0b = temp0b + tempb2 tempb = tempb - temp0 * tempb2 / temp arg1b = 0.0_pr call POPREAL8 ( temp0 ) arg1b = temp0b arg2b = 0.0_pr call POPREAL8 ( temp ) arg2b = tempb gb (:, i ) = gb (:, i ) + x * arg2b + xd * arg2db + x * tau (:, i ) * arg1b + (& & tau (:, i ) * xd + x * taud (:, i )) * arg1db gdb (:, i ) = gdb (:, i ) + x * arg2db + x * tau (:, i ) * arg1db arg10 = size ( n ) call POPREAL8ARRAY ( arg1d , arg10 ) tempb3 = g (:, i ) * arg1db xb = xb + g (:, i ) * arg2b + gd (:, i ) * arg2db + tau (:, i ) * g (:, i ) * & & arg1b + tau (:, i ) * gd (:, i ) * arg1db + taud (:, i ) * tempb3 xdb = xdb + g (:, i ) * arg2db + tau (:, i ) * tempb3 taub (:, i ) = taub (:, i ) + x * g (:, i ) * arg1b + x * gd (:, i ) * arg1db + xd & & * tempb3 taudb (:, i ) = taudb (:, i ) + x * tempb3 end do temp3 = sum ( nd ) tempb0 = xdb / temp tempb1 = - ( temp3 * tempb0 / temp ) temp2 = n / temp result1 = sum (( nd - temp3 * temp2 ) * tempb0 ) tempb = - ( sum ( n * xb ) / temp ** 2 ) - result1 / temp - sum ( temp2 * tempb1 ) taub = taub + model % c ** 2 * exp ( - ( model % c * tau )) * taud * gdb - model % c * exp (& & - ( model % c * tau )) * gb taudb = taudb - exp ( - ( model % c * tau )) * model % c * gdb tempb2 = - ( sum ( model % b * taudb ) / t ** 2 ) tb = tb - sum ( model % b * taub ) / t ** 2 - 2 * td * tempb2 / t tdb = tdb + tempb2 nb = nb + xb / temp + tempb1 + tempb ndb = ndb + tempb0 - sum ( temp2 * tempb0 ) gedb = 0.0_pr geb = 0.0_pr end subroutine EXCESS_GIBBS_D_B subroutine EXCESS_GIBBS_D ( model , n , nd , t , td , ge , ged ) implicit none class ( NRTL ) :: model real ( pr ), intent ( IN ) :: n (:) real ( pr ), intent ( IN ) :: nd (:) real ( pr ), intent ( IN ) :: t real ( pr ), intent ( IN ) :: td real ( pr ), intent ( OUT ) :: ge real ( pr ), intent ( OUT ) :: ged real ( pr ) :: x ( size ( n )), g ( size ( n ), size ( n )), tau ( size ( n ), size ( n )) real ( pr ) :: xd ( size ( n )), gd ( size ( n ), size ( n )), taud ( size ( n ), size ( n )) real ( pr ) :: a ( size ( n ), size ( n )), b ( size ( n ), size ( n )), c ( size ( n ), size (& & n )) real ( pr ) :: down integer :: i , j intrinsic SUM intrinsic EXP intrinsic SIZE real ( pr ), dimension ( size ( n )) :: arg1 real ( pr ), dimension ( size ( n )) :: arg1d real ( pr ), dimension ( size ( n )) :: arg2 real ( pr ), dimension ( size ( n )) :: arg2d real ( pr ) :: temp real ( pr ) :: temp0 real ( pr ) :: temp1 temp = sum ( n ) xd = ( nd - n * sum ( nd ) / temp ) / temp x = n / temp taud = - ( model % b (:, :) * td / t ** 2 ) tau = model % a (:, :) + model % b (:, :) / t gd = - ( exp ( - ( model % c * tau )) * model % c * taud ) g = exp ( - ( model % c * tau )) ge = 0 ged = 0.0_pr do i = 1 , size ( n ) arg1d (:) = g (:, i ) * ( tau (:, i ) * xd (:) + x (:) * taud (:, i )) + x (:) * tau (:& & , i ) * gd (:, i ) arg1 (:) = x (:) * tau (:, i ) * g (:, i ) arg2d (:) = g (:, i ) * xd (:) + x (:) * gd (:, i ) arg2 (:) = x (:) * g (:, i ) temp = sum ( arg2 (:)) temp0 = sum ( arg1 (:)) temp1 = x ( i ) * temp0 / temp ged = ged + ( temp0 * xd ( i ) + x ( i ) * sum ( arg1d (:)) - temp1 * sum ( arg2d (:))) / & & temp ge = ge + temp1 end do temp1 = sum ( n ) ged = r * ( t * ge * sum ( nd ) + temp1 * ( ge * td + t * ged )) ge = r * ( temp1 * ( t * ge )) end subroutine EXCESS_GIBBS_D subroutine EXCESS_GIBBS_B ( model , n , nb , t , tb , ge , geb ) implicit none class ( NRTL ) :: model real ( pr ), intent ( IN ) :: n (:) real ( pr ) :: nb (:) real ( pr ), intent ( IN ) :: t real ( pr ) :: tb real ( pr ) :: ge real ( pr ) :: geb real ( pr ) :: x ( size ( n )), g ( size ( n ), size ( n )), tau ( size ( n ), size ( n )) real ( pr ) :: xb ( size ( n )), gb ( size ( n ), size ( n )), taub ( size ( n ), size ( n )) real ( pr ) :: a ( size ( n ), size ( n )), b ( size ( n ), size ( n )), c ( size ( n ), size (& & n )) real ( pr ) :: down integer :: i , j intrinsic SUM intrinsic EXP intrinsic SIZE real ( pr ), dimension ( size ( n )) :: arg1 real ( pr ), dimension ( size ( n )) :: arg1b real ( pr ), dimension ( size ( n )) :: arg2 real ( pr ), dimension ( size ( n )) :: arg2b real ( pr ) :: temp real ( pr ) :: tempb real ( pr ) :: temp0 real ( pr ) :: tempb0 integer :: ad_to x = n / sum ( n ) tau = model % a (:, :) + model % b (:, :) / t g = exp ( - ( model % c * tau )) ge = 0 do i = 1 , size ( n ) arg1 (:) = x (:) * tau (:, i ) * g (:, i ) arg2 (:) = x (:) * g (:, i ) ge = ge + x ( i ) * sum ( arg1 (:)) / sum ( arg2 (:)) end do call PUSHINTEGER4 ( i - 1 ) nb = 0.0_pr nb = t * ge * r * geb tempb0 = sum ( n ) * r * geb geb = t * tempb0 tb = ge * tempb0 taub = 0.0_pr gb = 0.0_pr xb = 0.0_pr call POPINTEGER4 ( ad_to ) do i = ad_to , 1 , - 1 arg1 (:) = x (:) * tau (:, i ) * g (:, i ) arg2 (:) = x (:) * g (:, i ) arg1b = 0.0_pr arg2b = 0.0_pr temp = sum ( arg2 (:)) temp0 = sum ( arg1 (:)) tempb = geb / temp xb ( i ) = xb ( i ) + temp0 * tempb arg1b = x ( i ) * tempb arg2b = - ( x ( i ) * temp0 * tempb / temp ) xb = xb + g (:, i ) * arg2b + tau (:, i ) * g (:, i ) * arg1b gb (:, i ) = gb (:, i ) + x * arg2b + x * tau (:, i ) * arg1b taub (:, i ) = taub (:, i ) + x * g (:, i ) * arg1b end do taub = taub - model % c * exp ( - ( model % c * tau )) * gb tb = tb - sum ( model % b * taub ) / t ** 2 temp = sum ( n ) nb = nb + xb / temp - sum ( n * xb ) / temp ** 2 geb = 0.0_pr end subroutine EXCESS_GIBBS_B subroutine EXCESS_GIBBS ( model , n , t , ge ) implicit none class ( NRTL ) :: model real ( pr ), intent ( IN ) :: n (:) real ( pr ), intent ( IN ) :: t real ( pr ), intent ( OUT ) :: ge real ( pr ) :: x ( size ( n )), g ( size ( n ), size ( n )), tau ( size ( n ), size ( n )) real ( pr ) :: a ( size ( n ), size ( n )), b ( size ( n ), size ( n )), c ( size ( n ), size (& & n )) real ( pr ) :: down integer :: i , j intrinsic SUM intrinsic EXP intrinsic SIZE real ( pr ), dimension ( size ( n )) :: arg1 real ( pr ), dimension ( size ( n )) :: arg2 x = n / sum ( n ) tau = model % a (:, :) + model % b (:, :) / t g = exp ( - ( model % c * tau )) ge = 0 do i = 1 , size ( n ) arg1 (:) = x (:) * tau (:, i ) * g (:, i ) arg2 (:) = x (:) * g (:, i ) ge = ge + x ( i ) * sum ( arg1 (:)) / sum ( arg2 (:)) end do ge = sum ( n ) * r * t * ge end subroutine EXCESS_GIBBS end module yaeos__models_ge_NRTL","tags":"","url":"sourcefile/nrtl.f90.html"},{"title":"dortmund_parameters.f90 – yaeos","text":"Source Code module yaeos__models_ge_group_contribution_dortmund_parameters use yaeos__constants , only : pr use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters implicit none contains type ( GeGCModelParameters ) function DortmundParameters () integer :: nmg , nsg ! ======================================================================== ! PSRK subgroups ids definition ! ------------------------------------------------------------------------ DortmundParameters % subgroups_ids = [ & 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , & 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , & 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , & 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , & 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , & 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , & 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 91 , 92 , & 93 , 94 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , & 111 , 112 , 113 , 114 , 119 , 153 , 178 , 179 , 184 , 189 , 195 , 196 , 197 , 122 , & 123 , 124 , 201 , 209 , 210 , 211 , 220 ] ! ======================================================================== ! PSRK maingroups ids definition ! ------------------------------------------------------------------------ DortmundParameters % maingroups_ids = [& 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , & 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , & 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , & 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 52 , 53 , 55 , & 56 , 84 , 85 , 87 , 89 , 90 , 91 , 61 , 93 , 98 , 99 ] ! ======================================================================== ! PSRK subgroups maingroups ! ------------------------------------------------------------------------ DortmundParameters % subgroups_maingroups = [& 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 , & 5 , 6 , 7 , 8 , 9 , 9 , 10 , 11 , 11 , 12 , 13 , 13 , 13 , & 43 , 14 , 14 , 14 , 15 , 15 , 15 , 16 , 16 , 17 , 18 , 18 , 18 , & 19 , 19 , 20 , 44 , 21 , 21 , 21 , 22 , 22 , 22 , 45 , 23 , 24 , & 25 , 26 , 26 , 26 , 27 , 28 , 29 , 29 , 30 , 31 , 32 , 33 , 34 , & 34 , 35 , 36 , 37 , 2 , 38 , 39 , 39 , 40 , 40 , 40 , 41 , 42 , & 42 , 42 , 5 , 5 , 43 , 43 , 14 , 46 , 46 , 46 , 46 , 47 , 47 , & 49 , 49 , 47 , 48 , 48 , 48 , 52 , 52 , 52 , 53 , 53 , 53 , 56 , & 56 , 55 , 55 , 55 , 53 , 53 , 84 , 85 , 84 , 87 , 89 , 90 , 91 , 61 , & 61 , 61 , 93 , 98 , 98 , 99 , 90 ] nsg = size ( DortmundParameters % subgroups_ids ) nmg = size ( DortmundParameters % maingroups_ids ) ! ======================================================================== ! PSRK subgroups Rs ! ------------------------------------------------------------------------ DortmundParameters % subgroups_Rs = [& 0.632500_pr , 0.632500_pr , 0.632500_pr , 0.632500_pr , 1.283200_pr , & 1.283200_pr , 1.283200_pr , 1.283200_pr , 0.376300_pr , 0.376300_pr , & 0.910000_pr , 0.910000_pr , 0.910000_pr , 1.230200_pr , 0.858500_pr , & 1.733400_pr , 1.080000_pr , 1.704800_pr , 1.704800_pr , 0.717300_pr , & 1.270000_pr , 1.270000_pr , 1.900000_pr , 1.143400_pr , 1.143400_pr , & 1.143400_pr , 1.702300_pr , 1.660700_pr , 1.660700_pr , 1.660700_pr , & 1.368000_pr , 1.368000_pr , 1.368000_pr , 1.074600_pr , 1.074600_pr , & 1.184900_pr , 1.457800_pr , 1.239300_pr , 1.073100_pr , 1.557500_pr , & 1.557500_pr , 0.800000_pr , 0.800000_pr , 0.991900_pr , 0.991900_pr , & 0.991900_pr , 1.800000_pr , 1.800000_pr , 1.800000_pr , 2.450000_pr , & 2.650000_pr , 2.618000_pr , 0.536500_pr , 2.644000_pr , 2.500000_pr , & 2.887000_pr , 0.465600_pr , 1.240000_pr , 1.289000_pr , 1.535000_pr , & 1.299000_pr , 2.088000_pr , 1.076000_pr , 1.209000_pr , 0.921400_pr , & 1.303000_pr , 3.600000_pr , 1.000000_pr , 0.522900_pr , 1.283200_pr , & 0.881400_pr , 2.000000_pr , 2.381000_pr , 1.284000_pr , 1.284000_pr , & 0.821500_pr , 1.600000_pr , 0.713600_pr , 0.347900_pr , 0.347000_pr , & 1.063000_pr , 0.689500_pr , 1.404600_pr , 1.041300_pr , 1.660700_pr , & 3.981000_pr , 3.754300_pr , 3.526800_pr , 3.299400_pr , 1.451500_pr , & 1.500000_pr , 2.461700_pr , 2.461700_pr , 1.500000_pr , 2.474800_pr , & 2.273900_pr , 2.076700_pr , 1.794300_pr , 1.628200_pr , 1.462100_pr , & 1.360100_pr , 0.683000_pr , 0.910400_pr , 2.687000_pr , 2.460000_pr , & 2.420000_pr , 2.420000_pr , 2.420000_pr , 1.063000_pr , 0.910400_pr , & 1.366200_pr , 5.621000_pr , 1.843000_pr , 2.786700_pr , 3.962800_pr , & 2.109400_pr , 3.371000_pr , 1.613000_pr , 1.386300_pr , 1.158900_pr , & 1.067800_pr , 0.990300_pr , 1.565400_pr , 3.818300_pr , 2.487300_pr & ] ! ======================================================================== ! PSRK subgroups Qs ! ------------------------------------------------------------------------ DortmundParameters % subgroups_Qs = [& 1.060800_pr , 0.708100_pr , 0.355400_pr , 0.000000_pr , 1.601600_pr , & 1.248900_pr , 1.248900_pr , 0.896200_pr , 0.432100_pr , 0.211300_pr , & 0.949000_pr , 0.796200_pr , 0.376900_pr , 0.892700_pr , 0.993800_pr , & 2.456100_pr , 0.975000_pr , 1.670000_pr , 1.554200_pr , 0.771000_pr , & 1.628600_pr , 1.422800_pr , 1.800000_pr , 1.602200_pr , 1.249500_pr , & 0.896800_pr , 1.878400_pr , 1.690400_pr , 1.337700_pr , 0.985000_pr , & 1.433200_pr , 1.080500_pr , 0.727800_pr , 1.176000_pr , 0.824000_pr , & 0.806700_pr , 0.902200_pr , 0.633000_pr , 0.353000_pr , 1.519300_pr , & 1.166600_pr , 0.921500_pr , 1.274200_pr , 1.365400_pr , 1.012700_pr , & 0.660000_pr , 2.500000_pr , 2.147300_pr , 1.794600_pr , 2.891200_pr , & 2.377800_pr , 3.183600_pr , 0.317700_pr , 2.500000_pr , 2.304000_pr , & 2.241000_pr , 0.358900_pr , 1.068000_pr , 1.762000_pr , 1.316000_pr , & 1.289000_pr , 2.400000_pr , 0.916900_pr , 1.400000_pr , 1.300000_pr , & 1.132000_pr , 2.692000_pr , 0.920000_pr , 0.739100_pr , 0.458200_pr , & 0.726900_pr , 2.093000_pr , 1.522000_pr , 1.266000_pr , 1.098000_pr , & 0.513500_pr , 0.900000_pr , 0.863500_pr , 0.107100_pr , 0.000000_pr , & 0.866300_pr , 0.834500_pr , 1.400000_pr , 1.011600_pr , 0.985000_pr , & 3.200000_pr , 2.892000_pr , 2.580000_pr , 2.352000_pr , 1.248000_pr , & 1.080000_pr , 2.192000_pr , 1.842000_pr , 1.080000_pr , 1.964300_pr , & 1.575400_pr , 1.186600_pr , 1.340000_pr , 1.060000_pr , 0.780000_pr , & 1.803100_pr , 0.341800_pr , 0.653800_pr , 2.120000_pr , 1.808000_pr , & 2.497600_pr , 2.001800_pr , 2.249700_pr , 1.123000_pr , 0.653800_pr , & 0.679700_pr , 5.946300_pr , 1.699700_pr , 2.772300_pr , 0.621400_pr , & 2.510600_pr , 2.000100_pr , 1.368000_pr , 1.060000_pr , 0.748000_pr , & 2.244000_pr , 3.524900_pr , 3.807600_pr , 3.601800_pr , 2.445700_pr & ] ! ======================================================================== ! PSRK aij ! ------------------------------------------------------------------------ DortmundParameters % maingroups_aij = reshape ([& 0.0_pr , - 9 5.41801_pr , 1 6.07_pr , 4 7.2_pr , 160 6.0_pr , 8 2.593_pr , & - 1 7.253_pr , 198 7.0_pr , 19 9.0_pr , 25 6.21_pr , 63 2.22_pr , 23 8.5_pr , & - 9.654_pr , 32 6.04_pr , 20 7.26_pr , 20 5.65_pr , 225 7.3_pr , - 43 6.15_pr , & 29 3.81_pr , 201 7.7_pr , - 6 5.68501_pr , 31 1.55_pr , 130 2.6_pr , - 14 8.07_pr , & 326 4.0_pr , - 39 6.5_pr , 174 4.0_pr , 7 2.12_pr , - 5 9.9_pr , 21 0.5_pr , & 2 8.17_pr , 16 6.0_pr , - 6 2.08_pr , - 2 2.04_pr , 47 7.1_pr , - 29 1.9_pr , & 3.202_pr , - 16 0.3_pr , 15 1.0_pr , - 48 4.3_pr , - 31 4.6_pr , 17 0.9_pr , & 18 6.71_pr , - 2 1.23_pr , - 4 4.069_pr , - 24 9.85_pr , 18 9.911_pr , 8 2.6_pr , & 18 3.02_pr , - 1 6.034_pr , - 4 1.0_pr , - 0.067_pr , 43 8.76_pr , 7 7.7793_pr , & 99 6.5333_pr , 90 7.3842_pr , 45 4.5569_pr , - 30 7.8627_pr , 24 3.462_pr , - 30 9.943_pr , & 266 0.16_pr , 113 1.305_pr , 350 4.325_pr , 18 9.66_pr , 0.0_pr , - 15 7.2_pr , & - 11 3.1_pr , 156 6.0_pr , - 9 6.297_pr , - 130 1.0_pr , 19 1.6_pr , 9 1.811_pr , & 20 2.49_pr , - 58 2.82_pr , - 2 8.63_pr , - 84 4.3_pr , 49 8.8_pr , - 12 4.32_pr , & - 13 1.5_pr , 398 2.0_pr , - 1 3.317_pr , - 18 1.93_pr , - 34 7.5_pr , - 35 9.6_pr , & 5 5.881_pr , 25 5.41_pr , - 66 3.45_pr , 21 5.5_pr , 45 2.2_pr , 0.0_pr , & 7 0.88_pr , 0.0_pr , - 14 6.1_pr , 0.0_pr , 0.0_pr , 16 0.4_pr , & - 19 7.06_pr , 15 4.0_pr , - 11 3.8_pr , - 30 0.6_pr , - 13 9.5_pr , - 15 2.2_pr , & 0.0_pr , 69 8.5_pr , 6 0.2_pr , 118 2.6_pr , 0.0_pr , - 17 4.41_pr , & - 73 4.87_pr , 9 2.7_pr , - 8 1.79_pr , 9 0.0134_pr , - 3 9.373_pr , 5 7.86_pr , & 29 8.55_pr , - 6 5.66_pr , 175 3.135_pr , - 121 3.93_pr , - 115 1.296_pr , 489 6.219_pr , & 15 9.8103_pr , 72 4.9113_pr , - 15 6.458_pr , 23 2.905_pr , 180 4.025_pr , 65 8.1962_pr , & 11 4.2_pr , 17 4.1_pr , 0.0_pr , - 4 5.33_pr , 304 9.0_pr , 1 3.733_pr , & 33 2.3_pr , 234 0.0_pr , - 5 7.53_pr , 101 1.0_pr , 62 2.73_pr , 10 8.3_pr , & 17 9.0_pr , - 12 1.0_pr , 10 5.63_pr , 1 6.29_pr , 15 4.39_pr , 181 0.8_pr , & 11 1.8_pr , 61 3.32_pr , - 5 8.972_pr , - 14 2.2_pr , - 7 8.116_pr , - 30 5.5_pr , & 188 5.0_pr , - 33 0.0_pr , 186 6.23_pr , 57 4.6_pr , - 2.1662_pr , 0.4086_pr , & - 9 3.18999_pr , 29 8.9_pr , 18 7.5_pr , 0.0_pr , - 34 5.6_pr , 0.0_pr , & 188 7.0_pr , - 136 7.0_pr , 5 8.76_pr , 41 9.04_pr , 67 0.8_pr , - 2.619_pr , & 4 7.23_pr , - 114 1.6_pr , - 20 1.52_pr , - 25 8.12_pr , 16 0.13_pr , - 1 4.89_pr , & 4 5.4296_pr , - 66 0.25_pr , - 26 0.22_pr , - 35 8.06_pr , 56 2.72_pr , - 22 3.7499_pr , & 2 0.2719_pr , 2 6.3894_pr , 211 6.398_pr , 78 5.4488_pr , - 1 5.3556_pr , - 38 8.19_pr , & - 7 2.2694_pr , 87 7.6001_pr , - 96 9.6266_pr , 7.339_pr , 11 7.3_pr , 13 9.2_pr , & 0.0_pr , 267 3.0_pr , 14 5.54_pr , 2 4.144_pr , 182 5.0_pr , - 14 6.6_pr , & 196 3.0_pr , 162 4.0_pr , 37 7.26_pr , 37 5.0_pr , - 4 5.44_pr , - 31 6.22_pr , & 97 8.3_pr , 396 9.0_pr , 169 8.1_pr , 17 0.1_pr , 2 9.747_pr , 11 3.07_pr , & - 7 5.01_pr , - 3 8.939_pr , 10 7.8_pr , - 6 9.23_pr , 101 4.0_pr , 193 1.39_pr , & - 149 4.0_pr , 0.0_pr , 18 1.2_pr , 104 1.33_pr , 44 8.8_pr , - 15 6.7_pr , & 0.0_pr , 17 8.6_pr , 0.0_pr , - 11 5.9_pr , - 1 3.15_pr , 6 4.28_pr , & 15 3.32_pr , - 73 6.8_pr , 19 1.5_pr , 19 9.48_pr , 29 1.65_pr , - 24 8.3_pr , & 76 3.57_pr , 34 0.91_pr , 24 6.08_pr , 11 9.767_pr , - 13 9.78_pr , 10 2.04_pr , & 56 2.34_pr , 166 1.26_pr , 36 5.3965_pr , - 13 4.6708_pr , 410 1.374_pr , 125 9.47_pr , & 399 7.18_pr , - 99 8.0735_pr , - 30 5.273_pr , 1 5.0501_pr , - 28 1.4692_pr , 379 2.062_pr , & 277 7.0_pr , 264 9.0_pr , 397 2.0_pr , 398 9.0_pr , 0.0_pr , - 121 8.2_pr , & 146 0.0_pr , 46 5.4_pr , 65 3.3_pr , 159 0.0_pr , 31 0.4_pr , 83 9.6_pr , & 65 0.9_pr , - 7 5.63_pr , - 66 0.2_pr , 187 6.0_pr , 132 5.0_pr , - 64 3.09_pr , & - 4 6.0_pr , 152 5.8_pr , 217 7.0_pr , 238 9.0_pr , 96 3.37_pr , 313 9.0_pr , & 366 4.0_pr , 109 1.0_pr , 31 6.6_pr , 0.0_pr , 0.0_pr , 61 6.5_pr , & - 46 8.8_pr , 77 4.7_pr , 143 9.0_pr , 125 5.0_pr , - 45 2.3_pr , 107 2.0_pr , & 95 9.3_pr , 125 3.0_pr , - 36 6.4_pr , 0.0_pr , 70 3.4_pr , 260 1.0_pr , & - 23 8.36_pr , 0.0_pr , 298 5.8_pr , - 51 6.99_pr , 146 0.82_pr , - 80 8.4_pr , & 86 8.681_pr , 771 2.2_pr , 70 0.05_pr , 0.0_pr , 94 2.22_pr , 14 7.0663_pr , & - 79 2.988_pr , 100 3.498_pr , - 23 4.3916_pr , 104 4.876_pr , 66 2.1286_pr , 134 3.95_pr , & 3 4.7132_pr , 44 8.381_pr , 175 1.43_pr , 240 9.4_pr , - 62 8.07_pr , 160 4.3_pr , & 43 6.21_pr , 34 6.31_pr , 0.0_pr , - 52 4.3_pr , 26 5.5_pr , 39 4.78_pr , & - 15 8.4_pr , 29 4.76_pr , 44 4.7_pr , 47 5.2_pr , - 46 7.95_pr , - 27 8.09_pr , & 3 9.33_pr , 25 1.2_pr , - 23 0.38_pr , 61 5.01_pr , 107 5.5_pr , 183 1.2_pr , & 190 4.4_pr , 89 3.38_pr , 215 0.0_pr , 295 5.0_pr , 107 9.0_pr , 0.0_pr , & 264 5.0_pr , 133 4.0_pr , 66 2.0_pr , - 3.428_pr , 196 5.0_pr , 64 8.8_pr , & 0.0_pr , 14 5.0_pr , 13 5.9_pr , 242 1.0_pr , 123 5.0_pr , - 26 9.7_pr , & 0.0_pr , 67 8.1_pr , 254 0.7_pr , 95 2.24_pr , 0.0_pr , 451 9.3_pr , & 0.0_pr , - 5 2.69_pr , - 13 2.93_pr , - 19 5.127_pr , 267 6.7_pr , 52 4.52_pr , & 0.0_pr , 168 3.48_pr , 15 2.7192_pr , 212 7.895_pr , 114 2.897_pr , 98 5.4429_pr , & 9 4.629_pr , - 55 8.6751_pr , 64 1.041_pr , - 38 6.355_pr , 142 1.557_pr , 0.0_pr , & 139 1.3_pr , 77 8.3_pr , 79 2.0_pr , 105 0.2_pr , - 80 1.9_pr , - 32 8.5_pr , & 0.0_pr , 14 8.4_pr , 77 0.6_pr , 51 2.6_pr , 31 1.974_pr , 5 3.28_pr , & 43 3.207_pr , - 98 0.6_pr , - 85 1.0_pr , - 44 6.0_pr , - 13 1.0_pr , - 39 3.18_pr , & 50 9.6_pr , 62 4.97_pr , 31 3.3_pr , 74 8.2_pr , 0.0_pr , 128 2.0_pr , & 59 1.6_pr , 88 2.6_pr , 0.0_pr , 0.0_pr , 0.0_pr , 50 1.4_pr , & - 36 8.8_pr , 0.0_pr , - 1 7.99_pr , 0.0_pr , - 37 0.8_pr , 27 6.9_pr , & 0.0_pr , 0.0_pr , - 12 1.8_pr , 0.0_pr , 80 8.4_pr , 163 2.9_pr , & 71 7.485_pr , 59 4.45_pr , - 52 3.8_pr , - 58 8.21_pr , - 64 9.31_pr , - 43 9.58_pr , & - 12 8.903_pr , 0.0_pr , 95 2.57_pr , 0.0_pr , 65 2.86_pr , 15 1.31_pr , & 199 6.724_pr , 0.0_pr , - 39 9.1902_pr , 27 5.7479_pr , 38 5.0068_pr , - 27 0.53_pr , & - 44 4.615_pr , - 37 1.2031_pr , 0.0_pr , 138 1.0_pr , 120 7.0_pr , 135 6.0_pr , & 137 5.0_pr , 8 3.91_pr , - 86 7.0_pr , - 268 6.0_pr , 0.0_pr , - 66 6.8_pr , & - 41 0.21_pr , - 22 4.4_pr , 0.0_pr , - 8 0.58_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 13 1.1_pr , - 4 1.594_pr , 0.0_pr , 28 1.08_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 215 7.0_pr , 155 4.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 19 1.7_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 363 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 233 2.5_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 43 3.6_pr , 17 9.8_pr , 14 6.2_pr , 100 1.0_pr , - 25 0.0_pr , 8 6.439_pr , & 19 0.5_pr , - 14 5.2_pr , 0.0_pr , - 9 3.07999_pr , 3 3.415_pr , 10 1.3_pr , & 69 5.8_pr , 0.0_pr , 11 9.5_pr , 283 1.0_pr , 146 0.0_pr , 30 7.16_pr , & 7 9.08_pr , 17 8.22_pr , 5 5.27_pr , - 21 8.94_pr , - 4 8.641_pr , 15 5.73_pr , & 137 5.0_pr , - 3 2.6_pr , - 32 8.1_pr , 31 5.3_pr , 6 4.41_pr , 27 7.0_pr , & - 7 2.58_pr , - 18 2.0_pr , 31 9.69_pr , - 48 1.2_pr , 3 8.06_pr , 0.0_pr , & - 15 3.4_pr , 0.0_pr , 195 5.5_pr , 0.0_pr , - 14 8.3_pr , 36 4.423_pr , & 8 0.038_pr , 0.0_pr , 94 5.14_pr , 0.0_pr , 14 1.01_pr , - 11 6.4_pr , & - 20 1.105_pr , 231 1.5_pr , 0.0_pr , 0.0_pr , 0.0_pr , 95 8.3726_pr , & 67 0.0023_pr , - 150 4.191_pr , 17 7.8232_pr , - 3 0.955_pr , - 144 9.573_pr , 0.0_pr , & 0.0_pr , 330 6.365_pr , 0.0_pr , 87 5.85_pr , 47 6.25_pr , - 36 5.5_pr , & 68 3.6_pr , - 28 1.4_pr , - 39 2.5_pr , - 154 5.0_pr , 5.604_pr , 19 7.6_pr , & 0.0_pr , 38 9.7_pr , 22 6.6_pr , 23 5.7_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 18 8.0_pr , - 88 8.3_pr , & 35 4.71_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 39 7.5_pr , - 21 4.8_pr , 0.0_pr , 29 3.5_pr , 0.0_pr , & - 9 3.066_pr , 0.0_pr , 0.0_pr , 94 5.6_pr , 0.0_pr , - 22 5.3_pr , & 0.0_pr , 0.0_pr , 116 1.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 9 8.65601_pr , 98 0.74_pr , - 27 4.54_pr , - 24 2.5_pr , 97 3.8_pr , 29 9.23_pr , & - 43 3.288_pr , - 21 2.9_pr , - 1 6.486_pr , - 20 8.4_pr , 0.0_pr , - 25 1.7_pr , & 82 4.2_pr , 0.0_pr , 332 9.0_pr , 16 0.8_pr , 349 9.0_pr , 4 5.309_pr , & 13 9.55_pr , 5 9.594_pr , 4 8.852_pr , - 46 1.35_pr , 0.0_pr , 22 3.4_pr , & - 78 8.6_pr , - 5 0.36_pr , 0.0_pr , 28 0.0_pr , 0.0_pr , - 13 6.3_pr , & 6 9.25_pr , 1 1.62_pr , 24 8.3_pr , 0.0_pr , - 33 7.1_pr , 50 3.5_pr , & - 32 0.0_pr , 0.0_pr , 1 6.69_pr , 0.0_pr , 3.924_pr , 46 0.8_pr , & 3 6.948_pr , - 44 7.04_pr , 96 6.35_pr , 0.0_pr , 3 2.71_pr , - 103 1.78_pr , & 8 1.6384_pr , 0.0_pr , 0.0_pr , 0.0_pr , 191 5.2_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 262 2.04_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 50 8.4_pr , 30 9.8_pr , 17 0.5_pr , & 13 6.98_pr , 23 5.9_pr , 22 0.7_pr , 14 0.71_pr , 0.0_pr , - 8 3.57_pr , & - 16 0.7_pr , 34 2.4_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 12 3.73_pr , - 3 3.64_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 46 5.8_pr , 1 8.79_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 1 3.97_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 47 9.1_pr , 0.0_pr , - 28 5.5_pr , & 0.0_pr , 0.0_pr , 50 9.0_pr , 0.0_pr , - 44 1.01_pr , - 59 7.09_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 23 3.1_pr , 73 3.3_pr , - 8 7.08_pr , - 59 5.1_pr , 81 6.7_pr , - 8 7.48_pr , & 17 7.665_pr , - 32 9.3_pr , 364 5.0_pr , 20 9.0_pr , 19 5.3_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 43 0.49_pr , & - 58 8.8_pr , - 31 0.82_pr , 87 2.0_pr , 21 5.3_pr , 9 7.12801_pr , 64 1.2_pr , & 38 1.1_pr , 31 9.6_pr , 0.0_pr , 19 8.5_pr , - 21 0.1_pr , - 29 9.6_pr , & 0.0_pr , 46 4.0_pr , 0.0_pr , 16 9.27_pr , 0.0_pr , 0.0_pr , & - 32 6.4_pr , - 52 8.8_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 21 4.1_pr , & 56 1.14_pr , 31 0.75_pr , 136 8.0_pr , 0.0_pr , 0.0_pr , - 36 1.25_pr , & - 22 4.782_pr , 0.0_pr , 0.0_pr , 0.0_pr , 116 3.91_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 17 8.501_pr , 0.0_pr , 0.0_pr , - 16 4.04_pr , 185 7.0_pr , 203 6.0_pr , & 297 7.0_pr , - 92 3.7_pr , - 49 5.25_pr , 79 8.5_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 107 4.0_pr , & 83 6.6_pr , 0.0_pr , 0.0_pr , 241 2.2_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 33 3.9_pr , 387 3.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 24 4.4_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 11 2.76_pr , & 0.0_pr , 0.0_pr , 62 1.9_pr , 18 2.58_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 29 3.93_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 1 4.9127_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 35 0.58_pr , 22 4.8_pr , 13 9.67_pr , 125 0.0_pr , - 35 5.1_pr , - 150 8.5_pr , & 152 4.0_pr , 0.0_pr , - 4 7.97_pr , 0.0_pr , 316 8.0_pr , 0.0_pr , & 0.0_pr , 151 7.0_pr , 0.0_pr , - 63 9.9_pr , 0.0_pr , 0.0_pr , & - 13 1.9_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 4 3.83_pr , & - 86 8.8_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 90 4.1_pr , - 23 0.55_pr , 0.0_pr , 0.0_pr , 124 8.0_pr , & 29 5.07_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 19 6.23_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 166 7.89_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 17 5.7_pr , 16 5.3_pr , - 7 1.4_pr , & - 263 1.0_pr , 10 4.6_pr , - 103 9.0_pr , 27 4.5_pr , 0.0_pr , - 38 9.6_pr , & 0.0_pr , 15 2.8_pr , 0.0_pr , 0.0_pr , - 47 2.4_pr , 40 2.6_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 40 6.8_pr , 0.0_pr , - 82 5.9_pr , - 9 4.87_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 3 5.16_pr , - 31 1.9_pr , & 0.0_pr , 0.0_pr , - 19 8.32_pr , 0.0_pr , 0.0_pr , - 103 5.8_pr , & 0.0_pr , - 6 6.61_pr , - 23 5.61_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 178 0.41_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 95 8.74_pr , 280 0.0_pr , 104 4.7_pr , 400 0.0_pr , - 111 4.0_pr , - 201 2.0_pr , & 15 8.4_pr , 54 2.0_pr , 173 2.0_pr , 0.0_pr , - 135 5.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 55 8.39_pr , & 298 7.0_pr , 0.0_pr , - 33 8.0_pr , 0.0_pr , 0.0_pr , 262 6.0_pr , & 158 3.8_pr , 0.0_pr , 1.655_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 81 8.8_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 65 0.7_pr , 0.0_pr , 0.0_pr , 109 1.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 247 6.18_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 180 2.3_pr , 1 3.502_pr , - 155 3.9_pr , & 13 5.3_pr , - 306 1.2_pr , - 34 1.34_pr , - 317 8.5_pr , - 408 0.9_pr , - 190 8.7_pr , & 0.0_pr , 8 7.6_pr , - 9.2978_pr , - 19 9.94_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 7 4.285_pr , 0.0_pr , - 230 7.8_pr , - 261 7.7_pr , - 159 2.8_pr , & 94 6.79_pr , 0.0_pr , - 211 1.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 76 3.19_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 105 2.5_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 589 4.1_pr , - 126 9.7_pr , 0.0_pr , - 164 6.8_pr , & 0.0_pr , - 225 0.64_pr , 0.0_pr , 0.0_pr , 499 8.6_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 59 3.07_pr , 63 4.85_pr , - 1 7.44_pr , 20 8.1_pr , 12 3.5_pr , 9 7.97301_pr , & - 63 4.1_pr , 0.0_pr , - 19 1.0_pr , 0.0_pr , - 19 3.23_pr , 9 2.21_pr , & 198 7.0_pr , - 41 2.38_pr , 24 2.2_pr , 0.0_pr , 39 3.9_pr , 74 6.12_pr , & 0.0_pr , 0.0_pr , - 36 8.7_pr , 1 4.76_pr , 0.0_pr , 35 7.6_pr , & 233 1.0_pr , - 12 8.21_pr , 0.0_pr , 43 4.8_pr , 4 1.54_pr , 0.0_pr , & 1 1.72_pr , 0.0_pr , 36 2.6_pr , - 142 8.0_pr , 0.0_pr , - 14 4.7_pr , & - 1 9.1_pr , 0.0_pr , - 16 0.48_pr , 0.0_pr , 2 6.8_pr , 133 6.0_pr , & 5 6.754_pr , 0.0_pr , - 64 2.44_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 11 6.794_pr , 0.0_pr , 0.0_pr , 0.0_pr , 18 0.813_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 118 2.2_pr , - 202 6.1_pr , 6 9.561_pr , & 135 2.5_pr , - 129 5.0_pr , - 73 3.07_pr , - 179 5.2_pr , 40 1.88_pr , - 10 9.51_pr , & 43 5.64_pr , 6 2.031_pr , 0.0_pr , 52 1.48_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 45 1.49_pr , 0.0_pr , 0.0_pr , 70 2.4_pr , & 42 5.97_pr , 0.0_pr , 21 3.34_pr , 100 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 78 0.71_pr , 75 3.21_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 28 3.64_pr , 0.0_pr , 9 3.773_pr , & 0.0_pr , 21 8.974_pr , 57 8.3_pr , - 14 0.77_pr , - 1 4.016_pr , - 38 6.93_pr , & 0.0_pr , - 0.29_pr , - 24 4.69_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 40 1.0_pr , 49 8.9_pr , 7 3.04601_pr , - 4 6.994_pr , 23 8.1_pr , - 1 6.521_pr , & 8 6.68999_pr , 0.0_pr , - 9 9.97601_pr , 98 5.7_pr , - 4 9.339_pr , 0.0_pr , & - 20 8.6_pr , 0.0_pr , 0.0_pr , 0.0_pr , 58 2.1_pr , - 6 7.106_pr , & 17 6.5_pr , 2 7.618_pr , 0.0_pr , - 6 6.21_pr , 60 3.29_pr , 9 5.05_pr , & 1 5.62_pr , 14 2.1_pr , 129 5.0_pr , - 13 7.7_pr , 0.0_pr , - 39 0.6_pr , & 0.0_pr , 0.0_pr , - 9 2.68_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 20 7.3_pr , 0.0_pr , - 5 9.29_pr , 0.0_pr , 0.0_pr , 37 0.6_pr , & 7 0.075_pr , 1 7.052_pr , - 17 5.29_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 15 1.036_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 31 3.202_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 23 3.66_pr , - 4 4.958_pr , 13 3.66_pr , & 21 3.85_pr , - 12 6.0_pr , - 8 5.926_pr , 13 4.1_pr , 0.0_pr , - 1 8.695_pr , & - 4 1.537_pr , 16 8.17_pr , 0.0_pr , 49 2.9_pr , 0.0_pr , 0.0_pr , & - 47 3.0_pr , 0.0_pr , - 97 8.25_pr , - 7 8.96_pr , 9 4.606_pr , 7 0.79_pr , & 0.0_pr , 146 8.9_pr , 4 6.03_pr , 36 8.6_pr , - 42 3.1_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 10 6.3_pr , 0.0_pr , - 2 3.81_pr , 9 6.4_pr , & 0.0_pr , - 3 9.45_pr , 0.0_pr , - 13 5.9_pr , 0.0_pr , 7 5.45_pr , & 0.0_pr , 0.0_pr , 22 4.4_pr , - 35 8.57_pr , 0.0_pr , - 1.6641_pr , & 0.0_pr , 0.0_pr , - 44 6.86_pr , 89 4.509_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 22 9.081_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 65 3.74_pr , - 20 4.51_pr , 6 6.214_pr , 19 2.52_pr , 131 4.8_pr , - 13 9.58_pr , & 0.0_pr , 0.0_pr , 81 0.17_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 60 7.35_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 59 2.4_pr , 18 7.43_pr , 0.0_pr , 35 0.92_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 36 4.76_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 19 9.87_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 6 9.60101_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 15 7.634_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 26 7.51_pr , 61 6.62_pr , 26 9.0_pr , & - 10 6.2_pr , 92 5.6_pr , - 4 0.13_pr , 100 8.0_pr , 235 6.0_pr , - 20 8.71_pr , & 0.0_pr , - 5.71_pr , - 14 2.2_pr , - 42 5.4_pr , - 6 5.76_pr , - 3.28_pr , & 21 5.9_pr , 398 6.0_pr , 22 9.66_pr , 6 5.82_pr , 70 1.95_pr , 1 6.34_pr , & 4 6.29_pr , - 32 3.17_pr , 0.0_pr , 97 2.1_pr , - 6 5.74_pr , 16 7.5_pr , & 5 2.01_pr , 0.0_pr , 10 0.5_pr , 0.0_pr , 18 6.4_pr , - 136 0.0_pr , & 0.0_pr , - 6 0.89_pr , - 19 4.9_pr , - 13 4.4_pr , - 9 8.98_pr , - 16 8.4_pr , & 0.0_pr , 0.0_pr , 6 0.78_pr , - 13 1.87_pr , 0.0_pr , 1 4.947_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 19 8.677_pr , - 58 0.46_pr , 0.0_pr , & 0.0_pr , 26 1.15_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 138 5.0_pr , - 5 6.69_pr , 59 5.2_pr , - 11 3.6_pr , 186 2.0_pr , 300 0.0_pr , & - 189 5.0_pr , 55 5.5_pr , 129 7.0_pr , 0.0_pr , 335 1.0_pr , 189 4.0_pr , & 97 4.0_pr , 255 3.0_pr , 388 8.0_pr , 162 2.0_pr , 370 9.2_pr , 0.0_pr , & 128 3.0_pr , - 139 8.7_pr , 398 5.0_pr , 335 3.0_pr , 0.0_pr , - 13 1.8_pr , & 0.0_pr , 363 8.0_pr , 292 6.02_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 98 1.5_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 47 2.49_pr , 0.0_pr , 0.0_pr , 22 3.782_pr , & 299 1.9_pr , 0.0_pr , 423 5.3_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 8 8.32201_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 234 5.0_pr , 41 7.6_pr , 13 4.1_pr , & 135 8.0_pr , 74 1.8_pr , 37 4.2_pr , - 59 5.7_pr , 0.0_pr , - 3 5.89_pr , & 0.0_pr , 9.222_pr , 0.0_pr , - 30 5.1_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 11 7.53_pr , 0.0_pr , 2 4.44_pr , & 82 2.4_pr , 0.0_pr , 44 1.5_pr , 398 6.0_pr , 0.0_pr , 98 6.0_pr , & 65 5.7_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1 7.81_pr , 12 1.4_pr , & 13 2.2_pr , 0.0_pr , 0.0_pr , 10 8.4_pr , 0.0_pr , - 34 0.9_pr , & 0.0_pr , 0.0_pr , 52 2.9_pr , - 4 7.089_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1 1.442_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 238 3.0_pr , 0.0_pr , 93 6.3391_pr , 39 1.044_pr , 210 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 16 9.6_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 377 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 124 8.0_pr , 0.0_pr , 0.0_pr , 328 6.0_pr , & - 18 4.5_pr , 8 5.6_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 8 1.44501_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 260 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 2 4.33_pr , 4 6.06_pr , 373 6.0_pr , & 258 6.0_pr , 0.0_pr , - 33 2.4_pr , 0.0_pr , 0.0_pr , 41 9.9_pr , & 0.0_pr , 86 1.1_pr , 0.0_pr , 3 5.02_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 46 8.8_pr , 0.0_pr , 29 5.9_pr , & 0.0_pr , 0.0_pr , 9.362_pr , 0.0_pr , 6 8.87_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 20 0.6_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 31 9.4_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 9 2.4_pr , 1.0902_pr , 0.0_pr , 4 0.987_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 46 5.9_pr , 0.0_pr , 7 7.083_pr , 0.0_pr , 0.0_pr , 7 5.71_pr , & 0.0_pr , 0.0_pr , 2.714_pr , - 37 3.7_pr , 0.0_pr , 16 1.8_pr , & 10 2.6_pr , - 20 5.1_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 1 8.8_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 36 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 24 7.6_pr , 0.0_pr , 0.0_pr , 43 9.73_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 57 7.7_pr , 47 0.4_pr , 33 1.6_pr , & 15 7.9_pr , 73 8.4_pr , - 36 9.8_pr , - 12 3.8_pr , 0.0_pr , - 98 6.0_pr , & - 74 2.7_pr , 8 0.68999_pr , 0.0_pr , 51 3.7_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 66 6.0_pr , & - 17 4.6_pr , 0.0_pr , 75 0.2_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 116 8.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 84 6.7_pr , 0.0_pr , - 38 4.29_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 89 7.7_pr , 0.0_pr , - 14 8.14_pr , 185 6.45_pr , 49 9.8_pr , 3 3.19_pr , & 37 2.5_pr , - 30 9.0_pr , 47 8.5_pr , 0.0_pr , - 7 2.07_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 126 8.0_pr , 0.0_pr , & 50 6.6_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 4 7.81_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 23 1.6_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 10 6.79_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 55 9.9_pr , 0.0_pr , - 8 2.28_pr , & 6 9.0_pr , 83 8.8_pr , 18 0.5_pr , 0.0_pr , 0.0_pr , 34 6.6_pr , & 11 4.3_pr , 8 2.96_pr , 0.0_pr , - 10 4.8_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 14 6.06_pr , 0.0_pr , & 13 2.7_pr , 0.0_pr , 4 9.51_pr , 0.0_pr , 64 3.8_pr , 0.0_pr , & 21 2.4_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 55 8.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 9 2.429_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 52 7.7_pr , - 1 9.82_pr , - 24 8.2_pr , 27 7.0_pr , 69 9.7_pr , 2 8.95_pr , & 82 2.2_pr , 0.0_pr , - 71 7.76_pr , 0.0_pr , - 38 6.3_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 71 3.65_pr , & - 21 1.2_pr , - 1 8.328_pr , 12 8.8_pr , - 13 9.6_pr , 59 9.82_pr , 20 3.2_pr , & - 6 9.88_pr , 9.258_pr , 50 5.4_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 53 6.2_pr , 0.0_pr , 0.0_pr , - 11 6.7_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1 3.78_pr , 47 6.9_pr , & 26 5.42_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 27 1.226_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 47 7.5_pr , 64 2.27_pr , 0.0_pr , & 0.0_pr , - 14 8.9_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 6 2.43_pr , & 23 6.6_pr , 0.0_pr , 0.0_pr , - 13 7.87_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 1 1.65_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 7 0.24_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 41 6.5_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 54 7.5_pr , - 17 4.6_pr , 34 7.6_pr , 8 8.93_pr , 19 0.4_pr , - 18 5.9_pr , & 11 7.0_pr , 0.0_pr , - 7 6.87_pr , 0.0_pr , 29 6.8_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 17 8.3_pr , 0.0_pr , 32 5.2_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 46 7.1_pr , 0.0_pr , & - 22 8.4_pr , 0.0_pr , - 8 3.7_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 22 1.74_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 6 7.069_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 7 2.16901_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 166 2.0_pr , 17 9.7_pr , 0.0_pr , & 0.0_pr , 111 7.0_pr , 16 4.0_pr , 41 9.8_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 9 2.12_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 26 7.1_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 90 2.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 100 4.0_pr , 0.0_pr , 9 7.36_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 33 4.5_pr , 96 7.9_pr , 60 2.1_pr , 23 4.2_pr , 43 9.4_pr , - 4 3.88_pr , & 0.0_pr , 0.0_pr , 6 4.01_pr , - 4 3.56_pr , - 20 1.4_pr , 74 5.4_pr , & - 42 2.7_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 6 1.96_pr , - 44 7.95_pr , 28 0.0_pr , 16 0.7_pr , 32 5.81_pr , 22 0.6_pr , & 0.0_pr , 15 9.0_pr , 0.0_pr , - 9 3.31_pr , 0.0_pr , - 27 7.6_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 7 4.88_pr , & 0.0_pr , 0.0_pr , - 30 6.22_pr , 0.0_pr , 51 6.5_pr , 8 1.56_pr , & 71 3.9_pr , 0.0_pr , - 13 9.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 46 8.5_pr , 14 1.1_pr , 80 8.0_pr , & - 17 2.2_pr , 84 8.6_pr , - 9 9.57999_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 15 5.7_pr , 0.0_pr , - 33 0.2_pr , & - 7.532001_pr , 0.0_pr , 19 7.95_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 19 7.4_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 22 9.97_pr , & 11 0.4_pr , 0.0_pr , 2 1.04_pr , - 7.56_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 40 6.2_pr , 38 8.4_pr , - 8 1.68999_pr , 44 4.29_pr , 103 6.0_pr , 10 1.2_pr , & - 49 4.2_pr , 0.0_pr , 8 0.79201_pr , 237 1.0_pr , 9 6.77_pr , 58 0.3_pr , & 0.0_pr , 16 2.14_pr , - 8 8.49_pr , 96 5.0_pr , - 39 1.9_pr , 0.0_pr , & 5 7.08_pr , - 42 1.21_pr , - 7 0.45_pr , - 14 7.64_pr , 0.0_pr , 51 2.7_pr , & - 1 2.71_pr , 60 6.9_pr , 0.0_pr , 0.0_pr , 35 6.6_pr , 0.0_pr , & 37 3.8_pr , 0.0_pr , 0.0_pr , 102 5.0_pr , - 13 3.35_pr , - 11 0.34_pr , & 96 7.74_pr , 19 0.06_pr , 0.0_pr , 0.0_pr , 0.0_pr , 66 6.5_pr , & - 5 4.26_pr , - 36 7.48_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 2.27584_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 34 2.0_pr , 0.0_pr , 12 3.26_pr , & 2 9.57_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 5 7.38_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 10 9.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 131 2.0_pr , - 33 9.8_pr , - 12 6.2_pr , 230 3.0_pr , 40 3.8_pr , 30 8.7_pr , & 67 6.0_pr , 0.0_pr , 6 4.21_pr , 0.0_pr , - 33 8.8_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 7 5.67_pr , - 27 1.176_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 37 8.1_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 21 1.1_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 86 5.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 11 7.1_pr , 2.406_pr , 13 4.6_pr , & - 10 7.1_pr , 312 1.0_pr , 6 8.972_pr , 27 4.37_pr , 39 1.2_pr , 43 7.739_pr , & 71 6.7_pr , 37 4.1_pr , 22 7.6_pr , 39 7.0_pr , 12 4.3_pr , - 13 1.9_pr , & 32 4.15_pr , 137 1.0_pr , 26 8.23_pr , 25 6.2_pr , 106 0.0_pr , - 3 1.42_pr , & 1 0.7_pr , 28 9.08_pr , - 3 7.183_pr , 20 7.16_pr , 11 9.3_pr , 200 4.0_pr , & 2 9.45_pr , - 7.465_pr , 9 6.59_pr , 0.0_pr , 0.0_pr , - 12 2.5_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 2 4.82_pr , 11 2.7_pr , 14 1.2_pr , & 16 5.6_pr , 68 3.3_pr , 0.0_pr , 2 0.834_pr , 0.0_pr , - 6 1.922_pr , & 49 9.59_pr , 16 5.66_pr , 14 8.66_pr , 15 9.179_pr , - 3 0.564_pr , 0.0_pr , & 7 5.45_pr , 66 0.47_pr , 36 0.0808_pr , 98 6.9591_pr , - 93 5.6061_pr , 235 8.513_pr , & 103 9.753_pr , - 17 1.2349_pr , - 10 8.172_pr , 112 0.89_pr , 425 8.272_pr , 0.0_pr , & 7 9.507_pr , - 32 2.1_pr , - 2 6.852_pr , - 2 6.486_pr , 40 1.89_pr , - 30 8.7_pr , & - 7 5.7467_pr , 0.0_pr , - 6 2.857_pr , 0.0_pr , - 2 8.231_pr , 0.0_pr , & - 12 4.33_pr , - 14 3.07_pr , - 18 6.98_pr , 0.0_pr , 0.0_pr , - 25 0.25_pr , & - 2 8.653_pr , 72 0.45_pr , - 32 5.77_pr , 10 8.83_pr , 0.0_pr , 19 0.45_pr , & 9 6.855_pr , 5 3.75_pr , 0.0_pr , 16 6.56_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 18 6.4_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 32 1.62_pr , - 2 2.572_pr , 5 3.871_pr , 0.0_pr , 0.0_pr , 24 2.49_pr , & 0.0_pr , 0.0_pr , 141 4.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 11 7.208_pr , - 32 3.6833_pr , & - 45 0.7675_pr , 0.0_pr , 492 7.307_pr , 12 2.9861_pr , 18 6.7351_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 193 5.7_pr , 0.0_pr , - 117 2.0_pr , & - 51 4.79_pr , 0.0_pr , 0.0_pr , - 80 4.28_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 74 5.4_pr , 48 9.15_pr , - 45 4.92_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 6 5.631_pr , 53 0.3_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 77 8.78_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 31 0.13_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 16 4.25_pr , 38 9.28_pr , 38 0.02_pr , 29 7.73_pr , - 3 2.643_pr , - 24 2.6_pr , & 50 9.3_pr , 0.0_pr , - 49 7.98_pr , 0.0_pr , - 57 9.11_pr , 26 0.64_pr , & - 51 5.93_pr , 0.0_pr , 0.0_pr , - 42 0.24_pr , 0.0_pr , - 51 6.31_pr , & 23 7.42_pr , 50 8.72_pr , 20 7.12_pr , 7.3664_pr , 0.0_pr , 2 2.779_pr , & - 2 7.161_pr , 0.0_pr , 0.0_pr , 8 9.744_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 4 7.772_pr , 0.0_pr , 0.0_pr , - 32 2.46_pr , 0.0_pr , & 18 5.82_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 18 3.79_pr , & - 52 3.96_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 7 6.1382_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 67 7.32_pr , 49 1.23_pr , 31 3.79_pr , & 7 2.26_pr , 120 1.3_pr , 0.0_pr , 65 9.22_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 29 8.46_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 173 8.5_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 315 0.86_pr , 67 3.2271_pr , 108 3.63_pr , 169 6.96_pr , 18 6.24_pr , - 11 9.08_pr , & 93 4.67_pr , 0.0_pr , 50 2.1_pr , 0.0_pr , 75 8.13_pr , 0.0_pr , & 0.0_pr , 41 3.11_pr , 44 4.67_pr , - 72 9.5_pr , 127 1.42_pr , 48 9.93_pr , & 0.0_pr , - 36 9.31_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 21 0.34_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 218 7.67_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 11 7.57_pr , & 30 8.235_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 152 9.52_pr , 24 9.18_pr , 9 2.5_pr , & 7 6.73_pr , 162 7.81_pr , 21 0.91_pr , 6 4.43999_pr , 0.0_pr , 3 7.37_pr , & 0.0_pr , 61 1.47_pr , 0.0_pr , 132 1.52_pr , 0.0_pr , 0.0_pr , & 211 1.24_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 40 0.86_pr , 0.0_pr , & 10 2.8_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 49 9.19_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 9 1.65_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 92 3.282_pr , 117 1.32_pr , - 10 3.146_pr , - 18 2.325_pr , - 15 0.961_pr , 19 7.395_pr , & - 111 9.8_pr , 0.0_pr , 41 0.655_pr , 0.0_pr , 297 3.58_pr , 0.0_pr , & 385 8.07_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 29 7.646_pr , 0.0_pr , 95 5.8281_pr , - 101 7.26_pr , 0.0_pr , 51 6.966_pr , & 59 3.203_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 3.44708_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 1 8.3768_pr , 0.0_pr , 0.0_pr , - 4 9.6851_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 18 8.913_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 2 4.432_pr , - 8 6.231_pr , 141 2.0_pr , & 100 0.8_pr , - 374 5.0_pr , 67 3.72_pr , 0.0_pr , 491 1.4_pr , - 15 3.7_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 67 4.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 136 6.3_pr , 0.0_pr , 32 4.62_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 31 3.43_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 142 3.7_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 26 9.67_pr , 9.389999_pr , 39 2.56_pr , 16 4.05_pr , 49 5.28_pr , 13 7.95_pr , & 49 9.44_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 60 4.897_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 40 7.47_pr , - 45 6.08_pr , 84 9.08_pr , & 55 8.08_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 37 3.49_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 12 5.526_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 105 8.31_pr , 77 5.56_pr , - 52 2.32_pr , - 30 7.42_pr , 3 4.94_pr , 16 6.42_pr , & - 30 2.93_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 133 6.2_pr , 0.0_pr , & - 20 9.209_pr , 19 0.882_pr , 117 8.79_pr , 266 2.02_pr , 0.0_pr , 0.0_pr , & - 5 0.8443_pr , 0.0_pr , 84 2.486_pr , 26 2.138_pr , 40 1.698_pr , 12 0.59_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 245 9.01_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 58 1.16_pr , & 1 9.221_pr , 0.0_pr , 18 4.792_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 91 2.2161_pr , - 9.63211_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 74 2.31_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 7 0.38_pr , - 4 4.3408_pr , 27 7.4415_pr , & 93 0.7075_pr , 29 2.6468_pr , - 70 4.2285_pr , 65 9.2109_pr , 0.0_pr , 17 3.4451_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 88 3.9302_pr , - 61 7.0431_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 28 3.1673_pr , 0.0_pr , 109 4.895_pr , & 0.0_pr , - 59 1.0368_pr , 0.0_pr , 0.0_pr , - 3 5.932_pr , - 411 6.333_pr , & 126 0.02_pr , 56 6.2915_pr , 82 5.9189_pr , - 31 3.9384_pr , 102 6.29_pr , - 34 8.9494_pr , & 277 0.851_pr , 0.0_pr , 82 4.1235_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 49 3.7747_pr , & 82 6.0889_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 10 3.0519_pr , & 0.0_pr , - 51 6.843_pr , 0.0_pr , - 25 4.6989_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 28 3.8202_pr , - 9 2.7302_pr , - 130 4.107_pr , & - 93 5.3928_pr , - 34 8.7564_pr , - 123 0.497_pr , 0.0_pr , 0.0_pr , 9 9.5504_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 50 1.6695_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 140 3.31_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 182 4.841_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 36 0.8016_pr , 123 0.781_pr , 62 6.9603_pr , 52 4.3056_pr , - 244 8.212_pr , - 67 1.2604_pr , & 270 7.161_pr , 0.0_pr , 14 7.2528_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 38 1.9636_pr , & 58 0.1045_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 10 7.3735_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 420 9.48_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 65 6.528_pr , 162 5.909_pr , 16 1.7745_pr , & 45 3.4621_pr , 117 8.048_pr , 5 3.7776_pr , - 161 6.174_pr , 0.0_pr , 33 1.1518_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 107 8.495_pr , 27 7.9974_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 85 5.7144_pr , 0.0_pr , - 167 9.977_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 109 4.303_pr , 297 9.973_pr , 169 0.065_pr , 107 7.47_pr , - 15 9.8631_pr , 174 1.061_pr , & 31 8.2128_pr , 0.0_pr , 57 1.6566_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 165 4.642_pr , & - 31 2.4461_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 13 3.3952_pr , & 0.0_pr , - 113 8.034_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 86 0.51_pr , 32 4.316_pr , 45 4.316_pr , & 62 9.463_pr , 110 5.94_pr , 3 4.7884_pr , 103 8.3_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 136 6.59_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 50 9.274_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 20 0.04_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 46 8.398_pr , - 74 0.2421_pr , - 63 0.416_pr , - 47 8.068_pr , - 36 7.321_pr , 121 6.71_pr , & 487 8.28_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 58 4.728_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 24 6.348_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 185 9.374_pr , 248 7.632_pr , 101 4.686_pr , & 111 3.436_pr , 22 5.0235_pr , 103 7.56_pr , 20 6.2641_pr , 0.0_pr , 51 9.4855_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 44 9.5142_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 11 3.0145_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 404 1.479_pr , - 239 9.738_pr , 489 9.846_pr , 33 5.1104_pr , - 35 2.184_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 454 2.127_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr & ], [ nmg , nmg ]) ! ======================================================================== ! PSRK bij ! ------------------------------------------------------------------------ DortmundParameters % maingroups_bij = reshape ([& 0.0_pr , 0.061708_pr , - 0.2998_pr , 0.3575_pr , - 4.746_pr , - 0.48575_pr , & 0.8389_pr , - 4.615_pr , - 0.8709_pr , 0.0_pr , - 3.3912_pr , - 0.5358_pr , & - 0.03242_pr , - 2.6348_pr , - 1.0916_pr , - 1.4436_pr , - 5.6676_pr , 3.4225_pr , & - 1.3979_pr , - 9.0933_pr , 0.074091_pr , - 1.1856_pr , - 8.427_pr , 1.0927_pr , & - 2 0.84_pr , 3.092_pr , - 4.082_pr , - 1.126_pr , - 0.008313_pr , - 1.081_pr , & 0.0_pr , - 0.7116_pr , - 0.3658_pr , - 0.1018_pr , - 2.175_pr , 0.0_pr , & - 0.6894_pr , - 0.0108_pr , - 0.9023_pr , 2.467_pr , 1.287_pr , - 0.8062_pr , & - 1.3546_pr , 0.0_pr , 0.027778_pr , 1.7054_pr , - 0.9413_pr , - 0.615_pr , & - 1.22588_pr , - 0.5337_pr , 0.0_pr , - 0.3935_pr , - 1.2256_pr , 0.83298_pr , & - 5.48462_pr , 0.46568_pr , - 1.47382_pr , 3.60996_pr , - 1.03559_pr , 0.64856_pr , & - 6.86512_pr , - 0.93175_pr , 2.66288_pr , - 0.27232_pr , 0.0_pr , 0.6166_pr , & 1.172_pr , - 5.809_pr , 0.6304_pr , 4.072_pr , 0.4936_pr , - 0.71715_pr , & 0.0_pr , 1.6732_pr , 0.0_pr , 2.945_pr , - 5.148_pr , 0.0_pr , & 0.0_pr , - 1 9.72_pr , 0.0_pr , 0.0_pr , 1.216_pr , 1.238_pr , & 0.0_pr , 0.0_pr , 2.3281_pr , - 1.519_pr , - 1.997_pr , 0.0_pr , & - 1.09_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.5148_pr , & 1.8723_pr , - 1.303_pr , 0.0_pr , - 0.09576_pr , 0.9076_pr , 0.0_pr , & 0.0_pr , - 2.159_pr , 0.1565_pr , - 5.0_pr , 0.0_pr , 0.0_pr , & 3.3463_pr , - 0.8135_pr , 0.0_pr , - 0.920017_pr , 0.0_pr , 0.0_pr , & - 1.4153_pr , 0.0_pr , - 3.112_pr , 5.14012_pr , 4.7125_pr , - 1.86077_pr , & 1.85317_pr , - 4.79411_pr , 0.0_pr , 0.0_pr , - 5.18107_pr , 0.57714_pr , & 0.0933_pr , - 0.5886_pr , 0.0_pr , 0.4223_pr , - 1 2.77_pr , - 0.11768_pr , & 1.158_pr , - 5.043_pr , 1.212_pr , - 2.167_pr , - 1.7605_pr , - 0.262_pr , & 0.05615_pr , - 1.901_pr , - 0.60667_pr , - 0.6022_pr , 1.2458_pr , - 5.7594_pr , & - 0.5959_pr , - 1.595_pr , 0.1046_pr , 0.39662_pr , 0.69975_pr , 2.12_pr , & - 1 0.98_pr , 3.066_pr , - 9.28137_pr , - 3.702_pr , 0.1196_pr , - 0.4601_pr , & 1.5036_pr , - 0.8374_pr , - 0.9020001_pr , 0.0_pr , 1.545_pr , 0.0_pr , & - 8.707001_pr , 7.883_pr , - 0.6263_pr , - 0.1703_pr , - 1.807_pr , 1.094_pr , & 0.64039_pr , 8.656199_pr , - 0.068774_pr , 1.4084_pr , - 1.3578_pr , - 0.8126_pr , & - 0.570848_pr , 1.4602_pr , 0.0_pr , 3.6831_pr , - 2.4316_pr , 0.2781_pr , & - 0.33187_pr , 0.38631_pr , - 2.11062_pr , - 3.09114_pr , - 0.15571_pr , 1.04305_pr , & 0.0_pr , - 1.96581_pr , 3.81305_pr , - 0.4538_pr , - 0.8552_pr , - 0.65_pr , & 0.0_pr , - 5.765_pr , - 0.48799_pr , 1.6504_pr , - 3.743_pr , 0.2419_pr , & 2.656_pr , - 9.409_pr , 0.0_pr , - 1.57_pr , 5.141_pr , 0.0_pr , & - 6.481_pr , 8.497001_pr , - 9.8887_pr , - 0.8218_pr , 0.0_pr , - 0.59569_pr , & - 0.42684_pr , - 0.19378_pr , - 0.6785_pr , - 0.7359_pr , - 4.702_pr , - 5.15065_pr , & 7.679_pr , 0.0_pr , - 1.081_pr , - 5.2068_pr , - 0.9919_pr , 0.1221_pr , & 0.0_pr , - 0.7113_pr , 0.0_pr , - 0.02925_pr , 0.001763_pr , - 0.5839_pr , & 0.0_pr , 3.332_pr , - 0.5561_pr , 0.033695_pr , - 1.2039_pr , 0.25471_pr , & - 1.3961_pr , - 1.008_pr , - 0.8198_pr , - 0.608934_pr , 0.1146_pr , 0.0_pr , & - 3.4373_pr , - 8.697001_pr , - 1.20387_pr , 1.38462_pr , - 1.19824_pr , - 1.91791_pr , & - 2.994_pr , 4.48792_pr , 0.669085_pr , 0.0_pr , 1.00738_pr , - 2.55407_pr , & - 4.674_pr , - 6.508_pr , - 1 3.16_pr , - 1 4.09_pr , 0.0_pr , 9.7928_pr , & - 8.673_pr , - 1.841_pr , - 1.412_pr , - 2 4.57_pr , 1.538_pr , - 1.215_pr , & - 0.7132_pr , - 0.1511_pr , 1.743_pr , 1 1.5_pr , - 6.263_pr , 2.9346_pr , & 4.415_pr , - 4.9155_pr , - 4.363_pr , - 4.509_pr , 0.0_pr , - 5.964_pr , & 3 4.13_pr , - 1.274_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.1457_pr , & 2.421_pr , 0.0_pr , - 1.673_pr , - 2.538_pr , 1.956_pr , - 1.248_pr , & 0.0_pr , 0.0_pr , 1.129_pr , 0.0_pr , - 1.383_pr , - 1.25_pr , & 5.0_pr , 0.0_pr , - 6.227_pr , 2.1888_pr , - 5.962_pr , 3.8321_pr , & - 2.20103_pr , - 7.6896_pr , 0.2237_pr , 0.0_pr , - 2.3183_pr , 2.08434_pr , & 3.87681_pr , - 2.48421_pr , 4.01945_pr , - 3.71273_pr , - 3.28127_pr , - 2.16488_pr , & 0.0_pr , - 1.61662_pr , - 1.09998_pr , - 3.0099_pr , 1 0.0_pr , - 2.0299_pr , & 1.9094_pr , - 2.4583_pr , 0.0_pr , 4.6065_pr , - 2.905_pr , - 0.36048_pr , & - 0.6469_pr , 0.3745_pr , - 0.06819_pr , 0.1198_pr , 0.65743_pr , - 0.39888_pr , & - 3.354_pr , - 1.274_pr , - 0.3825_pr , - 0.9444399_pr , - 3.4339_pr , - 2.9694_pr , & - 2.7981_pr , 0.0_pr , - 2.813_pr , - 6.383_pr , - 1.766_pr , 0.0_pr , & - 9.172001_pr , - 1.863_pr , - 1.903_pr , 0.483_pr , - 3.858_pr , 0.8050001_pr , & 0.0_pr , - 0.6343_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1.732_pr , & 0.0_pr , - 1.335_pr , - 3.5236_pr , - 3.3287_pr , 0.0_pr , - 1 9.456_pr , & 0.0_pr , - 0.7465_pr , 0.6584_pr , 1.17652_pr , - 5.4899_pr , 0.4314_pr , & 0.0_pr , - 8.003099_pr , 2.17856_pr , - 4.14737_pr , - 2.92427_pr , - 2.42145_pr , & 0.30192_pr , 1.11398_pr , 0.0_pr , 3.77874_pr , 0.34143_pr , 0.0_pr , & - 3.6156_pr , 0.1482_pr , - 1.726_pr , - 1.9939_pr , 3.824_pr , 1.0823_pr , & 0.0_pr , - 2.757_pr , - 0.5873_pr , - 2.145_pr , - 1.3412_pr , 0.0_pr , & - 0.605276_pr , 3.671_pr , 1.034_pr , - 0.7738_pr , - 0.7957_pr , 0.5546_pr , & - 1.916_pr , - 4.6878_pr , - 0.5041_pr , - 1.319_pr , 0.0_pr , - 2.815_pr , & - 3.08_pr , - 2.606_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 1.939_pr , & 0.7775_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.1043_pr , - 0.9948_pr , & 0.0_pr , 0.0_pr , - 0.6029_pr , 0.0_pr , - 2.929_pr , - 2.8719_pr , & - 1.48515_pr , - 2.2535_pr , 3.158_pr , 0.9707_pr , 1.3487_pr , 0.3142_pr , & - 0.468519_pr , 0.0_pr , - 0.8437_pr , 0.0_pr , - 1.8013_pr , - 3.00895_pr , & - 5.47448_pr , 0.0_pr , 0.16195_pr , - 1.97057_pr , - 2.49001_pr , 0.0_pr , & - 0.776483_pr , 0.99046_pr , 0.0_pr , - 0.9977_pr , - 1.955_pr , - 2.118_pr , & - 1.702_pr , - 1.262_pr , - 1.258_pr , 1 9.44_pr , 0.0_pr , 1.918_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.9399_pr , - 3.5887_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 3.718_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 6.23_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 4.0832_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.1473_pr , 0.69911_pr , - 1.237_pr , - 1.871_pr , 2.857_pr , - 0.46505_pr , & - 3.669_pr , - 0.738_pr , 0.0_pr , 0.0_pr , 0.21913_pr , 0.0_pr , & - 0.9619_pr , 0.0_pr , 0.0_pr , - 1 3.01_pr , - 1 3.73_pr , - 0.8161_pr , & - 0.3808_pr , - 0.91676_pr , 0.0_pr , 1.0749_pr , - 0.79498_pr , 1.4412_pr , & 2.499_pr , 0.0847_pr , 0.3045_pr , - 0.5617_pr , 0.0_pr , - 1.357_pr , & 0.4909_pr , 0.7905_pr , - 1.4362_pr , 9.604_pr , - 0.5189_pr , 0.0_pr , & 3.143_pr , 0.0_pr , - 1 0.0_pr , 0.0_pr , 0.0_pr , 2.1022_pr , & - 0.10124_pr , 0.0_pr , - 3.8168_pr , 0.0_pr , - 0.9829_pr , 0.0_pr , & 0.7123_pr , - 6.6054_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 4.73012_pr , & - 5.05233_pr , 4.63058_pr , - 2.24998_pr , - 0.71244_pr , 4.44554_pr , 0.0_pr , & 0.0_pr , 0.15196_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1.874_pr , & - 1.02_pr , 2.379_pr , 2.256_pr , 6.512_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.1314_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 3.426_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.5724_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 1.9294_pr , - 2.4224_pr , 0.91491_pr , 2.72_pr , - 5.633_pr , - 1.2702_pr , & 3.0862_pr , 0.0_pr , - 0.27924_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 6.009_pr , 0.0_pr , - 1 3.78_pr , 0.8719_pr , - 2 2.96_pr , - 1.4281_pr , & - 0.43665_pr , - 0.71198_pr , 0.0_pr , 1.8569_pr , 0.0_pr , 0.1237_pr , & 1.693_pr , 0.02448_pr , 0.0_pr , - 0.9491_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 1.198_pr , 0.0_pr , 0.8843_pr , - 1.792_pr , & 1.052_pr , 0.0_pr , - 0.5966_pr , 0.0_pr , - 1.174_pr , - 0.06206_pr , & 0.0_pr , 0.0_pr , - 2.1861_pr , 0.0_pr , - 0.8641_pr , 3.9906_pr , & - 1.3111_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 9.9994_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 1 1.7013_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.6215_pr , 0.0_pr , - 0.02393_pr , & 0.0_pr , - 0.5874_pr , - 0.6402_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.7730001_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.8031_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.2248_pr , 0.0_pr , 0.0_pr , 2.5295_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.3155_pr , - 2.509_pr , - 0.1859_pr , 2.978_pr , - 5.092_pr , - 0.5522_pr , & - 3.72906_pr , 0.0_pr , - 2 6.91_pr , - 0.6241_pr , - 9.75_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.728_pr , & 1.481_pr , 0.0_pr , - 2.939_pr , - 2.482_pr , - 0.64386_pr , - 1.486_pr , & - 5.682_pr , - 1.368_pr , 0.0_pr , - 1.434_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.24_pr , 2.822_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1.134_pr , & - 0.7058_pr , 0.0_pr , - 2.6254_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.410609_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 7.1332_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 4.9683_pr , - 8.653001_pr , - 8.729_pr , & - 1 9.16_pr , 2.468_pr , 1.0807_pr , - 5.869_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 9.0_pr , & - 5.208_pr , 0.0_pr , 0.0_pr , - 1 0.495_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.1415_pr , - 9.315001_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.258_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.066729_pr , 0.0_pr , 0.037692_pr , 0.0_pr , 0.58_pr , 4.4917_pr , & - 2.531_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 2 4.07_pr , 0.0_pr , & 0.0_pr , - 1 2.72_pr , 0.0_pr , 2.561_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 2.948_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 2.79_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0511_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 7.58704_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 1.857_pr , 0.0_pr , 0.7078_pr , & 1 3.56_pr , - 5.014_pr , 5.603_pr , - 0.5905_pr , 0.0_pr , 0.1944_pr , & 0.0_pr , - 1.099_pr , 0.0_pr , 0.0_pr , - 0.2051_pr , - 1.614_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 1.524_pr , 0.0_pr , 3.15_pr , - 9.612_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.09722999_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 1.452_pr , 0.0_pr , 0.0_pr , 3.078_pr , & 0.0_pr , - 0.696_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 5.71975_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.14836_pr , - 1 0.72_pr , - 1.7112_pr , - 1 6.68_pr , 5.916_pr , 1 3.46_pr , & 0.5246_pr , - 6.792_pr , - 9.896001_pr , 0.0_pr , 7.683001_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1.2436_pr , & - 9.336_pr , 0.0_pr , 3.372_pr , 0.0_pr , 0.0_pr , - 1 0.59_pr , & 0.0_pr , 0.0_pr , - 1.164_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 3.229_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.2657_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1 0.9894_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 1 7.171_pr , 0.0_pr , 0.1615_pr , & - 2.369_pr , 9.5413_pr , - 5.8042_pr , 9.8213_pr , 1 2.859_pr , 4.1057_pr , & 0.0_pr , 1.4109_pr , 0.0_pr , - 6.9867_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 1 4.613_pr , 0.0_pr , 5.8186_pr , 4.614_pr , 2.8397_pr , & - 4.9886_pr , 0.0_pr , 6.3625_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.603_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1.6854_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 1 3.088_pr , 2.6335_pr , 0.0_pr , 2.7237_pr , & 0.0_pr , 5.4638_pr , 0.0_pr , 0.0_pr , 1.1962_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.7335_pr , 0.0_pr , 0.9437_pr , 1.333_pr , 0.8503_pr , - 0.28666_pr , & 3.59_pr , 0.0_pr , 0.6835_pr , 0.0_pr , 0.43006_pr , 0.0_pr , & - 8.022_pr , - 0.49092_pr , 0.0_pr , 0.0_pr , - 4.703_pr , - 2.1937_pr , & 0.0_pr , 0.0_pr , 1.992_pr , 0.0_pr , 0.0_pr , 0.7676_pr , & - 9.238001_pr , 0.50349_pr , 0.0_pr , 0.0_pr , 0.646_pr , 0.0_pr , & 0.7004_pr , 0.0_pr , 0.0_pr , 7.698_pr , 0.0_pr , 0.0_pr , & 1.195_pr , 0.0_pr , 1.0644_pr , 0.0_pr , 0.0_pr , - 3.395_pr , & 0.89781_pr , 0.0_pr , 2.8574_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.54754_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0641231_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 3.2647_pr , 8.1549_pr , 1.8881_pr , & 0.0_pr , 4.3634_pr , 2.3351_pr , 1 2.708_pr , 0.0_pr , 0.96888_pr , & 0.0_pr , 1.0567_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.4031_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 2.1861_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 1.5491_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.8061_pr , 1.493_pr , 0.309_pr , 0.0_pr , 2.3961_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.72772_pr , - 1.487_pr , - 0.21322_pr , 0.30443_pr , - 0.7077_pr , - 0.28137_pr , & 1.592_pr , 0.0_pr , 0.0_pr , - 2.986_pr , 0.0_pr , 0.0_pr , & - 0.2571_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 2.33_pr , - 0.4933_pr , & - 1.237_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 3.977_pr , - 0.2348_pr , & - 1.099_pr , - 0.153_pr , - 4.224_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.01307_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.322_pr , & - 1.149_pr , 0.0_pr , 0.32745_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.458824_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.4139_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 1.2561_pr , 0.0_pr , - 0.46141_pr , & 0.19998_pr , 0.1322_pr , - 0.26371_pr , 0.9495_pr , 0.0_pr , - 0.52606_pr , & 0.0_pr , - 1.0536_pr , 0.0_pr , - 6.475_pr , 0.0_pr , 0.0_pr , & 0.8883_pr , 0.0_pr , 2.1884_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 5.0_pr , 0.05388_pr , - 1.748_pr , 0.8154_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.09203999_pr , - 0.776_pr , & 0.0_pr , - 0.8556_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.1399_pr , 1.3307_pr , 0.0_pr , - 0.37825_pr , & 0.0_pr , 0.0_pr , 0.4276_pr , - 2.93164_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 4.5311_pr , 0.0_pr , - 0.63629_pr , - 0.25363_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 3.2209_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 2.3467_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 4.2459_pr , - 3.446_pr , 0.0_pr , - 1.3456_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.4274_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 1.7109_pr , - 2.1164_pr , - 1.776_pr , & 0.6081_pr , - 2.027_pr , - 0.06709_pr , - 1.795_pr , - 3.347_pr , 0.8293_pr , & 0.0_pr , - 0.2724_pr , 0.572_pr , 0.9514_pr , - 0.3148_pr , 0.0_pr , & - 1.399_pr , - 1 6.15_pr , - 1.5005_pr , - 0.6265_pr , - 1.7576_pr , 0.07287_pr , & - 0.2115_pr , 1.1973_pr , 0.0_pr , - 6.82_pr , 0.0967_pr , 0.0_pr , & - 0.9095_pr , 0.0_pr , - 0.8269_pr , 0.0_pr , - 0.7294_pr , 7.402_pr , & 0.0_pr , - 0.6321_pr , 0.0_pr , - 0.3226_pr , - 0.02128_pr , - 0.123_pr , & 0.0_pr , 0.0_pr , 0.024262_pr , - 0.014204_pr , 0.0_pr , - 0.11086_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.435084_pr , 1.1653_pr , 0.0_pr , & 0.0_pr , - 0.8815_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 1 5.89_pr , 9.805_pr , 3.309_pr , 1 9.72_pr , 3 2.07_pr , - 1 1.81_pr , & 9.303_pr , 0.0_pr , - 1.365_pr , 0.0_pr , - 1 4.54_pr , 0.0_pr , & - 1.368_pr , - 1 1.9_pr , - 1 6.26_pr , - 4.812_pr , 0.0_pr , 0.0_pr , & 3.361_pr , 0.0_pr , - 1 5.7_pr , - 1 4.2_pr , 0.0_pr , 9.802_pr , & 0.0_pr , - 1 4.25_pr , - 1.8141_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.5503_pr , 0.0_pr , 0.0_pr , - 0.5826_pr , & - 9.3959_pr , 0.0_pr , - 1 6.954_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.1605_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 1 3.2_pr , 0.08726_pr , - 0.8156_pr , & - 9.968_pr , - 2.098_pr , - 2.212_pr , 2.634_pr , 0.0_pr , - 0.1009_pr , & 0.0_pr , - 0.3292_pr , 0.0_pr , 0.7063_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.44692_pr , 0.0_pr , - 0.4713_pr , & - 2.05_pr , 0.0_pr , - 0.5353_pr , 2 5.0_pr , 0.0_pr , 0.0_pr , & - 2.203_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.2245_pr , 0.05397_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.2485_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.7866_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 2.693_pr , 0.0_pr , - 4.4141_pr , 0.196357_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 2.986_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1.686_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 2.04_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 2.2806_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 4.8_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 1.521_pr , 1.545_pr , - 2 5.0_pr , & - 9.5_pr , 0.0_pr , 4.419_pr , 0.0_pr , 0.0_pr , 0.09772_pr , & 0.0_pr , - 1.693_pr , 0.0_pr , 1.702_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 1.033_pr , 0.0_pr , 3.217_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.228_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.03419_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 1.191_pr , 1.5927_pr , 0.0_pr , 1.1526_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.8557_pr , 0.0_pr , - 0.3094_pr , 0.0_pr , 0.0_pr , - 0.3753_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.3652_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.2619_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.9384_pr , 0.0_pr , 0.3778_pr , & 1.408_pr , - 1.771_pr , 2.203_pr , 3.847_pr , 0.0_pr , 3.847_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.8165_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.2545_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 2.2658_pr , 5.9959_pr , - 2.41_pr , - 0.2074_pr , & - 0.9091_pr , 0.0_pr , - 1.148_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 3.042_pr , 0.0_pr , & - 1.263_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.9536999_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.3564_pr , 0.0_pr , 0.5677_pr , & 0.4317_pr , 0.0_pr , 0.3161_pr , 0.0_pr , 0.0_pr , - 0.7017_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.1183_pr , 0.0_pr , 0.6829_pr , 0.0_pr , - 0.7376_pr , 0.0_pr , & - 0.3692_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 1.924_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.17437_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.499_pr , 0.5941_pr , 1.214_pr , - 0.5955_pr , - 1.767_pr , - 0.3303_pr , & 0.0_pr , 0.0_pr , 2.9431_pr , 0.0_pr , 1.892_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1.9191_pr , & 0.0_pr , 0.0_pr , - 0.2077_pr , 1.022_pr , 0.0_pr , - 1.328_pr , & 0.0_pr , - 0.1079_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 1.995_pr , 0.0_pr , 0.0_pr , - 0.06775_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.936_pr , - 0.61_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.6581_pr , - 3.8641_pr , 0.0_pr , & 0.0_pr , 1.034_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.8977_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 1.229_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 3.457_pr , 1.96_pr , - 1.43_pr , 0.2236_pr , - 1.2_pr , 0.03906_pr , & - 0.611_pr , 0.0_pr , 0.5372_pr , 0.0_pr , - 1.264_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.7426_pr , 0.0_pr , 0.4405_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.1436_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.5021_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.23965_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 2.196_pr , 0.0_pr , 2.436_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.9031_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.009102_pr , - 0.03862_pr , - 7.798_pr , - 0.2311_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 1.077_pr , 0.0_pr , 0.5487_pr , - 0.622_pr , & 2.23_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.4161_pr , 1.5141_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.3756_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.1286_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.7293_pr , & - 2.7759_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 1.042_pr , - 0.3025_pr , - 5.331_pr , & 0.2257_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 1.578_pr , 0.0_pr , 0.0_pr , & - 0.8077_pr , 0.0_pr , - 0.3316_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.4858_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.1288_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.6525_pr , 0.0_pr , 1.1229_pr , 0.1947_pr , - 2.995_pr , - 1.078_pr , & 2.826_pr , 0.0_pr , - 3.702_pr , 0.0_pr , 0.4827_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.7417_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.02702_pr , & - 0.4758_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.1022_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.1555_pr , & 1.0612_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.601128_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 1.679_pr , 0.0_pr , - 0.6133_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 3.643_pr , 1.297_pr , 0.386_pr , - 6.346_pr , - 0.9346_pr , - 1.175_pr , & - 0.9909_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1.837_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 1.4107_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 2.56_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 2.89_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.5481_pr , - 0.1882_pr , - 1.231_pr , & 0.2564_pr , - 1 3.69_pr , - 0.41997_pr , - 0.5861_pr , - 0.8799_pr , - 2.7983_pr , & - 1.516_pr , - 1.976_pr , - 0.7762_pr , - 1.379_pr , - 1.147_pr , - 0.007369_pr , & - 1.4264_pr , - 3.323_pr , - 1.4137_pr , - 1.526_pr , - 2.822_pr , - 0.248_pr , & - 0.2702_pr , - 0.5852_pr , - 0.047827_pr , - 1.2206_pr , - 0.5691_pr , - 4.5_pr , & - 0.9194_pr , - 0.4151_pr , - 0.7691_pr , 0.0_pr , 0.0_pr , 0.0913_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.5324_pr , - 0.4103_pr , - 0.8783_pr , & 0.0_pr , 6.321_pr , 0.0_pr , - 0.34718_pr , 0.0_pr , - 0.059442_pr , & - 0.8158_pr , - 0.9151_pr , - 1.0328_pr , - 1.11479_pr , - 0.2455_pr , 0.0_pr , & - 0.6572_pr , - 2.0132_pr , - 1.37211_pr , - 2.85003_pr , 4.67403_pr , - 1.30922_pr , & - 3.51543_pr , 0.62135_pr , - 0.132539_pr , - 3.1028_pr , 0.34026_pr , 0.0_pr , & 0.70892_pr , - 0.20367_pr , - 0.44215_pr , - 0.29519_pr , - 0.43627_pr , 1.7454_pr , & - 0.98514_pr , 0.0_pr , 0.2898_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.29398_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.3811_pr , & - 0.48152_pr , - 1.5187_pr , 2.0412_pr , - 0.86059_pr , 0.0_pr , 0.012716_pr , & - 1.2993_pr , 0.0_pr , 0.0_pr , - 1.0407_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 4.9963_pr , 0.0_pr , - 0.67747_pr , 0.0_pr , 0.0_pr , - 0.038323_pr , & 0.0_pr , 0.0_pr , - 2.8776_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.3946_pr , - 0.13058_pr , & 0.94786_pr , 0.0_pr , - 0.63511_pr , - 1.96464_pr , - 0.9786_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1 0.106_pr , & 4.9372_pr , 0.0_pr , 0.0_pr , 2.828_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.26834_pr , 0.0_pr , - 0.23326_pr , - 0.24204_pr , - 0.010434_pr , 0.29562_pr , & - 0.29_pr , 0.0_pr , 0.79715_pr , 0.0_pr , 0.9455_pr , - 1.2868_pr , & 0.3835_pr , 0.0_pr , 0.0_pr , 0.26315_pr , 0.0_pr , 1.6943_pr , & - 1.2928_pr , - 1.4005_pr , - 0.43964_pr , 0.40456_pr , 0.0_pr , 0.042145_pr , & 0.611_pr , 0.0_pr , 0.0_pr , - 1.0122_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.009201_pr , 0.0_pr , 0.0_pr , - 0.020828_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.15182_pr , & 0.4945_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 2.0066_pr , - 1.8285_pr , - 1.1552_pr , & - 0.1919_pr , - 4.6803_pr , 0.0_pr , - 1.8841_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.6823_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 3.9729_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 3.1003_pr , 1.9523_pr , 0.9144_pr , - 0.7064_pr , - 3.1349_pr , 0.9938_pr , & - 4.4232_pr , 0.0_pr , 0.3401_pr , 0.0_pr , - 0.2593_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.8351_pr , 6.2811_pr , - 6.4373_pr , - 0.5591_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.9103_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 1.057_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.7114_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 6.2025_pr , 0.0_pr , 1.4186_pr , & 0.9394_pr , - 5.8598_pr , - 2.4953_pr , - 0.0094_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 2.4783_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.0879_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.5131_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.3411_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 7.80959_pr , 3.92127_pr , 2.6565_pr , 3.36729_pr , 0.527951_pr , - 0.985958_pr , & 7.95909_pr , 0.0_pr , - 1.1056_pr , 0.0_pr , - 5.45555_pr , 0.0_pr , & - 9.278001_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.66206_pr , 0.0_pr , - 1.00012_pr , 3.0909_pr , 0.0_pr , 0.19471_pr , & - 0.7904_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.450261_pr , 0.0_pr , 0.0_pr , 3.86633_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.2915_pr , 0.0_pr , - 3.9917_pr , & - 2.5194_pr , 4.5137_pr , - 2.3567_pr , 0.0_pr , 9.8501_pr , 0.242_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 1.8854_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 3.8385_pr , 0.0_pr , - 1.1828_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0911_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 3.9162_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 2.6496_pr , - 1.4112_pr , & - 6.6553_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 1.04748_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.2037_pr , 2.4334_pr , - 6.5044_pr , & 0.565_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0647_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.289226_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 1.1856_pr , 0.0_pr , 3.8856_pr , 4.1819_pr , 1.0075_pr , 0.994_pr , & 0.5975_pr , 0.0_pr , 0.0_pr , 0.0_pr , 6.7742_pr , 0.0_pr , & - 0.470423_pr , 0.0_pr , - 9.99911_pr , - 1 3.9855_pr , 0.0_pr , 0.0_pr , & - 0.025287_pr , 0.0_pr , - 1.8434_pr , 0.0_pr , 0.0_pr , 1.2816_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 4.1194_pr , & 0.4413_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 2.02314_pr , 0.555403_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 4.1234_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.24511_pr , - 0.65212_pr , - 0.1843_pr , & - 4.30401_pr , - 1.59145_pr , - 1.26236_pr , - 0.59252_pr , 0.0_pr , - 5.52695_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 4.0287_pr , 2.40181_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 5.14586_pr , 0.0_pr , - 4.10982_pr , & 0.0_pr , 0.45605_pr , 0.0_pr , 0.0_pr , - 1.52136_pr , - 1.71395_pr , & - 4.55446_pr , - 0.14057_pr , - 4.35541_pr , 2.06128_pr , - 3.17777_pr , 1.41462_pr , & - 2.00944_pr , 0.0_pr , - 2.88368_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 4.10779_pr , & - 0.93908_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 1.42845_pr , & 0.0_pr , - 3.5941_pr , 0.0_pr , - 0.46519_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 3.9547_pr , - 0.25088_pr , 3.87435_pr , & 1.26386_pr , 1.92474_pr , 3.91001_pr , 0.0_pr , 0.0_pr , 0.45575_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 1.6261_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 4.02583_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 4.26948_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 2.05302_pr , 0.17033_pr , - 4.30606_pr , - 4.26859_pr , - 2.13997_pr , 1.58636_pr , & - 2.51124_pr , 0.0_pr , - 2.74448_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 3.00577_pr , & - 2.24427_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 3.90856_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.75036_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 4.2237_pr , - 2.40107_pr , - 0.56713_pr , & - 2.03845_pr , 5.33766_pr , - 0.9791_pr , 5.32305_pr , 0.0_pr , - 1.11421_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 3.65154_pr , 0.25973_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 1.14021_pr , 0.0_pr , 4.40837_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 1.11888_pr , 4.82369_pr , - 3.38808_pr , - 2.43883_pr , 2.41804_pr , - 4.73718_pr , & - 1.42376_pr , 0.0_pr , - 4.43975_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 4.24837_pr , & 1.126_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 2.64806_pr , & 0.0_pr , 0.70013_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 1.96009_pr , 0.0_pr , - 1.21943_pr , & - 1.39039_pr , - 1.68763_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 5.90673_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.533745_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.1979_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 2.55668_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 5.44835_pr , & - 6.38758_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 1.9006_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 4.06308_pr , - 3.28182_pr , - 1.73087_pr , & - 0.428312_pr , - 4.3271_pr , - 5.46099_pr , - 2.57259_pr , 0.0_pr , - 5.4673_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 2.1727_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 1.48378_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 3.90698_pr , - 0.27451_pr , - 3.53433_pr , 2.26653_pr , - 1.58363_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.85207_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr & ],[ nmg , nmg ]) ! ======================================================================== ! PSRK cij ! ------------------------------------------------------------------------ DortmundParameters % maingroups_cij = reshape ([& 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0009181_pr , 0.0_pr , & 0.0009021_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0039282_pr , 0.0_pr , & 0.0_pr , 0.0033576_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0087_pr , & 0.0_pr , 0.010238_pr , 0.0_pr , 0.0_pr , 0.014417_pr , - 0.002416_pr , & 0.03317_pr , - 0.006266_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.001291_pr , & 0.0024016_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.000623_pr , & 0.000583_pr , 0.0_pr , 0.0_pr , 4e-05_pr , 0.0_pr , 0.0_pr , & 0.0095873_pr , - 0.0055872_pr , 0.0010454_pr , - 0.0081757_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.0330202_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.005197_pr , - 0.0018_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.01039_pr , 0.0_pr , & 0.0_pr , 0.02783_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.0027_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0037455_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0254894_pr , & 0.0_pr , 0.0056279_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0078001_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.01435_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.003715_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.006999_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0023_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.003239_pr , & 0.01661_pr , - 0.005376_pr , 0.008299_pr , 0.003682_pr , 0.0_pr , 0.0_pr , & - 0.00141_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.007813_pr , - 0.007754_pr , 0.000668_pr , 0.0_pr , 0.0_pr , - 0.001557_pr , & 0.0_pr , - 0.015439_pr , 0.0_pr , 0.0_pr , 0.001331_pr , 2e-06_pr , & 0.000281_pr , 0.0_pr , 0.0_pr , - 0.00782_pr , 0.00242_pr , 0.0_pr , & 0.0025793_pr , - 0.0027586_pr , 0.0_pr , 0.0_pr , - 0.0001404_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0028389_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.000332_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0001133_pr , & - 0.01355_pr , 0.01338_pr , 0.0_pr , 0.0_pr , - 0.0142_pr , 0.0_pr , & 0.007088_pr , - 0.005945_pr , 0.0153_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.004381_pr , 4.5e-07_pr , & - 0.01225_pr , 0.0_pr , 0.0_pr , 0.00717_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.000137_pr , 0.000607_pr , 0.0_pr , 0.0_pr , & 0.00633_pr , 0.01424_pr , - 0.0007792_pr , 0.0_pr , - 0.0186009_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0217293_pr , & 0.001551_pr , 0.004822_pr , 0.01208_pr , 0.0153_pr , 0.0_pr , - 0.016158_pr , & 0.01641_pr , 0.0_pr , 0.000954_pr , 0.06212_pr , - 0.004885_pr , 0.0_pr , & 0.000815_pr , 0.0_pr , 0.0_pr , 0.09_pr , 0.007584_pr , - 0.0055_pr , & - 0.00878_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.002987_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.006309_pr , & - 0.0081865_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.004691_pr , - 0.005877_pr , & 0.0_pr , - 0.035_pr , - 0.00244_pr , 0.0_pr , 0.001188_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.0134709_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.000518_pr , - 0.0148923_pr , 0.0_pr , - 0.014972_pr , 0.0_pr , & 0.0_pr , 0.0029287_pr , 0.0_pr , - 0.004_pr , 0.002283_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.006714_pr , 0.002214_pr , 0.0023_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.001238_pr , 0.0_pr , & 0.01177_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0053598_pr , 0.0_pr , 0.025981_pr , & 0.0_pr , 0.0_pr , - 0.00208_pr , 0.0_pr , 0.0_pr , - 0.00166_pr , & 0.0_pr , 0.01159_pr , - 0.0098745_pr , 0.0_pr , 0.0_pr , - 0.0062036_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.001144_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.007514_pr , - 0.0022_pr , & 0.0_pr , 0.002329_pr , - 0.003252_pr , 0.0_pr , 0.001074_pr , 0.0_pr , & - 0.000914_pr , - 0.005908_pr , 0.0_pr , 0.002634_pr , 0.0_pr , - 0.0029_pr , & 0.0_pr , 0.0052371_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.003455_pr , & - 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.001586_pr , 0.0_pr , & - 0.000916_pr , 0.0_pr , - 0.0048_pr , 0.0_pr , 0.0_pr , 0.0019814_pr , & 0.0_pr , 0.0_pr , - 0.0067585_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.000807_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.02998_pr , - 0.02702_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.000469_pr , 0.004_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.004237_pr , 0.000239_pr , - 0.006022_pr , 0.0_pr , & 0.008838_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.002462_pr , 0.0_pr , 0.0_pr , 0.01558_pr , 0.02917_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0037129_pr , - 0.0025_pr , & 0.006309_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.011386_pr , 0.0_pr , 0.0_pr , - 0.004653_pr , & 0.0_pr , 0.0_pr , 0.0045351_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0047161_pr , & 0.0074865_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.0082641_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.000869_pr , - 0.006668_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.0031331_pr , 0.0_pr , 0.0_pr , - 0.003449_pr , 0.00769_pr , 0.0_pr , & - 0.002012_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.008271_pr , 0.0_pr , 0.01193_pr , 0.0_pr , 0.03543_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 4.1e-05_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0126_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.013472_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.006065_pr , 0.0_pr , & 0.010763_pr , 0.0_pr , 0.04757_pr , 0.0_pr , 0.04051_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.004_pr , & - 0.002636_pr , 0.0_pr , 0.001269_pr , 0.002745_pr , 0.0_pr , 0.0_pr , & 0.01675_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 4e-06_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.00839_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.010252_pr , 0.01088_pr , 0.008138_pr , & 0.03333_pr , 0.0_pr , 0.0_pr , 0.01032_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.01795_pr , & 0.004801_pr , 0.0_pr , 0.0_pr , 0.0097411_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.04303_pr , 0.0_pr , & 0.0_pr , 0.02557_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.008006_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.007036_pr , 0.008854_pr , - 0.006551_pr , 0.002205_pr , 0.0_pr , 0.001863_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.01058_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.03722_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.00165_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.01339_pr , 0.0_pr , 0.02112_pr , - 0.007126_pr , - 0.02004_pr , & 0.0_pr , 0.01655_pr , 0.0141_pr , 0.0_pr , - 0.01012_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0007_pr , & 0.007147_pr , 0.0_pr , - 0.003676_pr , 0.0_pr , 0.0_pr , 0.01466_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.009617_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.036_pr , 0.0_pr , 0.0082_pr , & 0.0039_pr , 0.1842_pr , 0.0141_pr , - 0.0034_pr , - 0.0101_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0193_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.0283_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0027_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.00015_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.002478_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.01065_pr , 0.0062553_pr , 0.0_pr , 0.0_pr , 0.009003_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.01158_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.004586_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.009198_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.015455_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.002418_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.000377_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0062484_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.01806_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.003701_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.008735_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0021443_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0069046_pr , 0.0067179_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.003388_pr , 0.0_pr , 0.002645_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0014_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.01635_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.009219_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.001271_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.04831_pr , 0.0_pr , - 0.02844_pr , 0.0_pr , - 0.009397_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.02253_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.01983_pr , 0.0_pr , 0.0_pr , - 0.01856_pr , 0.0_pr , 0.0_pr , & - 0.02978_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.03582_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.02156_pr , 0.0_pr , 0.00145_pr , & 0.02093_pr , 0.0_pr , 0.002688_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.012232_pr , 2.25e-05_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.04593_pr , & 0.008819_pr , 0.0_pr , - 0.007797_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.00353_pr , - 0.01862_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0055_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.01966_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.00091722_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.006077_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.0004_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.00105_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.011586_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.00098_pr , 0.0_pr , 0.001488_pr , & 0.0_pr , 0.01446_pr , 0.0_pr , - 0.00030011_pr , 0.0_pr , 0.00364_pr , & 0.0_pr , 0.001682_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.001118_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0018563_pr , 0.0_pr , 0.0137839_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.029654_pr , 0.0_pr , & - 0.0020983_pr , 0.004517_pr , 0.0_pr , 0.0_pr , - 0.002004_pr , - 0.00335_pr , & 0.0033318_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.013871_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.0351738_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.01428_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 9.006e-05_pr , & 0.0_pr , 0.0_pr , 0.00029817_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.002141_pr , 0.0_pr , 0.007737_pr , 0.0_pr , & 0.006054_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.006451_pr , - 0.00102_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.00975_pr , 0.0_pr , 1.8e-05_pr , & - 0.00045_pr , 0.005497_pr , 0.0048_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.008808_pr , 0.0_pr , - 0.002819_pr , - 0.004625_pr , 0.0_pr , 0.0_pr , & - 0.008555_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 7e-06_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.001855_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0636_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.00159_pr , 0.00172_pr , & 0.01656_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.00016_pr , 0.0_pr , 0.01219_pr , & - 0.00331_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.000969_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.004212_pr , - 0.007723_pr , - 0.002547_pr , - 0.003346_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0082_pr , 0.0_pr , & 0.006918_pr , 0.0_pr , 0.020758_pr , 0.017738_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 6.5e-05_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0078_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.007841_pr , 0.0_pr , 0.0149627_pr , 0.0451602_pr , 0.0_pr , 0.0160979_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0208006_pr , 0.0_pr , 2.63e-05_pr , & 0.0_pr , - 0.0035024_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0073933_pr , & 0.0067607_pr , 0.0_pr , 0.0085572_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0041569_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0119213_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0094424_pr , & 0.0_pr , 0.0160959_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0103753_pr , 0.0_pr , 0.0039496_pr , & 0.0041351_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0382461_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.0166992_pr , 0.0141503_pr , 0.0_pr , 0.0_pr , 0.0332832_pr , - 0.0048637_pr , & - 0.0022558_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0076136_pr , & - 0.0080098_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0005537_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.0356672_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0074475_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0092342_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.0272505_pr , 0.0202432_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0025991_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.007325_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.0016_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0030855_pr , 0.0_pr , 0.0032526_pr , 0.0_pr , 0.0068391_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0360498_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & - 0.0254482_pr , 0.0329518_pr , - 0.0358313_pr , 0.0239277_pr , 0.0090199_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , - 0.0518203_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr & ],[ nmg , nmg ]) end function DortmundParameters end module yaeos__models_ge_group_contribution_dortmund_parameters","tags":"","url":"sourcefile/dortmund_parameters.f90.html"},{"title":"rachford_rice.f90 – yaeos","text":"Source Code module yaeos__equilibria_rachford_rice use yaeos__constants , only : pr implicit none contains subroutine betato01 ( z , K ) !! # betato01 !! !! ## Description !! Modify K-factor values to assure that \\beta lies between (0,1) implicit none real ( pr ), intent ( in ) :: z (:) !! Molar fractions of the system real ( pr ) :: K (:) !! K factors \\frac{y_i}{x_i} real ( pr ) :: g0 , g1 ! function g valuated at beta=0 and 1, based on K factors g1 = 1.0 do while ( g0 < 0 . or . g1 > 0 ) if (& any ( isnan ([ g0 , g1 ])) & . or . all ( K == 0 ) & . or . maxval ( abs ( K - 1 )) < 0.01_pr ) exit g0 = sum ( z * K ) - 1._pr g1 = 1._pr - sum ( z / K ) if ( g0 < 0 ) then ! Increased volatiliy will bring the solution from ! subcooled liquid into VLE K = 1.1_pr * K else if ( g1 > 0 ) then ! Decreased volatiliy will bring the solution from ! superheated vapor into VLE K = 0.9_pr * K end if end do end subroutine betato01 subroutine betalimits ( z , K , bmin , bmax ) !! # betalimits !! !! ## Description !! Define beta limits to avoid overshooting when solving the Rachford-Rice !! equation. !! !! This is based on the assumtion that either y_i < 1 and x_i < 1. real ( pr ), intent ( in ) :: z (:) !! Molar fractions vector real ( pr ), intent ( in ) :: K (:) !! K-factors real ( pr ), intent ( out ) :: bmin !! Minimum beta value real ( pr ), intent ( out ) :: bmax !! Maximum beta value real ( pr ), dimension ( size ( z )) :: vmin , vmax vmin = 0.d0 ! max=1.001d0    ! modified  3/3/15 (not to generate false separations with beta 0.9999...) vmax = 1.00001_pr ! modified 28/6/15 (to prevent overshooting in the Newton for solving RR eq.) where ( K * z > 1 ) vmin = ( K * z - 1._pr ) / ( K - 1._pr ) elsewhere ( K < z ) vmax = ( 1 - z ) / ( 1 - K ) end where bmin = maxval ( vmin ) bmax = minval ( vmax ) end subroutine betalimits subroutine rachford_rice ( z , K , beta , rr , drrdb ) !! # rachford_rice !! !! ## Description !! Rachford-Rice equation for a two phase system. This equation is used to !! calculate the \\beta value that satisfies the mass balance !! between two phases. !! !!  !! rr(\\beta) = \\sum_i \\frac{z_i(K_i - 1)}{1 + \\beta(K_i - 1)}] !!  real ( pr ), intent ( in ) :: z (:) !! Mole fractions vector real ( pr ), intent ( in ) :: K (:) !! K-factors real ( pr ), intent ( in ) :: beta !! \\beta value real ( pr ), intent ( out ) :: rr !! Rachford-Rice function value real ( pr ), intent ( out ) :: drrdb !! Derivative of the Rachford-Rice function real ( pr ) :: denom ( size ( z )) denom = 1 + beta * ( K - 1._pr ) rr = sum ( z * ( K - 1._pr ) / denom ) drrdb = - sum ( z * ( K - 1._pr ) ** 2 / denom ** 2 ) end subroutine rachford_rice subroutine solve_rr ( z , K , beta , beta_min , beta_max ) !! # solve_rr !! !! ## Description !! Solve the Rachford-Rice Equation using the Newton method. real ( pr ), intent ( in ) :: z (:) !! Mole fractions vector real ( pr ), intent ( in ) :: K (:) !! K-factors real ( pr ), intent ( out ) :: beta_min !! Lower limit for \\beta real ( pr ), intent ( out ) :: beta_max !! Upper limit for \\beta real ( pr ), intent ( out ) :: beta !! \\beta value real ( pr ) :: g , dgdb real ( pr ) :: step g = 1.0 step = 1.0 call betalimits ( z , k , beta_min , beta_max ) do while ( abs ( g ) > 1.d-5 . and . abs ( step ) > 1.d-10 ) call rachford_rice ( z , k , beta , g , dgdb ) step = - g / dgdb beta = beta + step do while (( beta < beta_min . or . beta_max < beta ) . and . abs ( step ) > 1e-10 ) step = step / 2 beta = beta - step end do end do end subroutine solve_rr end module yaeos__equilibria_rachford_rice","tags":"","url":"sourcefile/rachford_rice.f90.html"},{"title":"linalg.f90 – yaeos","text":"Source Code module yaeos__math_linalg !! Wrapper module around LAPACK's `dgesv` use yaeos__constants , only : pr implicit none contains function solve_system ( a , b ) result ( x ) !! Solve a linear sytem AX = b use iso_fortran_env , only : error_unit real ( pr ), intent ( in ) :: b (:) real ( pr ), intent ( in ) :: a ( size ( b ), size ( b )) integer , parameter :: dp = selected_real_kind ( 15 ) real ( pr ) :: x ( size ( b )) real ( dp ) :: a_lapack ( size ( b ), size ( b )), b_lapack ( size ( b )) integer :: n , nrhs , lda , ipiv ( size ( b )), ldb , info interface subroutine dgesv ( n , nrhs , a , lda , ipiv , b , ldb , info ) import dp integer :: n integer :: nrhs real ( dp ) :: a ( n , n ) integer :: lda integer :: ipiv ( n ) real ( dp ) :: b ( n ) integer :: ldb integer :: info end subroutine dgesv end interface n = size ( a , dim = 1 ) nrhs = 1 lda = n ldb = n a_lapack = a b_lapack = b call dgesv ( n , nrhs , a_lapack , lda , ipiv , b_lapack , ldb , info ) ! if (info > 0) write(error_unit, *) \"WARN: dgesv error\" x = b_lapack end function solve_system subroutine cubic_roots ( parameters , real_roots , complex_roots , flag ) use yaeos__auxiliar , only : sort real ( pr ), parameter :: pi = atan ( 1.0_pr ) * 4.0_pr real ( pr ), intent ( in ) :: parameters ( 4 ) real ( pr ), intent ( out ) :: real_roots ( 3 ) complex ( pr ), intent ( out ) :: complex_roots ( 3 ) integer , intent ( out ) :: flag !! flag that identifies which case the solution is !! - `0`: 3 real rotos, one of them repeated (use real_roots(1) and real_roots(2)) !! - `1`: 1 real root, 2 complex roots. !!   Use real_roots(1) and complex_roots(1) and complex_roots(2) !! - `-1`: 3 real roots, all different real ( pr ) :: p , q , u , v , nan real ( pr ) :: disc , theta nan = 0 nan = nan / nan associate (& a => parameters ( 1 ), b => parameters ( 2 ), & c => parameters ( 3 ), d => parameters ( 4 )& ) p = c / a - b ** 2 / ( 3 * a ** 2 ) q = d / a - b * c / ( 3 * a ** 2 ) + 2 * b ** 3 / ( 27 * a ** 3 ) disc = q ** 2 + 4 * p ** 3 / 27 real_roots = nan complex_roots = nan if ( abs ( disc ) < 1e-15 ) then flag = 0 real_roots ( 1 ) = 3 * q / p real_roots ( 2 ) = - 3 * q / ( 2 * p ) real_roots ( 3 ) = real_roots ( 2 ) elseif ( disc < 0 ) then flag = - 1 theta = acos ( 0.5_pr * 3 * q / p * sqrt ( - 3 / p )) real_roots ( 1 ) = 2 * sqrt ( - p / 3 ) * cos ( theta / 3 ) real_roots ( 2 ) = 2 * sqrt ( - p / 3 ) * cos (( theta + 2 * pi ) / 3 ) real_roots ( 3 ) = 2 * sqrt ( - p / 3 ) * cos (( theta + 4 * pi ) / 3 ) call sort ( real_roots ) elseif ( disc > 0 ) then flag = 1 u = (( - q + sqrt ( disc )) / 2 ) v = (( - q - sqrt ( disc )) / 2 ) u = sign ( abs ( u ) ** ( 1.0_pr / 3.0_pr ), u ) v = sign ( abs ( v ) ** ( 1.0_pr / 3.0_pr ), v ) real_roots ( 1 ) = u + v endif real_roots = real_roots - b / ( 3 * a ) end associate end subroutine cubic_roots subroutine cubic_roots_rosendo ( parameters , real_roots , complex_roots , flag ) use yaeos__auxiliar , only : sort real ( pr ), parameter :: pi = atan ( 1.0_pr ) * 4.0_pr real ( pr ), intent ( in ) :: parameters ( 4 ) real ( pr ), intent ( out ) :: real_roots ( 3 ) complex ( pr ), intent ( out ) :: complex_roots ( 3 ) integer , intent ( out ) :: flag real ( 16 ) :: d1 , d2 , d3 , Q , R , A , B , theta , alp , bet , gam integer :: i d1 = parameters ( 2 ) / parameters ( 1 ) d2 = parameters ( 3 ) / parameters ( 1 ) d3 = parameters ( 4 ) / parameters ( 1 ) Q = ( d1 ** 2 - 3 * d2 ) / 9.0_1 6 R = ( 2 * d1 ** 3 - 9 * d1 * d2 + 27 * d3 ) / 5 4.0_1 6 if ( R ** 2 <= Q ** 3 ) then theta = acos ( R / sqrt ( Q ** 3 )) real_roots ( 1 ) = - 2 * sqrt ( Q ) * cos ( theta / 3.0_1 6 ) - d1 / 3.0_1 6 real_roots ( 2 ) = - 2 * sqrt ( Q ) * cos (( theta + 2 * pi ) / 3.0_1 6 ) - d1 / 3.0_1 6 real_roots ( 3 ) = - 2 * sqrt ( Q ) * cos (( theta - 2 * pi ) / 3.0_1 6 ) - d1 / 3.0_1 6 ! Correction?? ! do i=1,100 !    real_roots(1) = -d1 - (real_roots(2) + real_roots(3)) !    real_roots(2) = (d2 - real_roots(1) * real_roots(3)) / (real_roots(1) + real_roots(3)) !    real_roots(3) = -d3 / (real_roots(1) * real_roots(2)) ! end do call sort ( real_roots ) flag = - 1 else A = - sign (( abs ( R ) + sqrt ( R ** 2 - Q ** 3 )) ** ( 1.0_1 6 / 3.0_1 6 ), R ) if ( abs ( A ) < 1e-6 ) then A = 0.0_1 6 B = 0.0_1 6 else B = Q / A end if real_roots = ( A + B ) - d1 / 3.0_1 6 flag = 1 end if end subroutine subroutine eigen ( A , eigenvalues , eigenvectors ) !! # eigen !! !! # Description !! Calculate the eigenvalues and eigenvectors of a real symmetric matrix !! `A` using LAPACK's `dsyev`. The eigenvectors are stored in the columns !! of `eigenvectors`. The eigenvalues are stored in `eigenvalues`. ! use stdlib_linalg, only: eigh, linalg_state_type ! type(linalg_state_type) :: stat real ( pr ), intent ( in out ) :: A (:, :) real ( pr ), intent ( out ) :: eigenvalues (:) real ( pr ), optional , intent ( out ) :: eigenvectors (:, :) interface subroutine dsyev ( JOBZ , UPLO , N , A , LDA , W , WORK , LWORK , INFO ) character ( 1 ) :: JOBZ character ( 1 ) :: UPLO integer :: N double precision :: A ( lda , * ) integer :: lda double precision :: W ( * ) double precision :: WORK ( * ) integer :: LWORK integer :: INFO end subroutine end interface integer :: istat real ( pr ) :: work ( size ( A , 1 ) * 10 ) real ( pr ) :: Ain ( size ( A , 1 ), size ( A , 1 )) integer :: n n = size ( A , 1 ) Ain = A call dsyev ( jobz = 'V' , uplo = 'U' , n = n , A = Ain , lda = n , w = eigenvalues , & work = work , lwork = size ( work , 1 ), info = istat & ) eigenvectors = Ain ! call eigh(& !    A=A, lambda=eigenvalues, vectors=eigenvectors, err=stat  & ! ) ! if (.not. stat%ok()) then !    write(*, *) stat%print_msg() ! end if end subroutine end module yaeos__math_linalg","tags":"","url":"sourcefile/linalg.f90.html"},{"title":"temperature_dependence.f90 – yaeos","text":"Source Code module yaeos__models_ge_gc_td use yaeos__constants , only : pr use yaeos__models_ge_group_contribution_groups , only : Groups implicit none ! =========================================================================== ! PsiFunction that defines the temperature dependence of a UNIFAC-like model ! --------------------------------------------------------------------------- type , abstract :: PsiFunction !! # \\psi(T) function !! UNIFAC \\psi(T) functions abstract type !! !! # Description !! Abstract derived type for UNIFAC models temperature dependent functions !! contains procedure ( temperature_dependence ), deferred :: psi end type PsiFunction abstract interface subroutine temperature_dependence (& self , systems_groups , T , psi , dpsi_dt , dpsi_dt2 & ) !! # temperature_dependence interface !! Interface subroutine for UNIFAC models temperature dependent !! functions !! import pr , PsiFunction , Groups class ( PsiFunction ) :: self !! PsiFunction type variable class ( Groups ) :: systems_groups !! Groups type variable containig all the system's groups. See the !! `groups_stew` variable on the `UNIFAC` documentation. real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: psi (:, :) !! \\psi(T) real ( pr ), optional , intent ( out ) :: dpsi_dt (:, :) !! \\frac{d \\psi (T)}{dT} real ( pr ), optional , intent ( out ) :: dpsi_dt2 (:, :) !! \\frac{d&#94;2 \\psi (T)}{dT&#94;2} end subroutine temperature_dependence end interface ! =========================================================================== ! Implementations ! --------------------------------------------------------------------------- type , extends ( PsiFunction ) :: UNIFACPsi !! # Original UNIFAC \\psi function !!  !!    \\psi_{ij}(T) = \\exp(-\\frac{A_{ij}}{T}) !!  !! !!  !!    \\frac{d \\psi_{ij}(T)}{dT} = \\frac{A_{ij}}{T&#94;2} !!    \\exp(-\\frac{A_{ij}}{T}) !!  !! !!  !!    \\frac{d&#94;2 \\psi_{ij}(T)}{dT&#94;2} = !!    \\frac{Aij (Aij - 2T)}{T&#94;4} \\exp(-\\frac{A_{ij}}{T}) !!  !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.ddbst !! .com/published-parameters-unifac.html) !! 2. Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975). !! Group‐contribution estimation of activity coefficients in nonideal liquid !! mixtures. AIChE Journal, 21(6), 1086–1099. !! [https://doi.org/10.1002/aic.690210607](https://doi.org/10.1002/aic.690210607) !! 3. Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979). !! Vapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and !! Extension. Industrial & Engineering Chemistry Process Design and !! Development, 18(4), 714–722. !! [https://doi.org/10.1021/i260072a024](https://doi.org/10.1021/i260072a024) !! 4. Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid !! equilibriums by UNIFAC group contribution. Revision and extension. 2. !! Industrial & Engineering Chemistry Process Design and Development, 21(1), !! 118–127. !! [https://doi.org/10.1021/i200016a021](https://doi.org/10.1021/i200016a021) !! 5. Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983). !! Vapor-liquid equilibriums by UNIFAC group contribution. Revision and !! extension. 3. Industrial & Engineering Chemistry Process Design and !! Development, 22(4), 676–678. !! [https://doi.org/10.1021/i200023a023](https://doi.org/10.1021/i200023a023) !! 6. Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987). !! Vapor-liquid equilibria by UNIFAC group contribution. 4. Revision and !! extension. Industrial & Engineering Chemistry Research, 26(1), 159–161. !! [https://doi.org/10.1021/ie00061a030](https://doi.org/10.1021/ie00061a030) !! 7. Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., & !! Gmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group !! contribution. 5. Revision and extension. Industrial & Engineering !! Chemistry Research, 30 (10), 2352–2355. !! [https://doi.org/10.1021/ie00058a017](https://doi.org/10.1021/ie00058a017) !! 8. Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria !! by UNIFAC Group Contribution. 6. Revision and Extension. Industrial & !! Engineering Chemistry Research, 42(1), 183–188. !! [https://doi.org/10.1021/ie020506l](https://doi.org/10.1021/ie020506l) !! 9. [SINTEF - Thermopack](https://github.com/thermotools/thermopack) !! real ( pr ), allocatable :: Aij (:, :) contains procedure :: psi => UNIFAC_temperature_dependence end type UNIFACPsi type , extends ( PsiFunction ) :: QuadraticPsi real ( pr ), allocatable :: Aij (:, :) real ( pr ), allocatable :: Bij (:, :) real ( pr ), allocatable :: Cij (:, :) contains procedure :: psi => Quadratic_temperature_dependence end type QuadraticPsi contains subroutine UNIFAC_temperature_dependence (& self , systems_groups , T , psi , dpsi_dt , dpsi_dt2 & ) !! # UNIFAC temperature dependence !! Implementation of the \\psi(T)  function of the UNIFAC model. !! !!  !!    \\psi_{ij}(T) = \\exp(-\\frac{A_{ij}}{T}) !!  !! !!  !!    \\frac{d \\psi_{ij}(T)}{dT} = \\frac{A_{ij}}{T&#94;2} !!    \\exp(-\\frac{A_{ij}}{T}) !!  !! !!  !!    \\frac{d&#94;2 \\psi_{ij}(T)}{dT&#94;2} = !!    \\frac{Aij (Aij - 2T)}{T&#94;4} \\exp(-\\frac{A_{ij}}{T}) !!  !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.ddbst !! .com/published-parameters-unifac.html) !! 2. Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975). !! Group‐contribution estimation of activity coefficients in nonideal liquid !! mixtures. AIChE Journal, 21(6), 1086–1099. !! [https://doi.org/10.1002/aic.690210607](https://doi.org/10.1002/aic.690210607) !! 3. Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979). !! Vapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and !! Extension. Industrial & Engineering Chemistry Process Design and !! Development, 18(4), 714–722. !! [https://doi.org/10.1021/i260072a024](https://doi.org/10.1021/i260072a024) !! 4. Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid !! equilibriums by UNIFAC group contribution. Revision and extension. 2. !! Industrial & Engineering Chemistry Process Design and Development, 21(1), !! 118–127. !! [https://doi.org/10.1021/i200016a021](https://doi.org/10.1021/i200016a021) !! 5. Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983). !! Vapor-liquid equilibriums by UNIFAC group contribution. Revision and !! extension. 3. Industrial & Engineering Chemistry Process Design and !! Development, 22(4), 676–678. !! [https://doi.org/10.1021/i200023a023](https://doi.org/10.1021/i200023a023) !! 6. Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987). !! Vapor-liquid equilibria by UNIFAC group contribution. 4. Revision and !! extension. Industrial & Engineering Chemistry Research, 26(1), 159–161. !! [https://doi.org/10.1021/ie00061a030](https://doi.org/10.1021/ie00061a030) !! 7. Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., & !! Gmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group !! contribution. 5. Revision and extension. Industrial & Engineering !! Chemistry Research, 30 (10), 2352–2355. !! [https://doi.org/10.1021/ie00058a017](https://doi.org/10.1021/ie00058a017) !! 8. Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria !! by UNIFAC Group Contribution. 6. Revision and Extension. Industrial & !! Engineering Chemistry Research, 42(1), 183–188. !! [https://doi.org/10.1021/ie020506l](https://doi.org/10.1021/ie020506l) !! 9. [SINTEF - Thermopack](https://github.com/thermotools/thermopack) !! class ( UNIFACPsi ) :: self !! \\psi function class ( Groups ) :: systems_groups !! Groups in the system real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: psi (:, :) !! \\psi real ( pr ), optional , intent ( out ) :: dpsi_dt (:, :) !! \\frac{d \\psi}{dT} real ( pr ), optional , intent ( out ) :: dpsi_dt2 (:, :) !! \\frac{d&#94;2 \\psi}{dT&#94;2} integer :: ngroups real ( pr ) :: Eij ( size ( self % Aij , 1 ), size ( self % Aij , 2 )) ngroups = size ( systems_groups % groups_ids ) Eij = exp ( - self % Aij / T ) if ( present ( psi )) & psi = Eij if ( present ( dpsi_dt )) & dpsi_dt = self % Aij * Eij / T ** 2 if ( present ( dpsi_dt2 )) & dpsi_dt2 = self % Aij * ( self % Aij - 2_pr * T ) * Eij / T ** 4 end subroutine UNIFAC_temperature_dependence subroutine Quadratic_temperature_dependence (& self , systems_groups , T , psi , dpsi_dt , dpsi_dt2 & ) !! # Quadratic temperature dependence class ( QuadraticPsi ) :: self !! \\psi function class ( Groups ) :: systems_groups !! Groups in the system real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: psi (:, :) !! \\psi real ( pr ), optional , intent ( out ) :: dpsi_dt (:, :) !! \\frac{d \\psi}{dT} real ( pr ), optional , intent ( out ) :: dpsi_dt2 (:, :) !! \\frac{d&#94;2 \\psi}{dT&#94;2} integer :: i , j integer :: ngroups real ( pr ) :: u , dudt , dudt2 real ( pr ) :: a , b , c ngroups = size ( systems_groups % groups_ids ) do concurrent ( i = 1 : ngroups , j = 1 : ngroups ) a = self % Aij ( i , j ) b = self % Bij ( i , j ) c = self % Cij ( i , j ) u = - ( A + B * T + C * T ** 2 ) / T dudt = a / T ** 2 - c dudt2 = - 2._pr * a / T ** 3 if ( present ( psi )) then psi ( i , j ) = exp ( u ) end if if ( present ( dpsi_dt )) then dpsi_dt ( i , j ) = dudt * exp ( u ) end if if ( present ( dpsi_dt2 )) then dpsi_dt2 ( i , j ) = ( dudt2 + dudt ** 2 ) * exp ( u ) end if end do end subroutine Quadratic_temperature_dependence end module yaeos__models_ge_gc_td","tags":"","url":"sourcefile/temperature_dependence.f90.html"},{"title":"base.f90 – yaeos","text":"Source Code module yaeos__models_ar_genericcubic_base use yaeos__constants , only : pr , R implicit none contains subroutine GenericCubic_Ar (& n , V , T , & B , dBi , dBij , & D , dDi , dDij , dDidT , dDdT , dDdT2 , & D1 , dD1i , dD1ij , & Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) !! Residual Helmholtz Energy for a generic Cubic Equation of State. !! !! Calculates the residual Helmholtz Energy for a generic Cubic EoS as !! defined by Michelsen and Møllerup: !! !!  !!   P = \\frac{RT}{V-B} !!       - \\frac{D(T)}{(V+B \\delta_1)(V+B\\delta_2)} !!  !! !! This routine assumes that the \\delta_1 is not a constant parameter !! (as it uses to be in classical Cubic EoS) to be compatible with the !! three parameter EoS RKPR where delta_1 is not a constant and !! has its own mixing rule. use yaeos__constants , only : R real ( pr ), intent ( in ) :: n (:) !! Number of moles real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( in ) :: B !! Repulsive parameter [L] real ( pr ), intent ( in ) :: dBi ( size ( n )) !! dB/dn_i real ( pr ), intent ( in ) :: dBij ( size ( n ), size ( n )) !! d&#94;2B/dn_{ij} real ( pr ), intent ( in ) :: D !! Attractive parameter real ( pr ), intent ( in ) :: dDi ( size ( n )) !! dD/dn_i real ( pr ), intent ( in ) :: dDij ( size ( n ), size ( n )) !! d&#94;2D/dn_{ij} real ( pr ), intent ( in ) :: dDidT ( size ( n )) !! d&#94;2D/dTdn_i real ( pr ), intent ( in ) :: dDdT !! \\frac{dD}{dT} real ( pr ), intent ( in ) :: dDdT2 !! \\frac{d&#94;2D}{dT&#94;2} real ( pr ), intent ( in ) :: D1 !! \\delta_1 parameter real ( pr ), intent ( in ) :: dD1i ( size ( n )) !! d\\delta_1/dn_i real ( pr ), intent ( in ) :: dD1ij ( size ( n ), size ( n )) !! d&#94;2\\delta_1/dn_{ij} real ( pr ), optional , intent ( out ) :: ar !! Residual Helmholtz real ( pr ), optional , intent ( out ) :: arv !! \\frac{dAr}{dV} real ( pr ), optional , intent ( out ) :: ArT !! \\frac{dAr}{dT} real ( pr ), optional , intent ( out ) :: artv !! \\frac{d&#94;2Ar}{dTdV} real ( pr ), optional , intent ( out ) :: arv2 !! \\frac{d&#94;2Ar}{dV&#94;2} real ( pr ), optional , intent ( out ) :: ArT2 !! \\frac{d&#94;2Ar}{dT&#94;2} real ( pr ), optional , intent ( out ) :: Arn ( size ( n )) !! \\frac{dAr}{dn_i} real ( pr ), optional , intent ( out ) :: ArVn ( size ( n )) !! \\frac{d&#94;2Ar}{dVdn_i} real ( pr ), optional , intent ( out ) :: ArTn ( size ( n )) !! \\frac{d&#94;2Ar}{dTdn_i} real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) !! \\frac{d&#94;2Ar}{dn_{ij}} real ( pr ) :: totn real ( pr ) :: auxD2 , fD1 , fBD1 , fVD1 , fD1D1 real ( pr ) d2 real ( pr ) :: f , g , fv , fB , gv , fv2 , gv2 , AUX , FFB , FFBV , FFBB integer :: i , j , nc nc = size ( n ) TOTN = sum ( n ) ! Delta 2 parameter is calculated from Delta 1 D2 = ( 1._pr - D1 ) / ( 1._pr + D1 ) ! ======================================================================== ! Main functions defined by Møllerup ! The f's and g's used here are for Ar, not F (reduced Ar) ! This requires to multiply by R all g, f ! ------------------------------------------------------------------------ f = log (( V + D1 * B ) / ( V + D2 * B )) / B / ( D1 - D2 ) g = R * log ( 1 - B / V ) fv = - 1 / (( V + D1 * B ) * ( V + D2 * B )) fB = - ( f + V * fv ) / B gv = R * B / ( V * ( V - B )) fv2 = ( - 1 / ( V + D1 * B ) ** 2 + 1 / ( V + D2 * B ) ** 2 ) / B / ( D1 - D2 ) gv2 = R * ( 1 / V ** 2 - 1 / ( V - B ) ** 2 ) ! DERIVATIVES OF f WITH RESPECT TO DELTA1 auxD2 = ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1 = ( 1 / ( V + D1 * B ) + 2 / ( V + D2 * B ) / ( 1 + D1 ) ** 2 ) - f * auxD2 fD1 = fD1 / ( D1 - D2 ) fBD1 = - ( fB * auxD2 + D1 / ( V + D1 * B ) ** 2 + 2 * D2 / ( V + D2 * B ) ** 2 / ( 1 + D1 ) ** 2 ) fBD1 = fBD1 / ( D1 - D2 ) fVD1 = - ( fV * auxD2 + 1 / ( V + D1 * B ) ** 2 + 2 / ( V + D2 * B ) ** 2 / ( 1 + D1 ) ** 2 ) / ( D1 - D2 ) fD1D1 = 4 * ( f - 1 / ( V + D2 * B )) / ( 1 + D1 ) ** 3 + B * ( - 1 / ( V + D1 * B ) ** 2 & + 4 / ( V + D2 * B ) ** 2 / ( 1 + D1 ) ** 4 ) - 2 * fD1 * ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1D1 = fD1D1 / ( D1 - D2 ) AUX = R * T / ( V - B ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - B ) + D * ( 2 * fv + V * fv2 ) / B FFBB = TOTN * AUX / ( V - B ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / B ** 2 ! ======================================================================== ! Reduced Helmholtz Energy and derivatives ! ------------------------------------------------------------------------ if ( present ( Ar )) Ar = - TOTN * g * T - D * f if ( present ( ArV )) ArV = - TOTN * gv * T - D * fv if ( present ( ArV2 )) ArV2 = - TOTN * gv2 * T - D * fv2 if ( present ( Arn )) Arn (:) = - g * T + FFB * dBi (:) - f * dDi (:) - D * fD1 * dD1i (:) if ( present ( ArVn )) ArVn (:) = - gv * T + FFBV * dBi (:) - fv * dDi (:) - D * fVD1 * dD1i (:) if ( present ( ArTn )) ArTn (:) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi (:) - f * dDidT (:) - dDdT * fD1 * dD1i (:) if ( present ( Arn2 )) then do i = 1 , nc do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( i , j ) = Arn2 ( i , j ) - D * fBD1 * ( dBi ( i ) * dD1i ( j ) + dBi ( j ) * dD1i ( i )) & - fD1 * ( dDi ( i ) * dD1i ( j ) + dDi ( j ) * dD1i ( i )) & - D * fD1 * dD1ij ( i , j ) - D * fD1D1 * dD1i ( i ) * dD1i ( j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end do end if ! TEMPERATURE DERIVATIVES if ( present ( ArT )) ArT = - TOTN * g - dDdT * f if ( present ( ArTV )) ArTV = - TOTN * gv - dDdT * fV if ( present ( ArT2 )) ArT2 = - dDdT2 * f end subroutine GenericCubic_Ar end module","tags":"","url":"sourcefile/base.f90.html"},{"title":"phase_envelopes_tx_mp.f90 – yaeos","text":"Source Code module yaeos__equilibria_boundaries_phase_envelopes_mp_tx !! Multiphase Px envelope calculation module. !! !! This module contains the functions to calculate the PT envelope of a !! mixture with multiple phases. use yaeos__constants , only : pr , R use yaeos__equilibria_equilibrium_state , only : EquilibriumState use yaeos__models_ar , only : ArModel use yaeos__math , only : solve_system use yaeos__equilibria_boundaries_auxiliar , only : get_z implicit none private public :: TXEnvelMP public :: tx_F_NP public :: tx_envelope type :: TXEnvelMP !! Multiphase PT envelope. type ( MPPoint ), allocatable :: points (:) !! Array of converged points. real ( pr ), allocatable :: alpha (:) real ( pr ), allocatable :: z0 (:) real ( pr ), allocatable :: zi (:) contains procedure :: write => write_envelope_Tx_MP procedure , nopass :: solve_point procedure , nopass :: get_values_from_X end type TXEnvelMP type :: MPPoint !! Multiphase equilibria point. integer :: np !! Number of phases integer :: nc !! Number of components real ( pr ) :: beta_w !! Fraction of the reference (incipient) phase. real ( pr ), allocatable :: betas (:) !! Fractions of the main phases. real ( pr ) :: P !! Pressure [bar] real ( pr ) :: T !! Temperature [K] real ( pr ), allocatable :: x_l (:, :) !! Mole fractions of the main phases. real ( pr ), allocatable :: w (:) !! Mole fractions of the incipient phase. integer :: iters !! Number of iterations needed to converge the point. integer :: ns !! Number of the specified variable. end type MPPoint contains type ( TXEnvelMP ) function tx_envelope (& model , z0 , zi , np , P , x_l0 , w0 , betas0 , T0 , alpha0 , ns0 , dS0 , beta_w , points & ) use yaeos__auxiliar , only : optval class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z0 (:) real ( pr ), intent ( in ) :: zi (:) integer , intent ( in ) :: np real ( pr ), intent ( in ) :: P real ( pr ), intent ( in ) :: x_l0 ( np , size ( z0 )) real ( pr ), intent ( in ) :: w0 ( size ( z0 )) real ( pr ), intent ( in ) :: betas0 ( np ) real ( pr ), intent ( in ) :: T0 real ( pr ), intent ( in ) :: alpha0 integer , intent ( in ) :: ns0 real ( pr ), intent ( in ) :: dS0 real ( pr ), intent ( in ) :: beta_w !! Fraction of the reference (incipient) phase. integer , optional , intent ( in ) :: points type ( MPPoint ), allocatable :: env_points (:) real ( pr ), allocatable :: alphas (:) type ( MPPoint ) :: point real ( pr ) :: F ( size ( z0 ) * np + np + 2 ) real ( pr ) :: dF ( size ( z0 ) * np + np + 2 , size ( z0 ) * np + np + 2 ) real ( pr ) :: dXdS ( size ( z0 ) * np + np + 2 ) real ( pr ) :: X ( size ( z0 ) * np + np + 2 ), dX ( size ( z0 ) * np + np + 2 ) integer :: nc integer :: its integer :: max_iterations = 100 integer :: number_of_points real ( pr ) :: x_l ( np , size ( z0 )), w ( size ( z0 )), betas ( np ), T , alpha integer :: i !! Point calculation index integer :: lb !! Lower bound, index of the first component of a phase integer :: ub !! Upper bound, index of the last component of a phase integer :: inner !! Number of times a failed point is retried to converge integer :: ns !! Number of the specified variable real ( pr ) :: dS !! Step size of the specification for the next point real ( pr ) :: S !! Specified value real ( pr ) :: X0 ( size ( X )) !! Initial guess for the point nc = size ( z0 ) number_of_points = optval ( points , 1000 ) do i = 1 , np lb = ( i - 1 ) * nc + 1 ub = i * nc X ( lb : ub ) = log ( x_l0 ( i , :) / w0 ) end do X ( np * nc + 1 : np * nc + np ) = betas0 X ( np * nc + np + 1 ) = log ( T0 ) X ( np * nc + np + 2 ) = alpha0 ns = ns0 S = X ( ns ) dS = dS0 allocate ( env_points ( 0 ), alphas ( 0 )) call solve_point (& model , z0 , zi , np , P , beta_w , X , ns , S , dXdS , & F , dF , its , 1000 & ) do i = 1 , number_of_points X0 = X call solve_point (& model , z0 , zi , np , P , beta_w , X , ns , S , dXdS , & F , dF , its , max_iterations & ) ! The point might not converge, in this case we try again with an ! initial guess closer to the previous (converged) point. inner = 0 do while ( i > 1 . and . its >= max_iterations . and . inner < 10 ) inner = inner + 1 X = X0 - ( 1 - real ( inner , pr ) / 1 0._pr ) * dX S = X ( ns ) call solve_point (& model , z0 , zi , np , T , beta_w , X , ns , S , dXdS , & F , dF , its , 5 & ) end do ! If the point did not converge, stop the calculation if ( any ( isnan ( F )) . or . its > max_iterations ) exit ! Save the information of the converged point call get_values_from_X ( X , np , z0 , zi , beta_w , x_l , w , betas , T , alpha ) point = MPPoint (& np = np , nc = nc , betas = betas , P = P , T = T , x_l = x_l , w = w , beta_w = beta_w , & iters = its , ns = ns & ) env_points = [ env_points , point ] alphas = [ alphas , alpha ] ! Update the specification for the next point. call update_specification ( its , nc , np , X , dF , dXdS , ns , dS ) ! Check if the system is close to a critical point, and try to jump ! over it. call detect_critical ( nc , np , X , dXdS , ns , dS , S ) ! Next point estimation. dX = dXdS * dS X = X + dX S = X ( ns ) end do ! This moves the locally saved points to the output variable. call move_alloc ( env_points , tx_envelope % points ) call move_alloc ( alphas , tx_envelope % alpha ) end function tx_envelope subroutine tx_F_NP ( model , z0 , zi , np , P , beta_w , X , ns , S , F , dF ) !! Function to solve at each point of a multi-phase envelope. use iso_fortran_env , only : error_unit class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z0 (:) real ( pr ), intent ( in ) :: zi (:) integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in ) :: P !! Pressure [bar] real ( pr ), intent ( in ) :: beta_w !! Fraction of the reference (incipient) phase. real ( pr ), intent ( in ) :: X (:) !! Vector of variables. integer , intent ( in ) :: ns !! Number of specification. real ( pr ), intent ( in ) :: S !! Specification value. real ( pr ), intent ( out ) :: F ( size ( X )) !! Vector of functions valuated. real ( pr ), intent ( out ) :: df ( size ( X ), size ( X )) !! Jacobian matrix. ! X variables real ( pr ) :: K ( np , size ( z0 )) real ( pr ) :: T real ( pr ) :: betas ( np ) real ( pr ) :: z ( size ( z0 )), alpha , dzda ( size ( z0 )) ! Main phases variables real ( pr ) :: moles ( size ( z0 )) real ( pr ) :: Vl ( np ) real ( pr ), dimension ( np , size ( z0 )) :: x_l , lnphi_l , dlnphi_dt_l real ( pr ), dimension ( np , size ( z0 ), size ( z0 )) :: dlnphi_dn_l real ( pr ) :: lnphi ( size ( z0 )), dlnphi_dt ( size ( z0 )) real ( pr ), dimension ( size ( z0 ), size ( z0 )) :: dlnphi_dn ! Incipient phase variables real ( pr ) :: Vw real ( pr ), dimension ( size ( z0 )) :: w , lnphi_w , dlnphi_dt_w real ( pr ), dimension ( size ( z0 ), size ( z0 )) :: dlnphi_dn_w real ( pr ) :: dwda ( size ( z0 )) ! Derivatives of w wrt beta and K real ( pr ) :: dwdb ( np , size ( z0 )) real ( pr ) :: dwdlnK ( np , size ( z0 )) real ( pr ) :: denom ( size ( z0 )) real ( pr ) :: denomdlnK ( np , size ( z0 ), size ( z0 )) real ( pr ) :: dx_l_dlnK ( np , np , size ( z0 )) integer :: i , j , l , phase , nc integer :: lb , ub integer :: idx_1 , idx_2 nc = size ( z0 ) ! ======================================================================== ! Extract variables from the vector X ! ------------------------------------------------------------------------ T = exp ( X ( np * nc + np + 1 )) alpha = X ( np * nc + np + 2 ) do l = 1 , np lb = ( l - 1 ) * nc + 1 ub = l * nc K ( l , :) = exp ( X ( lb : ub )) end do betas = X ( np * nc + 1 : np * nc + np ) call get_z ( alpha , z0 , zi , z , dzda ) denom = 0 denom = matmul ( betas , K ) + beta_w denomdlnK = 0 do i = 1 , nc denomdlnK (:, i , i ) = betas (:) * K (:, i ) end do w = z / denom ! ======================================================================== ! Calculation of fugacities coeficients and their derivatives ! ------------------------------------------------------------------------ call model % lnphi_pt (& w , P , T , V = Vw , root_type = \"stable\" , lnphi = lnphi_w , & dlnphidt = dlnphi_dt_w , dlnphidn = dlnphi_dn_w & ) do l = 1 , np x_l ( l , :) = K ( l , :) * w call model % lnphi_pt (& x_l ( l , :), P , T , V = Vl ( l ), root_type = \"stable\" , lnphi = lnphi , & dlnphidt = dlnphi_dt , dlnphidn = dlnphi_dn & ) lnphi_l ( l , :) = lnphi dlnphi_dn_l ( l , :, :) = dlnphi_dn dlnphi_dt_l ( l , :) = dlnphi_dt end do ! ======================================================================== ! Calculation of the system of equations ! ------------------------------------------------------------------------ do l = 1 , np ! Select the limits of the function lb = ( l - 1 ) * nc + 1 ub = l * nc F ( lb : ub ) = X ( lb : ub ) + lnphi_l ( l , :) - lnphi_w F ( nc * np + l ) = sum ( x_l ( l , :) - w ) end do F ( nc * np + np + 1 ) = sum ( betas ) + beta_w - 1 F ( nc * np + np + 2 ) = X ( ns ) - S ! ======================================================================== ! Derivatives and Jacobian Matrix of the whole system ! ------------------------------------------------------------------------ df = 0 dwdlnK = 0 dwda = dzda / denom do l = 1 , np ! Save the derivatives of w wrt beta and K of the incipient phase dwdb ( l , :) = - z * K ( l , :) / denom ** 2 dwdlnK ( l , :) = - K ( l , :) * betas ( l ) * z / denom ** 2 end do do l = 1 , np do phase = 1 , np dx_l_dlnK ( phase , l , :) = dwdlnK ( l , :) * K ( phase , :) if ( phase == l ) then dx_l_dlnK ( phase , l , :) = dx_l_dlnK ( phase , l , :) + w * K ( l , :) end if end do end do do l = 1 , np ! Derivatives of the isofugacity equations ! wrt lnK do phase = 1 , np do i = 1 , nc do j = 1 , nc idx_1 = i + ( phase - 1 ) * nc idx_2 = j + ( l - 1 ) * nc df ( idx_1 , idx_2 ) = & dlnphi_dn_l ( phase , i , j ) * dx_l_dlnK ( phase , l , j ) & - dlnphi_dn_w ( i , j ) * dwdlnK ( l , j ) if ( i == j . and . phase == l ) then df ( idx_1 , idx_2 ) = df ( idx_1 , idx_2 ) + 1 end if end do end do end do ! wrt betas do j = 1 , np lb = ( j - 1 ) * nc + 1 ub = j * nc do i = 1 , nc df ( lb + i - 1 , np * nc + l ) = & sum ( K ( j , :) * dlnphi_dn_l ( j , i , :) * dwdb ( l , :) & - dlnphi_dn_w ( i , :) * dwdb ( l , :)) end do end do ! disofug wrt P, alpha do i = 1 , nc lb = ( l - 1 ) * nc + i df ( lb , nc * np + np + 1 ) = T * ( dlnphi_dt_l ( l , i ) - dlnphi_dt_w ( i )) df ( lb , nc * np + np + 2 ) = sum (& dwda * K ( l , :) * dlnphi_dn_l ( l , i , :) - dwda * dlnphi_dn_w ( i , :) & ) end do ! Derivatives of the sum of mole fractions ! wrt lnK do phase = 1 , np do j = 1 , nc lb = nc * np + phase ub = j + ( l - 1 ) * nc df ( lb , ub ) = df ( lb , ub ) + ( dx_l_dlnK ( phase , l , j ) - dwdlnK ( l , j )) end do end do ! wrt beta, alpha do j = 1 , np lb = nc * np + j df ( lb , np * nc + l ) = sum ( K ( j , :) * dwdb ( l , :) - dwdb ( l , :)) end do df ( nc * np + l , nc * np + np + 2 ) = sum ( K ( l , :) * dwda - dwda ) ! Derivatives of sum(beta) + beta_w == 1 df ( nc * np + np + 1 , np * nc + l ) = 1 end do df ( nc * np + np + 2 , ns ) = 1 end subroutine tx_F_NP subroutine solve_point ( model , z0 , zi , np , P , beta_w , X , ns , S , dXdS , F , dF , iters , max_iterations ) use iso_fortran_env , only : error_unit use yaeos__math , only : solve_system class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z0 (:) real ( pr ), intent ( in ) :: zi (:) integer , intent ( in ) :: np !! Number of main phases real ( pr ), intent ( in ) :: P real ( pr ), intent ( in ) :: beta_w !! Fraction of the reference (incipient) phase real ( pr ), intent ( in out ) :: X (:) !! Vector of variables integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( in ) :: dXdS ( size ( X )) real ( pr ), intent ( out ) :: F ( size ( X )) !! Vector of functions valuated real ( pr ), intent ( out ) :: df ( size ( X ), size ( X )) !! Jacobian matrix integer , intent ( in ) :: max_iterations integer , intent ( out ) :: iters integer :: ia integer :: iT integer :: nc real ( pr ) :: X0 ( size ( X )) real ( pr ) :: dX ( size ( X )) nc = size ( z0 ) iT = np * nc + np + 1 ia = np * nc + np + 2 X0 = X do iters = 1 , max_iterations call tx_F_NP ( model = model , z0 = z0 , zi = zi , np = np , P = P , beta_w = beta_w , X = X , ns = ns , S = S , F = F , dF = dF ) if ( any ( isnan ( F ))) then X = X - 0.9 * dX cycle end if dX = solve_system ( dF , - F ) if ( maxval ( abs ( F )) < 1e-9_pr ) exit X = X + dX end do end subroutine solve_point subroutine update_specification ( its , nc , np , X , dF , dXdS , ns , dS ) !! # update_specification !! Change the specified variable for the next step. !! !! # Description !! Using the information of a converged point and the Jacobian matrix of !! the function. It is possible to determine the sensitivity of the !! variables with respect to the specification. This information is used !! to update the specification for the next point. Choosing the variable !! with the highest sensitivity. !! This can be done by solving the system of equations: !! !!  !! J \\frac{dX}{dS} + \\frac{dF}{dS} = 0 !!  !! !! for the  \\frac{dX}{dS}  vector. The variable with the highest value !! of  \\frac{dX}{dS}  is chosen as the new specification. !! !! # References !! integer , intent ( in ) :: its !! Iterations to solve the current point. integer , intent ( in ) :: nc !! Number of components in the mixture. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables. real ( pr ), intent ( in out ) :: dF (:, :) !! Jacobian matrix. real ( pr ), intent ( in out ) :: dXdS (:) !! Sensitivity of the variables wrt the specification. integer , intent ( in out ) :: ns !! Number of the specified variable. real ( pr ), intent ( in out ) :: dS !! Step size of the specification for the next point. real ( pr ) :: dFdS ( size ( X )) !! Sensitivity of the functions wrt the specification. integer :: i integer :: lb !! Lower bound of each phase integer :: ub !! Upper bound of each phase dFdS = 0 dFdS ( size ( X )) = - 1 dXdS = solve_system ( dF , - dFdS ) ns = maxloc ( abs ( dXdS ), dim = 1 ) ! ======================================================================== ! For each phase, check if the mole fractions are too low. ! this can be related to criticality and it is useful to force the ! specification of compositions. ! ------------------------------------------------------------------------ do i = 1 , np lb = ( i - 1 ) * nc + 1 ub = i * nc if ( maxval ( abs ( X ( lb : ub ))) < 0.3 ) then ns = lb + maxloc ( abs ( X ( lb : ub )), dim = 1 ) - 1 exit end if end do dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) ! We adapt the step size to the number of iterations, the desired number ! of iterations for each point is around 3. dS = dS * 3._pr / its end subroutine update_specification subroutine detect_critical ( nc , np , X , dXdS , ns , dS , S ) !! # detect_critical !! Detect if the system is close to a critical point. !! !! # Description !! When the system is close to a critical point, the \\ln K_i&#94;l values !! are close to zero, since the composition of the incipient phase and the !! l phase are similar (equal in the critical point). This can be used !! to detect if the system is close to a critical point and force a jump !! above it. !! !! # References !! integer , intent ( in ) :: nc !! Number of components in the mixture. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables. real ( pr ), intent ( in out ) :: dXdS (:) !! Sensitivity of the variables wrt the specification. integer , intent ( in out ) :: ns !! Number of the specified variable. real ( pr ), intent ( in out ) :: dS !! Step size of the specification for the next point. real ( pr ), intent ( in out ) :: S !! Specification value. integer :: i , lb , ub do i = 1 , np lb = ( i - 1 ) * nc + 1 ub = i * nc do while ( maxval ( abs ( X ( lb : ub ))) < 0.3 ) X = X + dXdS * dS end do end do end subroutine detect_critical subroutine get_values_from_X ( X , np , z0 , zi , beta_w , x_l , w , betas , T , alpha ) !! # get_values_from_X !! Extract the values of the variables from the vector X. !! real ( pr ), intent ( in ) :: X (:) !! Vector of variables. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in ) :: z0 (:) !! Initial mixture composition. real ( pr ), intent ( in ) :: zi (:) !! Second mixture composition. real ( pr ), intent ( in ) :: beta_w !! Reference phase beta. real ( pr ), intent ( out ) :: x_l ( np , size ( z0 )) !! Mole fractions of the main phases. real ( pr ), intent ( out ) :: w ( size ( z0 )) !! Mole fractions of the incipient phase. real ( pr ), intent ( out ) :: betas ( np ) !! Fractions of the main phases. real ( pr ), intent ( out ) :: T !! Pressure [bar]. real ( pr ), intent ( out ) :: alpha !! alpha. real ( pr ) :: z ( size ( z0 )) real ( pr ) :: K ( np , size ( z0 )) integer :: nc !! Number of components. integer :: i !! Loop index. integer :: l !! Phase index. integer :: lb !! Lower bound of each phase. integer :: ub !! Upper bound of each phase. nc = size ( z0 ) ! ======================================================================== ! Extract variables from the vector X ! ------------------------------------------------------------------------ call get_z ( alpha , z0 , zi , z ) T = exp ( X ( np * nc + np + 1 )) alpha = X ( np * nc + np + 2 ) do l = 1 , np lb = ( l - 1 ) * nc + 1 ub = l * nc K ( l , :) = exp ( X ( lb : ub )) end do betas = X ( np * nc + 1 : np * nc + np ) w = z / matmul ( betas , K ) + beta_w do l = 1 , np x_l ( l , :) = K ( l , :) * w end do end subroutine get_values_from_X subroutine write_envelope_TX_MP ( env , unit ) class ( TXEnvelMP ), intent ( in ) :: env integer , intent ( in ) :: unit integer :: i , j integer :: np , nc real ( pr ) :: P , T , alpha real ( pr ), allocatable :: betas (:) real ( pr ), allocatable :: w (:) real ( pr ), allocatable :: x_l (:, :) np = size ( env % points ) nc = size ( env % points ( 1 )% w ) do i = 1 , np alpha = env % alpha ( i ) P = env % points ( i )% P T = env % points ( i )% T betas = env % points ( i )% betas w = env % points ( i )% w x_l = env % points ( i )% x_l write ( unit , \"(*(E15.5,2x))\" ) alpha , P , T , betas , w , ( x_l ( j , :), j = 1 , size ( x_l , dim = 1 )) end do end subroutine write_envelope_TX_MP end module yaeos__equilibria_boundaries_phase_envelopes_mp_tx","tags":"","url":"sourcefile/phase_envelopes_tx_mp.f90.html"},{"title":"consistency.f90 – yaeos","text":"Source Code module yaeos__consistency !! # yaeos__consistency !! Subroutine to evaluate the consistency of thermodynamic models. !! !! # Description !! Tools to evaluate the consistency of A&#94;r and G&#94;E models. This !! module also provides subroutines for numerical evaluations of A&#94;r and !! G&#94;E derivatives using central finite differences. The purpose of the !! module is to assist in the development of new models and ensure the !! accuracy of the derivatives implementation. !! !! # Examples !! For detailed explanations and examples of each consistency test, please !! refer to the API documentation of each submodule. !! !! - A&#94;r consistency tests: [[yaeos__consistency_armodel]] !! - G&#94;E consistency tests: [[yaeos__consistency_gemodel]] !! !! # References !! 1. Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models: !! Fundamentals & computational aspects (2. ed). Tie-Line Publications. !! ! Consistency test for ArModels use yaeos__consistency_armodel use yaeos__consistency_gemodel end module yaeos__consistency","tags":"","url":"sourcefile/consistency.f90.html"},{"title":"continuation.f90 – yaeos","text":"Source Code module yaeos__math_continuation !! Implementation of Algower's numerical continuation method. use yaeos__constants , only : pr use yaeos__math_linalg , only : solve_system implicit none type :: ContinuationVariable real ( pr ), allocatable :: X (:) integer :: ns real ( pr ) :: S real ( pr ) :: dS end type ContinuationVariable abstract interface subroutine continuation_function ( X , ns , S , F , dF , dFdS ) import pr real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( out ) :: F (:) real ( pr ), intent ( out ) :: dF (:, :) real ( pr ), intent ( out ) :: dFdS (:) end subroutine continuation_function end interface abstract interface subroutine process ( X , ns , S , dS , dXdS , iterations ) !! Subroutine to make variation in the method after a point converged import pr real ( pr ), intent ( in out ) :: X (:) !! Vector of variables X integer , intent ( in out ) :: ns !! Position of specified variable real ( pr ), intent ( in out ) :: S !! Specification variable value real ( pr ), intent ( in out ) :: dS !! Step of specification in the method real ( pr ), intent ( in out ) :: dXdS (:) !! \\frac{dX}{dS} integer , intent ( in ) :: iterations !! Iterations needed to converge point end subroutine process logical function continuation_stopper ( X , ns , S , dS , dXdS , iterations ) !! Function that returns true if the method should stop import pr real ( pr ), intent ( in out ) :: X (:) !! Vector of variables X integer , intent ( in out ) :: ns !! Position of specified variable real ( pr ), intent ( in out ) :: S !! Specification variable value real ( pr ), intent ( in out ) :: dS !! Step of specification in the method real ( pr ), intent ( in out ) :: dXdS (:) !! \\frac{dX}{dS} integer , intent ( in ) :: iterations !! Iterations needed to converge point end function continuation_stopper end interface abstract interface subroutine continuation_solver (& fun , iters , X , ns , S , dS , dXdS , point , max_iters , F , dF , dFdS , tol & ) !! Solver to solve a point during numerical contination. import pr , continuation_function procedure ( continuation_function ) :: fun !! Function to solve integer , intent ( out ) :: iters !! Number of iterations needed real ( pr ), intent ( in out ) :: X (:) !! Variables vector integer , intent ( in ) :: ns !! Specification number real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( in ) :: dS !! Delta spec real ( pr ), intent ( in ) :: dXdS (:) !! integer , intent ( in ) :: point !! Point number integer , intent ( in ) :: max_iters !! Maximum iterations real ( pr ), intent ( out ) :: F (:) !! Function values at solved point real ( pr ), intent ( out ) :: df (:, :) !! Jacobian values real ( pr ), intent ( out ) :: dfds (:) !! dFdS real ( pr ), intent ( in ) :: tol !! Solver tolerance end subroutine continuation_solver end interface contains function continuation (& f , X0 , ns0 , S0 , dS0 , max_points , solver_tol , & update_specification , postprocess , solver , stop & ) result ( XS ) !! Numerical continuation of a function. !! !! Uses Algower method of numerical continuation to trace a line that !! solves a system of the kind: !! !!  F(X,S) = 0  !! !! Where X is the variables vector and S)\\ is the value of the !! specification. !! The method works with by providing a good set of initial points to !! solve the system of equations with an extrapolation using the previous !! solved point information. procedure ( continuation_function ) :: f !! Function to trace real ( pr ), intent ( in ) :: X0 (:) !! Initial point integer , intent ( in ) :: ns0 !! Initial specification real ( pr ), intent ( in ) :: S0 !! Initial specification value real ( pr ), intent ( in ) :: dS0 !! Initial \\deltaS integer , intent ( in ) :: max_points !! Maximum number of points to trace real ( pr ), intent ( in ) :: solver_tol !! Point solver tolerance procedure ( process ), optional :: update_specification !! Procedure to select the new specification and define the next step !! \\DeltaS)\\, defaults to: !! !! ```fortran !! ns = maxloc(abs(dXdS), dim=1) !! dS = dXdS(ns)*dS !! dXdS = dXdS/dXdS(ns) !! dS = sign(minval(abs([0.05_pr, dS])), dS) !! ``` procedure ( process ), optional :: postprocess !! Any kind of postprocess that could be done after defining the !! next step procedure ( continuation_solver ), optional :: solver !! Solver procedures, uses Newton-Raphson by default procedure ( continuation_stopper ), optional :: stop !! Stopping procedure real ( pr ) :: XS ( max_points , size ( X0 )) real ( pr ) :: X ( size ( X0 )), S , fval ( size ( X0 )), dF ( size ( X0 ), size ( X0 )), dFdS ( size ( X0 )) real ( pr ) :: dXdS ( size ( X0 )) integer :: ns real ( pr ) :: dS integer :: i , newton_its integer :: max_iters = 500 X = X0 ns = ns0 dS = dS0 S = S0 XS = 0 do i = 1 , max_points if ( present ( solver )) then call solver (& f , newton_its , X , ns , S , dS , dXdS , i , max_iters , & fval , dF , dFdS , solver_tol & ) else call full_newton (& f , newton_its , X , ns , S , dS , dXdS , i , max_iters , & fval , dF , dFdS , solver_tol & ) end if if ( newton_its >= max_iters . or . dS == 0._pr . or . any ( isnan ( Fval ))) exit XS ( i , :) = X dXdS = solve_system ( dF , - dFdS ) if ( present ( update_specification )) then call update_specification ( X , ns , S , dS , dXdS , newton_its ) else ns = maxloc ( abs ( dXdS ), dim = 1 ) dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) end if if ( present ( postprocess )) then call postprocess ( X , ns , S , dS , dXdS , newton_its ) end if if ( present ( stop )) then if ( stop ( X , ns , S , dS , dXdS , newton_its )) exit end if if ( dS == 0 ) exit X = X + dXdS * dS S = X ( ns ) end do end function continuation subroutine full_newton (& fun , iters , X , ns , S , dS , dXdS , point , max_iters , F , dF , dFdS , tol & ) !! Subroutine to solve a point. !! !! Procedure that solves a point with the Newton-Raphson method. use yaeos__auxiliar , only : optval use yaeos__math_linalg , only : solve_system procedure ( continuation_function ) :: fun !! Function to solve integer , intent ( out ) :: iters !! Number of iterations needed real ( pr ), intent ( in out ) :: X (:) !! Variables vector integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( in ) :: dS real ( pr ), intent ( in ) :: dXdS (:) integer , intent ( in ) :: point integer , intent ( in ) :: max_iters !! Maximum iterations real ( pr ), intent ( out ) :: F (:) !! Function values at solved point real ( pr ), intent ( out ) :: df (:, :) !! Jacobian values real ( pr ), intent ( out ) :: dfds (:) !! dFdS real ( pr ), intent ( in ) :: tol real ( pr ) :: X0 ( size ( X )) real ( pr ) :: dX ( size ( X )), solve_tol solve_tol = tol dX = 20 F = 500 X0 = X newton : do iters = 1 , max_iters call fun ( X , ns , S , F , dF , dFdS ) dX = solve_system ( dF , - F ) ! Converged point if ( maxval ( abs ( dx / x )) < 1e-5_pr . or . maxval ( abs ( F )) < tol ) exit newton ! Fix the step do while ( maxval ( abs ( dx )) > 0.1 ) dX = dX / 2 end do if ( iters == 10 . and . point > 1 ) then dX = X0 - 0.9 * dXdS * dS - X end if X = X + dX end do newton end subroutine full_newton ! subroutine levenberg_marquardt(& !    fun, iters, X, ns, S, dS, dXdS, point, max_iters, F, dF, dFdS, tol & !    ) !    use minpack_module, only: lmdif1 !    use yaeos__auxiliar, only: optval !    use yaeos__math_linalg, only: solve_system !    procedure(continuation_function) :: fun !! Function to solve !    integer,  intent(out) :: iters !! Number of iterations needed !    real(pr), intent(in out) :: X(:)  !! Variables vector !    integer, intent(in) :: ns !    real(pr), intent(in) :: S !    real(pr), intent(in) :: dS !    real(pr), intent(in) :: dXdS(:) !    integer, intent(in) :: point !    integer, intent(in) :: max_iters !! Maximum iterations !    real(pr), intent(out) :: F(:) !! Function values at solved point !    real(pr), intent(out) :: df(:, :) !! Jacobian values !    real(pr), intent(out) :: dfds(:) !! dFdS !    real(pr), intent(in) :: tol !    integer :: m, n, info, iwa(size(x)) !    integer :: lwa !    real(pr) :: wa(size(F) * size(x) + 5*size(x) + size(f)) !    m = size(F) !    n = size(x) !    lwa = size(F) * size(x)+5*size(x)+size(f) !    call lmdif1(fcn, m, n, x, F, tol, Info, Iwa, Wa, Lwa) !    contains !    subroutine fcn(m, n, xx, fvec, iflag) !       integer, intent(in) :: m, n !       real(pr), intent(in) :: xx(n) !       real(pr), intent(out) :: fvec(m) !       integer, intent(in out) :: iflag !       call fun(xx, ns, S, fvec, dF, dFdS) !    end subroutine ! end subroutine end module yaeos__math_continuation","tags":"","url":"sourcefile/continuation.f90.html"},{"title":"uniquac.f90 – yaeos","text":"Source Code module yaeos__models_ge_uniquac !! # UNIQUAC module !! UNIQUAC (**uni**versal **qua**si**c**hemical) Excess Gibbs free energy !! model. !! !! ## References !! 1. Maurer, G., & Prausnitz, J. M. (1978). On the derivation and extension !! of the UNIQUAC equation. Fluid Phase Equilibria, 2(2), 91-99. !! 2. Gmehling, Jurgen, Barbel Kolbe, Michael Kleiber, and Jurgen Rarey. !! Chemical Thermodynamics for Process Simulation. 1st edition. Weinheim: !! Wiley-VCH, 2012. !! 3. Caleb Bell and Contributors (2016-2024). Thermo: Chemical properties !! component of Chemical Engineering Design Library (ChEDL) !! https://github.com/CalebBell/thermo. !! use yaeos__constants , only : pr , R use yaeos__models_ge , only : GeModel use yaeos__math , only : derivative_dxk_dni , derivative_d2xk_dnidnj implicit none type , extends ( GeModel ) :: UNIQUAC !! # UNIQUAC model !! !! # Description !! UNIQUAC (**uni**versal **qua**si**c**hemical) Excess Gibbs free energy !! model. !! !!  !! \\frac{G&#94;E}{RT} = \\sum_k n_k \\ln\\frac{\\phi_k}{x_k} !! + \\frac{z}{2}\\sum_k q_k n_k \\ln\\frac{\\theta_k}{\\phi_k} !! - \\sum_k q_k n_k \\ln\\left(\\sum_l \\theta_l \\tau_{kl} \\right) !!  !! !! With: !! !!  x_k = \\frac{n_k}{\\sum_l n_l}  !! !!  \\phi_k = \\frac{r_k n_k}{\\sum_l r_l n_l}  !! !!  \\theta_k = \\frac{q_k n_k}{\\sum_l q_l n_l}  !! !!  \\tau_{lk} = \\exp \\left[\\frac{-\\Delta U_{lk}}{R T} \\right]  !! !!  !! \\frac{-\\Delta U_{lk}}{R T} = a_{lk}+\\frac{b_{lk}}{T}+c_{lk}\\ln T + !! d_{lk}T + e_{lk}{T&#94;2} !!  !! !! # Example !! !! ```fortran !! use yaeos, only: pr, setup_uniquac, UNIQUAC !! !! integer, parameter :: nc = 3 !! !! real(pr) :: rs(nc), qs(nc) !! real(pr) :: b(nc, nc) !! real(pr) :: n(nc) !! !! real(pr) :: ln_gammas(nc), T !! !! type(UNIQUAC) :: model !! !! rs = [0.92_pr, 2.1055_pr, 3.1878_pr] !! qs = [1.4_pr, 1.972_pr, 2.4_pr] !! !! T = 298.15_pr !! !! ! Calculate bij from DUij. We need -DU/R to get bij !! b(1, :) = [0.0_pr, -526.02_pr, -309.64_pr] !! b(2, :) = [318.06_pr, 0.0_pr, 91.532_pr] !! b(3, :) = [-1325.1_pr, -302.57_pr, 0.0_pr] !! !! model = setup_uniquac(qs, rs, bij=b) !! !! n = [0.8_pr, 0.1_pr, 0.2_pr] !! !! call model%ln_activity_coefficient(n, T, ln_gammas) !! !! print *, exp(ln_gammas) ! [8.856, 0.860, 1.425] !! !! ``` !! real ( pr ) :: z = 1 0.0_pr !! Model coordination number real ( pr ), allocatable :: qs (:) !! Molecule's relative areas Q_i real ( pr ), allocatable :: rs (:) !! Molecule's relative volumes R_i real ( pr ), allocatable :: aij (:,:) !! Interaction parameters matrix a_{ij} real ( pr ), allocatable :: bij (:,:) !! Interaction parameters matrix b_{ij} real ( pr ), allocatable :: cij (:,:) !! Interaction parameters matrix c_{ij} real ( pr ), allocatable :: dij (:,:) !! Interaction parameters matrix d_{ij} real ( pr ), allocatable :: eij (:,:) !! Interaction parameters matrix e_{ij} contains procedure :: excess_gibbs procedure :: taus end type UNIQUAC contains subroutine excess_gibbs ( self , n , T , Ge , GeT , GeT2 , Gen , GeTn , Gen2 ) !! Calculate the excess Gibbs free energy and its derivatives of the !! UNIQUAC model. !! class ( UNIQUAC ), intent ( in ) :: self !! UNIQUAC model real ( pr ), intent ( in ) :: n (:) !! Moles vector [mol] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: Ge !! Excess Gibbs energy real ( pr ), optional , intent ( out ) :: GeT !! \\frac{dG&#94;E}{dT} real ( pr ), optional , intent ( out ) :: GeT2 !! \\frac{d&#94;2G&#94;E}{dT&#94;2} real ( pr ), optional , intent ( out ) :: Gen ( size ( n )) !! \\frac{dG&#94;E}{dn} real ( pr ), optional , intent ( out ) :: GeTn ( size ( n )) !! \\frac{d&#94;2G&#94;E}{dTdn} real ( pr ), optional , intent ( out ) :: Gen2 ( size ( n ), size ( n )) !! \\frac{d&#94;2G&#94;E}{dn&#94;2} ! Main terms real ( pr ) :: thetak ( size ( n )) real ( pr ) :: dthetak_dni ( size ( n ), size ( n )) real ( pr ) :: d2thetak_dnidnj ( size ( n ), size ( n ), size ( n )) real ( pr ) :: tau ( size ( n ), size ( n )) real ( pr ) :: dtau ( size ( n ), size ( n )) real ( pr ) :: d2tau ( size ( n ), size ( n )) ! Indexes and lofical for optional arguments integer :: i , j , k logical :: dt , dt2 , dn , dtn , dn2 , dt_or_dtn ! Auxiliars integer :: nc real ( pr ) :: n_tot real ( pr ) :: r_i , q_i , r_j , q_j , r_k , q_k real ( pr ) :: sum_nq , sum_nr real ( pr ) :: Ge_comb , Ge_res real ( pr ) :: Ge_aux ! Auxiliars for temperature derivatives real ( pr ) :: sum_thetal_tau_lk ( size ( n )) real ( pr ) :: sum_theta_l_dtau_lk ( size ( n )) real ( pr ) :: sum_theta_l_d2tau_lk ( size ( n )) real ( pr ) :: GeT_aux , GeT2_aux , diff_aux ( size ( n )) ! Auxiliars for compositionals derivatives real ( pr ) :: Gen_comb ( size ( n )), Gen_res ( size ( n )) real ( pr ) :: Gen_aux ( size ( n )) real ( pr ) :: dln_nk_dni ( size ( n ), size ( n )) ! Auxiliars for second compositionals derivatives ! terms of the math expression real ( pr ) :: trm1 , trm2 , trm3 , trm4 , trm5 , trm6 real ( pr ) :: sum_d2theta_tau_lk ( size ( n )) real ( pr ) :: Gen2_aux ( size ( n ), size ( n )) ! cross derivative auxiliars real ( pr ) :: sum_dtheta_l_dtau_lk ( size ( n ), size ( n )) real ( pr ) :: sum_dtheta_l_tau_lk ( size ( n ), size ( n )) real ( pr ) :: GeTn_aux ( size ( n )) ! ======================================================================= ! Logical variables ! ----------------------------------------------------------------------- dt = present ( GeT ) dt2 = present ( GeT2 ) dn = present ( Gen ) dtn = present ( GeTn ) dn2 = present ( Gen2 ) dt_or_dtn = dt . or . dtn ! ======================================================================= ! Auxiliars ! ----------------------------------------------------------------------- nc = size ( n ) n_tot = sum ( n ) sum_nq = sum ( n * self % qs ) sum_nr = sum ( n * self % rs ) ! ======================================================================= ! tau call (temperature dependence term) ! ----------------------------------------------------------------------- if ( dt_or_dtn . and . . not . dt2 ) call self % taus ( T , tau , dtau ) if (. not . dt_or_dtn . and . dt2 ) call self % taus ( T , tau , dtau , d2tau ) if ( dt_or_dtn . and . dt2 ) call self % taus ( T , tau , dtau , d2tau ) if (. not . dt_or_dtn . and . . not . dt2 ) call self % taus ( T , tau ) ! ======================================================================= ! theta_k ! ----------------------------------------------------------------------- thetak = n * self % qs / sum_nq if ( dn . or . dn2 . or . dtn ) then dthetak_dni = 0 do concurrent ( k = 1 : nc , i = 1 : nc ) if ( i == k ) then dthetak_dni ( i , i ) = & ( self % qs ( i ) * sum_nq - n ( i ) * self % qs ( i ) ** 2 ) / sum_nq ** 2 else dthetak_dni ( k , i ) = - n ( k ) * self % qs ( i ) * self % qs ( k ) / sum_nq ** 2 end if end do end if if ( dn2 ) then d2thetak_dnidnj = 0 do concurrent ( k = 1 : nc , i = 1 : nc , j = 1 : nc ) if ( i == k . and . j == k ) then q_i = self % qs ( i ) d2thetak_dnidnj ( k , i , j ) = (& 2.0_pr * ( q_i ** 3 * n ( i ) - q_i ** 2 * sum_nq ) / sum_nq ** 3 & ) else if ( i == k ) then q_i = self % qs ( i ) q_j = self % qs ( j ) d2thetak_dnidnj ( k , i , j ) = (& ( 2.0_pr * n ( i ) * q_i ** 2 * q_j - q_i * q_j * sum_nq ) / sum_nq ** 3 & ) else if ( j == k ) then q_i = self % qs ( i ) q_j = self % qs ( j ) d2thetak_dnidnj ( k , i , j ) = (& ( 2.0_pr * n ( j ) * q_j ** 2 * q_i - q_i * q_j * sum_nq ) / sum_nq ** 3 & ) else q_i = self % qs ( i ) q_j = self % qs ( j ) q_k = self % qs ( k ) d2thetak_dnidnj ( k , i , j ) = (& 2.0_pr * n ( k ) * q_k * q_i * q_j / sum_nq ** 3 & ) end if end do end if ! ======================================================================= ! Ge ! ----------------------------------------------------------------------- ! Combinatorial term Ge_comb = ( & sum ( n * log ( n_tot * self % rs / sum_nr )) & + self % z / 2.0_pr * sum ( n * self % qs * log ( self % qs * sum_nr / self % rs / sum_nq )) & ) ! Residual term sum_thetal_tau_lk = 0.0_pr do k = 1 , nc sum_thetal_tau_lk ( k ) = sum ( thetak * tau (:, k )) end do Ge_res = - sum ( n * self % qs * log ( sum_thetal_tau_lk )) Ge_aux = R * T * ( Ge_comb + Ge_res ) ! ======================================================================= ! Ge Derivatives ! ----------------------------------------------------------------------- if ( dn . or . dtn . or . dn2 ) then do concurrent ( k = 1 : nc , i = 1 : nc ) sum_dtheta_l_tau_lk ( i , k ) = sum ( dthetak_dni (:, i ) * tau (:, k )) end do end if ! Compositional derivarives ! dn if ( dn . or . dtn ) then do i = 1 , nc ! Combinatorial term Gen_comb ( i ) = (& log ( n_tot * self % rs ( i ) / sum_nr ) & + sum ( n * ( sum_nr - n_tot * self % rs ( i )) / n_tot / sum_nr ) & + self % z / 2.0_pr * self % qs ( i ) * log ( self % qs ( i ) * sum_nr / self % rs ( i ) / sum_nq ) & + self % z / 2.0_pr * sum ( n * self % qs * ( self % rs ( i ) * sum_nq - self % qs ( i ) * sum_nr ) / sum_nq / sum_nr ) & ) ! Residual term Gen_res ( i ) = (& - self % qs ( i ) * log ( sum_thetal_tau_lk ( i )) & - sum ( n * self % qs * sum_dtheta_l_tau_lk ( i ,:) / sum_thetal_tau_lk ) & ) end do Gen_aux = R * T * ( Gen_comb + Gen_res ) end if ! dn2 if ( dn2 ) then do concurrent ( i = 1 : nc , j = 1 : nc ) trm1 = ( sum_nr - n_tot * self % rs ( j )) / n_tot / sum_nr trm2 = (& ( sum_nr - n_tot * self % rs ( i )) / n_tot / sum_nr & + sum ( n * ( self % rs ( i ) * self % rs ( j ) / sum_nr ** 2 - 1.0_pr / n_tot ** 2 )) & ) trm3 = (& self % z / 2.0_pr * self % qs ( i ) * ( self % rs ( j ) * sum_nq - & self % qs ( j ) * sum_nr ) / sum_nq / sum_nr & ) trm4 = (& self % z / 2.0_pr * self % qs ( j ) * ( self % rs ( i ) * sum_nq - & self % qs ( i ) * sum_nr ) / sum_nq / sum_nr & + self % z / 2.0_pr * sum ( n * self % qs * & ( self % qs ( i ) * self % qs ( j ) / sum_nq ** 2 - & self % rs ( i ) * self % rs ( j ) / sum_nr ** 2 ))& ) trm5 = - self % qs ( i ) * ( sum ( dthetak_dni (:, j ) * tau (:, i )) / sum_thetal_tau_lk ( i )) do k = 1 , nc sum_d2theta_tau_lk ( k ) = sum ( d2thetak_dnidnj (:, i , j ) * tau (:, k )) end do trm6 = (& - self % qs ( j ) * ( sum ( dthetak_dni (:, i ) * tau (:, j )) / sum_thetal_tau_lk ( j )) & - sum ( self % qs * n * (& sum_d2theta_tau_lk * sum_thetal_tau_lk & - sum_dtheta_l_tau_lk ( i ,:) * sum_dtheta_l_tau_lk ( j ,:) & ) / sum_thetal_tau_lk ** 2 ) & ) Gen2_aux ( i , j ) = R * T * ( trm1 + trm2 + trm3 + trm4 + trm5 + trm6 ) end do end if ! Temperature derivatives if ( dt . or . dt2 . or . dtn ) then sum_theta_l_dtau_lk = 0.0_pr do k = 1 , nc sum_theta_l_dtau_lk ( k ) = sum ( thetak * dtau (:, k )) end do end if if ( dt ) then GeT_aux = ( & Ge_aux / T - R * T * sum ( n * self % qs * sum_theta_l_dtau_lk / sum_thetal_tau_lk )& ) end if if ( dt2 ) then sum_theta_l_d2tau_lk = 0.0_pr do k = 1 , nc sum_theta_l_d2tau_lk ( k ) = sum ( thetak * d2tau (:, k )) end do diff_aux = (& sum_theta_l_d2tau_lk / sum_thetal_tau_lk & - ( sum_theta_l_dtau_lk / sum_thetal_tau_lk ) ** 2 & ) GeT2_aux = - R * ( & T * sum ( self % qs * n * diff_aux ) & + 2.0_pr * sum ( self % qs * n * sum_theta_l_dtau_lk / sum_thetal_tau_lk )& ) end if ! Cross derivative Tn if ( dtn ) then do concurrent ( k = 1 : nc , i = 1 : nc ) sum_dtheta_l_dtau_lk ( i , k ) = sum ( dthetak_dni (:, i ) * dtau (:, k )) end do end if if ( dtn ) then do i = 1 , nc GeTn_aux ( i ) = ( & 1.0_pr / T * Gen_aux ( i ) & - R * T * (& self % qs ( i ) * sum_theta_l_dtau_lk ( i ) / sum_thetal_tau_lk ( i ) & + sum ( n * self % qs * (& sum_dtheta_l_dtau_lk ( i ,:) * sum_thetal_tau_lk & - sum_theta_l_dtau_lk * sum_dtheta_l_tau_lk ( i ,:)) & / sum_thetal_tau_lk ** 2 ) & ) & ) end do end if ! ======================================================================= ! Excess Gibbs energy returns ! ----------------------------------------------------------------------- if ( present ( Ge )) Ge = Ge_aux if ( dt ) GeT = GeT_aux if ( dt2 ) GeT2 = GeT2_aux if ( dn ) Gen = Gen_aux if ( dtn ) GeTn = GeTn_aux if ( dn2 ) Gen2 = Gen2_aux end subroutine excess_gibbs subroutine taus ( self , T , tau , tauT , tauT2 ) !! Calculate the temperature dependence term of the UNIQUAC model. !! class ( UNIQUAC ), intent ( in ) :: self !! UNIQUAC model real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: tau ( size ( self % qs ), size ( self % qs )) !! UNIQUAC temperature dependence term real ( pr ), optional , intent ( out ) :: tauT ( size ( self % qs ), size ( self % qs )) !! \\frac{d\\tau_{ij}}{dT} real ( pr ), optional , intent ( out ) :: tauT2 ( size ( self % qs ), size ( self % qs )) !! \\frac{d&#94;2\\tau_{ij}}{dT&#94;2} ! aux real ( pr ) :: tau_aux ( size ( self % qs ), size ( self % qs )) real ( pr ) :: u ( size ( self % qs ), size ( self % qs )) real ( pr ) :: du ( size ( self % qs ), size ( self % qs )) real ( pr ) :: d2u ( size ( self % qs ), size ( self % qs )) ! Logical logical :: tt , dt , dt2 tt = present ( tau ) dt = present ( tauT ) dt2 = present ( tauT2 ) ! temperature function u = self % aij + self % bij / T + self % cij * log ( T ) + self % dij * T + self % eij * T ** 2 ! tau_ij tau_aux = exp ( u ) ! dT if ( dt . or . dt2 ) then du = - self % bij / T ** 2 + self % cij / T + self % dij + 2.0_pr * T * self % eij end if ! d2T if ( dt2 ) then d2u = 2.0_pr * self % bij / T ** 3 - self % cij / T ** 2 + 2.0_pr * self % eij end if if ( tt ) tau = tau_aux if ( dt ) tauT = tau_aux * du if ( dt2 ) tauT2 = tau_aux * du ** 2 + tau_aux * d2u end subroutine taus type ( UNIQUAC ) function setup_uniquac ( qs , rs , aij , bij , cij , dij , eij ) !! Instantiate a UNIQUAC model. !! !! Non provided interaction parameters are set to zero matrices. !! real ( pr ), intent ( in ) :: qs (:) !! Molecule's relative volumes Q_i real ( pr ), intent ( in ) :: rs ( size ( qs )) !! Molecule's relative areas R_i real ( pr ), optional , intent ( in ) :: aij ( size ( qs ), size ( qs )) !! Interaction parameters matrix a_{ij}, zero matrix if no provided. real ( pr ), optional , intent ( in ) :: bij ( size ( qs ), size ( qs )) !! Interaction parameters matrix b_{ij}, zero matrix if no provided. real ( pr ), optional , intent ( in ) :: cij ( size ( qs ), size ( qs )) !! Interaction parameters matrix c_{ij}, zero matrix if no provided. real ( pr ), optional , intent ( in ) :: dij ( size ( qs ), size ( qs )) !! Interaction parameters matrix d_{ij}, zero matrix if no provided. real ( pr ), optional , intent ( in ) :: eij ( size ( qs ), size ( qs )) !! Interaction parameters matrix e_{ij}, zero matrix if no provided. ! aij if ( present ( aij )) then setup_uniquac % aij = aij else allocate ( setup_uniquac % aij ( size ( qs ), size ( qs ))) setup_uniquac % aij = 0.0_pr end if ! bij if ( present ( bij )) then setup_uniquac % bij = bij else allocate ( setup_uniquac % bij ( size ( qs ), size ( qs ))) setup_uniquac % bij = 0.0_pr end if ! cij if ( present ( cij )) then setup_uniquac % cij = cij else allocate ( setup_uniquac % cij ( size ( qs ), size ( qs ))) setup_uniquac % cij = 0.0_pr end if ! dij if ( present ( dij )) then setup_uniquac % dij = dij else allocate ( setup_uniquac % dij ( size ( qs ), size ( qs ))) setup_uniquac % dij = 0.0_pr end if ! eij if ( present ( eij )) then setup_uniquac % eij = eij else allocate ( setup_uniquac % eij ( size ( qs ), size ( qs ))) setup_uniquac % eij = 0.0_pr end if setup_uniquac % qs = qs setup_uniquac % rs = rs end function setup_uniquac end module yaeos__models_ge_uniquac","tags":"","url":"sourcefile/uniquac.f90.html"},{"title":"phase_envelopes_px_mp.f90 – yaeos","text":"Source Code module yaeos__equilibria_boundaries_phase_envelopes_mp_px !! Multiphase Px envelope calculation module. !! !! This module contains the functions to calculate the PT envelope of a !! mixture with multiple phases. use yaeos__constants , only : pr , R use yaeos__equilibria_equilibrium_state , only : EquilibriumState use yaeos__models_ar , only : ArModel use yaeos__math , only : solve_system use yaeos__equilibria_boundaries_auxiliar , only : get_z implicit none private public :: PXEnvelMP public :: px_F_NP public :: px_envelope type :: PXEnvelMP !! Multiphase PX envelope. type ( MPPoint ), allocatable :: points (:) !! Array of converged points. real ( pr ), allocatable :: alpha (:) !! Molar relation between two mixtures. real ( pr ), allocatable :: z0 (:) !! Original mixture mole fractions. real ( pr ), allocatable :: zi (:) !! Other mixture mole fractions contains procedure :: write => write_envelope_Px_MP procedure , nopass :: solve_point procedure , nopass :: get_values_from_X end type PXEnvelMP type :: MPPoint !! Multiphase equilibria point. integer :: np !! Number of phases integer :: nc !! Number of components real ( pr ) :: beta_w !! Fraction of the reference (incipient) phase. real ( pr ), allocatable :: betas (:) !! Fractions of the main phases. real ( pr ) :: P !! Pressure [bar] real ( pr ) :: T !! Temperature [K] real ( pr ), allocatable :: x_l (:, :) !! Mole fractions of the main phases. real ( pr ), allocatable :: w (:) !! Mole fractions of the incipient phase. integer :: iters !! Number of iterations needed to converge the point. integer :: ns !! Number of the specified variable. end type MPPoint contains type ( PXEnvelMP ) function px_envelope (& model , z0 , zi , np , T , x_l0 , w0 , betas0 , P0 , alpha0 , ns0 , dS0 , beta_w , points & ) !! # `px_envelope` !! Calculation of a multiphase Px envelope. !! !! # Description !! Calculates a phase envelope at costant temperature, using a numerical !! continuation method. use yaeos__auxiliar , only : optval class ( ArModel ), intent ( in ) :: model !! Model to use. real ( pr ), intent ( in ) :: z0 (:) !! Original fluid composition. real ( pr ), intent ( in ) :: zi (:) !! Other fluid compostion. integer , intent ( in ) :: np !! Number of phases, without including the reference phaes real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: x_l0 ( np , size ( z0 )) !! Initial guess for composition of phases. real ( pr ), intent ( in ) :: w0 ( size ( z0 )) !! Initial guess for composition of reference phase. real ( pr ), intent ( in ) :: betas0 ( np ) !! Mole fractions of each phase. Excluding the reference phase. real ( pr ), intent ( in ) :: P0 !! Initial guess for pressure [bar] real ( pr ), intent ( in ) :: alpha0 !! Initial guess for relation between two fluids \\alpha integer , intent ( in ) :: ns0 !! First specified variable. !! !! The first `nc*np` values correspond to !! the different \\ln K_i&#94;l, which are sorted like !! [\\ln K_1&#94;1, \\ln K_2&#94;1, \\dots \\ln K_1&#94;2, \\dots, ln K_{nc}&#94;{np}]. !! !! From `nc*np+1` to `nc*np + np`, the different \\beta&#94;l values. !! !! `nc*np+np+1` and `cp*np+np+2` are P and \\alpha, !! respectively. real ( pr ), intent ( in ) :: dS0 !! First step to extrapolate for next point calculation. After that !! It will use an adaptive algorithm. real ( pr ), intent ( in ) :: beta_w !! Fraction of the reference (incipient) phase. integer , optional , intent ( in ) :: points !! Maximum number of points to calculate. type ( MPPoint ), allocatable :: env_points (:) real ( pr ), allocatable :: alphas (:) type ( MPPoint ) :: point real ( pr ) :: F ( size ( z0 ) * np + np + 2 ) real ( pr ) :: dF ( size ( z0 ) * np + np + 2 , size ( z0 ) * np + np + 2 ) real ( pr ) :: dXdS ( size ( z0 ) * np + np + 2 ) real ( pr ) :: X ( size ( z0 ) * np + np + 2 ), dX ( size ( z0 ) * np + np + 2 ) real ( pr ) :: z ( size ( z0 )) integer :: nc integer :: its integer :: max_iterations = 100 integer :: number_of_points real ( pr ) :: x_l ( np , size ( z0 )), w ( size ( z0 )), betas ( np ), P , alpha integer :: i !! Point calculation index integer :: lb !! Lower bound, index of the first component of a phase integer :: ub !! Upper bound, index of the last component of a phase integer :: inner !! Number of times a failed point is retried to converge integer :: ns !! Number of the specified variable real ( pr ) :: dS !! Step size of the specification for the next point real ( pr ) :: S !! Specified value real ( pr ) :: X0 ( size ( X )) !! Initial guess for the point integer :: ia nc = size ( z0 ) ia = nc * np + np + 2 number_of_points = optval ( points , 1000 ) do i = 1 , np lb = ( i - 1 ) * nc + 1 ub = i * nc X ( lb : ub ) = log ( x_l0 ( i , :) / w0 ) end do X ( np * nc + 1 : np * nc + np ) = betas0 X ( np * nc + np + 1 ) = log ( P0 ) X ( np * nc + np + 2 ) = alpha0 ns = ns0 S = X ( ns ) dS = dS0 allocate ( env_points ( 0 ), alphas ( 0 )) call solve_point (& model , z0 , zi , np , T , beta_w , X , ns , S , dXdS , & F , dF , its , 1000 & ) do i = 1 , number_of_points X0 = X call solve_point (& model , z0 , zi , np , T , beta_w , X , ns , S , dXdS , & F , dF , its , max_iterations & ) ! The point might not converge, in this case we try again with an ! initial guess closer to the previous (converged) point. inner = 0 do while ( i > 1 . and . its >= max_iterations . and . inner < 10 ) inner = inner + 1 X = X0 - ( 1 - real ( inner , pr ) / 1 0._pr ) * dX S = X ( ns ) call solve_point (& model , z0 , zi , np , T , beta_w , X , ns , S , dXdS , & F , dF , its , 5 & ) end do ! If the point did not converge, stop the calculation if ( any ( isnan ( F )) . or . its > max_iterations . or . dS == 0._pr ) exit ! Save the information of the converged point call get_values_from_X ( X , np , z0 , zi , beta_w , x_l , w , betas , P , alpha ) point = MPPoint (& np = np , nc = nc , betas = betas , P = P , T = T , x_l = x_l , w = w , beta_w = beta_w , & iters = its , ns = ns & ) env_points = [ env_points , point ] alphas = [ alphas , alpha ] ! Update the specification for the next point. call update_specification ( its , nc , np , X , dF , dXdS , ns , dS ) ! Check if the system is close to a critical point, and try to jump ! over it. call detect_critical ( nc , np , X , dXdS , ns , dS , S ) ! Next point estimation. dX = dXdS * dS alpha = X ( ia ) + dXdS ( ia ) * dS z = alpha * zi + ( 1 - alpha ) * z0 do while ( any ( z > 1 ) . or . any ( z < 0 )) dS = dS / 2 alpha = X ( ia ) + dXdS ( ia ) * dS z = alpha * zi + ( 1 - alpha ) * z0 end do X = X + dX S = X ( ns ) end do ! This moves the locally saved points to the output variable. call move_alloc ( env_points , px_envelope % points ) call move_alloc ( alphas , px_envelope % alpha ) end function px_envelope subroutine px_F_NP ( model , z0 , zi , np , T , beta_w , X , ns , S , F , dF ) !! # `px_F_NP` !! System of equations to solve a multiphase-point at constant !! temperature. !! !! # Description !! A multiphase equilibria point between `np+1` phases and `nc` !! components, where the `np+1` phase is a phase taken as reference for !! the calculation of equilibria rations !! K_i&#94;l = \\frac{\\mathbf{x}_i&#94;l}{\\mathbf{w}_i}, !! can be defined by the system of equations: !! !!  !! \\begin{bmatrix} !! \\ln K_i&#94;{l} + \\ln \\phi_i&#94;{l}(\\mathbf{x}&#94;l, P, T) - \\ln \\phi_i&#94;{l}(\\mathbf{w}, P, T) \\\\ !! \\sum_i{\\mathbf{x}&#94;l_i - \\mathbf{w}_i} !! \\sum&#94;l{\\beta&#94;l} + \\beta&#94;{np+1} - 1 !! \\end{bmatrix} !!  ! ------------------------------------------------------------------------ use iso_fortran_env , only : error_unit class ( ArModel ), intent ( in ) :: model !! Model to use. real ( pr ), intent ( in ) :: z0 (:) !! First mixture composition. real ( pr ), intent ( in ) :: zi (:) !! Second mixture composition. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in ) :: T !! Temperature [K]. real ( pr ), intent ( in ) :: beta_w !! Fraction of the reference (incipient) phase. real ( pr ), intent ( in ) :: X (:) !! Vector of variables. integer , intent ( in ) :: ns !! Number of specification. real ( pr ), intent ( in ) :: S !! Specification value. real ( pr ), intent ( out ) :: F ( size ( X )) !! Vector of functions valuated. real ( pr ), intent ( out ) :: df ( size ( X ), size ( X )) !! Jacobian matrix. ! X variables real ( pr ) :: K ( np , size ( z0 )) real ( pr ) :: P real ( pr ) :: betas ( np ) real ( pr ) :: z ( size ( z0 )), alpha , dzda ( size ( z0 )) ! Main phases variables real ( pr ) :: moles ( size ( z0 )) real ( pr ) :: Vl ( np ) real ( pr ), dimension ( np , size ( z0 )) :: x_l , lnphi_l , dlnphi_dt_l , dlnphi_dp_l real ( pr ), dimension ( np , size ( z0 ), size ( z0 )) :: dlnphi_dn_l real ( pr ) :: lnphi ( size ( z0 )), dlnphi_dt ( size ( z0 )), dlnphi_dp ( size ( z0 )) real ( pr ), dimension ( size ( z0 ), size ( z0 )) :: dlnphi_dn ! Incipient phase variables real ( pr ) :: Vw real ( pr ), dimension ( size ( z0 )) :: w , lnphi_w , dlnphi_dt_w , dlnphi_dp_w real ( pr ), dimension ( size ( z0 ), size ( z0 )) :: dlnphi_dn_w real ( pr ) :: dwda ( size ( z0 )) ! Derivatives of w wrt beta and K real ( pr ) :: dwdb ( np , size ( z0 )) real ( pr ) :: dwdlnK ( np , size ( z0 )) real ( pr ) :: denom ( size ( z0 )) real ( pr ) :: denomdlnK ( np , size ( z0 ), size ( z0 )) real ( pr ) :: dx_l_dlnK ( np , np , size ( z0 )) integer :: i , j , l , phase , nc integer :: lb , ub integer :: idx_1 , idx_2 nc = size ( z0 ) ! ======================================================================== ! Extract variables from the vector X ! ------------------------------------------------------------------------ P = exp ( X ( np * nc + np + 1 )) alpha = X ( np * nc + np + 2 ) do l = 1 , np lb = ( l - 1 ) * nc + 1 ub = l * nc K ( l , :) = exp ( X ( lb : ub )) end do betas = X ( np * nc + 1 : np * nc + np ) call get_z ( alpha , z0 , zi , z , dzda ) denom = 0 denom = matmul ( betas , K ) + beta_w denomdlnK = 0 do i = 1 , nc denomdlnK (:, i , i ) = betas (:) * K (:, i ) end do w = z / denom ! ======================================================================== ! Calculation of fugacities coeficients and their derivatives ! ------------------------------------------------------------------------ call model % lnphi_pt (& w , P , T , V = Vw , root_type = \"stable\" , lnphi = lnphi_w , & dlnphidp = dlnphi_dp_w , dlnphidt = dlnphi_dt_w , dlnphidn = dlnphi_dn_w & ) do l = 1 , np x_l ( l , :) = K ( l , :) * w call model % lnphi_pt (& x_l ( l , :), P , T , V = Vl ( l ), root_type = \"stable\" , lnphi = lnphi , & dlnphidp = dlnphi_dp , dlnphidt = dlnphi_dt , dlnphidn = dlnphi_dn & ) lnphi_l ( l , :) = lnphi dlnphi_dn_l ( l , :, :) = dlnphi_dn dlnphi_dt_l ( l , :) = dlnphi_dt dlnphi_dp_l ( l , :) = dlnphi_dp end do ! ======================================================================== ! Calculation of the system of equations ! ------------------------------------------------------------------------ do l = 1 , np ! Select the limits of the function lb = ( l - 1 ) * nc + 1 ub = l * nc F ( lb : ub ) = X ( lb : ub ) + lnphi_l ( l , :) - lnphi_w F ( nc * np + l ) = sum ( x_l ( l , :) - w ) end do F ( nc * np + np + 1 ) = sum ( betas ) + beta_w - 1 F ( nc * np + np + 2 ) = X ( ns ) - S ! ======================================================================== ! Derivatives and Jacobian Matrix of the whole system ! ------------------------------------------------------------------------ df = 0 dwdlnK = 0 dwda = dzda / denom do l = 1 , np ! Save the derivatives of w wrt beta and K of the incipient phase dwdb ( l , :) = - z * K ( l , :) / denom ** 2 dwdlnK ( l , :) = - K ( l , :) * betas ( l ) * z / denom ** 2 end do do l = 1 , np do phase = 1 , np dx_l_dlnK ( phase , l , :) = dwdlnK ( l , :) * K ( phase , :) if ( phase == l ) then dx_l_dlnK ( phase , l , :) = dx_l_dlnK ( phase , l , :) + w * K ( l , :) end if end do end do do l = 1 , np ! Derivatives of the isofugacity equations ! wrt lnK do phase = 1 , np do i = 1 , nc do j = 1 , nc idx_1 = i + ( phase - 1 ) * nc idx_2 = j + ( l - 1 ) * nc df ( idx_1 , idx_2 ) = & dlnphi_dn_l ( phase , i , j ) * dx_l_dlnK ( phase , l , j ) & - dlnphi_dn_w ( i , j ) * dwdlnK ( l , j ) if ( i == j . and . phase == l ) then df ( idx_1 , idx_2 ) = df ( idx_1 , idx_2 ) + 1 end if end do end do end do ! wrt betas do j = 1 , np lb = ( j - 1 ) * nc + 1 ub = j * nc do i = 1 , nc df ( lb + i - 1 , np * nc + l ) = & sum ( K ( j , :) * dlnphi_dn_l ( j , i , :) * dwdb ( l , :) & - dlnphi_dn_w ( i , :) * dwdb ( l , :)) end do end do ! disofug wrt P, alpha do i = 1 , nc lb = ( l - 1 ) * nc + i df ( lb , nc * np + np + 1 ) = P * ( dlnphi_dp_l ( l , i ) - dlnphi_dp_w ( i )) df ( lb , nc * np + np + 2 ) = sum (& dwda * K ( l , :) * dlnphi_dn_l ( l , i , :) - dwda * dlnphi_dn_w ( i , :) & ) end do ! Derivatives of the sum of mole fractions ! wrt lnK do phase = 1 , np do j = 1 , nc lb = nc * np + phase ub = j + ( l - 1 ) * nc df ( lb , ub ) = df ( lb , ub ) + ( dx_l_dlnK ( phase , l , j ) - dwdlnK ( l , j )) end do end do ! wrt beta, alpha do j = 1 , np lb = nc * np + j df ( lb , np * nc + l ) = sum ( K ( j , :) * dwdb ( l , :) - dwdb ( l , :)) end do df ( nc * np + l , nc * np + np + 2 ) = sum ( K ( l , :) * dwda - dwda ) ! Derivatives of sum(beta) + beta_w == 1 df ( nc * np + np + 1 , np * nc + l ) = 1 end do df ( nc * np + np + 2 , ns ) = 1 end subroutine px_F_NP subroutine solve_point ( model , z0 , zi , np , T , beta_w , X , ns , S , dXdS , F , dF , iters , max_iterations ) !! # `solve_point` !! Solve the system of equations for a multiphase point. !! !! # Description !! Solves the point of a multiphase system using the Newton-Raphson !! method. The system of equations is defined in [[px_F_NP(procedure)]] use iso_fortran_env , only : error_unit use yaeos__math , only : solve_system class ( ArModel ), intent ( in ) :: model !! Model to use. real ( pr ), intent ( in ) :: z0 (:) !! First mixture composition. real ( pr ), intent ( in ) :: zi (:) !! Second mixture composition. integer , intent ( in ) :: np !! Number of main phases real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: beta_w !! Fraction of the reference (incipient) phase real ( pr ), intent ( in out ) :: X (:) !! Vector of variables integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( in ) :: dXdS ( size ( X )) !! Sensitivity of the variables wrt the specification real ( pr ), intent ( out ) :: F ( size ( X )) !! Vector of functions valuated real ( pr ), intent ( out ) :: df ( size ( X ), size ( X )) !! Jacobian matrix integer , intent ( in ) :: max_iterations !! Maximum number of iterations to solve the point integer , intent ( out ) :: iters !! Number of iterations needed to converge the point integer :: ia integer :: iP integer :: nc real ( pr ) :: X0 ( size ( X )) real ( pr ) :: dX ( size ( X )) nc = size ( z0 ) iP = np * nc + np + 1 ia = np * nc + np + 2 X0 = X F = 1 dX = 1 do iters = 1 , max_iterations call px_F_NP ( model = model , z0 = z0 , zi = zi , np = np , T = T , beta_w = beta_w , X = X , ns = ns , S = S , F = F , dF = dF ) if ( any ( isnan ( F ))) then X = X - 0.9 * dX cycle end if dX = solve_system ( dF , - F ) if ( maxval ( abs ( F )) < 1e-9_pr ) exit do while ( abs ( exp ( X ( iP )) - exp ( X ( iP ) + dX ( iP ))) > 10 ) dX = dX * 0.9 end do X = X + dX end do end subroutine solve_point subroutine update_specification ( its , nc , np , X , dF , dXdS , ns , dS ) !! # update_specification !! Change the specified variable for the next step. !! !! # Description !! Using the information of a converged point and the Jacobian matrix of !! the function. It is possible to determine the sensitivity of the !! variables with respect to the specification. This information is used !! to update the specification for the next point. Choosing the variable !! with the highest sensitivity. !! This can be done by solving the system of equations: !! !!  !! J \\frac{dX}{dS} + \\frac{dF}{dS} = 0 !!  !! !! for the  \\frac{dX}{dS}  vector. The variable with the highest value !! of  \\frac{dX}{dS}  is chosen as the new specification. !! !! # References !! integer , intent ( in ) :: its !! Iterations to solve the current point. integer , intent ( in ) :: nc !! Number of components in the mixture. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables. real ( pr ), intent ( in out ) :: dF (:, :) !! Jacobian matrix. real ( pr ), intent ( in out ) :: dXdS (:) !! Sensitivity of the variables wrt the specification. integer , intent ( in out ) :: ns !! Number of the specified variable. real ( pr ), intent ( in out ) :: dS !! Step size of the specification for the next point. real ( pr ) :: dFdS ( size ( X )) !! Sensitivity of the functions wrt the specification. integer :: i integer :: lb !! Lower bound of each phase integer :: ub !! Upper bound of each phase dFdS = 0 dFdS ( size ( X )) = - 1 dXdS = solve_system ( dF , - dFdS ) ns = maxloc ( abs ( dXdS ), dim = 1 ) ! ======================================================================== ! For each phase, check if the mole fractions are too low. ! this can be related to criticality and it is useful to force the ! specification of compositions. ! ------------------------------------------------------------------------ do i = 1 , np lb = ( i - 1 ) * nc + 1 ub = i * nc if ( maxval ( abs ( X ( lb : ub ))) < 0.3 ) then ns = lb + maxloc ( abs ( X ( lb : ub )), dim = 1 ) - 1 exit end if end do dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) ! We adapt the step size to the number of iterations, the desired number ! of iterations for each point is around 3. dS = dS * 3._pr / its end subroutine update_specification subroutine detect_critical ( nc , np , X , dXdS , ns , dS , S ) !! # detect_critical !! Detect if the system is close to a critical point. !! !! # Description !! When the system is close to a critical point, the \\ln K_i&#94;l values !! are close to zero, since the composition of the incipient phase and the !! l phase are similar (equal in the critical point). This can be used !! to detect if the system is close to a critical point and force a jump !! above it. !! !! # References !! integer , intent ( in ) :: nc !! Number of components in the mixture. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables. real ( pr ), intent ( in out ) :: dXdS (:) !! Sensitivity of the variables wrt the specification. integer , intent ( in out ) :: ns !! Number of the specified variable. real ( pr ), intent ( in out ) :: dS !! Step size of the specification for the next point. real ( pr ), intent ( in out ) :: S !! Specification value. integer :: i , lb , ub do i = 1 , np lb = ( i - 1 ) * nc + 1 ub = i * nc do while ( maxval ( abs ( X ( lb : ub ))) < 0.3 ) if ( nc == 2 ) then dS = 0 exit end if X = X + dXdS * dS end do end do end subroutine detect_critical subroutine get_values_from_X ( X , np , z0 , zi , beta_w , x_l , w , betas , P , alpha ) !! # get_values_from_X !! Extract the values of the variables from the vector X. !! real ( pr ), intent ( in ) :: X (:) !! Vector of variables. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in ) :: z0 (:) !! Initial mixture composition. real ( pr ), intent ( in ) :: zi (:) !! Second mixture composition. real ( pr ), intent ( in ) :: beta_w !! Reference phase beta. real ( pr ), intent ( out ) :: x_l ( np , size ( z0 )) !! Mole fractions of the main phases. real ( pr ), intent ( out ) :: w ( size ( z0 )) !! Mole fractions of the incipient phase. real ( pr ), intent ( out ) :: betas ( np ) !! Fractions of the main phases. real ( pr ), intent ( out ) :: P !! Pressure [bar]. real ( pr ), intent ( out ) :: alpha !! alpha. real ( pr ) :: z ( size ( z0 )) real ( pr ) :: K ( np , size ( z0 )) integer :: nc !! Number of components. integer :: i !! Loop index. integer :: l !! Phase index. integer :: lb !! Lower bound of each phase. integer :: ub !! Upper bound of each phase. nc = size ( z0 ) ! ======================================================================== ! Extract variables from the vector X ! ------------------------------------------------------------------------ alpha = X ( np * nc + np + 2 ) call get_z ( alpha , z0 , zi , z ) P = exp ( X ( np * nc + np + 1 )) do l = 1 , np lb = ( l - 1 ) * nc + 1 ub = l * nc K ( l , :) = exp ( X ( lb : ub )) end do betas = X ( np * nc + 1 : np * nc + np ) w = z / matmul ( betas , K ) + beta_w do l = 1 , np x_l ( l , :) = K ( l , :) * w end do end subroutine get_values_from_X subroutine write_envelope_PX_MP ( env , unit ) class ( PXEnvelMP ), intent ( in ) :: env integer , intent ( in ) :: unit integer :: i , j integer :: np , nc real ( pr ) :: P , T , alpha real ( pr ), allocatable :: betas (:) real ( pr ), allocatable :: w (:) real ( pr ), allocatable :: x_l (:, :) np = size ( env % points ) nc = size ( env % points ( 1 )% w ) do i = 1 , np alpha = env % alpha ( i ) P = env % points ( i )% P T = env % points ( i )% T betas = env % points ( i )% betas w = env % points ( i )% w x_l = env % points ( i )% x_l write ( unit , \"(*(E15.5,2x))\" ) alpha , P , T , betas , w , ( x_l ( j , :), j = 1 , size ( x_l , dim = 1 )) end do end subroutine write_envelope_PX_MP end module yaeos__equilibria_boundaries_phase_envelopes_mp_px","tags":"","url":"sourcefile/phase_envelopes_px_mp.f90.html"},{"title":"ge_models.f90 – yaeos","text":"Source Code module yaeos__models_ge !! Excess Gibbs Models. use yaeos__constants , only : pr , R use yaeos__models_base , only : BaseModel implicit none type , extends ( BaseModel ), abstract :: GeModel !! Excess Gibbs energy model. contains procedure ( excess_gibbs ), deferred :: excess_gibbs procedure :: ln_activity_coefficient => ln_activity_coefficient procedure :: excess_enthalpy => excess_enthalpy procedure :: excess_entropy => excess_entropy end type abstract interface subroutine excess_gibbs ( self , n , T , Ge , GeT , GeT2 , Gen , GeTn , Gen2 ) !! Calculate Excess Gibbs and its derivatives. !! import pr , GeModel class ( GeModel ), intent ( in ) :: self !! Model real ( pr ), intent ( in ) :: n (:) !! Moles vector real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: Ge !! Excess Gibbs free energy real ( pr ), optional , intent ( out ) :: GeT !! \\frac{dG&#94;E}{dT} real ( pr ), optional , intent ( out ) :: GeT2 !! \\frac{d&#94;2G&#94;E}{dT&#94;2} real ( pr ), optional , intent ( out ) :: Gen ( size ( n )) !! \\frac{dG&#94;E}{dn} real ( pr ), optional , intent ( out ) :: GeTn ( size ( n )) !! \\frac{d&#94;2G&#94;E}{dTdn} real ( pr ), optional , intent ( out ) :: Gen2 ( size ( n ), size ( n )) !! \\frac{d&#94;2G&#94;E}{dn&#94;2} end subroutine end interface contains subroutine ln_activity_coefficient ( self , n , T , lngamma , dlngammadT , dlngammadn ) !! Calculate natural logarithm of activity coefficients. !! !!  !!  \\ln \\gamma_i = \\frac{1}{RT} \\frac{\\partial G&#94;E}{\\partial n_i} !!  !! class ( GeModel ), intent ( in ) :: self !! Model real ( pr ), intent ( in ) :: n (:) !! Moles vector real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: lngamma (:) !! Natural logarithm of activity coefficients real ( pr ), optional , intent ( out ) :: dlngammadT ( size ( n )) !! \\frac{d\\ln \\gamma_i}{dT} real ( pr ), optional , intent ( out ) :: dlngammadn ( size ( n ), size ( n )) !! \\frac{d\\ln \\gamma_i}{dn_j} real ( pr ) :: Ge , Gen ( size ( n )), GeTn ( size ( n )), Gen2 ( size ( n ), size ( n )) logical :: tt , dt , dn tt = present ( lngamma ) dt = present ( dlngammadT ) dn = present ( dlngammadn ) if ( tt . and . . not . dt . and . . not . dn ) then call self % excess_gibbs ( n , T , Ge = Ge , Gen = Gen ) else if (. not . dn ) then call self % excess_gibbs ( n , T , Ge = Ge , Gen = Gen , GeTn = GeTn ) else call self % excess_gibbs ( n , T , Ge = Ge , Gen = Gen , GeTn = GeTn , Gen2 = Gen2 ) end if if ( tt ) lngamma = Gen / ( R * T ) if ( dt ) dlngammadT = ( GeTn - Gen / T ) / ( R * T ) if ( dn ) dlngammadn = Gen2 / ( R * T ) end subroutine subroutine excess_enthalpy ( self , n , T , He , HeT , Hen ) !! Calculate Excess enthalpy and its derivatives. !! !!  !! H&#94;E = G&#94;E - T \\frac{\\partial G&#94;E}{\\partial T} !!  !! !! ## References !! [1] https://en.wikipedia.org/wiki/Gibbs%E2%80%93Helmholtz_equation !! class ( GeModel ), intent ( in ) :: self !! Model real ( pr ), intent ( in ) :: n (:) !! Moles vector real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: He !! Excess enthalpy real ( pr ), optional , intent ( out ) :: HeT !! \\frac{dH&#94;E}{dT} real ( pr ), optional , intent ( out ) :: Hen (:) !! \\frac{dH&#94;E}{dn} real ( pr ) :: Ge , GeT , GeT2 , Gen ( size ( n )), GeTn ( size ( n )) call self % excess_gibbs (& n , T , Ge = Ge , GeT = GeT , GeT2 = GeT2 , Gen = Gen , GeTn = GeTn & ) if ( present ( He )) He = Ge - T * GeT if ( present ( HeT )) HeT = - T * GeT2 if ( present ( Hen )) Hen = Gen - T * GeTn end subroutine excess_enthalpy subroutine excess_entropy ( self , n , T , Se , SeT , Sen ) !! Calculate Excess entropy and its derivatives. !! !!  !! S&#94;E = \\frac{H&#94;E - G&#94;E}{T} !!  !! class ( GeModel ), intent ( in ) :: self !! Model real ( pr ), intent ( in ) :: n (:) !! Moles vector real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: Se !! Excess entropy real ( pr ), optional , intent ( out ) :: SeT !! \\frac{dS&#94;E}{dT} real ( pr ), optional , intent ( out ) :: Sen (:) !! \\frac{dS&#94;E}{dn} real ( pr ) :: Ge , GeT , GeT2 , GeTn ( size ( n )) call self % excess_gibbs ( n , T , Ge = Ge , GeT = GeT , GeT2 = GeT2 , GeTn = GeTn ) if ( present ( Se )) Se = - GeT if ( present ( SeT )) SeT = - GeT2 if ( present ( Sen )) Sen = - GeTn end subroutine excess_entropy end module","tags":"","url":"sourcefile/ge_models.f90.html"},{"title":"generic_cubic.f90 – yaeos","text":"Source Code module yaeos__models_ar_genericcubic use yaeos__constants , only : pr use yaeos__models_ar , only : ArModel use yaeos__substance , only : Substances implicit none type , abstract :: AlphaFunction !! Abstract derived type that describe the required !! procedure for an alpha function. contains procedure ( abs_alpha ), deferred :: alpha end type AlphaFunction type , abstract :: CubicMixRule !! Abstract derived type that describe the required !! procedure for a mixing rule on a Cubic EoS logical :: dn2 = . false . !! Calculate second order derivatives contains procedure ( abs_Dmix ), deferred :: Dmix procedure ( abs_Bmix ), deferred :: Bmix procedure ( abs_D1mix ), deferred :: D1mix end type CubicMixRule type , extends ( ArModel ) :: CubicEoS !! # Cubic Equation of State. !! !! Generic Cubic Equation of State as defined by Michelsen and Mollerup !! with a \\delta_1 parameter that is not constant, !! and a \\delta_2 parameter that depends on it. In the case of a !! two parameter EoS like PengRobinson the \\delta_1 is the same for !! all components so it can be considered as a constant instead of a !! variable. The expression of the Equation is: !! !!  !!   P = \\frac{RT}{V-B} !!       - \\frac{D(T_r)}{(V+B\\Delta_1)(V+B\\Delta_2)} !!  class ( CubicMixRule ), allocatable :: mixrule !! # CubicMixRule derived type. !! Uses the abstract derived type `CubicMixRule` to define the !! mixing rule that the CubicEoS will use. It includes internally !! three methods to calculate the corresponding parameters for the !! Cubic EoS: `Dmix`, `Bmix` and `D1mix`. !! !! # Examples !! ## Calculation of the B parameter. !! ```fortran !! use yaeos, only: CubicEoS, PengRobinson76 !! type(CubicEoS) :: eos !! eos = PengRobinson76(tc, pc, w) !! call eos%mixrule%Bmix(n, eos%b, B, dBi, dBij) !! ``` !! ## Calculation of the D parameter. !! ```fortran !! use yaeos, only: CubicEoS, PengRobinson76 !! type(CubicEoS) :: eos !! eos = PengRobinson76(tc, pc, w) !! !! ! The mixing rule takes the `a` parameters of the components so !! ! they should be calculated externally !! call eos%alpha%alpha(Tr, a, dadt, dadt2) !! a = a * eos%ac !! dadt = dadt * eos%ac / eos%components%Tc !! dadt = dadt * eos%ac / eos%components%Tc**2 !! ! Calculate parameter !! call eos%mixrule%Dmix(n, T, a, dadt, dadt2, D, dDdT, dDdT2, dDi, dDidT, dDij) !! ``` !! ## Calculation of the D1 parameter. !! ```fortran !! use yaeos, only: CubicEoS, PengRobinson76 !! type(CubicEoS) :: eos !! eos = PengRobinson76(tc, pc, w) !! call eos%mixrule%D1mix(n, eos%del1, D1, dD1i, dD1ij) !! ``` class ( AlphaFunction ), allocatable :: alpha !! # AlphaFunction derived type. !! Uses the abstract derived type `AlphaFunction` to define the !! Alpha function that the CubicEoS will use. The Alpha function !! receives the reduced temperature and returns the values of alpha !! and its derivatives, named `a`, `dadt` and `dadt2` respectively. !! !! # Examples !! ## Callign the AlphaFunction of a setted up model. !! ```fortran !! use yaeos, only: CubicEoS, PengRobinson76 !! !! type(CubicEoS) :: eos !! eos = PengRobinson76(tc, pc, w) !! call eos%alpha%alpha(Tr, a, dadt, dadt2) !! ``` real ( pr ), allocatable :: ac (:) !! Attractive critical parameter real ( pr ), allocatable :: b (:) !! Repulsive parameter real ( pr ), allocatable :: del1 (:) !! \\delta_1 paramter real ( pr ), allocatable :: del2 (:) !! \\delta_2 paramter contains procedure :: residual_helmholtz => GenericCubic_Ar procedure :: get_v0 => v0 procedure :: volume => volume procedure :: set_delta1 => set_delta1 procedure :: set_mixrule => set_mixrule end type CubicEoS abstract interface subroutine abs_alpha ( self , Tr , a , dadt , dadt2 ) import AlphaFunction , pr class ( AlphaFunction ), intent ( in ) :: self real ( pr ), intent ( in ) :: Tr (:) real ( pr ), intent ( out ) :: a (:), dadt (:), dadt2 (:) end subroutine abs_alpha subroutine abs_Dmix ( self , n , T , & ai , daidt , daidt2 , & D , dDdT , dDdT2 , dDi , dDidT , dDij & ) import CubicMixRule , pr class ( CubicMixRule ), intent ( in ) :: self real ( pr ), intent ( in ) :: T , n (:) real ( pr ), intent ( in ) :: ai (:), daidt (:), daidt2 (:) real ( pr ), intent ( out ) :: D , dDdT , dDdT2 , dDi (:), dDidT (:), dDij (:, :) end subroutine abs_Dmix subroutine abs_Bmix ( self , n , bi , B , dBi , dBij ) import CubicMixRule , pr class ( CubicMixRule ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: bi (:) real ( pr ), intent ( out ) :: B , dBi (:), dBij (:, :) end subroutine abs_Bmix subroutine abs_D1mix ( self , n , d1i , D1 , dD1i , dD1ij ) import pr , CubicMixRule class ( CubicMixRule ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: d1i (:) real ( pr ), intent ( out ) :: D1 real ( pr ), intent ( out ) :: dD1i (:) real ( pr ), intent ( out ) :: dD1ij (:, :) end subroutine abs_D1mix end interface contains subroutine GenericCubic_Ar (& self , n , V , T , Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) !! Residual Helmholtz Energy for a generic Cubic Equation of State. !! !! Calculates the residual Helmholtz Energy for a generic Cubic EoS as !! defined by Michelsen and Møllerup: !! !!  !!   P = \\frac{RT}{V-b} !!       - \\frac{a_c\\alpha(T_r)}{(V+b\\delta_1)(V+b\\delta_2)} !!  !! !! This routine assumes that the \\delta_1 is not a constant parameter !! (as it uses to be in classical Cubic EoS) to be compatible with the !! three parameter EoS RKPR where delta_1 is not a constant and !! has its own mixing rule. !! use yaeos__models_ar_genericcubic_base , only : generic => GenericCubic_Ar use yaeos__constants , only : R class ( CubicEoS ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) !! Number of moles real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), optional , intent ( out ) :: ar !! Residual Helmholtz real ( pr ), optional , intent ( out ) :: arv !! \\frac{dAr}{dV} real ( pr ), optional , intent ( out ) :: ArT !! \\frac{dAr}{dT} real ( pr ), optional , intent ( out ) :: artv !! \\frac{d&#94;2Ar}{dTdV} real ( pr ), optional , intent ( out ) :: arv2 !! \\frac{d&#94;2Ar}{dV&#94;2} real ( pr ), optional , intent ( out ) :: ArT2 !! \\frac{d&#94;2Ar}{dT&#94;2} real ( pr ), optional , intent ( out ) :: Arn ( size ( n )) !! \\frac{dAr}{dn_i} real ( pr ), optional , intent ( out ) :: ArVn ( size ( n )) !! \\frac{d&#94;2Ar}{dVdn_i} real ( pr ), optional , intent ( out ) :: ArTn ( size ( n )) !! \\frac{d&#94;2Ar}{dTdn_i} real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) !! \\frac{d&#94;2Ar}{dn_{ij}} real ( pr ) :: B , dBi ( size ( n )), dBij ( size ( n ), size ( n )) real ( pr ) :: D , dDi ( size ( n )), dDij ( size ( n ), size ( n )), dDidT ( size ( n )), dDdT , dDdT2 real ( pr ) :: totn real ( pr ) d1 , dD1i ( size ( n )), dD1ij ( size ( n ), size ( n )) real ( pr ) :: Tr ( size ( n )), a ( size ( n )), dadt ( size ( n )), dadt2 ( size ( n )) integer :: nc nc = size ( n ) TOTN = sum ( n ) Tr = T / self % components % Tc ! ======================================================================== ! Attractive parameter and derivatives ! ------------------------------------------------------------------------ call self % alpha % alpha ( Tr , a , dadt , dadt2 ) a = self % ac * a dadt = self % ac * dadt / self % components % Tc dadt2 = self % ac * dadt2 / self % components % Tc ** 2 ! ======================================================================== ! Mixing rules ! ------------------------------------------------------------------------ call self % mixrule % D1mix ( n , self % del1 , D1 , dD1i , dD1ij ) call self % mixrule % Bmix ( n , self % b , B , dBi , dBij ) call self % mixrule % Dmix (& n , T , a , dadt , dadt2 , D , dDdT , dDdT2 , dDi , dDidT , dDij & ) call generic (& n , V , T , & B , dBi , dBij , & D , dDi , dDij , dDidT , dDdT , dDdT2 , & D1 , dD1i , dD1ij , & Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) end subroutine GenericCubic_Ar subroutine set_delta1 ( self , delta1 ) class ( CubicEoS ) :: self real ( pr ), intent ( in ) :: delta1 (:) self % del1 = delta1 self % del2 = ( 1._pr - delta1 ) / ( 1._pr + delta1 ) end subroutine set_delta1 subroutine set_mixrule ( self , mixrule ) class ( CubicEoS ), intent ( in out ) :: self class ( CubicMixRule ), intent ( in ) :: mixrule if ( allocated ( self % mixrule )) deallocate ( self % mixrule ) self % mixrule = mixrule end subroutine set_mixrule function v0 ( self , n , p , t ) !! Cubic EoS volume initializer. !! For a Cubic Equation of State, the covolume calculated with the mixing !! rule is a good estimate for the initial volume solver on the liquid !! region. class ( CubicEoS ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:), p , t real ( pr ) :: v0 real ( pr ) :: dbi ( size ( n )), dbij ( size ( n ), size ( n )) call self % mixrule % Bmix ( n , self % b , v0 , dbi , dbij ) end function v0 subroutine volume ( eos , n , P , T , V , root_type ) !! # Cubic EoS volume solver !! Volume solver optimized for Cubic Equations of State. !! !! @warn !! This routine intends to use the analyitical solution of the cubic !! equation, but due to errors in the solutions it is not used. And !! the general volume solver by Michelsen is used instead. !! @endwarn !! !! # Description !! Cubic equations can be analytically solved. Using an anallytical !! solution provides the best possible solution in terms of speed and !! precision. This subroutine uses the modified cardano method proposed !! by Rosendo. !! !! # Examples !! !! ```fortran !!  use yaeos, only: CubicEoS, PengRobinson !!  type(CubicEoS) :: eos !! !!  eos = PengRobinson(tc, pc, w) !!  ! Possible roots to solve !!  call eos%volume(n, P, T, V, \"liquid\") !!  call eos%volume(n, P, T, V, \"vapor\") !!  call eos%volume(n, P, T, V, \"stable\") !! ``` !! !! # References !! !! - [1] \"Thermodynamic Models: Fundamental and Computational Aspects\", !!  Michael L. Michelsen, Jørgen M. Mollerup. !!  Tie-Line Publications, Denmark (2004) !! [doi](http://dx.doi.org/10.1016/j.fluid.2005.11.032) !! !! - [2] \"A Note on the Analytical Solution of Cubic Equations of State !! in Process Simulation\", Rosendo Monroy-Loperena !! [doi](https://dx.doi.org/10.1021/ie2023004) use yaeos__constants , only : R use yaeos__math_linalg , only : cubic_roots , cubic_roots_rosendo use yaeos__models_solvers , only : volume_michelsen class ( CubicEoS ), intent ( in ) :: eos real ( pr ), intent ( in ) :: n (:), P , T real ( pr ), intent ( out ) :: V character ( len =* ), intent ( in ) :: root_type real ( pr ) :: z ( size ( n )) real ( pr ) :: cp ( 4 ), rr ( 3 ) complex ( pr ) :: cr ( 3 ) integer :: flag real ( pr ) :: V_liq , V_vap real ( pr ) :: Ar , AT_Liq , AT_Vap real ( pr ) :: Bmix , dBi ( size ( n )), dBij ( size ( n ), size ( n )) real ( pr ) :: D , dDi ( size ( n )), dDij ( size ( n ), size ( n )), dDidT ( size ( n )), dDdT , dDdT2 real ( pr ) :: D1 , D2 , dD1i ( size ( n )), dD1ij ( size ( n ), size ( n )) real ( pr ) :: Tr ( size ( n )) real ( pr ) :: a ( size ( n )), dadt ( size ( n )), dadt2 ( size ( n )) real ( pr ) :: totn call volume_michelsen ( eos , n = n , P = P , T = T , V = V , root_type = root_type ) return totn = sum ( n ) z = n / totn Tr = T / eos % components % Tc ! ======================================================================== ! Attractive parameter and derivatives ! ------------------------------------------------------------------------ call eos % alpha % alpha ( Tr , a , dadt , dadt2 ) a = eos % ac * a dadt = eos % ac * dadt / eos % components % Tc dadt2 = eos % ac * dadt2 / eos % components % Tc ** 2 ! ======================================================================== ! Mixing rules ! ------------------------------------------------------------------------ call eos % mixrule % D1mix ( z , eos % del1 , D1 , dD1i , dD1ij ) call eos % mixrule % Bmix ( z , eos % b , Bmix , dBi , dBij ) call eos % mixrule % Dmix (& z , T , a , dadt , dadt2 , D , dDdT , dDdT2 , dDi , dDidT , dDij & ) D2 = ( 1._pr - D1 ) / ( 1._pr + D1 ) cp ( 1 ) = - P cp ( 2 ) = - P * Bmix * ( D1 + D2 - 1 ) + R * T cp ( 3 ) = - P * ( D1 * D2 * Bmix ** 2 - D1 * Bmix ** 2 - D2 * Bmix ** 2 ) + R * T * Bmix * ( D1 + D2 ) - D cp ( 4 ) = P * D1 * D2 * Bmix ** 3 + R * T * D1 * D2 * Bmix ** 2 + D * Bmix ! call cubic_roots(cp, rr, cr, flag) ! call cubic_roots_rosendo(cp, rr, cr, flag) select case ( flag ) case ( - 1 ) V_liq = rr ( 1 ) V_vap = rr ( 3 ) if ( V_liq < 0 ) V_liq = V_vap case ( 1 ) V_liq = rr ( 1 ) V_vap = rr ( 1 ) end select select case ( root_type ) case ( \"liquid\" ) V = V_liq case ( \"vapor\" ) V = V_vap case ( \"stable\" ) ! AT is something close to Gr(P,T) call eos % residual_helmholtz ( z , V_liq , T , Ar = Ar ) AT_Liq = ( Ar + V_liq * P ) / ( T * R ) - sum ( z ) * log ( V_liq ) call eos % residual_helmholtz ( z , V_vap , T , Ar = Ar ) AT_Vap = ( Ar + V_vap * P ) / ( T * R ) - sum ( z ) * log ( V_vap ) if ( AT_liq <= AT_vap ) then V = V_liq else V = V_vap end if end select V = totn * V end subroutine volume end module yaeos__models_ar_genericcubic","tags":"","url":"sourcefile/generic_cubic.f90.html"},{"title":"phase_envelopes_px.f90 – yaeos","text":"Source Code module yaeos__equilibria_boundaries_phase_envelopes_px !! Phase boundaries line on the P\\alpha plane calculation procedures. use yaeos__constants , only : pr use yaeos__models , only : ArModel use yaeos__equilibria_equilibrium_state , only : EquilibriumState use yaeos__math_continuation , only : & continuation , continuation_solver , continuation_stopper use yaeos__equilibria_boundaries_auxiliar , only : get_z implicit none private public :: PXEnvel2 public :: px_envelope_2ph type :: CriticalPoint !! Critical point real ( pr ) :: alpha !! \\alpha real ( pr ) :: P !! Pressure [bar] end type CriticalPoint type :: PXEnvel2 !! Two-phase PX envelope. !! Phase boundary line of a fluid at constant temperature !! with variation in composition. real ( pr ), allocatable :: alpha (:) !! Second fluid molar fraction real ( pr ), allocatable :: z0 (:) !! Original fluid composition real ( pr ), allocatable :: z_inj (:) !! Second fluid composition type ( EquilibriumState ), allocatable :: points (:) !! Each point through the line. type ( CriticalPoint ), allocatable :: cps (:) !! Critical points found along the line. end type PXEnvel2 ! Private volumes of each phase to share between functions real ( pr ), private :: Vz !! Main phase volume [L/mol] real ( pr ), private :: Vy !! Incipient phase volume [L/mol] contains function px_envelope_2ph (& model , z0 , alpha0 , z_injection , first_point , & points , iterations , delta_0 , specified_variable_0 , & solver , stop_conditions & ) result ( envelopes ) !! PX two-phase envelope calculation procedure. !! !! Phase envelope calculation using the continuation method. !! Defaults to solving the saturation temperature and continues with !! an increment in it. The variable to specify can be changed by modifying !! `specified_variable_0` with the corresponding variable number. ! ======================================================================== use yaeos__auxiliar , only : optval class ( ArModel ), intent ( in ) :: model !! Thermodyanmic model real ( pr ), intent ( in ) :: z0 (:) !! Vector of molar fractions of the global composition (main phase) real ( pr ), intent ( in ) :: alpha0 !! First point of alpha real ( pr ), intent ( in ) :: z_injection (:) !! Vector of molar fractions of the injection fluid type ( EquilibriumState ) :: first_point integer , optional , intent ( in ) :: points !! Maxmimum number of points, defaults to 500 integer , optional , intent ( in ) :: iterations !! Point solver maximum iterations, defaults to 100 real ( pr ), optional , intent ( in ) :: delta_0 !! Initial extrapolation \\Delta integer , optional , intent ( in ) :: specified_variable_0 !! Position of specified variable, since the vector of variables is !! X = [lnK_i, \\dots, lnP, \\alpha] the values for specification !! will be [1 \\dots nc] for the equilibria constants, nc+1 for !! lnP and nc + 2 for \\alpha. procedure ( continuation_solver ), optional :: solver !! Specify solver for each point, defaults to a full newton procedure procedure ( continuation_stopper ), optional :: stop_conditions !! Function that returns true if the continuation method should stop type ( PXEnvel2 ) :: envelopes ! ------------------------------------------------------------------------ integer :: nc !! Number of components integer :: ns !! Number of specified variable real ( pr ) :: dS0 !! Initial specification step real ( pr ) :: S0 !! Initial specification value real ( pr ) :: z ( size ( z0 )) !! Composition at some point integer :: max_points !! Maximum number of points integer :: max_iterations !! Maximum number of iterations real ( pr ) :: X ( size ( z ) + 2 ), T real ( pr ), allocatable :: XS (:, :) character ( len = 14 ) :: kind ! ======================================================================== ! Handle input ! ------------------------------------------------------------------------ call get_z ( alpha0 , z0 , z_injection , z ) kind = first_point % kind nc = size ( z ) max_points = optval ( points , 500 ) max_iterations = optval ( iterations , 100 ) ns = optval ( specified_variable_0 , nc + 2 ) dS0 = optval ( delta_0 , 0.1_pr ) ! Correctly define the K-values based on the provided incipient point. select case ( first_point % kind ) case ( \"bubble\" , \"liquid-liquid\" ) X (: nc ) = log ( first_point % y / z ) case ( \"dew\" ) X (: nc ) = log ( first_point % x / z ) end select T = first_point % T X ( nc + 1 ) = log ( first_point % P ) X ( nc + 2 ) = alpha0 S0 = X ( ns ) ! print *, X, S0 ! call exit allocate ( envelopes % points ( 0 ), envelopes % cps ( 0 ), envelopes % alpha ( 0 )) test_numdiff : block real ( pr ) :: F ( size ( X )), df ( size ( X ), size ( X )), numdiff ( size ( X ), size ( X )) real ( pr ) :: FdX ( size ( X )), dx ( size ( X )), dFdS ( size ( X )) real ( pr ) :: FdX2 ( size ( X )) integer :: i integer :: loc ( 2 ) real ( pr ) :: maxerr exit test_numdiff do i = 1 , size ( X ) dx = 0 dx ( i ) = 1.e-5_pr * X ( i ) call foo ( X - dx , ns , S0 , FdX , df , dFdS ) call foo ( X + dx , ns , S0 , FdX2 , df , dFdS ) call foo ( X , ns , S0 , F , df , dFdS ) numdiff (:, i ) = ( FdX2 - FdX ) / ( 2 * dx ( i )) end do loc = maxloc ( abs ( numdiff - df )) maxerr = abs (& ( numdiff ( loc ( 1 ), loc ( 2 )) - df ( loc ( 1 ), loc ( 2 ))& ) / numdiff ( loc ( 1 ), loc ( 2 ))) if ( maxerr > 0.01_pr ) then print * , \"ERROR: PXEnvel2 Numerical differentiation failed\" loc = maxloc ( abs ( numdiff - df )) print * , loc print * , df ( loc ( 1 ), loc ( 2 )), numdiff ( loc ( 1 ), loc ( 2 )) error stop 1 end if end block test_numdiff ! ======================================================================== ! Trace the line using the continuation method. ! ------------------------------------------------------------------------ XS = continuation (& foo , X , ns0 = ns , S0 = S0 , & dS0 = dS0 , max_points = max_points , solver_tol = 1.e-5_pr , & update_specification = update_spec , & solver = solver , stop = stop_conditions & ) contains recursive subroutine foo ( X , ns , S , F , dF , dFdS ) !! Function that needs to be solved at each envelope point real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( out ) :: F (:) real ( pr ), intent ( out ) :: dF (:, :) real ( pr ), intent ( out ) :: dFdS (:) character ( len = 14 ) :: kind_z , kind_y real ( pr ) :: y ( nc ) real ( pr ) :: lnphip_z ( nc ), lnphip_y ( nc ) real ( pr ) :: dlnphi_dt_z ( nc ), dlnphi_dt_y ( nc ) real ( pr ) :: dlnphi_dp_z ( nc ), dlnphi_dp_y ( nc ) real ( pr ) :: dlnphi_dn_z ( nc , nc ), dlnphi_dn_y ( nc , nc ) real ( pr ) :: P , K ( nc ), alpha , dzda ( nc ) integer :: i , j F = 0 dF = 0 K = exp ( X (: nc )) P = exp ( X ( nc + 1 )) alpha = X ( nc + 2 ) call get_z ( alpha , z0 , z_injection , z , dzda ) y = K * z select case ( kind ) case ( \"bubble\" ) kind_z = \"liquid\" kind_y = \"vapor\" case ( \"dew\" ) kind_z = \"vapor\" kind_y = \"liquid\" case default kind_z = \"stable\" kind_y = \"stable\" end select call model % lnphi_pt (& z , P = P , T = T , V = Vz , root_type = kind_z , & lnphi = lnphip_z , dlnPhidt = dlnphi_dt_z , & dlnPhidp = dlnphi_dp_z , dlnphidn = dlnphi_dn_z & ) call model % lnphi_pt (& y , P = P , T = T , V = Vy , root_type = kind_y , & lnphi = lnphip_y , dlnPhidt = dlnphi_dt_y , & dlnPhidp = dlnphi_dp_y , dlnphidn = dlnphi_dn_y & ) F (: nc ) = X (: nc ) + lnphip_y - lnphip_z F ( nc + 1 ) = sum ( y - z ) F ( nc + 2 ) = X ( ns ) - S ! Jacobian Matrix do i = 1 , nc do j = 1 , nc df ( i , j ) = y ( j ) * dlnphi_dn_y ( i , j ) end do df ( i , i ) = df ( i , i ) + 1 df ( i , nc + 2 ) = sum ( K * dlnphi_dn_y ( i , :) * dzda - dlnphi_dn_z ( i , :) * dzda ) end do df (: nc , nc + 1 ) = P * ( dlnphi_dp_y - dlnphi_dp_z ) df ( nc + 1 , : nc ) = y df ( nc + 1 , nc + 2 ) = sum ( dzda * ( K - 1 )) df ( nc + 2 , :) = 0 df ( nc + 2 , ns ) = 1 dFdS = 0 dFdS ( nc + 2 ) = - 1 end subroutine foo subroutine update_spec ( X , ns , S , dS , dXdS , step_iters ) !! Update the specification during continuation. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables [lnK_i \\dots , lnT, lnP] integer , intent ( in out ) :: ns !! Number of specified variable in the vector real ( pr ), intent ( in out ) :: S !! Variable specification value real ( pr ), intent ( in out ) :: dS !! Step in specification real ( pr ), intent ( in out ) :: dXdS (:) !! Variation of variables with respect to specification integer , intent ( in ) :: step_iters !! Iterations used in the solver real ( pr ) :: maxdS ! ===================================================================== ! Update specification ! - Dont select T or P near critical points ! - Update dS wrt specification units ! - Set step ! --------------------------------------------------------------------- if ( maxval ( abs ( X (: nc ))) < 0.1_pr . and . abs ( Vz - Vy ) < 0.05 ) then ns = maxloc ( abs ( dXdS (: nc )), dim = 1 ) maxdS = 0.01_pr else ns = maxloc ( abs ( dXdS ), dim = 1 ) maxdS = 0.5_pr end if dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) dS = sign ( 1.0_pr , dS ) * minval ([ & max ( sqrt ( abs ( X ( ns )) / 1 0._pr ), 0.1_pr ), & abs ( dS ) * 3 / step_iters & ] & ) ! do while (maxval(abs(dXdS(:nc)*dS)) < 0.01) !    dS = dS*1.1_pr ! end do call save_point ( X , step_iters ) call detect_critical ( X , dXdS , ns , S , dS ) end subroutine update_spec subroutine save_point ( X , iters ) !! Save the converged point real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: iters type ( EquilibriumState ) :: point real ( pr ) :: y ( nc ), P , alpha P = exp ( X ( nc + 1 )) alpha = X ( nc + 2 ) y = exp ( X (: nc )) * z select case ( kind ) case ( \"bubble\" ) point = EquilibriumState (& kind = kind , x = z , Vx = Vz , y = y , Vy = Vy , & T = T , P = P , beta = 0._pr , iters = iters & ) case ( \"dew\" ) point = EquilibriumState (& kind = kind , x = y , Vx = Vy , y = z , Vy = Vz , & T = T , P = P , beta = 0._pr , iters = iters & ) case default point = EquilibriumState (& kind = \"saturation\" , x = z , Vx = Vz , y = y , Vy = Vy , & T = T , P = P , beta = 0._pr , iters = iters & ) end select envelopes % alpha = [ envelopes % alpha , alpha ] envelopes % points = [ envelopes % points , point ] end subroutine save_point subroutine detect_critical ( X , dXdS , ns , S , dS ) !! # `detect_critical` !! Critical point detection !! !! # Description !! If the values of lnK (X[:nc]) change sign then a critical point !! Has passed, since for this to happen all variables should pass !! through zero. Near critical points (lnK < 0.05) points are harder !! to converge, so more steps in the extrapolation vector are made to !! jump over the critical point. !! If the critical point is detected then the kind of the point is !! changed and the point is saved using an interpolation knowing that !! !!  !!   X_c = a * X + (1-a)*X_{new} !!  !! !! With X_c is the variables at the critical point, X_{new} !! is the new initialization point of the method and a is the !! parameter to interpolate the values. This subroutine finds the !! value of  a to obtain X_c. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables real ( pr ), intent ( in out ) :: dXdS (:) !! Variation of variables wrt S integer , intent ( in out ) :: ns !! Number of specified variable real ( pr ), intent ( in out ) :: S !! Specification value real ( pr ), intent ( in out ) :: dS !! Step in specification real ( pr ) :: Xc ( nc + 2 ) !! Value at (near) critical point real ( pr ) :: a !! Parameter for interpolation real ( pr ) :: Xold ( size ( X )) !! Old value of X real ( pr ) :: Xnew ( size ( X )) !! Value of the next initialization Xold = X do while ( maxval ( abs ( X (: nc ))) < 0.1_pr . and . abs ( Vz - Vy ) < 0.05_pr ) ! If near a critical point, jump over it if ( nc == 2 ) then exit end if S = S + dS X = X + dXdS * dS end do Xnew = X + dXdS * dS if ( all ( Xold (: nc ) * ( Xnew (: nc )) < 0 )) then select case ( kind ) case ( \"dew\" ) kind = \"bubble\" case ( \"bubble\" ) kind = \"dew\" case default kind = \"liquid-liquid\" end select ! 0 = a*X(ns) + (1-a)*Xnew(ns) Interpolation equation to get X(ns) = 0 a = - Xnew ( ns ) / ( X ( ns ) - Xnew ( ns )) Xc = a * X + ( 1 - a ) * Xnew envelopes % cps = [& envelopes % cps , & CriticalPoint ( P = exp ( Xc ( nc + 1 )), alpha = Xc ( nc + 2 )) & ] X = Xc + dXdS * dS if ( nc == 2 ) then X = Xc dS = 0 end if end if end subroutine detect_critical end function px_envelope_2ph end module yaeos__equilibria_boundaries_phase_envelopes_px","tags":"","url":"sourcefile/phase_envelopes_px.f90.html"},{"title":"implementations.f90 – yaeos","text":"Source Code module yaeos__models_ar_cubic_implementations use yaeos__constants , only : pr , R use yaeos__models_ar_genericcubic , only : CubicEoS use yaeos__substance , only : Substances implicit none !! Implemented Cubic Equations of State. !! !! - PengRobinson76 !! - PengRobinson78 !! - SoaveRedlichKwong !! - RKPR private public :: PengRobinson76 public :: PengRobinson78 public :: SoaveRedlichKwong public :: RKPR public :: PSRK public :: refit_rkpr_k contains type ( CubicEoS ) function PengRobinson76 ( tc , pc , w , kij , lij ) result ( model ) !! PengRobinson76. !! !! Using the critical constants setup the parameters to use the !! PengRobinson Equation of State !! !! - \\alpha(T_r) = (1 + k (1 - \\sqrt{T_r}))&#94;2 !! - k = 0.37464 + 1.54226 * \\omega - 0.26993 \\omega&#94;2  !! - a_c = 0.45723553  R&#94;2 T_c&#94;2 / P_c !! - b = 0.07779607r  R T_c/P_c !! - \\delta_1 = 1 + \\sqrt{2} !! - \\delta_2 = 1 - \\sqrt{2} !! !! There is also the optional posibility to include the k_{ij} and !! l_{ij} matrices. Using by default Classic Van der Waals mixing !! rules. !! !! After setting up the model, it is possible to redefine either the !! mixing rule or the alpha function using a different derived type !! defined outside the function. use yaeos__constants , only : pr , R use yaeos__substance , only : Substances use yaeos__models_ar_genericcubic , only : CubicEoS use yaeos__models_ar_cubic_alphas , only : AlphaSoave use yaeos__models_ar_cubic_quadratic_mixing , only : QMR real ( pr ), intent ( in ) :: tc (:) !! Critical Temperatures [K] real ( pr ), intent ( in ) :: pc (:) !! Critical Pressures [bar] real ( pr ), intent ( in ) :: w (:) !! Acentric Factors real ( pr ), optional , intent ( in ) :: kij (:, :) !! k_{ij} matrix real ( pr ), optional , intent ( in ) :: lij (:, :) !! l_{ij} matrix type ( Substances ) :: composition type ( QMR ) :: mixrule type ( AlphaSoave ) :: alpha integer :: nc integer :: i nc = size ( tc ) composition % tc = tc composition % pc = pc composition % w = w alpha % k = 0.37464_pr & + 1.54226_pr * composition % w & - 0.26993_pr * composition % w ** 2 if ( present ( kij )) then mixrule % k = kij else mixrule % k = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif if ( present ( lij )) then mixrule % l = lij else mixrule % l = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif model % components = composition model % ac = 0.45723553_pr * R ** 2 * composition % tc ** 2 / composition % pc model % b = 0.07779607_pr * R * composition % tc / composition % pc model % del1 = [( 1 + sqrt ( 2.0_pr ), i = 1 , nc )] model % del2 = [( 1 - sqrt ( 2.0_pr ), i = 1 , nc )] model % alpha = alpha model % mixrule = mixrule model % name = \"PR76\" end function PengRobinson76 type ( CubicEoS ) function PengRobinson78 ( tc , pc , w , kij , lij ) result ( model ) !! PengRobinson78. !! !! Using the critical constants setup the parameters to use the !! PengRobinson Equation of State !! !! - \\alpha(T_r) = (1 + k (1 - \\sqrt{T_r}))&#94;2 !! - k = 0.37464 + 1.54226 \\omega - 0.26992 \\omega&#94;2  \\text{ where } \\omega <=0.491 !! - k = 0.37464 + 1.48503 \\omega - 0.16442 \\omega&#94;2  + 0.016666 \\omega&#94;3 \\text{ where } \\omega > 0.491 !! - a_c = 0.45723553  R&#94;2 T_c&#94;2 / P_c !! - b = 0.07779607r  R T_c/P_c !! - \\delta_1 = 1 + \\sqrt{2} !! - \\delta_2 = 1 - \\sqrt{2} !! !! There is also the optional posibility to include the k_{ij} and !! l_{ij} matrices. Using by default Classic Van der Waals mixing !! rules. !! !! After setting up the model, it is possible to redefine either the !! mixing rule or the alpha function using a different derived type !! defined outside the function. use yaeos__constants , only : pr , R use yaeos__substance , only : Substances use yaeos__models_ar_genericcubic , only : CubicEoS use yaeos__models_ar_cubic_alphas , only : AlphaSoave use yaeos__models_ar_cubic_quadratic_mixing , only : QMR real ( pr ), intent ( in ) :: tc (:) !! Critical Temperatures [K] real ( pr ), intent ( in ) :: pc (:) !! Critical Pressures [bar] real ( pr ), intent ( in ) :: w (:) !! Acentric Factors real ( pr ), optional , intent ( in ) :: kij (:, :) !! k_{ij} matrix real ( pr ), optional , intent ( in ) :: lij (:, :) !! l_{ij} matrix type ( Substances ) :: composition type ( QMR ) :: mixrule type ( AlphaSoave ) :: alpha integer :: nc integer :: i nc = size ( tc ) composition % tc = tc composition % pc = pc composition % w = w allocate ( alpha % k ( nc )) where ( composition % w <= 0.491 ) alpha % k = 0.37464 + 1.54226 * composition % w - 0.26992 * composition % w ** 2 elsewhere alpha % k = 0.379642 + 1.48503 * composition % w - 0.164423 * composition % w ** 2 + 0.016666 * composition % w ** 3 end where if ( present ( kij )) then mixrule % k = kij else mixrule % k = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif if ( present ( lij )) then mixrule % l = lij else mixrule % l = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif model % components = composition model % ac = 0.45723553_pr * R ** 2 * composition % tc ** 2 / composition % pc model % b = 0.07779607_pr * R * composition % tc / composition % pc model % del1 = [( 1 + sqrt ( 2.0_pr ), i = 1 , nc )] model % del2 = [( 1 - sqrt ( 2.0_pr ), i = 1 , nc )] model % alpha = alpha model % mixrule = mixrule model % name = \"PR78\" end function PengRobinson78 type ( CubicEoS ) function SoaveRedlichKwong ( tc , pc , w , kij , lij ) result ( model ) !! SoaveRedlichKwong. !! !! Using the critical constants setup the parameters to use the !! SoaveRedlichKwong Equation of State !! !! - \\alpha(T_r) = (1 + k (1 - \\sqrt{T_r}))&#94;2 !! - k = 0.48 + 1.574 \\omega - 0.175 \\omega&#94;2  !! - a_c = 0.427480  R&#94;2 * T_c&#94;2/P_c !! - b = 0.086640  R T_c/P_c !! - \\delta_1 = 1 !! - \\delta_2 = 0 !! !! There is also the optional posibility to include the k_{ij} and l_{ij} !! matrices. Using by default Classic Van der Waals mixing rules. !! !! After setting up the model, it is possible to redefine either the !! mixing rule or the alpha function using a different derived type !! defined outside the function. use yaeos__models_ar_genericcubic , only : CubicEoS use yaeos__models_ar_cubic_alphas , only : AlphaSoave use yaeos__models_ar_cubic_quadratic_mixing , only : QMR real ( pr ), intent ( in ) :: tc (:) !! Critical temperature [K] real ( pr ), intent ( in ) :: pc (:) !! Critical pressure [bar] real ( pr ), intent ( in ) :: w (:) !! Acentric factor real ( pr ), optional , intent ( in ) :: kij (:, :) !! k_{ij} matrix real ( pr ), optional , intent ( in ) :: lij (:, :) !! l_{ij} matrix type ( Substances ) :: composition type ( QMR ) :: mixrule type ( AlphaSoave ) :: alpha integer :: nc integer :: i nc = size ( tc ) composition % tc = tc composition % pc = pc composition % w = w alpha % k = 0.48_pr + 1.574_pr * composition % w - 0.175_pr * composition % w ** 2 if ( present ( kij )) then mixrule % k = kij else mixrule % k = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif if ( present ( lij )) then mixrule % l = lij else mixrule % l = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif model % components = composition model % ac = 0.427480_pr * R ** 2 * composition % tc ** 2 / composition % pc model % b = 0.086640_pr * R * composition % tc / composition % pc model % del1 = [( 1 , i = 1 , nc )] model % del2 = [( 0 , i = 1 , nc )] model % alpha = alpha model % mixrule = mixrule model % name = \"SRK\" end function SoaveRedlichKwong type ( CubicEoS ) function PSRK ( tc , pc , w , molecules , c1 , c2 , c3 ) result ( model ) use yaeos__models_ar_genericcubic , only : CubicEoS use yaeos__models_ar_cubic_alphas , only : AlphaMathiasCopeman , AlphaSoave use yaeos__models_cubic_mixing_rules_huron_vidal , only : MHV use yaeos__models_ge_implementations , only : setup_psrk , UNIFAC use yaeos__models_ge_group_contribution_groups , only : Groups real ( pr ), intent ( in ) :: tc (:) !! Critical temperature [K] real ( pr ), intent ( in ) :: pc (:) !! Critical pressure [bar] real ( pr ), intent ( in ) :: w (:) !! Acentric factor type ( Groups ), intent ( in ) :: molecules (:) real ( pr ), optional , intent ( in ) :: c1 (:), c2 (:), c3 (:) type ( UNIFAC ) :: ge type ( Substances ) :: composition type ( MHV ) :: mixrule type ( AlphaSoave ) :: alpha type ( AlphaMathiasCopeman ) :: alpha_mc integer :: nc integer :: i nc = size ( tc ) composition % tc = tc composition % pc = pc composition % w = w ge = setup_psrk ( molecules ) if ( present ( c1 ) . and . present ( c2 ) . and . present ( c3 )) then alpha_mc = AlphaMathiasCopeman ( c1 , c2 , c3 ) model % alpha = alpha_mc else alpha % k = 0.48_pr + 1.574_pr * composition % w - 0.175_pr * composition % w ** 2 model % alpha = alpha end if model % components = composition model % ac = 0.427480_pr * R ** 2 * composition % tc ** 2 / composition % pc model % b = 0.086640_pr * R * composition % tc / composition % pc model % del1 = [( 1 , i = 1 , nc )] model % del2 = [( 0 , i = 1 , nc )] mixrule = MHV ( ge = ge , b = model % b , q =- 0.64663_pr ) model % mixrule = mixrule model % name = \"PSRK\" end function PSRK type ( CubicEoS ) function RKPR ( tc , pc , w , zc , kij , lij , delta_1 , k ) result ( model ) !! RKPR Equation of State !! !! The RKPR EoS extends the classical formulation of Cubic Equations !! of State by freeing the parameter \\delta_1. This extra degree !! provides extra ways of implementing the equation in comparison !! of other Cubic EoS (like PR and SRK) which are limited to definition !! of their critical constants. !! !! Besides that extra parameter, the RKRR includes another \\alpha !! function: !!  !!  \\alpha(T_r) = \\left(\\frac{3}{2+T_r}\\right)&#94;k !!  !! !! In this implementation we take the simplest form which correlates !! the extra parameter to the critical compressibility factor Z_c and !! the k parameter of the \\alpha function to Z_c and \\omega: !! !! \\delta_1 = d_1 + d_2 (d_3 - Z_c)&#94;d_4 + d_5 (d_3 - Z_c) &#94; d_6 !! k = (A_1  Z_c + A_0)\\omega&#94;2 + (B_1 Z_c + B_0)\\omega + (C_1 Z_c + C_0) use yaeos__models_ar_cubic_quadratic_mixing , only : QMR use yaeos__models_ar_cubic_alphas , only : AlphaRKPR real ( pr ), intent ( in ) :: tc (:) !! Critical Temperature [K] real ( pr ), intent ( in ) :: pc (:) !! Critical Pressure [bar] real ( pr ), intent ( in ) :: w (:) !! Acentric Factor real ( pr ), intent ( in ) :: zc (:) !! Critical compressibility real ( pr ), optional , intent ( in ) :: kij (:, :) !! k_{ij} matrix real ( pr ), optional , intent ( in ) :: lij (:, :) !! l_{ij} matrix real ( pr ), optional , intent ( in ) :: delta_1 (:) real ( pr ), optional , intent ( in ) :: k (:) type ( AlphaRKPR ) :: alpha type ( QMR ) :: mixrule type ( Substances ) :: composition integer :: i , nc real ( pr ), parameter :: d1 = 0.428364 , & d2 = 1 8.496215 , & d3 = 0.338426 , & d4 = 0.66 , & d5 = 78 9.723105 , & d6 = 2.512392 real ( pr ), parameter :: A1 = - 2.4407 real ( pr ), parameter :: A0 = 0.0017 real ( pr ), parameter :: B1 = 7.4513 real ( pr ), parameter :: B0 = 1.9681 real ( pr ), parameter :: C1 = 1 2.504 real ( pr ), parameter :: C0 =- 2.6238 real ( pr ) :: OMa ( size ( pc )), OMb ( size ( pc )) real ( pr ) :: Zc_eos ( size ( pc )) real ( pr ) :: Psat_i , diff nc = size ( tc ) composition % pc = pc composition % tc = tc composition % w = w Zc_eos = 1.168 * Zc if ( present ( k )) then alpha % k = k else alpha % k = ( A1 * Zc_eos + A0 ) * w ** 2 + ( B1 * zc + B0 ) * w + ( C1 * Zc_eos + C0 ) end if if ( present ( kij )) then mixrule % k = kij else mixrule % k = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) end if if ( present ( lij )) then mixrule % l = lij else mixrule % l = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) end if model % components = composition if ( present ( delta_1 )) then model % del1 = delta_1 else model % del1 = d1 + d2 * ( d3 - zc_eos ) ** d4 + d5 * ( d3 - zc_eos ) ** d6 end if model % del2 = ( 1._pr - model % del1 ) / ( 1._pr + model % del1 ) model % alpha = alpha call get_OMa_OMb ( model % del1 , oma , omb ) model % ac = OMa * ( R * Tc ) ** 2 / Pc model % b = OMb * ( R * Tc ) / Pc model % mixrule = mixrule model % name = \"RKPR 2005\" if (. not . present ( k )) then do i = 1 , nc call refit_rkpr_k ( model , i ) end do end if end function RKPR subroutine refit_rkpr_k ( model , component ) !! # refit_rkpr_k !! !! Refit the k parameter of the RKPR EoS to match the acentric !! factor use yaeos__models_ar_cubic_alphas , only : AlphaRKPR use yaeos__equilibria_boundaries_pure_saturation , only : & PurePsat , pure_saturation_line type ( CubicEoS ), intent ( in out ) :: model !! The model to be refitted integer , intent ( in ) :: component !! Component index to refit real ( pr ) :: Psat_i , diff , Tc , Pc , w integer :: i type ( AlphaRKPR ) :: alpha type ( PurePsat ) :: Psat associate ( a => model % alpha ) select type ( a ) type is ( AlphaRKPR ) alpha = a end select end associate i = component Tc = model % components % tc ( i ) Pc = model % components % pc ( i ) w = model % components % w ( i ) diff = 1 do while ( abs ( diff ) / abs ( w ) > 1e-5 ) Psat_i = model % Psat_pure ( i , 0.7 * Tc ) if ( Psat_i < 1e-10 ) then ! If the saturation pressure did not converge, calculate the ! whole line Psat = pure_saturation_line ( model , i , minp = 0.01 * Pc , minT = 0.6 * Tc ) Psat_i = Psat % get_P ( 0.7 * Tc ) ! If the saturation pressure still not converges, just give it ! a value of 80% of the critical pressure. ! TODO: This could be improved by using a better initial guess if ( Psat_i < 1e-10 ) Psat_i = 0.8 * Pc end if diff = ( w - ( - 1 - log10 ( Psat_i / Pc ))) alpha % k ( i ) = alpha % k ( i ) + 0.1 * diff deallocate ( model % alpha ) model % alpha = alpha if ( Psat_i < 1e-6 ) error stop end do end subroutine refit_rkpr_k subroutine get_OMa_OMb ( del1 , OMa , OMb ) real ( pr ), intent ( in ) :: del1 (:) real ( pr ), intent ( out ) :: OMa ( size ( del1 )) real ( pr ), intent ( out ) :: OMb ( size ( del1 )) real ( pr ) :: d1 ( size ( del1 )), y ( size ( del1 )) d1 = ( 1._pr + del1 ** 2._pr ) / ( 1._pr + del1 ) y = 1._pr + ( 2._pr * ( 1._pr + del1 )) ** ( 1.0_pr / 3._pr ) + ( 4._pr / ( 1._pr + del1 )) ** ( 1.0_pr / 3 ) OMa = ( 3._pr * y * y + 3._pr * y * d1 + d1 ** 2._pr + d1 - 1.0_pr ) / ( 3._pr * y + d1 - 1.0_pr ) ** 2._pr OMb = 1._pr / ( 3._pr * y + d1 - 1.0_pr ) end subroutine get_OMa_OMb end module yaeos__models_ar_cubic_implementations","tags":"","url":"sourcefile/implementations.f90~2.html"},{"title":"phase_envelopes_px_3ph.f90 – yaeos","text":"Source Code module yaeos__equilibria_boundaries_phase_envelopes_px3 use yaeos__constants , only : pr , R use yaeos__equilibria_equilibrium_state , only : EquilibriumState use yaeos__models_ar , only : ArModel use yaeos__math , only : solve_system use yaeos__equilibria_boundaries_auxiliar , only : get_z implicit none private public :: PXEnvel3 public :: px_envelope_3ph public :: solve_point public :: get_values_from_X type :: PXEnvel3 real ( pr ), allocatable :: beta (:) !! Mole fraction between phase x and phase y real ( pr ), allocatable :: x (:, :) !! Mole fraction of phase x real ( pr ), allocatable :: y (:, :) !! Mole fraction of phase x real ( pr ), allocatable :: w (:, :) !! Mole fraction of phase x real ( pr ) :: T !! Temperature [K] real ( pr ), allocatable :: P (:) !! Pressure [bar] real ( pr ), allocatable :: alpha (:) !! Mole fraction of other fluid integer , allocatable :: ns (:) !! Specified variable to solve point `i` real ( pr ), allocatable :: S (:) !! Specified value to solve point `i` end type PXEnvel3 real ( pr ), parameter :: lnK_min = 2.0_pr contains type ( PXEnvel3 ) function px_envelope_3ph (& model , z0 , zi , T , x0 , y0 , w0 , beta0 , P0 , a0 , ns0 , dS0 , & points & ) result ( envelope ) class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z0 (:) real ( pr ), intent ( in ) :: zi (:) real ( pr ), intent ( in ) :: T real ( pr ), intent ( in ) :: x0 (:) real ( pr ), intent ( in ) :: y0 (:) real ( pr ), intent ( in ) :: w0 (:) real ( pr ), intent ( in ) :: beta0 real ( pr ), intent ( in ) :: P0 real ( pr ), intent ( in ) :: a0 integer , intent ( in ) :: ns0 real ( pr ), intent ( in ) :: dS0 integer , intent ( in ) :: points real ( pr ) :: kx ( size ( z0 )) real ( pr ) :: ky ( size ( z0 )) integer :: i integer :: nc real ( pr ) :: Xvars ( size ( z0 ) * 2 + 3 ), dX ( size ( z0 ) * 2 + 3 ) real ( pr ) :: F ( size ( z0 ) * 2 + 3 ), dF ( size ( z0 ) * 2 + 3 , size ( z0 ) * 2 + 3 ) integer :: ns !! Specified variable real ( pr ) :: S !! Specified value real ( pr ) :: dS !! Specified value step for next point extrapolation real ( pr ) :: dXdS ( size ( z0 ) * 2 + 3 ) real ( pr ) :: x ( points , size ( z0 )) real ( pr ) :: y ( points , size ( z0 )) real ( pr ) :: w ( points , size ( z0 )) real ( pr ) :: beta ( points ) real ( pr ) :: P ( points ) real ( pr ) :: a ( points ) integer :: its integer :: max_its = 500 nc = size ( z0 ) ns = ns0 dS = dS0 kx = x0 / w0 ky = y0 / w0 Xvars = [ log ( kx ), log ( ky ), log ( P0 ), a0 , beta0 ] S = Xvars ( ns ) allocate ( envelope % S ( 0 ), envelope % ns ( 0 )) do i = 1 , points call solve_point ( model , z0 , zi , T , ns , S , Xvars , F , dF , its , max_its ) if ( any ( isnan ( F )) . or . any ( isnan ( Xvars )) . or . its >= max_its . or . dS == 0 ) exit envelope % ns = [ envelope % ns , ns ] envelope % S = [ envelope % S , S ] call get_values_from_X ( z0 , zi , Xvars , x ( i , :), y ( i , :), w ( i , :), P ( i ), a ( i ), beta ( i )) call update_specification ( its , Xvars , dF , dXdS , ns , dS ) call detect_critical ( Xvars , dXdS , ns , S , dS ) dX = dXdS * dS Xvars = Xvars + dX S = Xvars ( ns ) end do i = i - 1 envelope % x = x (: i , :) envelope % y = y (: i , :) envelope % w = w (: i , :) envelope % P = P (: i ) envelope % alpha = a (: i ) envelope % T = T envelope % beta = beta (: i ) end function px_envelope_3ph subroutine get_values_from_X ( z0 , zi , Xvars , x , y , w , P , alpha , beta ) real ( pr ), intent ( in ) :: z0 (:) real ( pr ), intent ( in ) :: zi (:) real ( pr ), intent ( in ) :: Xvars ( size ( z0 ) * 2 + 3 ) real ( pr ), intent ( out ) :: x ( size ( z0 )) real ( pr ), intent ( out ) :: y ( size ( z0 )) real ( pr ), intent ( out ) :: w ( size ( z0 )) real ( pr ), intent ( out ) :: P real ( pr ), intent ( out ) :: alpha real ( pr ), intent ( out ) :: beta integer :: nc real ( pr ) :: Kx (( Size ( Xvars ) - 3 ) / 2 ), Ky (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: z ( size ( z0 )) nc = ( Size ( Xvars ) - 3 ) / 2 Kx = exp ( Xvars ( 1 : nc )) Ky = exp ( Xvars ( nc + 1 : 2 * nc )) P = exp ( Xvars ( 2 * nc + 1 )) alpha = Xvars ( 2 * nc + 2 ) beta = Xvars ( 2 * nc + 3 ) call get_z ( alpha , z0 , zi , z ) w = z / ( beta * Ky + ( 1 - beta ) * Kx ) x = w * Kx y = w * Ky end subroutine get_values_from_X subroutine update_specification ( its , X , dF , dXdS , ns , dS ) integer , intent ( in ) :: its real ( pr ), intent ( in out ) :: X (:) real ( pr ), intent ( in out ) :: dF (:, :) real ( pr ), intent ( in out ) :: dXdS (:) integer , intent ( in out ) :: ns real ( pr ), intent ( in out ) :: dS integer :: nc real ( pr ) :: dFdS ( size ( X )) dFdS = 0 dFdS ( size ( X )) = - 1 nc = ( size ( X ) - 3 ) / 2 ns = maxloc ( abs ( dXdS ), dim = 1 ) dXdS = solve_system ( dF , - dFdS ) dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) dS = sign ( minval ([ abs ( dS ), 0.1_pr ]), dS ) end subroutine update_specification subroutine detect_critical ( X , dXdS , ns , S , dS ) !! # `detect_critical` !! Critical point detection !! !! # Description !! If the values of lnK (X[:nc]) change sign then a critical point !! Has passed, since for this to happen all variables should pass !! through zero. Near critical points (lnK < 0.05) points are harder !! to converge, so more steps in the extrapolation vector are made to !! jump over the critical point. !! If the critical point is detected then the kind of the point is !! changed and the point is saved using an interpolation knowing that !! !!  !!   X_c = a * X + (1-a)*X_{new} !!  !! !! With X_c is the variables at the critical point, X_{new} !! is the new initialization point of the method and a is the !! parameter to interpolate the values. This subroutine finds the !! value of  a to obtain X_c. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables real ( pr ), intent ( in out ) :: dXdS (:) !! Variation of variables wrt S integer , intent ( in out ) :: ns !! Number of specified variable real ( pr ), intent ( in out ) :: S !! Specification value real ( pr ), intent ( in out ) :: dS !! Step in specification real ( pr ) :: Xc ( size ( X )) !! Value at (near) critical point real ( pr ) :: a !! Parameter for interpolation real ( pr ) :: Xold ( size ( X )) !! Old value of X real ( pr ) :: Xnew ( size ( X )) !! Value of the next initialization logical :: found_critical integer :: nc integer :: first_set (( size ( X ) - 3 ) / 2 ), second_set (( size ( X ) - 3 ) / 2 ), idx (( size ( X ) - 3 ) / 2 ) integer :: i , critical_set (( size ( X ) - 3 ) / 2 ) real ( pr ) :: step ( size ( X )) nc = ( size ( X ) - 3 ) / 2 first_set = [( i , i = 1 , nc )] second_set = [( i , i = nc + 1 , 2 * nc )] Xold = X Xnew = X + dXdS * dS found_critical = . false . do i = 1 , 2 select case ( i ) case ( 1 ) idx = first_set case ( 2 ) idx = second_set end select do while ( maxval ( abs ( Xnew ( idx ))) < 0.1 ) dS = dS * 2 Xnew = Xnew + dXdS * dS end do if ( all ( Xnew ( idx ) * Xold ( idx ) < 0 )) then ! If two steps imply the crossing of a critical point, then ! make those two steps to avoid falling into it found_critical = . true . critical_set = idx Xnew = Xnew + dXdS * dS end if end do if ( found_critical ) then a = critical_interpol ( Xnew , Xold , critical_set ) Xc = a * Xold + ( 1 - a ) * Xnew ! Xnew = Xc ! do while(maxval(abs(Xnew(idx))) < 0.5) !    Xnew = Xnew + dXdS*dS ! end do X = X + ( Xnew - Xold ) end if end subroutine detect_critical real ( pr ) function critical_interpol ( Xnew , Xold , idx ) result ( a ) !! # `critical_interpol` !! Critical point interpolation !! !! # Description !! This function calculates the parameter a to interpolate the !! values of the variables at the critical point. The interpolation !! is done using the equation: !! !!  !!   0 = a*X_{old}(ns) + (1-a)*X_{new}(ns) !!  !! !! Where X_{old} is the old value of the variables and X_{new} !! is the new value of the variables. The critical point is the point !! where the variables change sign, so the interpolation is done to !! find the value of the variables at the critical point. real ( pr ), intent ( in ) :: Xnew (:) !! New value of the variables real ( pr ), intent ( in ) :: Xold (:) !! Old value of the variables integer , intent ( in ) :: idx (:) !! Index of the variables to interpolate integer :: ncomp ! 0 = a*X(ns) + (1-a)*Xnew(ns) < Interpolation equation to get X(ns) = 0 ! Find the component that is changing sign with the highest slope ncomp = maxloc ( abs ( Xold ( idx ) - Xnew ( idx )), dim = 1 ) a = - Xnew ( ncomp ) / ( Xold ( ncomp ) - Xnew ( ncomp )) end function critical_interpol subroutine px_F_three_phases ( model , z0 , zi , T , Xvars , ns , S , F , dF ) !! Function to solve at each point of a three phase envelope. !! !! The vector of variables X corresponds to: !!  X = [lnKx_i, lnKy_i lnP, \\alpha, \\beta]  !! !! While the equations are: !! !!  F = [ !!        lnKx_i - ln \\phi_i(x, P, T) + ln \\phi_i(w, P, T), !!        lnKy_i - ln \\phi_i(y, P, T) + ln \\phi_i(w, P, T), !!        \\sum_{i=1}&#94;N (w_i) - 1, !!        \\sum_{i=1}&#94;N (x_i - y_i), !!        X_{ns} - S !! ]  use iso_fortran_env , only : error_unit class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z0 (:) real ( pr ), intent ( in ) :: zi (:) real ( pr ), intent ( in ) :: T real ( pr ), intent ( in ) :: Xvars (:) !! Vector of variables integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( out ) :: F ( size ( Xvars )) !! Vector of functions valuated real ( pr ), intent ( out ) :: df ( size ( Xvars ), size ( Xvars )) !! Jacobian matrix ! Xvars variables real ( pr ) :: Kx ( size ( z0 )) real ( pr ) :: Ky ( size ( z0 )) real ( pr ) :: P real ( pr ) :: alpha real ( pr ) :: beta real ( pr ) :: z ( size ( z0 )) ! Main phase 1 variables real ( pr ) :: Vx real ( pr ), dimension ( size ( z0 )) :: x , lnphi_x , dlnphi_dt_x , dlnphi_dp_x real ( pr ), dimension ( size ( z0 ), size ( z0 )) :: dlnphi_dn_x ! Main phase 2 variables real ( pr ) :: Vy real ( pr ), dimension ( size ( z0 )) :: y , lnphi_y , dlnphi_dt_y , dlnphi_dp_y real ( pr ), dimension ( size ( z0 ), size ( z0 )) :: dlnphi_dn_y ! Incipient phase variables real ( pr ) :: Vw real ( pr ), dimension ( size ( z0 )) :: w , lnphi_w , dlnphi_dt_w , dlnphi_dp_w real ( pr ), dimension ( size ( z0 ), size ( z0 )) :: dlnphi_dn_w ! Derivative of w wrt beta real ( pr ) :: dwdb ( size ( z0 )) real ( pr ) :: dzda ( size ( z0 )) real ( pr ) :: dwda ( size ( z0 )) real ( pr ) :: dwdKx ( size ( z0 )), dxdKx ( size ( z0 )), dydKx ( size ( z0 )) real ( pr ) :: dwdKy ( size ( z0 )), dxdKy ( size ( z0 )), dydKy ( size ( z0 )) integer :: i , j , nc nc = size ( z0 ) Kx = exp ( Xvars ( 1 : nc )) Ky = exp ( Xvars ( nc + 1 : 2 * nc )) P = exp ( Xvars ( 2 * nc + 1 )) alpha = Xvars ( 2 * nc + 2 ) beta = Xvars ( 2 * nc + 3 ) call get_z ( alpha , z_0 = z0 , z_inj = zi , z = z , dzda = dzda ) w = z / ( beta * Ky + ( 1 - beta ) * Kx ) x = w * Kx y = w * Ky call model % lnphi_pt (& x , P , T , V = Vx , root_type = \"stable\" , lnphi = lnphi_x , & dlnphidp = dlnphi_dp_x , dlnphidt = dlnphi_dt_x , dlnphidn = dlnphi_dn_x & ) call model % lnphi_pt (& y , P , T , V = Vy , root_type = \"stable\" , lnphi = lnphi_y , & dlnphidp = dlnphi_dp_y , dlnphidt = dlnphi_dt_y , dlnphidn = dlnphi_dn_y & ) call model % lnphi_pt (& w , P , T , V = Vw , root_type = \"stable\" , lnphi = lnphi_w , & dlnphidp = dlnphi_dp_w , dlnphidt = dlnphi_dt_w , dlnphidn = dlnphi_dn_w & ) F ( 1 : nc ) = Xvars ( 1 : nc ) + lnphi_x - lnphi_w F ( nc + 1 : 2 * nc ) = Xvars ( nc + 1 : 2 * nc ) + lnphi_y - lnphi_w F ( 2 * nc + 1 ) = sum ( w ) - 1 F ( 2 * nc + 2 ) = sum ( x - y ) F ( 2 * nc + 3 ) = Xvars ( ns ) - S df = 0 dwda = 1.0_pr / ( beta * Ky + ( 1 - beta ) * Kx ) * dzda dwdb = z * ( Kx - Ky ) / (( 1 - beta ) * Kx + beta * Ky ) ** 2 dwdKx = - z * ( 1 - beta ) / ( Ky * beta + ( 1 - beta ) * Kx ) ** 2 dxdKx = Kx * dwdKx + w dydKx = Ky * dwdKx dwdKy = - z * ( beta ) / ( Ky * beta + ( 1 - beta ) * Kx ) ** 2 dxdKy = Kx * dwdKy dydKy = Ky * dwdKy + w do i = 1 , nc do j = 1 , nc df ( i , j ) = Kx ( j ) * ( dlnphi_dn_x ( i , j ) * dxdKx ( j ) & - dlnphi_dn_w ( i , j ) * dwdKx ( j )) df ( i + nc , j ) = Kx ( j ) * ( dlnphi_dn_y ( i , j ) * dydKx ( j ) & - dlnphi_dn_w ( i , j ) * dwdKx ( j )) df ( i , j + nc ) = Ky ( j ) * ( dlnphi_dn_x ( i , j ) * dxdKy ( j ) & - dlnphi_dn_w ( i , j ) * dwdKy ( j )) df ( i + nc , j + nc ) = Ky ( j ) * ( dlnphi_dn_y ( i , j ) * dydKy ( j ) & - dlnphi_dn_w ( i , j ) * dwdKy ( j )) end do df ( i , i ) = df ( i , i ) + 1 df ( i + nc , i + nc ) = df ( i + nc , i + nc ) + 1 df ( i , 2 * nc + 2 ) = sum ( & Kx * dlnphi_dn_x ( i , :) * dwda - dlnphi_dn_w ( i , :) * dwda & ) df ( i + nc , 2 * nc + 2 ) = sum ( Ky * dlnphi_dn_y ( i , :) * dwda & - dlnphi_dn_w ( i , :) * dwda ) ! Derivatives wrt beta df ( i , 2 * nc + 3 ) = sum ( Kx * dlnphi_dn_x ( i , :) * dwdb & - dlnphi_dn_w ( i , :) * dwdb ) df ( i + nc , 2 * nc + 3 ) = sum ( Ky * dlnphi_dn_y ( i , :) * dwdb & - dlnphi_dn_w ( i , :) * dwdb ) df ( 2 * nc + 1 , i ) = Kx ( i ) * dwdKx ( i ) df ( 2 * nc + 1 , i + nc ) = Ky ( i ) * dwdKy ( i ) df ( 2 * nc + 2 , i ) = Kx ( i ) * dxdKx ( i ) - Kx ( i ) * dydKx ( i ) df ( 2 * nc + 2 , i + nc ) = Ky ( i ) * dxdKy ( i ) - Ky ( i ) * dydKy ( i ) end do ! Derivatives wrt P df (: nc , 2 * nc + 1 ) = P * ( dlnphi_dp_x - dlnphi_dp_w ) df ( nc + 1 : 2 * nc , 2 * nc + 1 ) = P * ( dlnphi_dp_y - dlnphi_dp_w ) ! Derivatives wrt alpha df ( 2 * nc + 1 , 2 * nc + 2 ) = sum ( dwda ) df ( 2 * nc + 2 , 2 * nc + 2 ) = sum ( Kx * dwda - Ky * dwda ) ! Derivatives wrt beta df ( 2 * nc + 1 , 2 * nc + 3 ) = sum ( dwdb ) df ( 2 * nc + 2 , 2 * nc + 3 ) = sum ( Kx * dwdb - Ky * dwdb ) ! Derivatives wrt Xs df ( 2 * nc + 3 , :) = 0 df ( 2 * nc + 3 , ns ) = 1 end subroutine px_F_three_phases subroutine solve_point ( model , z0 , zi , T , ns , S , X , F , dF , its , maxits ) class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z0 (:) real ( pr ), intent ( in ) :: zi (:) real ( pr ), intent ( in ) :: T integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( in out ) :: X (:) real ( pr ), intent ( out ) :: F (:) real ( pr ), intent ( out ) :: dF (:,:) integer , intent ( in out ) :: its integer , intent ( in ) :: maxits real ( pr ) :: dX ( size ( X )) integer :: nc its = 0 F = 1 dX = 1 nc = ( size ( X ) - 3 ) / 2 do while (( maxval ( abs ( F )) > 1e-5 . and . maxval ( abs ( dX / X )) > 1e-5 ) . and . its < maxits ) its = its + 1 call px_F_three_phases ( model , z0 , zi , T , X , ns , S , F , dF ) dX = solve_system ( dF , - F ) do while (( abs ( dX ( 2 * nc + 1 ) / X ( 2 * nc + 1 ))) > 0.1 ) dX = dX / 2 end do do while (( abs ( dX ( 2 * nc + 2 ))) > 0.1 ) dX = dX / 2 end do do while ( abs ( dX ( 2 * nc + 3 ) / X ( 2 * nc + 3 )) > 10 ) dX = dX / 2 end do X = X + dX end do end subroutine solve_point end module yaeos__equilibria_boundaries_phase_envelopes_px3","tags":"","url":"sourcefile/phase_envelopes_px_3ph.f90.html"},{"title":"psrk_parameters.f90 – yaeos","text":"Source Code module yaeos__models_ge_group_contribution_psrk_parameters use yaeos__constants , only : pr use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters implicit none contains type ( GeGCModelParameters ) function PSRKParameters () integer :: nmg , nsg ! ======================================================================== ! PSRK subgroups ids definition ! ------------------------------------------------------------------------ PSRKParameters % subgroups_ids = [ & 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , & 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , & 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , & 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , & 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , & 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , & 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , & 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , & 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , & 118 , 119 , 120 , 121 , 122 , 123 , 124 , 125 , 126 , 127 , 128 , 129 , 130 , & 131 , 132 , 133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , & 144 , 145 , 146 , 147 , 148 , 149 , 152 ] ! ======================================================================== ! PSRK maingroups ids definition ! ------------------------------------------------------------------------ PSRKParameters % maingroups_ids = [& 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , & 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , & 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , & 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , & 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 ] ! ======================================================================== ! PSRK subgroups maingroups ! ------------------------------------------------------------------------ PSRKParameters % subgroups_maingroups = [& 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 , 5 , 6 , 7 , 8 , & 9 , 9 , 10 , 11 , 11 , 12 , 13 , 13 , 13 , 13 , 14 , 14 , 14 , 15 , 15 , 15 , 16 , & 16 , 17 , 18 , 18 , 18 , 19 , 19 , 20 , 20 , 21 , 21 , 21 , 22 , 22 , 22 , 23 , 23 , & 24 , 25 , 26 , 26 , 26 , 27 , 28 , 29 , 29 , 30 , 31 , 32 , 33 , 34 , 34 , 35 , 36 , & 37 , 2 , 38 , 39 , 39 , 40 , 40 , 40 , 41 , 42 , 42 , 42 , 42 , 43 , 43 , 43 , 44 , & 45 , 45 , 45 , 45 , 45 , 45 , 45 , 45 , 46 , 46 , 46 , 46 , 46 , 46 , 47 , 47 , 48 , & 48 , 48 , 49 , 50 , 50 , 50 , 2 , 34 , 55 , 63 , 62 , 61 , 60 , 59 , 56 , 57 , 58 , & 62 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 29 , 29 , 51 , & 51 , 51 , 51 , 51 , 51 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 14 ] nsg = size ( PSRKParameters % subgroups_ids ) nmg = size ( PSRKParameters % maingroups_ids ) ! ======================================================================== ! PSRK subgroups Rs ! ------------------------------------------------------------------------ PSRKParameters % subgroups_Rs = [& 0.9011_pr , 0.6744_pr , 0.4469_pr , 0.2195_pr , 1.3454_pr , & 1.1167_pr , 1.1173_pr , 0.8886_pr , 0.5313_pr , 0.3652_pr , & 1.2663_pr , 1.0396_pr , 0.8121_pr , 1.0_pr , 1.4311_pr , & 0.92_pr , 0.8952_pr , 1.6724_pr , 1.4457_pr , 0.998_pr , & 1.9031_pr , 1.6764_pr , 1.242_pr , 1.145_pr , 0.9183_pr , & 0.6908_pr , 0.9183_pr , 1.5959_pr , 1.3692_pr , 1.1417_pr , & 1.4337_pr , 1.207_pr , 0.9795_pr , 1.1865_pr , 0.9597_pr , & 1.06_pr , 2.9993_pr , 2.8332_pr , 2.667_pr , 1.8701_pr , & 1.6434_pr , 1.3013_pr , 1.528_pr , 1.4654_pr , 1.238_pr , & 1.0106_pr , 2.2564_pr , 2.0606_pr , 1.8016_pr , 2.87_pr , & 2.6401_pr , 3.39_pr , 1.1562_pr , 2.0086_pr , 1.7818_pr , & 1.5544_pr , 1.4199_pr , 2.057_pr , 1.877_pr , 1.651_pr , & 3.168_pr , 2.4088_pr , 1.264_pr , 0.9492_pr , 1.292_pr , & 1.0613_pr , 2.8266_pr , 2.3144_pr , 0.791_pr , 0.6605_pr , & 0.6948_pr , 3.0856_pr , 2.6322_pr , 1.406_pr , 1.0105_pr , & 0.615_pr , 1.38_pr , 1.6035_pr , 1.4443_pr , 1.2853_pr , & 1.047_pr , 1.4838_pr , 1.303_pr , 1.1044_pr , 3.981_pr , & 3.0356_pr , 2.2287_pr , 2.406_pr , 1.6493_pr , 1.8174_pr , & 1.967_pr , 2.1721_pr , 2.6243_pr , 1.4515_pr , 2.1905_pr , & 1.9637_pr , 2.8589_pr , 2.6322_pr , 2.4054_pr , 2.1226_pr , & 1.8952_pr , 1.613_pr , 1.3863_pr , 1.1589_pr , 3.474_pr , & 2.8569_pr , 2.6908_pr , 2.5247_pr , 1.3564_pr , 0.791_pr , & 0.851_pr , 0.711_pr , 0.416_pr , 1.235_pr , 0.856_pr , & 1.177_pr , 1.3_pr , 1.1292_pr , 0.733_pr , 0.37_pr , & 1.343_pr , 0.716_pr , 0.98_pr , 2.374_pr , 0.885_pr , & 0.886_pr , 1.12_pr , 1.13_pr , 1.016_pr , 1.056_pr , & 1.058_pr , 1.393_pr , 1.6785_pr , 1.425_pr , 1.199_pr , & 1.3652_pr , 1.1378_pr , 0.9104_pr , 1.5926_pr , 1.1378_pr , & 0.6829_pr , 0.75_pr , 1.53_pr , 1.9_pr , 1.2_pr , & 1.0_pr , 1.78_pr , 1.1_pr , 1.48_pr , 0.9147_pr & ] ! ======================================================================== ! PSRK subgroups Qs ! ------------------------------------------------------------------------ PSRKParameters % subgroups_Qs = [& 0.848_pr , 0.54_pr , 0.228_pr , 0.0_pr , 1.176_pr , & 0.867_pr , 0.988_pr , 0.676_pr , 0.4_pr , 0.12_pr , & 0.968_pr , 0.66_pr , 0.348_pr , 1.2_pr , 1.432_pr , & 1.4_pr , 0.68_pr , 1.488_pr , 1.18_pr , 0.948_pr , & 1.728_pr , 1.42_pr , 1.188_pr , 1.088_pr , 0.78_pr , & 0.468_pr , 1.1_pr , 1.544_pr , 1.236_pr , 0.924_pr , & 1.244_pr , 0.936_pr , 0.624_pr , 0.94_pr , 0.632_pr , & 0.816_pr , 2.113_pr , 1.833_pr , 1.553_pr , 1.724_pr , & 1.416_pr , 1.224_pr , 1.532_pr , 1.264_pr , 0.952_pr , & 0.724_pr , 1.988_pr , 1.684_pr , 1.448_pr , 2.41_pr , & 2.184_pr , 2.91_pr , 0.844_pr , 1.868_pr , 1.56_pr , & 1.248_pr , 1.104_pr , 1.65_pr , 1.676_pr , 1.368_pr , & 2.484_pr , 2.248_pr , 0.992_pr , 0.832_pr , 1.088_pr , & 0.784_pr , 2.472_pr , 2.052_pr , 0.724_pr , 0.485_pr , & 0.524_pr , 2.736_pr , 2.12_pr , 1.38_pr , 0.92_pr , & 0.46_pr , 1.2_pr , 1.2632_pr , 1.0063_pr , 0.7494_pr , & 0.4099_pr , 1.0621_pr , 0.7639_pr , 0.4657_pr , 3.2_pr , & 2.644_pr , 1.916_pr , 2.116_pr , 1.416_pr , 1.648_pr , & 1.828_pr , 2.1_pr , 2.376_pr , 1.248_pr , 1.796_pr , & 1.488_pr , 2.428_pr , 2.12_pr , 1.812_pr , 1.904_pr , & 1.592_pr , 1.368_pr , 1.06_pr , 0.748_pr , 2.796_pr , & 2.14_pr , 1.86_pr , 1.58_pr , 1.3098_pr , 0.72_pr , & 0.778_pr , 0.828_pr , 0.571_pr , 1.202_pr , 0.93_pr , & 1.116_pr , 0.982_pr , 1.124_pr , 0.849_pr , 0.527_pr , & 1.164_pr , 0.62_pr , 0.888_pr , 2.056_pr , 0.985_pr , & 0.986_pr , 1.12_pr , 1.13_pr , 1.216_pr , 1.256_pr , & 1.258_pr , 1.208_pr , 1.316_pr , 1.06_pr , 0.752_pr , & 1.008_pr , 0.696_pr , 0.468_pr , 1.32_pr , 0.78_pr , & 0.24_pr , 0.88_pr , 1.44_pr , 1.66_pr , 1.19_pr , & 1.1_pr , 1.82_pr , 1.27_pr , 1.34_pr , 0.614_pr & ] ! ======================================================================== ! PSRK aij ! ------------------------------------------------------------------------ PSRKParameters % maingroups_aij = reshape ([& 0.00000_pr , - 3 5.36000_pr , - 1 1.12000_pr , - 6 9.70000_pr , 15 6.40000_pr , & 5 0.15500_pr , 30 0.00000_pr , 27 5.80000_pr , 2 6.76000_pr , 50 5.70000_pr , & 11 4.80000_pr , 32 9.30000_pr , 8 3.36000_pr , - 3 0.48000_pr , 6 5.33000_pr , & - 8 3.98000_pr , 113 9.00000_pr , - 10 1.56000_pr , 2 4.82000_pr , 31 5.30000_pr , & 9 1.46000_pr , 3 4.01000_pr , 3 6.70000_pr , - 7 8.45000_pr , 10 6.80000_pr , & - 3 2.69000_pr , 554 1.00000_pr , 18 0.28000_pr , - 6 1.86300_pr , - 2 5.31000_pr , & 13 9.93000_pr , 12 8.00000_pr , - 3 1.52000_pr , 451 8.29980_pr , 5 0.49000_pr , & - 16 5.90000_pr , 4 7.41000_pr , - 5.13200_pr , - 3 1.95000_pr , 14 7.30000_pr , & 52 9.00000_pr , - 3 4.36000_pr , 11 0.20000_pr , 1 3.89000_pr , 3 0.74000_pr , & 2 7.97000_pr , - 1 1.92000_pr , - 5 7.78800_pr , - 2 3.61000_pr , - 8.47900_pr , & - 10 2.09000_pr , 124 3.90000_pr , - 3 8.67200_pr , 6 8.14100_pr , 10 4.28000_pr , & - 14 5.00000_pr , 3.75060_pr , 74 2.31000_pr , 31 5.96000_pr , 16 5.81000_pr , & 10 5.30000_pr , - 17 8.50000_pr , 7.16440_pr , 2 7.87000_pr , 7 8.06000_pr , & 10 2.35000_pr , 2 2.15000_pr , 3 0.14000_pr , 0.00000_pr , 50 4.10000_pr , & 3 5.64000_pr , 27 4.74000_pr , - 17 1.06000_pr , 0.00000_pr , - 28 4.66000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 1 2.03900_pr , 0.00000_pr , & - 13 4.73000_pr , 8 6.02000_pr , 0.00000_pr , 3.44600_pr , - 11 3.60000_pr , & 45 7.00000_pr , - 1 2.52000_pr , 49 6.10000_pr , 21 7.50000_pr , 4 2.92000_pr , & 5 6.30000_pr , 13 2.10000_pr , 11 0.40000_pr , 2 6.51000_pr , 1.16300_pr , & - 2 8.70000_pr , - 2 5.38000_pr , 200 0.00000_pr , - 4 7.63000_pr , - 4 0.62000_pr , & 126 4.00000_pr , 4 0.25000_pr , - 2 3.50000_pr , 5 1.06000_pr , 16 0.90000_pr , & 7 0.32000_pr , - 1.99600_pr , 0.00000_pr , 1 6.62300_pr , - 7 4.46900_pr , & 8 2.64000_pr , 0.00000_pr , 0.00000_pr , 17 4.60000_pr , 21 1.88000_pr , & 6 4.07000_pr , 57 3.00000_pr , 12 4.20000_pr , - 13 1.70000_pr , 24 9.00000_pr , & 6 2.40000_pr , 139 7.00000_pr , 0.00000_pr , 0.00000_pr , - 1 6.11000_pr , & 0.00000_pr , 9.75500_pr , 13 2.40000_pr , - 6 2.73600_pr , 16 1.10000_pr , & 0.00000_pr , - 6 8.78000_pr , 238 1.10010_pr , 14 8.57000_pr , 1 8.78000_pr , & 0.00000_pr , 3 8.76000_pr , 66 7.10000_pr , 0.00000_pr , 39 9.44000_pr , & - 36 4.32000_pr , - 113 6.00000_pr , 0.00000_pr , - 15 2.00000_pr , 0.00000_pr , & 11 6.20000_pr , 0.00000_pr , 6 9.48000_pr , - 5.81500_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 49 7.34000_pr , & 0.00000_pr , 0.00000_pr , 6 1.13000_pr , 3 8.81000_pr , 0.00000_pr , & - 14 6.80000_pr , 8 9.60000_pr , - 30 5.90000_pr , 36 2.30000_pr , 2 5.34000_pr , & 14 0.10000_pr , 2 3.39000_pr , 8 5.84000_pr , 1 8.12000_pr , 5 2.13000_pr , & - 4 4.85000_pr , - 2 2.31000_pr , - 22 3.90000_pr , 24 7.50000_pr , 3 1.87000_pr , & - 2 2.97000_pr , 6 2.32000_pr , 4.68000_pr , 12 1.30000_pr , 28 8.50000_pr , & - 4.70000_pr , - 9 7.27000_pr , 1 0.38000_pr , 182 4.00000_pr , 2 1.49700_pr , & 2 8.41000_pr , 15 7.29000_pr , 22 1.40000_pr , 5 8.68000_pr , - 15 4.20000_pr , & - 11 7.14000_pr , - 2.50400_pr , - 12 3.60000_pr , 39 5.80000_pr , - 23 7.20000_pr , & - 13 3.90000_pr , 14 0.60000_pr , 31 7.60000_pr , 78 7.90000_pr , 23 4.40000_pr , & - 2 3.88000_pr , 16 7.90000_pr , 0.00000_pr , - 8 6.88000_pr , 0.00000_pr , & 14 2.90000_pr , 2 3.93000_pr , 7 0.56700_pr , 53 4.60000_pr , - 2 9.40000_pr , & - 6 5.12300_pr , - 0.69890_pr , - 13 3.40000_pr , 5 8.68700_pr , - 9 8.10700_pr , & 1 6.88400_pr , - 25 2.61000_pr , 6 5.28000_pr , 0.00000_pr , 8 7.12000_pr , & 0.00000_pr , - 4 6.77000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 12 7.00000_pr , - 13 1.40000_pr , - 13 5.70000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 332 9.20000_pr , 0.00000_pr , 0.00000_pr , 7 6.50000_pr , 7 4.15000_pr , & 16 7.00000_pr , 0.00000_pr , 2 5.82000_pr , - 4 4.50000_pr , 37 7.60000_pr , & 24 4.20000_pr , 36 5.80000_pr , 10 6.00000_pr , - 17 0.00000_pr , 42 8.00000_pr , & 6 5.69000_pr , 29 6.40000_pr , 22 3.00000_pr , 10 9.90000_pr , 76 2.80000_pr , & 4 9.80000_pr , - 13 8.40000_pr , 8 9.86000_pr , 12 2.91000_pr , 14 0.78000_pr , & 6 9.90000_pr , 13 4.70000_pr , 40 2.50000_pr , - 9 7.05000_pr , - 12 7.80000_pr , & 4 0.67500_pr , 1 9.56000_pr , 12 8.80000_pr , 15 0.64000_pr , 2 6.41000_pr , & 111 2.00000_pr , 77 4.87000_pr , - 14 3.20000_pr , 39 7.40000_pr , 41 9.10000_pr , & - 15 7.30000_pr , - 24 0.20000_pr , 0.00000_pr , 61 5.80000_pr , 0.00000_pr , & 0.00000_pr , 6.21400_pr , 0.00000_pr , 0.00000_pr , - 1 9.45000_pr , & 0.00000_pr , 27 4.10000_pr , 2.84500_pr , 147 5.90000_pr , 43 2.46000_pr , & 24 9.32000_pr , 5.57620_pr , 38 4.98000_pr , 0.00000_pr , 40 6.32000_pr , & 4 0.01100_pr , 12 6.44000_pr , - 1 6.62100_pr , 28 4.60000_pr , 0.00000_pr , & 13 9.80000_pr , 0.00000_pr , - 15 6.90000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 20 4.70000_pr , - 7 4.10000_pr , - 17 9.19000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 6 8.98300_pr , 0.00000_pr , 0.00000_pr , 98 6.50000_pr , & 52 4.10000_pr , 63 6.10000_pr , 80 3.20000_pr , 0.00000_pr , 24 9.10000_pr , & - 22 9.10000_pr , - 45 1.60000_pr , 16 4.50000_pr , 52 9.00000_pr , 24 5.40000_pr , & 13 9.40000_pr , 23 7.70000_pr , - 24 2.80000_pr , - 15 0.00000_pr , 2 8.60000_pr , & - 1 7.40000_pr , - 13 2.30000_pr , 18 5.40000_pr , - 15 1.00000_pr , 56 2.20000_pr , & 52 7.60000_pr , 74 2.10000_pr , 85 6.30000_pr , 32 5.70000_pr , 26 1.60000_pr , & 56 1.60000_pr , 60 9.80000_pr , 46 1.60000_pr , 52 1.63000_pr , 26 7.60000_pr , & 50 1.30000_pr , 52 4.90000_pr , 6 8.95000_pr , - 2 5.87000_pr , 38 9.30000_pr , & 73 8.90000_pr , 64 9.70000_pr , 6 4.16000_pr , 0.00000_pr , 8 8.63000_pr , & 191 3.00000_pr , 0.00000_pr , 79 6.90000_pr , 79 4.40000_pr , 39 4.80000_pr , & 51 7.50000_pr , 0.00000_pr , - 6 1.20000_pr , 68 2.50000_pr , 121 0.00000_pr , & - 24 5.90000_pr , 14 8.16000_pr , 51 6.17000_pr , 38 2.59000_pr , 22 3.60000_pr , & 283 6.89990_pr , 315 6.00000_pr , 235 7.20000_pr , 50 5.73000_pr , - 23 1.60000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 369 4.70000_pr , 0.00000_pr , & 0.00000_pr , 55 9.06000_pr , 0.00000_pr , - 145 5.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 476 0.29980_pr , 0.00000_pr , 0.00000_pr , & 67 4.80000_pr , 78 7.60000_pr , 150 0.10000_pr , 60 3.25000_pr , - 13 7.10000_pr , & 0.00000_pr , 28 9.60000_pr , - 26 5.20000_pr , 10 8.65000_pr , - 34 0.18000_pr , & 24 9.63000_pr , 22 7.80000_pr , 23 8.40000_pr , - 48 1.65000_pr , - 37 0.30000_pr , & - 40 6.80000_pr , - 11 8.10000_pr , - 37 8.24000_pr , 16 2.60000_pr , 33 9.80000_pr , & 52 9.00000_pr , 66 9.90000_pr , 64 9.10000_pr , 70 9.60000_pr , 61 2.80000_pr , & 25 2.56000_pr , 0.00000_pr , 91 4.20000_pr , 44 8.60000_pr , 0.00000_pr , & 24 0.80000_pr , 43 1.30000_pr , 49 4.70000_pr , 404 0.70000_pr , 69 5.00000_pr , & 21 8.80000_pr , 52 8.00000_pr , 64 5.90000_pr , 17 2.20000_pr , 0.00000_pr , & 17 1.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 76 2.70000_pr , & 0.00000_pr , 0.00000_pr , 42 0.00000_pr , - 8 9.24000_pr , 59 7.80000_pr , & 19 6.54000_pr , - 49 0.47000_pr , 41 4.57000_pr , 253 4.39990_pr , - 51 6.85000_pr , & - 8.53260_pr , 238 9.20000_pr , 30 7.19000_pr , 213 6.60010_pr , 23 1.32000_pr , & 26 4.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 50 1.40000_pr , & 0.00000_pr , 0.00000_pr , 60 9.43000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 10 1.54000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 131 8.00000_pr , 27 0.60000_pr , 90 3.80000_pr , 569 5.00000_pr , & 35 3.50000_pr , - 18 0.95000_pr , 0.00000_pr , - 60 1.80000_pr , 47 2.50000_pr , & 48 0.80000_pr , 20 0.80000_pr , 0.00000_pr , - 31 4.70000_pr , - 33 0.40000_pr , & - 44 8.20000_pr , - 59 8.80000_pr , - 34 1.60000_pr , - 33 2.90000_pr , 24 2.80000_pr , & - 6 6.17000_pr , 69 8.24000_pr , 70 8.69000_pr , 82 6.76000_pr , 120 1.00000_pr , & - 27 4.50000_pr , 41 7.90000_pr , 36 0.70000_pr , 108 1.00000_pr , 0.00000_pr , & 2 3.48400_pr , - 13 7.40000_pr , 0.00000_pr , 0.00000_pr , 384 2.50000_pr , & - 24 0.00000_pr , 38 6.60000_pr , 0.00000_pr , 0.00000_pr , - 28 7.10000_pr , & 0.00000_pr , 28 4.40000_pr , 18 0.20000_pr , 0.00000_pr , 83 2.20000_pr , & 0.00000_pr , - 50 9.30000_pr , - 20 5.70000_pr , 0.00000_pr , - 38 4.30000_pr , & 0.00000_pr , 76 7.82000_pr , - 39 5.59000_pr , 172 0.60000_pr , - 114 9.10000_pr , & - 189 9.60000_pr , 20 0.01000_pr , 145 9.60000_pr , - 8.18810_pr , 556 4.10010_pr , & - 605 8.10010_pr , 388 9.00000_pr , 0.00000_pr , 498 0.00000_pr , 0.00000_pr , & - 126 2.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 164 1.00000_pr , & - 79 6.40000_pr , - 95 4.65000_pr , - 127 0.50000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 94 4.10000_pr , 7 9.52400_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 133 3.00000_pr , 52 6.10000_pr , 132 9.00000_pr , & 88 4.90000_pr , - 25 9.70000_pr , - 10 1.70000_pr , 32 4.50000_pr , 0.00000_pr , & - 13 3.10000_pr , - 15 5.60000_pr , - 3 6.72000_pr , 0.00000_pr , - 17 8.54610_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 25 3.10000_pr , - 34 1.60000_pr , & 0.00000_pr , - 1 1.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 1000 0.00000_pr , 62 2.30000_pr , 0.00000_pr , 0.00000_pr , 142 1.30000_pr , & 0.00000_pr , 0.00000_pr , 83 8.40000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 16 7.30000_pr , 0.00000_pr , 0.00000_pr , & - 23 4.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 81 0.50000_pr , 0.00000_pr , 0.00000_pr , 62 8.80000_pr , & 229 0.50000_pr , 0.00000_pr , 0.00000_pr , 141 9.00000_pr , 0.00000_pr , & 398 8.60010_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 47 6.40000_pr , 18 2.60000_pr , & 2 5.77000_pr , - 5 2.10000_pr , 8 4.00000_pr , 2 3.39000_pr , - 19 5.40000_pr , & - 35 6.10000_pr , 0.00000_pr , 12 8.00000_pr , 37 2.20000_pr , 38 5.40000_pr , & 19 1.10000_pr , 0.00000_pr , 39 4.60000_pr , 22 5.30000_pr , - 45 0.30000_pr , & 2 9.10000_pr , - 28 7.50000_pr , - 29 7.80000_pr , 28 6.28000_pr , 8 2.86000_pr , & 55 2.10000_pr , 37 2.00000_pr , 51 8.40000_pr , - 14 2.61000_pr , - 10 1.50000_pr , & 30 3.65700_pr , 16 0.60000_pr , 31 7.50000_pr , 13 5.40000_pr , 13 8.00000_pr , & - 14 2.60000_pr , - 16 0.70000_pr , 11 0.40000_pr , 0.00000_pr , - 4 0.90000_pr , & 0.00000_pr , 9 7.04000_pr , 0.00000_pr , 12 3.40000_pr , 99 2.40000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 15 6.40000_pr , & 0.00000_pr , 0.00000_pr , 27 8.80000_pr , - 7 2.03600_pr , 34 1.49000_pr , & 1 8.07400_pr , - 0.86320_pr , 0.00000_pr , 0.00000_pr , 64 9.52000_pr , & - 11 9.69000_pr , 160 2.10000_pr , 62 1.00000_pr , - 36 1.80000_pr , 0.00000_pr , & - 4 6.78000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 67 7.00000_pr , & 44 8.75000_pr , 34 7.30000_pr , 58 6.80000_pr , - 20 3.60000_pr , 30 6.42000_pr , & - 11 6.00000_pr , - 27 1.10000_pr , - 3 7.36000_pr , 0.00000_pr , 18 5.10000_pr , & - 23 6.50000_pr , - 7.83800_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 16 5.50000_pr , - 4 7.51000_pr , & 19 0.60000_pr , 24 2.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 24 5.90000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 35 4.00000_pr , & 18 3.80000_pr , 0.00000_pr , 1 3.89000_pr , 0.00000_pr , 57 7.50000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 2.68910_pr , & 0.00000_pr , 34 0.00000_pr , 86 7.50000_pr , 0.00000_pr , 0.00000_pr , & 145 5.70000_pr , 0.00000_pr , - 7 4.96000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 23 2.10000_pr , 3 7.85000_pr , 5.99400_pr , 568 8.00000_pr , 10 1.10000_pr , & - 1 0.72000_pr , 7 2.87000_pr , - 44 9.40000_pr , - 21 3.70000_pr , - 11 0.30000_pr , & 0.00000_pr , 116 7.00000_pr , 46 1.30000_pr , 0.00000_pr , 13 6.00000_pr , & 288 8.60010_pr , - 29 4.80000_pr , 0.00000_pr , - 26 6.60000_pr , - 25 6.30000_pr , & 3 5.38000_pr , - 13 2.95000_pr , 17 6.45000_pr , 12 9.49000_pr , - 17 1.10000_pr , & 12 9.30000_pr , 0.00000_pr , 24 3.77500_pr , 0.00000_pr , - 14 6.31000_pr , & 15 2.00000_pr , 2 1.92000_pr , 2 4.37000_pr , - 32 7.44000_pr , 4 1.57000_pr , & 17 5.53000_pr , 61 1.30000_pr , 0.00000_pr , - 8 2.12000_pr , 0.00000_pr , & - 23 4.90000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 3.44400_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 13 2.47000_pr , 0.00000_pr , - 74 2.20000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 34 7.00000_pr , 0.00000_pr , & 3 1.83000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 26 9.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 9 8.18000_pr , 50 7.00000_pr , 33 3.50000_pr , 28 7.10000_pr , 19 7.80000_pr , & 26 7.80000_pr , 17 9.70000_pr , 0.00000_pr , 0.00000_pr , - 19 0.40000_pr , & 76 6.00000_pr , - 24 1.80000_pr , 0.00000_pr , 45 7.30000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 55 4.40000_pr , 9 9.37000_pr , & 19 3.90000_pr , 0.00000_pr , 0.00000_pr , 23 5.60000_pr , 35 1.90000_pr , & 38 3.30000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 20 1.50000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 13 4.50000_pr , 0.00000_pr , - 11 6.70000_pr , & 0.00000_pr , 14 5.40000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 18 9.89000_pr , 0.00000_pr , 60 6.20000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 184 3.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 25 1.50000_pr , 21 4.50000_pr , 3 2.14000_pr , & 21 3.10000_pr , 2 8.06000_pr , - 12 8.60000_pr , 54 0.50000_pr , - 16 2.87420_pr , & - 10 3.60000_pr , 30 4.10000_pr , - 23 5.70000_pr , - 23 4.00000_pr , 0.00000_pr , & 22 2.10000_pr , - 5 6.08000_pr , - 19 4.10000_pr , 0.00000_pr , - 15 6.10000_pr , & 3 8.81000_pr , - 33 8.50000_pr , 22 5.39000_pr , - 19 7.71000_pr , - 2 0.93000_pr , & 11 3.90000_pr , - 2 5.15000_pr , - 9 4.49000_pr , 0.00000_pr , 11 2.38200_pr , & 6 3.71000_pr , - 8 7.31000_pr , 9.20700_pr , 47 6.60000_pr , 73 6.40000_pr , & - 19 8.49000_pr , - 9 3.51000_pr , 0.00000_pr , - 21 7.90000_pr , 16 7.30000_pr , & - 15 8.20000_pr , 0.00000_pr , - 24 7.80000_pr , 44 8.50000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 2 8.09700_pr , - 10 6.55000_pr , - 35 0.71000_pr , & 7 0.09300_pr , 198 6.80000_pr , 0.00000_pr , 26 6.63000_pr , - 17 8.30000_pr , & 32 5.50000_pr , 88 1.01000_pr , - 48 0.90000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 19 9.90000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 39 1.50000_pr , 24 0.90000_pr , & 16 1.70000_pr , 1 9.02000_pr , 8.64200_pr , 35 9.30000_pr , 4 8.89000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 7 8.36000_pr , 0.00000_pr , 12 7.40000_pr , 3 8.89000_pr , - 1 5.07000_pr , & 0.00000_pr , - 15 7.30000_pr , 0.00000_pr , 13 1.20000_pr , 0.00000_pr , & 0.00000_pr , 26 1.10000_pr , 10 8.50000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 10 6.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 4 9.70000_pr , 0.00000_pr , 0.00000_pr , 96 1.80000_pr , & - 12 5.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 4 9.14500_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 60 7.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 25 5.70000_pr , & 16 3.90000_pr , 12 2.80000_pr , - 4 9.29000_pr , 4 2.70000_pr , - 2 0.98000_pr , & 16 8.00000_pr , 0.00000_pr , - 17 4.20000_pr , 0.00000_pr , - 7 3.50000_pr , & 0.00000_pr , 25 1.50000_pr , - 10 7.20000_pr , 0.00000_pr , 86 5.90000_pr , & 0.00000_pr , 0.00000_pr , - 10 8.50000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 9 1.13000_pr , 10 2.20000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 19 8.80000_pr , 0.00000_pr , 0.00000_pr , 28 4.50000_pr , & 146 4.20000_pr , 160 3.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 2 7.88800_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 127 3.00000_pr , 0.00000_pr , - 49 7.83000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 20 6.60000_pr , 6 1.11000_pr , 9 0.49000_pr , 2 3.50000_pr , - 32 3.00000_pr , & 5 3.90000_pr , 30 4.00000_pr , 0.00000_pr , - 16 9.00000_pr , 0.00000_pr , & - 19 6.70000_pr , 0.00000_pr , 542 2.29980_pr , - 4 1.11000_pr , - 18 9.20000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 14 1.40000_pr , - 29 3.70000_pr , 31 6.90000_pr , 295 1.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 25 7.20000_pr , & 0.00000_pr , 0.00000_pr , 11 6.47800_pr , - 18 5.20000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 4 5.25800_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 30 8.90000_pr , 0.00000_pr , & - 73 0.22000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 92 0.70000_pr , 74 9.30000_pr , 64 8.20000_pr , 66 4.20000_pr , & - 5 2.39000_pr , 48 9.70000_pr , 24 3.20000_pr , 11 9.90000_pr , 620 1.00000_pr , & 0.00000_pr , 47 5.50000_pr , 0.00000_pr , 0.00000_pr , - 20 0.70000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 11 7.40000_pr , 77 7.40000_pr , & 49 3.80000_pr , 42 9.70000_pr , 14 0.80000_pr , 0.00000_pr , 89 8.20000_pr , & 33 4.90000_pr , 0.00000_pr , 13 4.90000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 19 2.30000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 34 3.70000_pr , & 0.00000_pr , - 2 2.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 28 7.77000_pr , 28 0.50000_pr , - 4.44900_pr , & 5 2.80000_pr , 17 0.02900_pr , 58 0.48000_pr , 45 9.00000_pr , - 30 5.50000_pr , & 7.34100_pr , 0.00000_pr , 0.00000_pr , - 23 3.40000_pr , 21 3.20000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 8 9.70000_pr , 0.00000_pr , & 13 4.28000_pr , - 31 3.50000_pr , 0.00000_pr , 58 7.30000_pr , 1 8.98000_pr , & 36 8.50000_pr , 0.00000_pr , 0.00000_pr , 247 5.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 4 2.71000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 28 1.60000_pr , 15 9.80000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 22 1.40000_pr , 0.00000_pr , 0.00000_pr , - 10 9.83000_pr , & 22 6.85000_pr , 0.00000_pr , 0.00000_pr , 13 2.98000_pr , 0.00000_pr , & - 6 8.65300_pr , - 2 8.75000_pr , - 36 9.70000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 7 5.33800_pr , 59 7.00000_pr , 33 6.90000_pr , & 21 2.50000_pr , 609 6.00000_pr , 6.71200_pr , 5 3.28000_pr , 11 2.60000_pr , & 0.00000_pr , 48 1.70000_pr , 0.00000_pr , 49 4.60000_pr , - 4 7.25000_pr , & - 1 8.51000_pr , 35 8.90000_pr , 14 7.10000_pr , 0.00000_pr , - 28 1.60000_pr , & - 16 9.67000_pr , 0.00000_pr , 0.00000_pr , 5 4.32000_pr , 25 8.60000_pr , & 7 4.04000_pr , 49 1.95000_pr , 36 3.50000_pr , 0.28300_pr , 0.00000_pr , & 33 5.74300_pr , 16 1.00000_pr , 0.00000_pr , 16 9.60000_pr , 0.00000_pr , & 13 6.90000_pr , 32 9.12000_pr , 0.00000_pr , - 4 2.31000_pr , 33 5.20000_pr , & 0.00000_pr , 15 0.60000_pr , 0.00000_pr , - 6 1.60000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 11 9.20000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 50 4.60000_pr , & - 23 1.30000_pr , 0.00000_pr , - 7.73890_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 5 3.75000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 18 8.14000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 66 3.50000_pr , & 31 8.90000_pr , 53 7.40000_pr , 87 2.30000_pr , 19 9.00000_pr , - 20 2.00000_pr , & - 1 4.09000_pr , 40 8.90000_pr , 66 9.40000_pr , 49 7.50000_pr , 66 0.20000_pr , & - 26 8.10000_pr , 66 4.60000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 39 6.00000_pr , - 15 3.70000_pr , 0.00000_pr , 0.00000_pr , 51 9.10000_pr , & 54 3.30000_pr , 50 4.20000_pr , 63 1.00000_pr , 99 3.40000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 57 0.60000_pr , 0.00000_pr , & 61 6.60000_pr , 525 6.00000_pr , 0.00000_pr , - 18 0.20000_pr , 0.00000_pr , & 89 8.20000_pr , 0.00000_pr , - 9 7.77000_pr , 0.00000_pr , 117 9.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 7 0.25000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 5 0.34900_pr , 69 8.17000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 67 1.59000_pr , 0.00000_pr , - 26 3.27000_pr , 19 7.50000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 3 6.34000_pr , - 49 1.10000_pr , & - 54 9.40000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 3 5.93000_pr , - 3 6.87000_pr , - 1 8.81000_pr , - 11 4.14000_pr , 7 5.62000_pr , & - 3 8.32000_pr , 32 5.44000_pr , 0.00000_pr , - 19 1.69000_pr , 75 1.90000_pr , & - 3 4.74000_pr , 0.00000_pr , 30 1.14000_pr , - 8 2.92000_pr , 0.00000_pr , & 0.00000_pr , 28 7.00000_pr , 0.00000_pr , 4.93300_pr , 1 3.41000_pr , & 0.00000_pr , - 8 4.53000_pr , - 15 7.10000_pr , 1 1.80000_pr , - 12 9.70000_pr , & 11 3.00000_pr , 197 1.00000_pr , - 7 3.09200_pr , - 2 7.94000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 26 2.30000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 38 3.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 18 2.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 6 6.60800_pr , 0.00000_pr , 4 1.58900_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 8 9.89000_pr , & - 3 5.08000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 5 3.76000_pr , 5 8.55000_pr , - 14 4.40000_pr , - 11 1.00000_pr , & 6 5.28000_pr , - 10 2.54000_pr , 37 0.40000_pr , 0.00000_pr , - 13 0.30000_pr , & 6 7.52000_pr , 10 8.85000_pr , 0.00000_pr , 13 7.77000_pr , 0.00000_pr , & 0.00000_pr , - 7 3.85000_pr , - 11 1.00000_pr , - 35 1.60000_pr , - 15 2.70000_pr , & - 4 4.70000_pr , 10 8.31000_pr , 0.00000_pr , 0.00000_pr , 1 7.97000_pr , & - 8.30900_pr , - 9.63900_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 4 0.82000_pr , - 17 4.50000_pr , 0.00000_pr , & - 21 5.00000_pr , 0.00000_pr , 30 1.90000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 30 5.40000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 19 4.70000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 13 2.38000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 28 8.17000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 7 7.94000_pr , - 6 5.42000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 2 4.90000_pr , - 1 3.99000_pr , - 23 1.90000_pr , & - 8 0.25000_pr , - 9 8.12000_pr , - 13 9.35000_pr , 35 3.68000_pr , 0.00000_pr , & - 35 4.55000_pr , - 48 3.70000_pr , - 20 9.66000_pr , - 12 6.20000_pr , - 15 4.30000_pr , & 0.00000_pr , 0.00000_pr , - 35 2.90000_pr , 0.00000_pr , - 11 4.73000_pr , & - 1 5.62000_pr , 3 9.63000_pr , 24 9.15000_pr , 0.00000_pr , 0.00000_pr , & 5 1.90000_pr , - 0.22660_pr , 0.00000_pr , 0.00000_pr , - 2 6.05800_pr , & 0.00000_pr , 4 8.48400_pr , 0.00000_pr , 2 1.76000_pr , 0.00000_pr , & 0.00000_pr , - 34 3.60000_pr , 0.00000_pr , - 14 9.80000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 19 3.00000_pr , 0.00000_pr , 0.00000_pr , & - 19 6.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 36 3.10000_pr , & 0.00000_pr , 0.00000_pr , - 29 1.14000_pr , 70 9.31000_pr , - 2 9.29000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 5 4.69000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 5 0.14000_pr , - 1 7.58800_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 3 6.23000_pr , 10 4.30000_pr , - 10 9.70000_pr , & 3.00000_pr , - 14 1.30000_pr , 14 3.10000_pr , - 4 4.76000_pr , 49 7.54000_pr , & 182 7.00000_pr , - 3 9.20000_pr , 0.00000_pr , 5 4.57000_pr , 17 9.70000_pr , & 4 7.67000_pr , - 9 9.81000_pr , 7 1.23000_pr , - 26 2.00000_pr , 88 2.00000_pr , & - 20 5.30000_pr , - 5 4.86000_pr , 18 3.40000_pr , 6 2.42000_pr , 5 6.33000_pr , & - 3 0.10000_pr , 0.00000_pr , 24 8.40000_pr , - 3 4.68000_pr , 51 4.60000_pr , & - 6 0.71000_pr , 0.00000_pr , - 13 3.16000_pr , 0.00000_pr , 4 8.49000_pr , & 7 7.55000_pr , 19 5.84000_pr , - 5 8.43000_pr , - 8 5.14800_pr , - 13 4.20000_pr , & - 12 4.60000_pr , - 18 6.70000_pr , 0.00000_pr , 33 5.70000_pr , 0.00000_pr , & 7 0.81000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 3.16300_pr , & - 1 1.30000_pr , 0.00000_pr , - 7 9.34000_pr , - 4 3.83400_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 37 8.87000_pr , 0.00000_pr , & 0.00000_pr , 29 0.17000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 6 0.50000_pr , 2 9.53000_pr , 32 3.47000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 23 6.96000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 1 1.44000_pr , & 10 0.10000_pr , 18 7.00000_pr , - 21 1.00000_pr , 12 3.50000_pr , - 2 8.25000_pr , & 13 3.90000_pr , 691 5.00000_pr , - 11 9.80000_pr , 0.00000_pr , 44 2.40000_pr , & 2 4.28000_pr , 13 4.80000_pr , 3 0.05000_pr , - 1 8.93000_pr , - 18 1.90000_pr , & 61 7.50000_pr , 0.00000_pr , - 4.62400_pr , - 7 9.08000_pr , 15 3.00000_pr , & 22 3.10000_pr , 19 2.10000_pr , - 7 5.97000_pr , 0.00000_pr , 13 2.90000_pr , & - 12 3.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 18 5.30000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 95 6.10000_pr , & 0.00000_pr , 0.00000_pr , 16 1.50000_pr , 0.00000_pr , 0.00000_pr , & 7.08200_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 15 2.67000_pr , - 7 8.40000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 15 7.35000_pr , 1 7.60000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 7 8.05000_pr , & - 10 5.78000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 66 1.50000_pr , 35 7.50000_pr , 16 8.04000_pr , 362 9.00000_pr , 25 6.50000_pr , & 7 5.14000_pr , 22 0.60000_pr , 0.00000_pr , 13 7.50000_pr , 0.00000_pr , & - 8 1.13000_pr , 0.00000_pr , 9 5.18000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.51500_pr , 0.00000_pr , & 3 2.73000_pr , 10 8.90000_pr , 0.00000_pr , 49 0.88000_pr , 13 2.70000_pr , & 0.00000_pr , - 8 5.12000_pr , 27 7.80000_pr , 0.00000_pr , 0.00000_pr , & 48 1.34800_pr , 6 4.28000_pr , 12 5.30000_pr , 17 4.43300_pr , 0.00000_pr , & 0.00000_pr , 37 9.40000_pr , 0.00000_pr , 22 3.60000_pr , 0.00000_pr , & - 12 4.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 84 4.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 17 6.30000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 54 3.00000_pr , 0.00000_pr , 19 4.90000_pr , 444 8.00000_pr , & 15 7.10000_pr , 0.00000_pr , 39 9.50000_pr , 0.00000_pr , 54 8.50000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 13 9.30000_pr , 284 5.00000_pr , 0.00000_pr , & 0.00000_pr , 8 6.20000_pr , 0.00000_pr , 0.00000_pr , 53 4.70000_pr , & 221 3.00000_pr , 53 3.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 244 8.00000_pr , 428 8.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 35 9.30000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 7 9.88000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 5 4.43300_pr , 7 6.30000_pr , 5 2.06800_pr , & - 9.45100_pr , 48 8.90000_pr , - 3 1.09000_pr , 88 7.10000_pr , 848 3.50000_pr , & 21 6.13800_pr , 0.00000_pr , 18 3.04600_pr , 0.00000_pr , 14 0.89600_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 23 0.85200_pr , 0.00000_pr , 45 0.08800_pr , 0.00000_pr , 11 6.61200_pr , & 13 2.20000_pr , 0.00000_pr , 32 0.20000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 2 7.45000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 16 7.90000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 88 5.50000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 44 6.14000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 27 6.40000_pr , & 4 2.98700_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 1 4.90700_pr , & 35 3.99000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 28 7.38000_pr , 28 1.67000_pr , & - 1 0.43000_pr , 39 3.60000_pr , 14 7.50000_pr , 1 7.50000_pr , 0.00000_pr , & 0.00000_pr , - 4 6.28000_pr , 0.00000_pr , 0.00000_pr , 10 3.90000_pr , & - 8.53800_pr , - 7 0.14000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.46040_pr , 0.00000_pr , 5 9.02000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 8 5.70000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 7 1.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 27 4.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 6.97100_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 2 6.90100_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 8 7.26400_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 35 4.55000_pr , & 26 2.90000_pr , - 6 4.69000_pr , 4 8.49000_pr , - 12 0.46000_pr , 0.00000_pr , & 18 8.02600_pr , 0.00000_pr , - 16 3.70000_pr , 0.00000_pr , 20 2.25000_pr , & 0.00000_pr , 17 0.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 20 8.90000_pr , 0.00000_pr , & 0.00000_pr , - 6 4.38000_pr , 54 6.68000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 6 4.28000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 16 8.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 302 5.00000_pr , 0.00000_pr , 21 0.36600_pr , 497 5.00000_pr , - 31 8.93000_pr , & - 11 9.20000_pr , 1 2.72000_pr , - 68 7.10000_pr , 7 1.46000_pr , 0.00000_pr , & - 10 1.70000_pr , 0.00000_pr , - 2 0.11000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.10040_pr , 0.00000_pr , 17 7.50000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 13 9.82200_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 53 5.80000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 19 1.70000_pr , 0.00000_pr , & - 26 4.30000_pr , 0.00000_pr , 0.00000_pr , 26 2.00000_pr , 0.00000_pr , & 0.00000_pr , 51 5.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 15 6.35000_pr , 0.00000_pr , 198 5.00000_pr , 139 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 15 0.80000_pr , - 18 6.40000_pr , 13 5.70000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 33 5.80000_pr , 0.00000_pr , 11 3.30000_pr , 25 9.00000_pr , & 31 3.50000_pr , 21 2.10000_pr , 0.00000_pr , 0.00000_pr , 5 3.59000_pr , & 11 7.00000_pr , 14 8.30000_pr , 0.00000_pr , - 14 9.50000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 22 8.40000_pr , 0.00000_pr , 17 7.60000_pr , 8 6.40000_pr , 24 7.80000_pr , & 0.00000_pr , 30 4.30000_pr , 299 0.00000_pr , 29 2.70000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 28 8.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 47 9.50000_pr , 18 3.80000_pr , 26 1.30000_pr , & 21 0.00000_pr , 20 2.10000_pr , 10 6.30000_pr , 0.00000_pr , 0.00000_pr , & 24 5.20000_pr , 0.00000_pr , 1 8.88000_pr , 0.00000_pr , - 20 2.30000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 6 0.78000_pr , & - 6 2.17000_pr , - 9 5.00000_pr , 34 4.40000_pr , 31 5.90000_pr , 0.00000_pr , & 14 6.60000_pr , 59 3.40000_pr , 1 0.17000_pr , - 12 4.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 11 1.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 62 7.70000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 3 9.26700_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 8 0.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 2 7.13900_pr , 7 4.05100_pr , & 40 6.59000_pr , - 14 7.47000_pr , 72 7.80000_pr , - 18 9.07000_pr , 75 2.00000_pr , & 0.00000_pr , - 6 5.22900_pr , 0.00000_pr , 118 4.60000_pr , 0.00000_pr , & - 17 7.71000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 20 3.02000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 22 2.38000_pr , 0.00000_pr , - 2 7.70100_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 12 1.00000_pr , 0.00000_pr , 63 1.50000_pr , & 0.00000_pr , 6.69900_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 12 5.98000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 17 3.86000_pr , & - 9.77500_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 52 6.50000_pr , & 17 9.00000_pr , 16 9.90000_pr , 428 4.00000_pr , - 20 2.10000_pr , - 39 9.30000_pr , & - 13 9.00000_pr , 0.00000_pr , - 4 4.58000_pr , 0.00000_pr , 5 2.08000_pr , & 0.00000_pr , 12 8.80000_pr , 0.00000_pr , 0.00000_pr , 24 3.10000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 46 3.60000_pr , 0.00000_pr , & 21 5.00000_pr , 36 3.70000_pr , 33 7.70000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 3 1.66000_pr , 0.00000_pr , - 41 7.20000_pr , & 0.00000_pr , 3 2.90000_pr , 13 7.40000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 13 6.60000_pr , 0.00000_pr , - 2 9.34000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 68 9.00000_pr , - 5 2.87000_pr , 38 3.90000_pr , - 11 9.20000_pr , 7 4.27000_pr , & - 5.22400_pr , 16 0.80000_pr , 0.00000_pr , 0.00000_pr , - 33 9.20000_pr , & - 2 8.61000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 8 1.57000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 36 9.49000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 83 7.20000_pr , 0.00000_pr , 5.15000_pr , 0.00000_pr , & - 5 3.91000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 6 7.39200_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 4.18900_pr , - 6 6.46000_pr , - 25 9.10000_pr , - 28 2.50000_pr , & 22 5.80000_pr , 3 3.47000_pr , 0.00000_pr , 0.00000_pr , - 3 4.57000_pr , & 17 2.40000_pr , - 27 5.20000_pr , - 1 1.40000_pr , 24 0.20000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 16 0.70000_pr , - 5 5.77000_pr , & - 1 1.16000_pr , - 16 8.20000_pr , - 9 1.80000_pr , 11 1.20000_pr , 18 7.10000_pr , & 0.00000_pr , 1 0.76000_pr , 0.00000_pr , - 4 7.37000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 207 3.20000_pr , & 0.00000_pr , - 20 8.80000_pr , 0.00000_pr , 0.00000_pr , - 13 7.70000_pr , & 0.00000_pr , - 19 8.00000_pr , 0.00000_pr , 0.00000_pr , - 6 6.31000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 8 3.45080_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 54 7.63000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 4 3.95800_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 12 5.80000_pr , 35 9.30000_pr , 38 9.30000_pr , & 10 1.40000_pr , 4 4.78000_pr , - 4 8.25000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 27 3.95000_pr , & 0.00000_pr , 57 0.90000_pr , - 19 6.31200_pr , 0.00000_pr , - 15 8.80000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 21 5.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 18 5.60000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 4.76490_pr , 0.00000_pr , 0.00000_pr , 48 5.30000_pr , - 7 0.45000_pr , & 24 5.60000_pr , 562 9.00000_pr , - 14 3.90000_pr , - 17 2.40000_pr , 31 9.00000_pr , & 0.00000_pr , - 6 1.70000_pr , - 26 8.80000_pr , 8 5.33000_pr , 30 8.90000_pr , & 25 4.80000_pr , - 16 4.00000_pr , 0.00000_pr , 2 2.05000_pr , - 33 4.40000_pr , & 0.00000_pr , - 15 1.50000_pr , - 22 8.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 49 8.60000_pr , 0.00000_pr , - 22 3.10000_pr , 0.00000_pr , & 0.00000_pr , 7 8.92000_pr , 0.00000_pr , 30 2.20000_pr , 0.00000_pr , & 0.00000_pr , - 11 9.80000_pr , - 9 7.71000_pr , - 8.80400_pr , 25 5.00000_pr , & 0.00000_pr , 0.00000_pr , 5 5.80000_pr , - 2 8.65000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 21 3.90000_pr , - 10 6.80000_pr , 0.00000_pr , 0.00000_pr , - 8 6.30000_pr , & 0.00000_pr , 36 6.10000_pr , 0.00000_pr , 16 5.65000_pr , 0.00000_pr , & 26 0.30000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 2.85900_pr , & 44 9.40000_pr , 2 2.67000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 11 7.17000_pr , - 5.57900_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 3 2.17000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 21 3.34000_pr , 0.00000_pr , 0.00000_pr , 70 5.60000_pr , & 0.00000_pr , 0.00000_pr , 13 6.80000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 51 6.70000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 6 5.97000_pr , 8 6.24300_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 15 8.17000_pr , 0.00000_pr , 0.00000_pr , & 38 7.10000_pr , 4 8.33000_pr , 10 3.50000_pr , 6 9.26000_pr , 19 0.30000_pr , & 16 5.70000_pr , - 19 7.50000_pr , - 49 4.20000_pr , - 1 8.80000_pr , - 27 5.50000_pr , & 56 0.20000_pr , - 12 2.30000_pr , 41 7.00000_pr , 0.00000_pr , - 3 8.77000_pr , & 0.00000_pr , - 8 9.42000_pr , 0.00000_pr , 12 0.30000_pr , - 33 7.00000_pr , & 6 3.67000_pr , - 9 6.87000_pr , 25 5.80000_pr , 25 6.50000_pr , - 7 1.18000_pr , & 24 8.40000_pr , 0.00000_pr , 46 9.80000_pr , 0.00000_pr , 4 3.37000_pr , & 34 7.80000_pr , 6 8.55000_pr , - 19 5.10000_pr , 0.00000_pr , 15 3.70000_pr , & 42 3.40000_pr , 73 0.80000_pr , 0.00000_pr , 7 2.31000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 10 1.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 5.80250_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 45 0.40000_pr , 0.00000_pr , - 43 2.30000_pr , 0.00000_pr , & - 81 7.70000_pr , 0.00000_pr , - 36 3.80000_pr , 0.00000_pr , - 58 8.90000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 133 8.00000_pr , - 66 4.40000_pr , & 44 8.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 74 5.30000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 25 2.70000_pr , 0.00000_pr , 23 8.90000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 27 5.90000_pr , - 132 7.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 23 3.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 216 6.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 22 0.30000_pr , 8 6.46000_pr , & 3 0.04000_pr , 4 6.38000_pr , - 50 4.20000_pr , 0.00000_pr , - 45 2.20000_pr , & - 65 9.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 3 5.68000_pr , 0.00000_pr , - 20 9.70000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 100 4.20000_pr , 0.00000_pr , - 26 2.00000_pr , 0.00000_pr , & 0.00000_pr , - 2 2.58900_pr , 0.00000_pr , 0.00000_pr , 2 6.35000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 5 7.14400_pr , 5 2.71000_pr , 0.00000_pr , 0.00000_pr , 11 3.21000_pr , & - 16 4.86000_pr , 1 4.90400_pr , 37 3.02000_pr , - 38 2.92000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 5.86900_pr , & 0.00000_pr , - 8 8.11000_pr , 0.00000_pr , 7 2.96000_pr , - 5 2.10000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 21 8.90000_pr , & 0.00000_pr , 13 0.13000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 11 1.80000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 3 0.02700_pr , - 18 6.90000_pr , 0.00000_pr , - 19 3.10000_pr , & 20 9.42000_pr , 0.00000_pr , - 7 8.75000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 25 0.50000_pr , - 6 2.40000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 14 8.90000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 39 0.90000_pr , 20 0.20000_pr , 0.00000_pr , 0.00000_pr , - 38 2.70000_pr , & 0.00000_pr , 83 5.60000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 32 2.30000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 17 4.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 36 3.40000_pr , 0.00000_pr , 0.00000_pr , & - 13 7.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 55 3.30000_pr , 26 8.10000_pr , 33 3.30000_pr , 42 1.90000_pr , & - 24 8.30000_pr , 0.00000_pr , 13 9.60000_pr , 0.00000_pr , 3 7.54000_pr , & 0.00000_pr , 15 1.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 1 6.23000_pr , & 0.00000_pr , 0.00000_pr , 36 1.10000_pr , 0.00000_pr , 42 3.10000_pr , & 43 4.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 35 3.50000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 12 2.40000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 24 1.64000_pr , 0.00000_pr , - 16 7.10000_pr , 7 6.05000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 24 0.00000_pr , - 2 7.10000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 29 8.62000_pr , 22 4.31000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 3 7.63000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 56 5.90000_pr , & 6 3.95000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 1 8.27000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 3 2.10390_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 14 6.01000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 2 0.80700_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 21 6.10000_pr , 6 2.56000_pr , & - 5 9.58000_pr , - 20 3.60000_pr , 10 4.70000_pr , - 5 9.40000_pr , 40 7.90000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 9 2.99000_pr , & 0.00000_pr , - 3 9.16000_pr , 18 4.90000_pr , 5 7.65000_pr , - 4 6.01000_pr , & 0.00000_pr , 100 5.00000_pr , - 16 2.60000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 13 6.60000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 10 8.50000_pr , 0.00000_pr , - 4.56500_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 36 1.75000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 59 1.04000_pr , 28 2.09000_pr , 3 5.97300_pr , 4.61620_pr , 21 7.22000_pr , & 9.52510_pr , - 15 9.20000_pr , 0.00000_pr , 7 0.16000_pr , 17 3.78000_pr , & 15 2.49000_pr , 33 3.00000_pr , 10 9.27000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 3 1.40100_pr , 0.00000_pr , 12 6.47000_pr , 25 9.39000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 13 7.27000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 21 1.09000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 53 1.64000_pr , 44 4.81000_pr , 0.00000_pr , & 0.00000_pr , - 3.27340_pr , 0.00000_pr , 52 8.38000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 23 4.81000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 205 4.30000_pr , 228 7.50000_pr , 99 8.74000_pr , 59 4.75000_pr , & - 25 2.04000_pr , 13 8.95000_pr , - 65 5.58000_pr , 0.00000_pr , 0.16190_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 32 2.12000_pr , 4 3.04800_pr , & 1 7.88500_pr , 7 4.72800_pr , 0.00000_pr , 0.00000_pr , - 26 8.20000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 23 7.66000_pr , 0.00000_pr , & 34 7.79000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 3 2.64800_pr , & 0.00000_pr , 0.00000_pr , 71 3.90000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 136 1.70000_pr , 427 8.70020_pr , & 0.00000_pr , 145 3.40000_pr , 190 0.00000_pr , 0.00000_pr , 189 3.10000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 14 4.22000_pr , 0.00000_pr , 52 2.60000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 91 9.80000_pr , - 5 2.10700_pr , 21 9.25000_pr , & 29 6.88000_pr , 51 0.64000_pr , - 7 2.04000_pr , - 116 3.50000_pr , 69 5.70000_pr , & 13 2.28000_pr , - 16 2.00000_pr , 81 8.72000_pr , - 56 0.60000_pr , 279 5.30000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 4 3.71700_pr , & 30 7.10000_pr , 7 3.85900_pr , - 6.39730_pr , 33 7.09000_pr , 12 8.30000_pr , & 0.00000_pr , 29 9.00000_pr , 0.00000_pr , 0.00000_pr , 57 5.80000_pr , & 0.00000_pr , 40 5.10000_pr , 5 2.10000_pr , 0.00000_pr , 10 0.31000_pr , & - 1 0.69900_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 36 0.10000_pr , 33 2.65000_pr , 18 3.65000_pr , 0.00000_pr , 0.00000_pr , & - 20 9.22000_pr , 9 5.54800_pr , 31 6.90000_pr , 35 5.50000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 132 9.90000_pr , - 139 7.60000_pr , 0.00000_pr , & 19 6.16000_pr , 3 2.04300_pr , - 20 1.60000_pr , 69 4.28000_pr , 11 4.96000_pr , & 304 8.89990_pr , 4.20380_pr , 6 9.85000_pr , 0.00000_pr , 14 4.40000_pr , & 19 8.92000_pr , 5 5.66000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 10 9.11000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 3 9.10100_pr , 3 8.60200_pr , & 13 1.51000_pr , 3 7.87600_pr , 67 1.69000_pr , 55 3.56000_pr , - 157 3.20000_pr , & 82 4.71000_pr , 53 6.92000_pr , 41 5.90000_pr , 0.00000_pr , 0.00000_pr , & 19 7.09000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 20 8.55000_pr , 0.00000_pr , 110 2.10000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 21 4.10000_pr , 33 8.87000_pr , 0.00000_pr , 28 3.80000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 40 0.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 20 4.80000_pr , 34 9.00000_pr , 0.00000_pr , 36 9.70000_pr , & 35 0.68000_pr , 0.00000_pr , 0.00000_pr , 2 9.47700_pr , 108 0.30000_pr , & 7 3.56300_pr , 0.00000_pr , 0.00000_pr , 1 1.86800_pr , 1 1.86500_pr , & 27 8.10000_pr , 12 8.55000_pr , 1.62330_pr , 39 4.70000_pr , 0.00000_pr , & 21 1.01000_pr , 0.00000_pr , - 289 7.00000_pr , 0.00000_pr , - 5.56000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 10 3.94000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 14 2.06000_pr , 0.00000_pr , 0.00000_pr , - 1 9.62800_pr , & 0.00000_pr , 28 5.26000_pr , 13 0.37000_pr , 201 8.60000_pr , 106 1.40000_pr , & - 218 1.89990_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 14 7.51000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 43 4.74000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 20 8.14000_pr , 0.00000_pr , 0.00000_pr , 3 2.63100_pr , & 4 4.34900_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 110 1.90000_pr , 0.00000_pr , - 16 2.70750_pr , 15 3.80000_pr , & 4 0.49000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 37 3.66000_pr , 0.00000_pr , & 12 0.00000_pr , 40 6.80000_pr , 32 2.70000_pr , 0.00000_pr , - 56 8.20000_pr , & 21 3.64000_pr , - 31 8.89000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 19 1.54000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 33 8.30000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 38 4.20000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 59 0.21000_pr , 56 8.20000_pr , 1 7.42500_pr , - 7.72020_pr , & 0.00000_pr , 2.12140_pr , 0.00000_pr , 419 6.20020_pr , - 1 8.70300_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 453 6.00000_pr , & 20 9.30000_pr , 5 4.02000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 5 8.35000_pr , 0.00000_pr , & 0.00000_pr , 27 1.12000_pr , - 23 1.09000_pr , 30 9.59000_pr , - 30 3.76000_pr , & 58 9.20000_pr , 19 0.24000_pr , - 312 3.39990_pr , 150 3.50000_pr , 64 6.47000_pr , & 131 0.90000_pr , 0.00000_pr , 0.00000_pr , 319 1.30000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 33 7.77000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 139 0.30000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 61 6.30000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 45 6.40000_pr , & - 25 5.14000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 4 3.46100_pr , 97 3.45000_pr , - 58 0.82000_pr , 6 4.10800_pr , & - 2 3.35800_pr , 1 1.98600_pr , 0.00000_pr , 64 8.20000_pr , 24 7.42000_pr , & 6.42300_pr , 128 7.00000_pr , 14 0.90000_pr , 55 8.30000_pr , 0.00000_pr , & 31 9.70000_pr , 6 7.28000_pr , - 1 9.70000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 8 5.38000_pr , & 0.00000_pr , 0.00000_pr , 89 3.01000_pr , 0.00000_pr , 4 9.13200_pr , & 2 3.15800_pr , - 11 1.34000_pr , - 3 3.07900_pr , 72 4.93000_pr , 0.00000_pr , & 7.64530_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 9 6.10000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 8 5.00100_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 6 9.38300_pr , 0.00000_pr , 0.00000_pr , 16 2.98000_pr , & - 0.14860_pr , 0.00000_pr , 52 1.38000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 9 4.95900_pr , 0.00000_pr , 12 1.90000_pr , 33 0.80000_pr , - 15 1.94000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 7 8.98000_pr , & 51 1.99000_pr , 0.00000_pr , 0.00000_pr , 86 2.84000_pr , 0.00000_pr , & 13 7.00000_pr , 11 6.97000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 22 9.32000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 61 3.30000_pr , 58 5.00000_pr , & 73 4.87000_pr , 32 0.00000_pr , 284 7.39990_pr , 25 0.05000_pr , - 153 1.60000_pr , & 402 7.50000_pr , 67 9.19000_pr , - 340 1.00000_pr , 71 7.20000_pr , 189 2.00000_pr , & 68 7.90000_pr , 99 7.20000_pr , 237 8.00000_pr , 167 8.00000_pr , 0.00000_pr , & 63 4.45000_pr , 89 1.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 58 9.06000_pr , 47 7.45000_pr , 0.00000_pr , 0.00000_pr , & 77 4.56000_pr , 0.00000_pr , 0.00000_pr , 115 8.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 64 1.60000_pr , 33 0.73000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 82 6.49000_pr , 59 8.80000_pr , 0.00000_pr , 117 7.00000_pr , & 0.00000_pr , 0.00000_pr , 20 0.48000_pr , 76 2.73000_pr , 133 9.00000_pr , & 83 8.06000_pr , 25 3.92000_pr , 0.00000_pr , 19 0.87000_pr , 7 7.70100_pr , & 62 8.00000_pr , 0.00000_pr , 49 4.67000_pr , 86 3.20000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 37 2.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 52 2.68000_pr , 0.00000_pr , 0.00000_pr , - 7 8.38900_pr , & - 24 1.56000_pr , 68 0.05000_pr , 34 8.35000_pr , 213 8.39990_pr , 26 1.54000_pr , & - 166 5.50000_pr , 0.00000_pr , 41 6.90000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 38 2.82000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 37 8.00000_pr , 0.00000_pr , 30 1.76000_pr , 0.00000_pr , & 28 4.02000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 76 7.11000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 16 1.54000_pr , 6 2.41900_pr , 0.00000_pr , 6 4.10000_pr , & 2 5.06000_pr , 66 5.70000_pr , 86 3.18000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 17 7.90000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 48 1.70000_pr , 40 5.70000_pr , 3 0.72000_pr , - 18 7.60000_pr , 43 6.00000_pr , & - 35 2.20000_pr , - 74 5.70000_pr , 0.00000_pr , - 32 0.90000_pr , 0.00000_pr , & - 38 5.60000_pr , 0.00000_pr , - 56 8.50000_pr , 0.00000_pr , - 62 8.26000_pr , & - 93 5.40000_pr , 0.00000_pr , - 44 2.89000_pr , 0.00000_pr , - 15 0.50000_pr , & 0.00000_pr , 0.00000_pr , 36 6.70000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 11 5.10000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 36 5.54000_pr , 0.00000_pr , - 101 3.70000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 23 3.85000_pr , 0.00000_pr , & - 66 7.30000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 18 0.20000_pr , 4 4.22000_pr , 0.00000_pr , & 0.00000_pr , - 3 7.18000_pr , 0.00000_pr , 27 6.40000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 1 8.86000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 47 1.48000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 27 0.90000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 41 2.60000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 59 3.30000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 385 9.30000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 20 5.51000_pr , 33 0.70000_pr , 30 1.70000_pr , & - 7 0.50000_pr , 0.00000_pr , 0.00000_pr , - 296 5.00000_pr , 0.00000_pr , & 22 4.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 5 2.82000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 10 8.91000_pr , & - 2 7.59600_pr , 53 5.78000_pr , 0.00000_pr , - 11 2.90000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 28 0.06000_pr , 4 4.30000_pr , 0.00000_pr , 0.00000_pr , 20 9.80000_pr , & 0.00000_pr , 7 6.95500_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 17 2.90000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 7 4.07000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 8 1.70000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 3 8.27400_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.79200_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 53 4.14000_pr , 0.00000_pr , 0.00000_pr , 55 8.00000_pr , & 46 5.50000_pr , 67 8.40000_pr , 41 1.50000_pr , 322 2.50000_pr , 0.00000_pr , & 8 5.79000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 28 5.40000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 56 5.20000_pr , 36 4.30000_pr , 44 9.94180_pr , 21 7.20000_pr , & 15 4.60000_pr , 0.00000_pr , 6 2.01700_pr , 20 3.40000_pr , 0.00000_pr , & 0.00000_pr , 60 7.50000_pr , 0.00000_pr , 0.00000_pr , 10 9.55000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 27 3.45000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 1 0.94000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 136 9.30000_pr , 0.00000_pr , 0.00000_pr , 13 0.50000_pr , & 12 0.50000_pr , 6 9.59000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 4 4.72900_pr , & 0.00000_pr , 16 0.53000_pr , 36 6.81000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 2 4.42000_pr , 6 3.78000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 1 4.38000_pr , & 4 3.11000_pr , - 2 1.61000_pr , 11 0.30000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 35 3.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 14 5.20000_pr , 0.00000_pr , - 12 1.30000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 2 9.86000_pr , 1 6.35000_pr , 0.00000_pr , & 0.00000_pr , 47 0.09000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 43 0.20000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 25 0.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 20 8.66000_pr , 25 9.10000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 10 1.90000_pr , & 0.00000_pr , 0.00000_pr , 173 1.30000_pr , 27 8.60000_pr , 0.00000_pr , & 0.00000_pr , 18 4.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 283 2.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 120 4.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 61 3.10000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 63 0.21000_pr , 78 3.19000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 12 3.40000_pr , & 0.00000_pr , - 5 9.15000_pr , 5 0.80000_pr , - 105 8.00000_pr , - 112 8.00000_pr , & - 219 7.80000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 86 3.40000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 65 9.50000_pr , - 4 2.71000_pr , & 2 0.50000_pr , 0.00000_pr , 22 0.20000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 2 3.91000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 35 6.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 11 2.60000_pr , & 0.00000_pr , - 2 7.21600_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 21 8.80000_pr , 16 9.99000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 13 2.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 5 4.02000_pr , 0.00000_pr , - 7 0.13000_pr , - 5 8.42000_pr , 0.00000_pr , & 0.00000_pr , - 102 6.70000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 50 0.10000_pr , & - 7 3.25000_pr , 6 9.71000_pr , 5 3.86000_pr , 6 5.79000_pr , 18 0.50000_pr , & 0.00000_pr , 25 6.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 8 8.34100_pr , 0.00000_pr , 11 5.80000_pr , 22 0.72000_pr , & 0.00000_pr , 0.00000_pr , 69 6.36000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 205 1.60010_pr , 0.00000_pr , 0.00000_pr , 9 2.00200_pr , - 8 0.97600_pr , & 53 7.50000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 27 0.32000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 1 5.33500_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 27 1.31000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 7 5.68000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 16 8.03000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 15 8.20000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 67 8.27000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 23 4.93000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 30 8.78000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 51 5.25000_pr , 2.00690_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 20 5.30000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 52 5.98000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 3 4.52100_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 10 1.79000_pr , 26 1.73000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 24 5.39000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 8.79960_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 451 6.50000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 18 4.05000_pr , 37 2.06000_pr , & 8 7.26200_pr , 333 9.60010_pr , 447 9.79980_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 3 7.65000_pr , 0.00000_pr , 28 8.20000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 7 2.98600_pr , 0.00000_pr , 9 7.11700_pr , 1 9.59700_pr , & 0.00000_pr , 16 6.92000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 24 3.01000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 44 8.22000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 56 2.89000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 3 9.90300_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.09020_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 8 1.61100_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 58 4.43000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr & ], [ nmg , nmg ]) ! ======================================================================== ! PSRK bij ! ------------------------------------------------------------------------ PSRKParameters % maingroups_bij = reshape ([& 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 0.12870_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 1 7.41200_pr , 0.86150_pr , - 0.73860_pr , - 1.21910_pr , & 4.97820_pr , 0.32290_pr , - 5.70740_pr , - 0.45630_pr , - 1.14900_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 1.39100_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 1.11510_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 8.09990_pr , 0.00000_pr , - 0.58060_pr , & 0.81340_pr , 3.19800_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.21200_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 1.67780_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.87200_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.84840_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 0.92490_pr , 0.00000_pr , - 2.11630_pr , 0.00000_pr , - 1.52300_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 3.85110_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 8.13300_pr , & - 5.29970_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.73960_pr , 0.00000_pr , - 2.64230_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 9.21930_pr , 1.16960_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.04760_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 0.24610_pr , - 4.34370_pr , 5.86040_pr , & 5 8.04500_pr , 1 2.19000_pr , - 7.64070_pr , - 0.20770_pr , - 2 7.41000_pr , & 3 1.28100_pr , - 9.32500_pr , 0.00000_pr , - 8.25100_pr , 0.00000_pr , & 3.37100_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 7.45600_pr , & - 0.28250_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 2.95880_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 1.88790_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.43150_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 1.15600_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 2.91730_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.45590_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 0.61210_pr , 0.00000_pr , 0.00000_pr , - 1.13260_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 1.13760_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 0.80470_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.36660_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.86740_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 1.60260_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 0.91380_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 0.45550_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 0.05850_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 1.36620_pr , 0.00000_pr , 0.50400_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.62030_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 1.20300_pr , 0.00000_pr , 0.00000_pr , & - 0.75300_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00380_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 0.16750_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.01990_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 0.80320_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 3.42330_pr , 0.00000_pr , - 1.64540_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 1.06670_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 3.11970_pr , & 0.00000_pr , 0.00000_pr , 3.41500_pr , 0.00000_pr , 1 1.55600_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 5.07880_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 3.91320_pr , 1.54730_pr , 0.00000_pr , & - 0.20730_pr , 0.00000_pr , 0.00000_pr , 5.47650_pr , 0.00000_pr , & - 1.47610_pr , 0.00000_pr , - 3.56270_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.81910_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 1.70240_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 3.23250_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 3.01730_pr , 0.00000_pr , & - 1 0.24700_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.84590_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 4.78290_pr , 1 1.99300_pr , & 0.06960_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 0.10980_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 0.83720_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 0.50430_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 1.90750_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 0.23000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 2 7.48000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 1.81920_pr , & 0.00000_pr , 0.00000_pr , 6 3.32300_pr , 0.00000_pr , - 1.25610_pr , & 1 4.23800_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 6.98640_pr , 0.00000_pr , 1.38000_pr , - 0.85300_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 2.66840_pr , 0.00000_pr , & - 1.45490_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 8.07900_pr , & 0.00000_pr , 2.83680_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 1.31500_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 0.99030_pr , 5.82210_pr , 0.00000_pr , 2.19660_pr , & 2.68100_pr , 0.00000_pr , 2 0.68300_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 1 5.52400_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 2.22030_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 0.03020_pr , 3.69970_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.30070_pr , 0.00000_pr , & 0.57950_pr , - 1.71400_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 0.75280_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.38010_pr , & 0.00000_pr , 0.00000_pr , - 3.13420_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.01360_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 1.91000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 1.17610_pr , 0.00000_pr , 0.00000_pr , - 2.15690_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.53510_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 2.54180_pr , - 0.87270_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 1 2.17400_pr , & 0.00000_pr , 0.00000_pr , 1 3.11000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 0.88000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 1 9.01100_pr , 0.00000_pr , 0.14030_pr , & - 1.01580_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 8.18690_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 1.55590_pr , 0.00000_pr , 0.00000_pr , 1.87270_pr , & 1.22960_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.33500_pr , & 1 3.77200_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 2.69560_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 1.31170_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & - 0.77260_pr , 0.00000_pr , - 1 2.30900_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.42850_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 2.44200_pr , 0.00000_pr , 0.38130_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.96200_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 2.63540_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 1.28400_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 0.46540_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.35010_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 1.53000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 4.06640_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 1 7.80000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 2.98260_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 1.49900_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 3.62300_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.26170_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 0.65120_pr , - 3.04890_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 1.46470_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 2.58050_pr , 0.00000_pr , 0.00000_pr , - 0.60900_pr , & - 0.55300_pr , - 0.35270_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 4.67090_pr , & 0.00000_pr , - 0.15100_pr , - 1.33660_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 2.12000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , - 0.60300_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.10100_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , - 5.73680_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 9.66300_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 5.22820_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00330_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.94550_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 14 0.84000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.98960_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , - 0.00120_pr , & 0.00000_pr , 5.40920_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , - 3.53500_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , 0.00000_pr , & 0.00000_pr & ],[ nmg , nmg ]) ! ======================================================================== ! PSRK cij ! ------------------------------------------------------------------------ PSRKParameters % maingroups_cij = reshape ([& 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , - 0.0017906_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.0020106_pr , 0.012651_pr , - 0.0015601_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.022564_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0080196_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 7.6678e-05_pr , 0.0013099_pr , - 0.005122_pr , - 0.097615_pr , & 0.0_pr , 0.0094502_pr , 0.00013033_pr , 0.07115_pr , - 0.03308_pr , & 0.0_pr , 0.0_pr , - 0.0053_pr , 0.0_pr , 0.006117_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.01156_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.00057918_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0046309_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.0026029_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.010324_pr , - 0.01225_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.06494_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.012451_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.034469_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0031901_pr , - 0.016546_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.019561_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0013022_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0010576_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0066383_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.006931_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.04718_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.014048_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.046316_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.0193_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.002973_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , - 0.000736_pr , 0.0089373_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , - 0.01247_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr , & 0.0_pr ],[ nmg , nmg ]) end function PSRKParameters end module yaeos__models_ge_group_contribution_psrk_parameters","tags":"","url":"sourcefile/psrk_parameters.f90.html"},{"title":"ar_models.f90 – yaeos","text":"Source Code module yaeos__models_ar !! # Module that defines the basics of a residual Helmholtz energy. !! !! All the residual properties that are calculated in this library are !! based on residual Helmholtz Equations of State. Following the book by !! Michelsen and Mollerup. !! !! In this library up to second derivatives of residual Helmholtz energy !! are used. Because they're the fundamentals for phase equilibria !! calculation. !! !! @note !! Later on, third derivative with respect to volume will be included !! since it's importance on calculation of critical points. !! @endnote !! !! # Properties !! !! ## Available properties: !! !! - pressure(n, V, T) !! - fugacity(n, V, T) !! - fugacity(n, P, T, root=[vapor, liquid, stable]) !! - volume !! !! Calculate thermodynamic properties using Helmholtz energy as a basis. !! All the routines in this module work with the logic: !! !! ```fortran !! call foo(x, V, T, [dfoodv, dfoodT, ...]) !! ``` !! Where the user can call the routine of the desired property. And include !! as optional values the desired derivatives of said properties. use yaeos__constants , only : pr , R use yaeos__models_base , only : BaseModel implicit none private public :: ArModel , size , volume type , abstract , extends ( BaseModel ) :: ArModel !! Abstract residual Helmholtz model. !! !! This derived type defines the basics needed for the calculation !! of residual properties. !! The basics of a residual Helmholtz model is a routine that calculates !! all the needed derivatives of Ar `residual_helmholtz` and !! a volume initializer function, that is used to initialize a Newton !! solver of volume when specifying pressure. character ( len = :), allocatable :: name !! Name of the model contains procedure ( abs_residual_helmholtz ), deferred :: residual_helmholtz procedure ( abs_volume_initializer ), deferred :: get_v0 procedure :: lnphi_vt procedure :: lnphi_pt procedure :: lnfug_vt procedure :: pressure procedure :: volume procedure :: enthalpy_residual_vt procedure :: gibbs_residual_vt procedure :: entropy_residual_vt procedure :: internal_energy_residual_vt procedure :: Cv_residual_vt procedure :: Cp_residual_vt procedure :: Psat_pure end type ArModel interface size module procedure :: size_ar_model end interface size abstract interface subroutine abs_residual_helmholtz (& self , n , v , t , Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) !! Residual Helmholtz model generic interface. !! !! This interface represents how an Ar model should be implemented. !! By our standard, a Resiudal Helmholtz model takes as input: !! !! - The mixture's number of moles vector. !! - Volume, by default in liters. !! - Temperature, by default in Kelvin. !! !! All the output arguments are optional. While this keeps a long !! signature for the implementation, this is done this way to take !! advantage of any inner optimizations to calculate derivatives !! inside the procedure. !! !! Once the model is implemented, the signature can be short like !! `model%residual_helmholtz(n, v, t, ArT2=dArdT2)` import ArModel , pr class ( ArModel ), intent ( in ) :: self !! ArModel real ( pr ), intent ( in ) :: n (:) !! Moles vector real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), optional , intent ( out ) :: Ar !! Residual Helmoltz energy real ( pr ), optional , intent ( out ) :: ArV !! \\frac{dAr}{dV} real ( pr ), optional , intent ( out ) :: ArT !! \\frac{dAr}{dT} real ( pr ), optional , intent ( out ) :: ArT2 !! \\frac{d&#94;2Ar}{dT&#94;2} real ( pr ), optional , intent ( out ) :: ArTV !! \\frac{d&#94;2Ar}{dTV} real ( pr ), optional , intent ( out ) :: ArV2 !! \\frac{d&#94;2Ar}{dV&#94;2} real ( pr ), optional , intent ( out ) :: Arn ( size ( n )) !! \\frac{dAr}{dn_i} real ( pr ), optional , intent ( out ) :: ArVn ( size ( n )) !! \\frac{d&#94;2Ar}{dVn_i} real ( pr ), optional , intent ( out ) :: ArTn ( size ( n )) !! \\frac{d&#94;2Ar}{dTn_i} real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) !! \\frac{d&#94;2Ar}{dn_{ij}} end subroutine abs_residual_helmholtz function abs_volume_initializer ( self , n , p , t ) !! Function that provides an initializer value for the liquid-root !! of newton solver of volume. In the case the model will use the !! `volume_michelsen` routine this value should provide the co-volume !! of the model. import ArModel , pr class ( ArModel ), intent ( in ) :: self !! Ar Model real ( pr ), intent ( in ) :: n (:) !! Moles vector real ( pr ), intent ( in ) :: p !! Pressure [bar] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ) :: abs_volume_initializer !! Initial volume [L] end function abs_volume_initializer end interface contains integer pure function size_ar_model ( eos ) !! Get the size of the model. class ( ArModel ), intent ( in ) :: eos size_ar_model = size ( eos % components % pc ) end function size_ar_model subroutine volume ( eos , n , P , T , V , root_type ) !! Volume solver routine for residual Helmholtz models. !! !! Solves volume roots using newton method. Given pressure and !! temperature. !! !! # Description !! This subroutine solves the volume using a newton method. The variable !! `root_type` is used to specify the desired root to solve. The options !! are: `[\"liquid\", \"vapor\", \"stable\"]` !! !! # Examples !! !! ```fortran !! eos = PengRobinson76(Tc, Pc, w) !! !! n = [1.0_pr, 1.0_pr] !! T = 300.0_pr !! P = 1.0_pr !! !! call eos%volume(n, P, T, V, root_type=\"liquid\") !! call eos%volume(n, P, T, V, root_type=\"vapor\") !! call eos%volume(n, P, T, V, root_type=\"stable\") !! ``` use yaeos__constants , only : pr , R use yaeos__math , only : newton class ( ArModel ), intent ( in ) :: eos !! Model real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: P !! Pressure [bar] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( out ) :: V !! Volume [L] character ( len =* ), intent ( in ) :: root_type !! Desired root-type to solve. Options are: !! `[\"liquid\", \"vapor\", \"stable\"]` integer :: max_iters = 30 real ( pr ) :: tol = 1e-7 real ( pr ) :: totnRT , GrL , GrV , Gr real ( pr ) :: Vliq , Vvap GrL = HUGE ( GrL ) GrV = HUGE ( GrV ) totnRT = sum ( n ) * R * T select case ( root_type ) case ( \"liquid\" ) Vliq = eos % get_v0 ( n , P , T ) * 1.001_pr call newton ( foo , Vliq , tol = tol , max_iters = max_iters ) GrL = Gr case ( \"vapor\" ) Vvap = R * T / P call newton ( foo , Vvap , tol = tol , max_iters = max_iters ) GrV = Gr case ( \"stable\" ) Vliq = eos % get_v0 ( n , P , T ) * 1.00001_pr call newton ( foo , Vliq , tol = tol , max_iters = max_iters ) GrL = Gr Vvap = R * T / P call newton ( foo , Vvap , tol = tol , max_iters = max_iters ) GrV = Gr end select if ( GrL < GrV ) then V = Vliq else V = Vvap end if contains subroutine foo ( x , f , df ) real ( pr ), intent ( in ) :: x real ( pr ), intent ( out ) :: f , df real ( pr ) :: Ar , ArV , ArV2 , Pcalc , dPcalcdV , Vin Vin = x call eos % residual_helmholtz ( n , Vin , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 ) Pcalc = totnRT / Vin - ArV dPcalcdV = - totnRT / Vin ** 2 - ArV2 f = Pcalc - p df = dPcalcdV Gr = Ar + P * Vin - totnRT - totnRT * log ( P * Vin / ( R * T )) end subroutine foo end subroutine volume subroutine pressure ( eos , n , V , T , P , dPdV , dPdT , dPdn ) !! Calculate pressure. !! !! Calculate pressure using residual helmholtz models. !! !! # Examples !! !! ```fortran !! eos = PengRobinson76(Tc, Pc, w) !! !! n = [1.0_pr, 1.0_pr] !! T = 300.0_pr !! V = 1.0_pr !! !! call eos%pressure(n, V, T, P, dPdV=dPdV, dPdT=dPdT, dPdn=dPdn) !! ``` class ( ArModel ), intent ( in ) :: eos !! Model real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), intent ( out ) :: P !! Pressure [bar] real ( pr ), optional , intent ( out ) :: dPdV !! \\frac{dP}}{dV} real ( pr ), optional , intent ( out ) :: dPdT !! \\frac{dP}}{dT} real ( pr ), optional , intent ( out ) :: dPdn (:) !! \\frac{dP}}{dn_i} real ( pr ) :: totn real ( pr ) :: Ar , ArV , ArV2 , ArTV , ArVn ( size ( eos )) totn = sum ( n ) if ( present ( dPdn )) then call eos % residual_helmholtz (& n , v , t , Ar = Ar , ArV = ArV , ArV2 = ArV2 , ArTV = ArTV , ArVn = ArVn & ) else call eos % residual_helmholtz (& n , v , t , Ar = Ar , ArV = ArV , ArV2 = ArV2 , ArTV = ArTV & ) end if P = totn * R * T / V - ArV if ( present ( dPdV )) dPdV = - ArV2 - R * T * totn / V ** 2 if ( present ( dPdT )) dPdT = - ArTV + totn * R / V if ( present ( dPdn )) dPdn (:) = R * T / V - ArVn (:) end subroutine pressure subroutine lnphi_pt ( eos , & n , P , T , V , root_type , lnPhi , dlnPhidP , dlnPhidT , dlnPhidn , & dPdV , dPdT , dPdn & ) !! Calculate natural logarithm of fugacity given pressure and temperature. !! !! Calculate the natural logarithm of the fugacity coefficient and its !! derivatives given pressure and temperature. This routine will obtain !! the desired volume root at the specified pressure and calculate !! fugacity at that point.The routine gives the possibility to calculate !! the pressure derivatives and volume. !! !! # Examples !! !! ```fortran !! eos = PengRobinson76(Tc, Pc, w) !! !! n = [1.0_pr, 1.0_pr] !! T = 300.0_pr !! V = 1.0_pr !! !! call eos%lnphi_pt(& !!    n, V, T, lnPhi=lnPhi, & !!    dlnPhidP=dlnPhidP, dlnPhidT=dlnPhidT, dlnPhidn=dlnPhidn & !!    ) !! ``` use iso_fortran_env , only : error_unit class ( ArModel ), intent ( in ) :: eos !! Model real ( pr ), intent ( in ) :: n (:) !! Mixture mole numbers character ( len =* ), intent ( in ) :: root_type !! Type of root desired [\"liquid\", \"vapor\", \"stable\"] real ( pr ), intent ( in ) :: P !! Pressure [bar] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: lnPhi ( size ( n )) !! \\ln(phi) vector real ( pr ), optional , intent ( out ) :: V !! Volume [L] real ( pr ), optional , intent ( out ) :: dlnPhidT ( size ( n )) !! ln(phi) Temperature derivative real ( pr ), optional , intent ( out ) :: dlnPhidP ( size ( n )) !! ln(phi) Presssure derivative real ( pr ), optional , intent ( out ) :: dlnPhidn ( size ( n ), size ( n )) !! ln(phi) compositional derivative real ( pr ), optional , intent ( out ) :: dPdV !! \\frac{dP}{dV} real ( pr ), optional , intent ( out ) :: dPdT !! \\frac{dP}{dT} real ( pr ), optional , intent ( out ) :: dPdn ( size ( n )) !! \\frac{dP}{dn_i} real ( pr ) :: V_in , P_in call eos % volume ( n , P = P , T = T , V = V_in , root_type = root_type ) call eos % lnphi_vt (& n , V = V_in , T = T , & P = P_in , lnPhi = lnPhi , & dlnPhidP = dlnPhidP , dlnPhidT = dlnPhidT , dlnPhidn = dlnPhidn , & dPdV = dPdV , dPdT = dPdT , dPdn = dPdn & ) if ( present ( V )) V = V_in ! Check if the calculated pressure is the same as the input pressure. ! if(abs(P_in - P) > 1e-2) then !    write(error_unit, *) \"WARN: possible bad root solving: \", P_in, P ! end if end subroutine lnphi_pt subroutine lnphi_vt ( eos , & n , V , T , P , lnPhi , & dlnPhidP , dlnPhidT , dlnPhidn , & dPdV , dPdT , dPdn & ) !! Calculate natural logarithm of fugacity coefficent. !! !! Calculate the natural logarithm of the fugacity coefficient and its !! derivatives given volume and temperature. The routine gives the !! possibility to calculate the pressure and it's derivatives. !! !! # Examples !! !! ```fortran !! eos = PengRobinson76(Tc, Pc, w) !! !! n = [1.0_pr, 1.0_pr] !! T = 300.0_pr !! V = 1.0_pr !! !! call eos%lnphi_vt(& !!    n, V, T, lnPhi=lnPhi, & !!    dlnPhidP=dlnPhidP, dlnPhidT=dlnPhidT, dlnPhidn=dlnPhidn & !!    ) !! ``` class ( ArModel ) :: eos !! Model real ( pr ), intent ( in ) :: n (:) !! Mixture mole numbers real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: P !! Pressure [bar] real ( pr ), optional , intent ( out ) :: lnPhi ( size ( n )) !! \\ln(\\phi_i) vector real ( pr ), optional , intent ( out ) :: dlnPhidT ( size ( n )) !! ln(phi_i) Temp derivative real ( pr ), optional , intent ( out ) :: dlnPhidP ( size ( n )) !! ln(phi_i) Presssure derivative real ( pr ), optional , intent ( out ) :: dlnPhidn ( size ( n ), size ( n )) !! ln(phi_i) compositional derivative real ( pr ), optional , intent ( out ) :: dPdV !! \\frac{dP}{dV} real ( pr ), optional , intent ( out ) :: dPdT !! \\frac{dP}{dT} real ( pr ), optional , intent ( out ) :: dPdn (:) !! \\frac{dP}{dn_i} real ( pr ) :: Ar , ArTV , ArV , ArV2 real ( pr ), dimension ( size ( n )) :: Arn , ArVn , ArTn real ( pr ) :: Arn2 ( size ( n ), size ( n )) real ( pr ) :: dPdV_in , dPdT_in , dPdn_in ( size ( n )) real ( pr ) :: P_in real ( pr ) :: RT , Z real ( pr ) :: totn integer :: nc , i , j totn = sum ( n ) nc = size ( n ) RT = R * T if ( present ( lnPhi ) . and . . not . (& present ( dlnPhidn ) & . or . present ( dlnPhidP ) & . or . present ( dlnPhidT ) & )) then call eos % residual_helmholtz ( n , v , t , Arn = Arn , ArV = ArV ) P_in = totn * RT / V - ArV Z = P_in * V / ( totn * RT ) lnPhi (:) = Arn (:) / RT - log ( Z ) if ( present ( P )) P = P_in return else if ( present ( dlnPhidn )) then call eos % residual_helmholtz (& n , V , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 , ArTV = ArTV , & Arn = Arn , ArVn = ArVn , ArTn = ArTn , Arn2 = Arn2 & ) else call eos % residual_helmholtz (& n , V , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 , ArTV = ArTV , & Arn = Arn , ArVn = ArVn , ArTn = ArTn & ) end if P_in = totn * RT / V - ArV Z = P_in * V / ( totn * RT ) if ( present ( P )) P = P_in dPdV_in = - ArV2 - RT * totn / V ** 2 dPdT_in = - ArTV + totn * R / V dPdn_in = RT / V - ArVn if ( present ( lnPhi )) lnPhi = Arn (:) / RT - log ( Z ) if ( present ( dlnPhidP )) then dlnPhidP (:) = - dPdn_in (:) / dPdV_in / RT - 1._pr / P_in end if if ( present ( dlnPhidT )) then dlnPhidT (:) = ( ArTn (:) - Arn (:) / T ) / RT + dPdn_in (:) * dPdT_in / dPdV_in / RT + 1._pr / T end if if ( present ( dlnPhidn )) then do i = 1 , nc do j = i , nc dlnPhidn ( i , j ) = 1._pr / totn + ( Arn2 ( i , j ) + dPdn_in ( i ) * dPdn_in ( j ) / dPdV_in ) / RT dlnPhidn ( j , i ) = dlnPhidn ( i , j ) end do end do end if if ( present ( dPdV )) dPdV = dPdV_in if ( present ( dPdT )) dPdT = dPdT_in if ( present ( dPdn )) dPdn = dPdn_in end subroutine lnphi_vt subroutine lnfug_vt ( eos , & n , V , T , P , lnf , & dlnfdV , dlnfdT , dlnfdn , & dPdV , dPdT , dPdn & ) !! Calculate natural logarithm of fugacity given volume and temperature. !! !! Calculate the natural logarithm of the fugacity and its derivatives. !! The routine gives the possibility to calculate the pressure and it's !! derivatives. !! !! # Examples !! !! ```fortran !! eos = PengRobinson76(Tc, Pc, w) !! !! n = [1.0_pr, 1.0_pr] !! T = 300.0_pr !! V = 1.0_pr !! !! call eos%lnfug_vt(& !!    n, V, T, lnf=lnf, & !!    dlnfdV=dlnfdV, dlnfdT=dlnfdT, dlnfdn=dlnfdn & !!    ) !! ``` class ( ArModel ) :: eos !! Model real ( pr ), intent ( in ) :: n (:) !! Mixture mole numbers real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: P !! Pressure [bar] real ( pr ), optional , intent ( out ) :: lnf ( size ( n )) !! \\ln(\\f_i) vector real ( pr ), optional , intent ( out ) :: dlnfdT ( size ( n )) !! ln(f_i) Temp derivative real ( pr ), optional , intent ( out ) :: dlnfdV ( size ( n )) !! ln(f_i) Volume derivative real ( pr ), optional , intent ( out ) :: dlnfdn ( size ( n ), size ( n )) !! ln(f_i) compositional derivative real ( pr ), optional , intent ( out ) :: dPdV !! \\frac{dP}{dV} real ( pr ), optional , intent ( out ) :: dPdT !! \\frac{dP}{dT} real ( pr ), optional , intent ( out ) :: dPdn (:) !! \\frac{dP}{dn_i} real ( pr ) :: Ar , ArTV , ArV , ArV2 real ( pr ), dimension ( size ( n )) :: Arn , ArVn , ArTn real ( pr ) :: Arn2 ( size ( n ), size ( n )) real ( pr ) :: dPdV_in , dPdT_in , dPdn_in ( size ( n )) real ( pr ) :: P_in real ( pr ) :: RT , Z real ( pr ) :: totn integer :: nc , i , j totn = sum ( n ) nc = size ( n ) RT = R * T if ( present ( lnf ) . and . . not . (& present ( dlnfdn ) & . or . present ( dlnfdV ) & . or . present ( dlnfdT ) & )) then call eos % residual_helmholtz ( n , v , t , Arn = Arn , ArV = ArV ) P_in = totn * RT / V - ArV lnf = 0.0_pr where ( n /= 0 ) lnf = log ( n / totn ) + Arn / RT - log ( V / ( totn * RT )) endwhere if ( present ( P )) P = P_in return else if ( present ( dlnfdn )) then call eos % residual_helmholtz (& n , V , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 , ArTV = ArTV , & Arn = Arn , ArVn = ArVn , ArTn = ArTn , Arn2 = Arn2 & ) else call eos % residual_helmholtz (& n , V , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 , ArTV = ArTV , & Arn = Arn , ArVn = ArVn , ArTn = ArTn & ) end if P_in = totn * RT / V - ArV Z = P_in * V / ( totn * RT ) if ( present ( P )) P = P_in dPdV_in = - ArV2 - RT * totn / V ** 2 dPdT_in = - ArTV + totn * R / V dPdn_in = RT / V - ArVn if ( present ( lnf )) then lnf = 0.0_pr where ( n /= 0 ) lnf = log ( n / totn ) + Arn / RT - log ( V / ( totn * RT )) endwhere end if if ( present ( dlnfdV )) then dlnfdV = - dPdn_in / RT end if if ( present ( dlnfdT )) then dlnfdT = ( ArTn - Arn / T ) / RT + 1._pr / T end if if ( present ( dlnfdn )) then do i = 1 , nc do j = 1 , nc dlnfdn ( i , j ) = Arn2 ( i , j ) / RT end do dlnfdn ( i , i ) = dlnfdn ( i , i ) + 1 / n ( i ) end do end if if ( present ( dPdV )) dPdV = dPdV_in if ( present ( dPdT )) dPdT = dPdT_in if ( present ( dPdn )) dPdn = dPdn_in end subroutine lnfug_vt subroutine enthalpy_residual_vt ( eos , n , V , T , Hr , HrV , HrT , Hrn ) !! Calculate residual enthalpy given volume and temperature. !! !! # Examples !! !! ```fortran !! eos = PengRobinson76(Tc, Pc, w) !! !! n = [1.0_pr, 1.0_pr] !! T = 300.0_pr !! V = 1.0_pr !! !! call eos%enthalpy_residual_vt(& !!    n, V, T, Hr=Hr, HrV=HrV, HrT=HrT, Hrn=Hrn & !!    ) !! ``` class ( ArModel ), intent ( in ) :: eos !! Model real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), optional , intent ( out ) :: Hr !! Residual enthalpy [bar L] real ( pr ), optional , intent ( out ) :: HrV !! \\frac{dH&#94;r}}{dV} real ( pr ), optional , intent ( out ) :: HrT !! \\frac{dH&#94;r}}{dT} real ( pr ), optional , intent ( out ) :: Hrn ( size ( n )) !! \\frac{dH&#94;r}}{dn} real ( pr ) :: Ar , ArV , ArT , Arn ( size ( n )) real ( pr ) :: ArV2 , ArT2 , ArTV , ArVn ( size ( n )), ArTn ( size ( n )) call eos % residual_helmholtz (& n , V , T , Ar = Ar , ArV = ArV , ArT = ArT , ArTV = ArTV , & ArV2 = ArV2 , ArT2 = ArT2 , Arn = Arn , ArVn = ArVn , ArTn = ArTn & ) if ( present ( Hr )) Hr = Ar - T * ArT - V * ArV if ( present ( HrT )) HrT = - T * ArT2 - V * ArTV if ( present ( HrV )) HrV = - T * ArTV - V * ArV2 if ( present ( Hrn )) Hrn (:) = Arn (:) - T * ArTn (:) - V * ArVn (:) end subroutine enthalpy_residual_vt subroutine gibbs_residual_vt ( eos , n , V , T , Gr , GrV , GrT , Grn ) !! Calculate residual Gibbs energy given volume and temperature. !! !! # Examples !! !! ```fortran !! eos = PengRobinson76(Tc, Pc, w) !! !! n = [1.0_pr, 1.0_pr] !! T = 300.0_pr !! V = 1.0_pr !! !! call eos%gibbs_residual_vt(& !!    n, V, T, Gr=Gr, GrV=GrV, GrT=GrT, Grn=Grn & !!    ) !! ``` use yaeos__constants , only : R class ( ArModel ), intent ( in ) :: eos !! Model real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: Gr !! Gibbs energy [bar L] real ( pr ), optional , intent ( out ) :: GrV !! \\frac{dG&#94;r}}{dV} real ( pr ), optional , intent ( out ) :: GrT !! \\frac{dG&#94;r}}{dT} real ( pr ), optional , intent ( out ) :: Grn ( size ( n )) !! \\frac{dG&#94;r}}{dn} real ( pr ) :: Ar , ArV , ArT , Arn ( size ( n )), ArTV , ArV2 , ArVn ( size ( n )) call eos % residual_helmholtz (& n , v , t , Ar = Ar , ArV = ArV , & ArT = ArT , Arn = Arn , ArTV = ArTV , ArV2 = ArV2 , ArVn = ArVn & ) if ( present ( Gr )) Gr = Ar - V * ArV if ( present ( GrT )) GrT = ArT - V * ArTV if ( present ( GrV )) GrV = - V * ArV2 if ( present ( Grn )) Grn (:) = Arn (:) - V * ArVn (:) end subroutine gibbs_residual_vt subroutine entropy_residual_vt ( eos , n , V , T , Sr , SrV , SrT , Srn ) !! Calculate residual entropy given volume and temperature. !! !! # Examples !! !! ```fortran !! eos = PengRobinson76(Tc, Pc, w) !! !! n = [1.0_pr, 1.0_pr] !! T = 300.0_pr !! V = 1.0_pr !! !! call eos%entropy_residual_vt(& !!    n, V, T, Sr=Sr, SrV=SrV, SrT=SrT, Srn=Srn & !!    ) !! ``` class ( ArModel ), intent ( in ) :: eos !! Model real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: Sr !! Entropy [bar L / K] real ( pr ), optional , intent ( out ) :: SrV !! \\frac{dS&#94;r}}{dV} real ( pr ), optional , intent ( out ) :: SrT !! \\frac{dS&#94;r}}{dT} real ( pr ), optional , intent ( out ) :: Srn ( size ( n )) !! \\frac{dS&#94;r}}{dn} real ( pr ) :: Ar , ArT , ArT2 , ArTV , ArTn ( size ( n )) call eos % residual_helmholtz (& n , v , t , Ar = Ar , ArT = ArT , ArTV = ArTV , ArT2 = ArT2 , ArTn = ArTn & ) if ( present ( Sr )) Sr = - ArT if ( present ( SrT )) SrT = - ArT2 if ( present ( SrV )) SrV = - ArTV if ( present ( SrN )) Srn = - ArTn end subroutine entropy_residual_vt subroutine internal_energy_residual_vt ( eos , n , V , T , Ur , UrV , UrT , Urn ) !! Calculate residual internal energy given volume and temperature. !! !! # Examples !! !! ```fortran !! eos = PengRobinson76(Tc, Pc, w) !! !! n = [1.0_pr, 1.0_pr] !! T = 300.0_pr !! V = 1.0_pr !! !! call eos%internal_energy_residual_vt(& !!    n, V, T, Ur=Ur, UrV=UrV, UrT=UrT, Urn=Urn & !!    ) !! ``` class ( ArModel ), intent ( in ) :: eos !! Model real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: Ur !! Internal energy [bar L] real ( pr ), optional , intent ( out ) :: UrV !! \\frac{dU&#94;r}}{dV} real ( pr ), optional , intent ( out ) :: UrT !! \\frac{dU&#94;r}}{dT} real ( pr ), optional , intent ( out ) :: Urn ( size ( n )) !! \\frac{dU&#94;r}}{dn} real ( pr ) :: Ar , ArV , ArT , Arn ( size ( n )), ArT2 , ArTV , ArTn ( size ( n )) call eos % residual_helmholtz (& n , v , t , Ar = Ar , ArV = ArV , ArT = ArT , Arn = Arn , & ArTV = ArTV , ArT2 = ArT2 , ArTn = ArTn & ) if ( present ( Ur )) Ur = Ar - T * ArT if ( present ( UrT )) UrT = - T * ArT2 if ( present ( UrV )) UrV = ArV - T * ArTV if ( present ( Urn )) Urn = Arn - T * ArTn end subroutine internal_energy_residual_vt subroutine Cv_residual_vt ( eos , n , V , T , Cv ) !! Calculate residual heat capacity volume constant given V and T. !! !! # Examples !! !! ```fortran !! eos = PengRobinson76(Tc, Pc, w) !! !! n = [1.0_pr, 1.0_pr] !! T = 300.0_pr !! V = 1.0_pr !! !! call eos%Cv_residual_vt(n, V, T, Cv=Cv) !! ``` class ( ArModel ), intent ( in ) :: eos !! Model real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), intent ( out ) :: Cv !! heat capacity V constant [bar L / K] real ( pr ) :: ArT2 call eos % residual_helmholtz ( n , V , T , ArT2 = ArT2 ) Cv = - T * ArT2 end subroutine Cv_residual_vt subroutine Cp_residual_vt ( eos , n , V , T , Cp ) !! Calculate residual heat capacity pressure constant given V and T. !! !! # Examples !! !! ```fortran !! eos = PengRobinson76(Tc, Pc, w) !! !! n = [1.0_pr, 1.0_pr] !! T = 300.0_pr !! V = 1.0_pr !! !! call eos%Cp_residual_vt(n, V, T, Cp=Cp) !! ``` use yaeos__constants , only : R class ( ArModel ), intent ( in ) :: eos !! Model real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( out ) :: Cp !! heat capacity P constant [bar L / K] real ( pr ) :: Cv , P , dPdT , dPdV , n_t n_t = sum ( n ) call Cv_residual_vt ( eos , n , V , T , Cv ) call pressure ( eos , n , V , T , P , dPdV = dPdV , dPdT = dPdT ) Cp = Cv - T * dPdT ** 2 / dPdV - n_t * R end subroutine Cp_residual_vt real ( pr ) function Psat_pure ( eos , ncomp , T ) !! Calculation of saturation pressure of a pure component using the !! secant method. class ( ArModel ), intent ( in ) :: eos !! Model that will be used integer , intent ( in ) :: ncomp !! Number of component in the mixture from which the saturation pressure !! will be calculated real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ) :: P1 , P2 real ( pr ) :: f1 , f2 real ( pr ) :: n ( size ( eos )) n = 0 n ( ncomp ) = 1 P1 = 0.5 P2 = 1 do while ( abs ( diff ( P2 )) > 1e-5 ) f1 = diff ( P1 ) f2 = diff ( P2 ) Psat_pure = ( P1 * f2 - P2 * f1 ) / ( f2 - f1 ) P1 = P2 P2 = Psat_pure end do contains real ( pr ) function diff ( P ) real ( pr ), intent ( in ) :: P real ( pr ) :: V_l , V_v real ( pr ) :: phi_v ( size ( eos )), phi_l ( size ( eos )) call eos % lnphi_pt ( n , P = P , T = T , V = V_v , lnPhi = phi_v , root_type = \"vapor\" ) call eos % lnphi_pt ( n , P = P , T = T , V = V_l , lnPhi = phi_l , root_type = \"liquid\" ) diff = phi_v ( ncomp ) - phi_l ( ncomp ) end function diff end function Psat_pure end module yaeos__models_ar","tags":"","url":"sourcefile/ar_models.f90.html"},{"title":"phase_envelopes_tx.f90 – yaeos","text":"Source Code module yaeos__equilibria_boundaries_phase_envelopes_tx !! Phase boundaries line on the T\\alpha plane calculation procedures. use yaeos__constants , only : pr use yaeos__models , only : ArModel use yaeos__equilibria_equilibrium_state , only : EquilibriumState use yaeos__math_continuation , only : & continuation , continuation_solver , continuation_stopper use yaeos__equilibria_boundaries_auxiliar , only : get_z implicit none private public :: TXEnvel2 public :: tx_envelope_2ph type :: CriticalPoint !! Critical point real ( pr ) :: alpha !! \\alpha real ( pr ) :: T !! Temperature [K] end type CriticalPoint type :: TXEnvel2 !! Two-phase TX envelope. !! Phase boundary line of a fluid at constant temperature !! with variation in composition. real ( pr ), allocatable :: alpha (:) !! Second fluid molar fraction real ( pr ), allocatable :: z0 (:) !! Original fluid composition real ( pr ), allocatable :: z_inj (:) !! Second fluid composition type ( EquilibriumState ), allocatable :: points (:) !! Each point through the line. type ( CriticalPoint ), allocatable :: cps (:) !! Critical points found along the line. end type TXEnvel2 ! Private volumes of each phase to share between functions real ( pr ), private :: Vz !! Main phase volume [L/mol] real ( pr ), private :: Vy !! Incipient phase volume [L/mol] contains function tx_envelope_2ph (& model , z0 , alpha0 , z_injection , first_point , & points , iterations , delta_0 , specified_variable_0 , & solver , stop_conditions & ) result ( envelopes ) !! TX two-phase envelope calculation procedure. !! !! Phase envelope calculation using the continuation method. !! Defaults to solving the saturation temperature and continues with !! an increment in it. The variable to specify can be changed by modifying !! `specified_variable_0` with the corresponding variable number. ! ======================================================================== use yaeos__auxiliar , only : optval class ( ArModel ), intent ( in ) :: model !! Thermodyanmic model real ( pr ), intent ( in ) :: z0 (:) !! Vector of molar fractions of the global composition (main phase) real ( pr ), intent ( in ) :: alpha0 !! First point of alpha real ( pr ), intent ( in ) :: z_injection (:) !! Vector of molar fractions of the injection fluid type ( EquilibriumState ) :: first_point integer , optional , intent ( in ) :: points !! Maxmimum number of points, defaults to 500 integer , optional , intent ( in ) :: iterations !! Point solver maximum iterations, defaults to 100 real ( pr ), optional , intent ( in ) :: delta_0 !! Initial extrapolation \\Delta integer , optional , intent ( in ) :: specified_variable_0 !! Position of specified variable, since the vector of variables is !! X = [lnK_i, \\dots, lnP, \\alpha] the values for specification !! will be [1 \\dots nc] for the equilibria constants, nc+1 for !! lnP and nc + 2 for \\alpha. procedure ( continuation_solver ), optional :: solver !! Specify solver for each point, defaults to a full newton procedure procedure ( continuation_stopper ), optional :: stop_conditions !! Function that returns true if the continuation method should stop type ( TXEnvel2 ) :: envelopes ! ------------------------------------------------------------------------ integer :: nc !! Number of components integer :: ns !! Number of specified variable real ( pr ) :: dS0 !! Initial specification step real ( pr ) :: S0 !! Initial specification value real ( pr ) :: z ( size ( z0 )) !! Composition at some point integer :: max_points !! Maximum number of points integer :: max_iterations !! Maximum number of iterations real ( pr ) :: X ( size ( z ) + 2 ), P real ( pr ), allocatable :: XS (:, :) character ( len = 14 ) :: kind ! ======================================================================== ! Handle input ! ------------------------------------------------------------------------ call get_z ( alpha0 , z0 , z_injection , z ) kind = first_point % kind nc = size ( z ) max_points = optval ( points , 500 ) max_iterations = optval ( iterations , 100 ) ns = optval ( specified_variable_0 , nc + 2 ) dS0 = optval ( delta_0 , 0.1_pr ) ! Correctly define the K-values based on the provided incipient point. select case ( first_point % kind ) case ( \"bubble\" , \"liquid-liquid\" ) X (: nc ) = log ( first_point % y / z ) case ( \"dew\" ) X (: nc ) = log ( first_point % x / z ) end select P = first_point % P X ( nc + 1 ) = log ( first_point % T ) X ( nc + 2 ) = alpha0 S0 = X ( ns ) allocate ( envelopes % points ( 0 ), envelopes % cps ( 0 ), envelopes % alpha ( 0 )) test_numdiff : block real ( pr ) :: F ( size ( X )), df ( size ( X ), size ( X )), numdiff ( size ( X ), size ( X )) real ( pr ) :: FdX ( size ( X )), dx ( size ( X )), dFdS ( size ( X )) real ( pr ) :: FdX2 ( size ( X )) integer :: i integer :: loc ( 2 ) real ( pr ) :: maxerr exit test_numdiff do i = 1 , size ( X ) dx = 0 dx ( i ) = 1.e-5_pr * X ( i ) call foo ( X - dx , ns , S0 , FdX , df , dFdS ) call foo ( X + dx , ns , S0 , FdX2 , df , dFdS ) call foo ( X , ns , S0 , F , df , dFdS ) numdiff (:, i ) = ( FdX2 - FdX ) / ( 2 * dx ( i )) end do loc = maxloc ( abs ( numdiff - df )) maxerr = abs (& ( numdiff ( loc ( 1 ), loc ( 2 )) - df ( loc ( 1 ), loc ( 2 ))& ) / numdiff ( loc ( 1 ), loc ( 2 ))) if ( maxerr > 0.01_pr ) then write ( * , * ) \"ERROR: TXEnvel2 Numerical differentiation failed\" loc = maxloc ( abs ( numdiff - df )) write ( * , * ) loc write ( * , * ) df ( loc ( 1 ), loc ( 2 )), numdiff ( loc ( 1 ), loc ( 2 )) error stop 1 end if end block test_numdiff ! ======================================================================== ! Trace the line using the continuation method. ! ------------------------------------------------------------------------ XS = continuation (& foo , X , ns0 = ns , S0 = S0 , & dS0 = dS0 , max_points = max_points , solver_tol = 1.e-5_pr , & update_specification = update_spec , & solver = solver , stop = stop_conditions & ) contains recursive subroutine foo ( X , ns , S , F , dF , dFdS ) !! Function that needs to be solved at each envelope point real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( out ) :: F (:) real ( pr ), intent ( out ) :: dF (:, :) real ( pr ), intent ( out ) :: dFdS (:) character ( len = 14 ) :: kind_z , kind_y real ( pr ) :: y ( nc ) real ( pr ) :: lnphip_z ( nc ), lnphip_y ( nc ) real ( pr ) :: dlnphi_dt_z ( nc ), dlnphi_dt_y ( nc ) real ( pr ) :: dlnphi_dp_z ( nc ), dlnphi_dp_y ( nc ) real ( pr ) :: dlnphi_dn_z ( nc , nc ), dlnphi_dn_y ( nc , nc ) real ( pr ) :: T , K ( nc ), alpha , dzda ( nc ) integer :: i , j F = 0 dF = 0 K = exp ( X (: nc )) T = exp ( X ( nc + 1 )) alpha = X ( nc + 2 ) call get_z ( alpha , z0 , z_injection , z , dzda ) y = K * z select case ( kind ) case ( \"bubble\" ) kind_z = \"liquid\" kind_y = \"vapor\" case ( \"dew\" ) kind_z = \"vapor\" kind_y = \"liquid\" case default kind_z = \"stable\" kind_y = \"stable\" end select call model % lnphi_pt (& z , P = P , T = T , V = Vz , root_type = kind_z , & lnphi = lnphip_z , dlnPhidt = dlnphi_dt_z , & dlnPhidp = dlnphi_dp_z , dlnphidn = dlnphi_dn_z & ) call model % lnphi_pt (& y , P = P , T = T , V = Vy , root_type = kind_y , & lnphi = lnphip_y , dlnPhidt = dlnphi_dt_y , & dlnPhidp = dlnphi_dp_y , dlnphidn = dlnphi_dn_y & ) F (: nc ) = X (: nc ) + lnphip_y - lnphip_z F ( nc + 1 ) = sum ( y - z ) F ( nc + 2 ) = X ( ns ) - S ! Jacobian Matrix do i = 1 , nc do j = 1 , nc df ( i , j ) = y ( j ) * dlnphi_dn_y ( i , j ) end do df ( i , i ) = df ( i , i ) + 1 df ( i , nc + 2 ) = sum ( K * dlnphi_dn_y ( i , :) * dzda - dlnphi_dn_z ( i , :) * dzda ) end do df (: nc , nc + 1 ) = T * ( dlnphi_dT_y - dlnphi_dT_z ) df ( nc + 1 , : nc ) = y df ( nc + 1 , nc + 2 ) = sum ( dzda * ( K - 1 )) df ( nc + 2 , :) = 0 df ( nc + 2 , ns ) = 1 dFdS = 0 dFdS ( nc + 2 ) = - 1 end subroutine foo subroutine update_spec ( X , ns , S , dS , dXdS , step_iters ) !! Update the specification during continuation. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables [lnK_i \\dots , lnT, lnP] integer , intent ( in out ) :: ns !! Number of specified variable in the vector real ( pr ), intent ( in out ) :: S !! Variable specification value real ( pr ), intent ( in out ) :: dS !! Step in specification real ( pr ), intent ( in out ) :: dXdS (:) !! Variation of variables with respect to specification integer , intent ( in ) :: step_iters !! Iterations used in the solver real ( pr ) :: maxdS ! ===================================================================== ! Update specification ! - Dont select T or P near critical points ! - Update dS wrt specification units ! - Set step ! --------------------------------------------------------------------- if ( maxval ( abs ( X (: nc ))) < 0.1_pr . and . abs ( Vz - Vy ) / maxval ([ Vz , Vy ]) < 0.1 ) then ns = maxloc ( abs ( dXdS (: nc )), dim = 1 ) maxdS = 0.01_pr else ns = maxloc ( abs ( dXdS ( nc + 1 :)), dim = 1 ) + nc maxdS = 0.5_pr end if dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) dS = sign ( 1.0_pr , dS ) * minval ([ & max ( sqrt ( abs ( X ( ns )) / 1 0._pr ), 0.1_pr ), & abs ( dS ) * 3 / step_iters & ] & ) do while ( maxval ( abs ( dXdS (: nc ) * dS )) < 0.05 ) dS = dS * 1.1_pr end do if ( step_iters < max_iterations ) then call save_point ( X , step_iters ) call detect_critical ( X , dXdS , ns , S , dS ) end if end subroutine update_spec subroutine save_point ( X , iters ) !! Save the converged point real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: iters type ( EquilibriumState ) :: point real ( pr ) :: y ( nc ), T , alpha T = exp ( X ( nc + 1 )) alpha = X ( nc + 2 ) y = exp ( X (: nc )) * z select case ( kind ) case ( \"bubble\" ) point = EquilibriumState (& kind = kind , x = z , Vx = Vz , y = y , Vy = Vy , & T = T , P = P , beta = 0._pr , iters = iters & ) case ( \"dew\" ) point = EquilibriumState (& kind = kind , x = y , Vx = Vy , y = z , Vy = Vz , & T = T , P = P , beta = 0._pr , iters = iters & ) case default point = EquilibriumState (& kind = \"saturation\" , x = z , Vx = Vz , y = y , Vy = Vy , & T = T , P = P , beta = 0._pr , iters = iters & ) end select envelopes % alpha = [ envelopes % alpha , alpha ] envelopes % points = [ envelopes % points , point ] end subroutine save_point subroutine detect_critical ( X , dXdS , ns , S , dS ) !! # `detect_critical` !! Critical point detection !! !! # Description !! If the values of lnK (X[:nc]) change sign then a critical point !! Has passed, since for this to happen all variables should pass !! through zero. Near critical points (lnK < 0.05) points are harder !! to converge, so more steps in the extrapolation vector are made to !! jump over the critical point. !! If the critical point is detected then the kind of the point is !! changed and the point is saved using an interpolation knowing that !! !!  !!   X_c = a * X + (1-a)*X_{new} !!  !! !! With X_c is the variables at the critical point, X_{new} !! is the new initialization point of the method and a is the !! parameter to interpolate the values. This subroutine finds the !! value of  a to obtain X_c. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables real ( pr ), intent ( in out ) :: dXdS (:) !! Variation of variables wrt S integer , intent ( in out ) :: ns !! Number of specified variable real ( pr ), intent ( in out ) :: S !! Specification value real ( pr ), intent ( in out ) :: dS !! Step in specification real ( pr ) :: Xc ( nc + 2 ) !! Value at (near) critical point real ( pr ) :: a !! Parameter for interpolation real ( pr ) :: Xold ( size ( X )) !! Old value of X real ( pr ) :: Xnew ( size ( X )) !! Value of the next initialization Xold = X do while ( maxval ( abs ( X (: nc ))) < 0.1_pr . and . abs ( Vz - Vy ) / max ( Vz , Vy ) < 0.1_pr ) ! If near a critical point, jump over it S = S + dS X = X + dXdS * dS end do Xnew = X + dXdS * dS if ( all ( Xold (: nc ) * ( Xnew (: nc )) < 0 )) then if ( nc == 2 ) dS = 0 select case ( kind ) case ( \"dew\" ) kind = \"bubble\" case ( \"bubble\" ) kind = \"dew\" case default kind = \"liquid-liquid\" end select ! 0 = a*X(ns) + (1-a)*Xnew(ns) Interpolation equation to get X(ns) = 0 a = - Xnew ( ns ) / ( Xold ( ns ) - Xnew ( ns )) Xc = a * Xold + ( 1 - a ) * Xnew envelopes % cps = [& envelopes % cps , & CriticalPoint ( T = exp ( Xc ( nc + 1 )), alpha = Xc ( nc + 2 )) & ] X = Xc + dXdS * dS end if end subroutine detect_critical end function tx_envelope_2ph end module yaeos__equilibria_boundaries_phase_envelopes_tx","tags":"","url":"sourcefile/phase_envelopes_tx.f90.html"},{"title":"consistency_armodel.f90 – yaeos","text":"Source Code module yaeos__consistency_armodel !! # yaeos__consistency_armodel !! Consistency checks of Helmholtz free energy models ([[ArModel]]). !! !! # Description !! This module contains tools to validate the analityc derivatives of !! implmented Helmholtz free energy models ([[ArModel]]). Also, allows to !! evaluate the consistency tests described in Thermodynamic Models: !! Fundamentals & Computational Aspects 2 ed. by Michelsen and Mollerup !! Chapter 2 section 3. !! !! Available tools: !! !! - [[numeric_ar_derivatives]]: From an instantiated [[ArModel]] evaluate !! all the Helmholtz free energy derivatives from the central finite !! difference method. !! !! - [[ar_consistency]]: From an instantiated [[ArModel]] evaluate all the !! Michelsen and Mollerup consistency tests. !! !! # References !! 1. Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models: !! Fundamentals & computational aspects (2. ed). Tie-Line Publications. !! use yaeos__constants , only : pr , R use yaeos__models_ar , only : ArModel implicit none contains subroutine ar_consistency (& eos , n , V , T , eq31 , eq33 , eq34 , eq36 , eq37 & ) !! # ar_consistency !! A&#94;r models consistency tests. !! !! # Description !! The evaluated equations are taken from Fundamentals & Computational !! Aspects 2 ed. by Michelsen and Mollerup Chapter 2 section 3. The !! \"eq\" are evaluations of the left hand side of the following !! expressions: !! !! Equation 31: !! !! \\sum_i n_i ln \\hat{\\phi}_i - \\frac{G&#94;r(T,P,n)}{RT} = 0 !! !! Equation 33: !! !!  !!    \\left(\\frac{\\partial ln \\hat{\\phi}_i}{\\partial n_j} \\right)_{T,P} !!    - \\left(\\frac{\\partial ln \\hat{\\phi}_j}{\\partial n_i} \\right)_{T,P} !!    = 0 !!  !! !! Equation 34: !! !!  !!    \\sum_i n_i !!    \\left(\\frac{\\partial ln \\hat{\\phi}_i}{\\partial n_j} \\right)_{T,P} !!    = 0 !!  !! !! Equation 36: !! !!  !!    \\left(\\frac{\\partial}{\\partial P} !!    \\sum_i n_i ln \\hat{\\phi}_i \\right)_{T,n} - \\frac{(Z - 1)n}{P} = 0 !!  !! !! Equation 37: !! !!  !!    \\sum_i n_i \\left(\\frac{\\partial ln \\hat{\\phi}_i}{\\partial T} !!    \\right)_{P,n} + \\frac{H&#94;r(T,P,n)}{RT&#94;2} = 0 !!  !! !! The consistency test could be applied to any instantiated [[ArModel]] !! as shown in the following example. !! !! # Examples !! !! ```fortran !!  use yaeos, only: pr, SoaveRedlichKwong, ArModel !!  use yaeos__consistency_armodel, only: ar_consistency !! !!  class(ArModel), allocatable :: model !!  real(pr) :: tc(4), pc(4), w(4) !! !!  real(pr) :: n(4), T, V !! !!  real(pr) :: eq31, eq33(size(n), size(n)), eq34(size(n)), eq36, eq37 !! !!  n = [1.5, 0.2, 0.7, 2.3] !!  tc = [190.564, 425.12, 300.11, 320.25] !!  pc = [45.99, 37.96, 39.23, 40.21] !!  w = [0.0115478, 0.200164, 0.3624, 0.298] !! !!  T = 600_pr !!  V = 0.5_pr !! !!  model = SoaveRedlichKwong(tc, pc, w) !! !!  call ar_consistency(& !!     model, n, V, T, eq31=eq31, eq33=eq33, eq34=eq34, eq36=eq36, eq37=eq37 & !!     ) !! ``` !! All `eqXX` variables should be close to zero. !! !! # References !! 1. Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models: !! Fundamentals & computational aspects (2. ed). Tie-Line Publications. !! class ( ArModel ), intent ( in ) :: eos !! Equation of state real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), optional , intent ( out ) :: eq31 !! MM Eq. 31 ! TODO real(pr), optional, intent(out) :: eq32 real ( pr ), optional , intent ( out ) :: eq33 ( size ( n ), size ( n )) !! MM Eq. 33 real ( pr ), optional , intent ( out ) :: eq34 ( size ( n )) !! MM Eq. 34 real ( pr ), optional , intent ( out ) :: eq36 !! MM Eq. 36 real ( pr ), optional , intent ( out ) :: eq37 !! MM Eq. 37 integer i , j ! ======================================================================== ! Previous calculations ! ------------------------------------------------------------------------ real ( pr ) :: Grp , Grv , Hrv , P , dPdn ( size ( n )), ntot , z real ( pr ) :: lnphi ( size ( n )), dlnPhidP ( size ( n )) real ( pr ) :: dlnPhidT ( size ( n )), dlnPhidn ( size ( n ), size ( n )) call eos % pressure ( n , V , T , P , dPdn = dPdn ) call eos % gibbs_residual_vt ( n , V , T , Grv ) call eos % enthalpy_residual_vt ( n , V , T , Hr = Hrv ) call eos % lnphi_vt (& n , V , T , lnPhi = lnPhi , & dlnPhidP = dlnPhidP , dlnPhidT = dlnPhidT , dlnPhidn = dlnPhidn & ) ntot = sum ( n ) z = P * V / ntot / R / T Grp = Grv - ntot * R * T * log ( Z ) ! ======================================================================== ! Equation 31 ! ------------------------------------------------------------------------ if ( present ( eq31 )) eq31 = sum ( n (:) * lnPhi (:)) - Grp / ( R * T ) ! ======================================================================== ! Equation 32 ! ------------------------------------------------------------------------ ! TODO ! ======================================================================== ! Equation 33 ! ------------------------------------------------------------------------ if ( present ( eq33 )) then do i = 1 , size ( n ), 1 do j = 1 , size ( n ), 1 eq33 ( i , j ) = dlnPhidn ( i , j ) - dlnPhidn ( j , i ) end do end do end if ! ======================================================================== ! Equation 34 ! ------------------------------------------------------------------------ if ( present ( eq34 )) then eq34 = 0.0_pr do j = 1 , size ( n ), 1 do i = 1 , size ( n ), 1 eq34 ( j ) = eq34 ( j ) + n ( i ) * dlnPhidn ( i , j ) end do end do end if ! ======================================================================== ! Equation 36 ! ------------------------------------------------------------------------ if ( present ( eq36 )) eq36 = sum ( n (:) * dlnPhidP (:)) - ( z - 1 ) * ntot / P ! ======================================================================== ! Equation 37 ! ------------------------------------------------------------------------ if ( present ( eq37 )) then eq37 = sum ( n (:) * dlnPhidT (:)) + Hrv / ( R * T ** 2 ) end if end subroutine ar_consistency subroutine numeric_ar_derivatives (& eos , n , V , T , d_n , d_v , d_t , & Ar , ArV , ArT , Arn , ArV2 , ArT2 , ArTV , ArVn , ArTn , Arn2 & ) !! # numeric_ar_derivatives !! Evaluate the Helmholtz derivatives with central finite difference. !! !! # Description !! Tool to facilitate the development of new [[ArModel]] by testing !! the implementation of analytic derivatives. !! !! # Examples !! !! ```fortran !!  use yaeos, only: pr, SoaveRedlichKwong, ArModel !!  use yaeos__consistency_armodel, only: numeric_ar_derivatives !! !!  class(ArModel), allocatable :: model !!  real(pr) :: tc(4), pc(4), w(4) !! !!  real(pr) :: n(4), T, V !! !!  real(pr) :: Ar_num, ArV_num, ArT_num, Arn_num(size(n)), ArV2_num, ArT2_num !!  real(pr) :: ArTV_num, ArVn_num(size(n)), ArTn_num(size(n)) !!  real(pr) :: Arn2_num(size(n), size(n)) !! !!  n = [1.5, 0.2, 0.7, 2.3] !!  tc = [190.564, 425.12, 300.11, 320.25] !!  pc = [45.99, 37.96, 39.23, 40.21] !!  w = [0.0115478, 0.200164, 0.3624, 0.298] !! !!  T = 600_pr !!  V = 0.5_pr !! !!  model = SoaveRedlichKwong(tc, pc, w) !! !!  call numeric_ar_derivatives(& !!     model, n, V, T, d_n = 0.0001_pr, d_v = 0.0001_pr, d_t = 0.01_pr, & !!     Ar=Ar_num, ArV=ArV_num, ArT=ArT_num, ArTV=ArTV_num, ArV2=ArV2_num, & !!     ArT2=ArT2_num, Arn=Arn_num, ArVn=ArVn_num, ArTn=ArTn_num, & !!     Arn2=Arn2_num & !!     ) !! ``` !! class ( ArModel ), intent ( in ) :: eos !! Equation of state real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), intent ( in ) :: d_n !! Moles finite difference step real ( pr ), intent ( in ) :: d_t !! Temperature finite difference step real ( pr ), intent ( in ) :: d_v !! Volume finite difference step real ( pr ), intent ( out ) :: Ar !! Residual Helmoltz energy real ( pr ), optional , intent ( out ) :: ArV !! \\frac{dAr}{dV} real ( pr ), optional , intent ( out ) :: ArT !! \\frac{dAr}{dT} real ( pr ), optional , intent ( out ) :: Arn ( size ( n )) !! \\frac{dAr}{dn_i} real ( pr ), optional , intent ( out ) :: ArV2 !! \\frac{d&#94;2Ar}{dV&#94;2} real ( pr ), optional , intent ( out ) :: ArT2 !! \\frac{d&#94;2Ar}{dT&#94;2} real ( pr ), optional , intent ( out ) :: ArTV !! \\frac{d&#94;2Ar}{dTdV} real ( pr ), optional , intent ( out ) :: ArVn ( size ( n )) !! \\frac{d&#94;2Ar}{dVdn_i} real ( pr ), optional , intent ( out ) :: ArTn ( size ( n )) !! \\frac{d&#94;2Ar}{dTdn_i} real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) !! \\frac{d&#94;2Ar}{dn_{ij}} ! Auxiliary real ( pr ) :: Ar_aux1 , Ar_aux2 , Ar_aux3 , Ar_aux4 real ( pr ) :: dn_aux1 ( size ( n )), dn_aux2 ( size ( n )) integer :: i , j ! ======================================================================== ! Ar valuations ! ------------------------------------------------------------------------ ! on point valuation call eos % residual_helmholtz ( n , V , T , Ar = Ar ) ! ======================================================================== ! Central numeric derivatives ! ------------------------------------------------------------------------ ! Volume if ( present ( ArV ) . or . present ( ArV2 )) then call eos % residual_helmholtz ( n , V + d_v , T , Ar = Ar_aux1 ) call eos % residual_helmholtz ( n , V - d_v , T , Ar = Ar_aux2 ) if ( present ( ArV )) ArV = ( Ar_aux1 - Ar_aux2 ) / ( 2 * d_v ) if ( present ( ArV2 )) ArV2 = ( Ar_aux1 - 2 * Ar + Ar_aux2 ) / d_v ** 2 end if ! Temperature if ( present ( ArT ) . or . present ( ArT2 )) then call eos % residual_helmholtz ( n , V , T + d_t , Ar = Ar_aux1 ) call eos % residual_helmholtz ( n , V , T - d_t , Ar = Ar_aux2 ) if ( present ( ArT )) ArT = ( Ar_aux1 - Ar_aux2 ) / ( 2 * d_t ) if ( present ( ArT2 )) ArT2 = ( Ar_aux1 - 2 * Ar + Ar_aux2 ) / d_t ** 2 end if ! Mole first derivatives if ( present ( Arn )) then Arn = 0.0_pr do i = 1 , size ( n ), 1 dn_aux1 = 0.0_pr dn_aux1 ( i ) = d_n call eos % residual_helmholtz ( n + dn_aux1 , V , T , Ar = Ar_aux1 ) call eos % residual_helmholtz ( n - dn_aux1 , V , T , Ar = Ar_aux2 ) Arn ( i ) = ( Ar_aux1 - Ar_aux2 ) / ( 2 * d_n ) end do end if ! ======================================================================== ! Central cross derivatives ! ------------------------------------------------------------------------ ! Temperature - Volume if ( present ( ArTV )) then call eos % residual_helmholtz ( n , V + d_v , T + d_t , Ar = Ar_aux1 ) call eos % residual_helmholtz ( n , V + d_v , T - d_t , Ar = Ar_aux2 ) call eos % residual_helmholtz ( n , V - d_v , T + d_t , Ar = Ar_aux3 ) call eos % residual_helmholtz ( n , V - d_v , T - d_t , Ar = Ar_aux4 ) ArTV = ( Ar_aux1 - Ar_aux2 - Ar_aux3 + Ar_aux4 ) / ( 4 * d_t * d_v ) end if ! Temperature - Mole if ( present ( ArTn )) then ArTn = 0.0_pr do i = 1 , size ( n ), 1 dn_aux1 = 0.0_pr dn_aux1 ( i ) = d_n call eos % residual_helmholtz ( n + dn_aux1 , V , T + d_t , Ar = Ar_aux1 ) call eos % residual_helmholtz ( n + dn_aux1 , V , T - d_t , Ar = Ar_aux2 ) call eos % residual_helmholtz ( n - dn_aux1 , V , T + d_t , Ar = Ar_aux3 ) call eos % residual_helmholtz ( n - dn_aux1 , V , T - d_t , Ar = Ar_aux4 ) ArTn ( i ) = & ( Ar_aux1 - Ar_aux2 - Ar_aux3 + Ar_aux4 ) / ( 4 * d_t * d_n ) end do end if ! Volume - Mole if ( present ( ArVn )) then ArVn = 0.0_pr do i = 1 , size ( n ), 1 dn_aux1 = 0.0_pr dn_aux1 ( i ) = d_n call eos % residual_helmholtz ( n + dn_aux1 , V + d_v , T , Ar = Ar_aux1 ) call eos % residual_helmholtz ( n + dn_aux1 , V - d_v , T , Ar = Ar_aux2 ) call eos % residual_helmholtz ( n - dn_aux1 , V + d_v , T , Ar = Ar_aux3 ) call eos % residual_helmholtz ( n - dn_aux1 , V - d_v , T , Ar = Ar_aux4 ) ArVn ( i ) = & ( Ar_aux1 - Ar_aux2 - Ar_aux3 + Ar_aux4 ) / ( 4 * d_v * d_n ) end do end if ! Mole second derivatives if ( present ( Arn2 )) then Arn2 = 0.0_pr do i = 1 , size ( n ), 1 do j = 1 , size ( n ), 1 if ( i . eq . j ) then dn_aux1 = 0.0_pr dn_aux1 ( i ) = d_n call eos % residual_helmholtz ( n + dn_aux1 , V , T , Ar = Ar_aux1 ) call eos % residual_helmholtz ( n - dn_aux1 , V , T , Ar = Ar_aux2 ) Arn2 ( i , j ) = ( Ar_aux1 - 2 * Ar + Ar_aux2 ) / d_n ** 2 else dn_aux1 = 0.0_pr dn_aux2 = 0.0_pr dn_aux1 ( i ) = d_n dn_aux2 ( j ) = d_n call eos % residual_helmholtz (& n + dn_aux1 + dn_aux2 , V , T , Ar = Ar_aux1 & ) call eos % residual_helmholtz (& n + dn_aux1 - dn_aux2 , V , T , Ar = Ar_aux2 & ) call eos % residual_helmholtz (& n - dn_aux1 + dn_aux2 , V , T , Ar = Ar_aux3 & ) call eos % residual_helmholtz (& n - dn_aux1 - dn_aux2 , V , T , Ar = Ar_aux4 & ) Arn2 ( i , j ) = & ( Ar_aux1 - Ar_aux2 - Ar_aux3 + Ar_aux4 ) / ( 4 * d_n ** 2 ) end if end do end do end if end subroutine numeric_ar_derivatives end module yaeos__consistency_armodel","tags":"","url":"sourcefile/consistency_armodel.f90.html"},{"title":"admm_tapenade_interface.f90 – yaeos","text":"Source Code MODULE ADMM_TAPENADE_INTERFACE IMPLICIT NONE INTERFACE PUSHPOINTER8 SUBROUTINE PUSHPOINTER8 ( pp ) BIND ( c , name = 'pushPointer8' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: pp END SUBROUTINE PUSHPOINTER8 END INTERFACE PUSHPOINTER8 INTERFACE POPPOINTER8 SUBROUTINE POPPOINTER8 ( pp ) BIND ( c , name = 'popPointer8' ) USE ISO_C_BINDING TYPE ( C_PTR ) :: pp END SUBROUTINE POPPOINTER8 END INTERFACE POPPOINTER8 INTERFACE ADMM_REGISTERSHADOWED SUBROUTINE ADMM_REGISTERSHADOWED ( base , obase , size , baseb , obaseb & & , sizeb , nbelem ) BIND ( c , name = 'ADMM_registerShadowed' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base , obase TYPE ( C_PTR ), VALUE :: baseb , obaseb INTEGER , VALUE :: size , sizeb INTEGER , VALUE :: nbelem END SUBROUTINE ADMM_REGISTERSHADOWED END INTERFACE ADMM_REGISTERSHADOWED INTERFACE ADMM_REGISTER SUBROUTINE ADMM_REGISTER ( base , obase , size , nbelem ) BIND ( c , name = & & 'ADMM_register' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base , obase INTEGER , VALUE :: size INTEGER , VALUE :: nbelem END SUBROUTINE ADMM_REGISTER END INTERFACE ADMM_REGISTER INTERFACE ADMM_UNREGISTERSHADOWED SUBROUTINE ADMM_UNREGISTERSHADOWED ( base , baseb , nbelem ) BIND ( c , & & name = 'ADMM_unregisterShadowed' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base , baseb INTEGER :: nbelem END SUBROUTINE ADMM_UNREGISTERSHADOWED END INTERFACE ADMM_UNREGISTERSHADOWED INTERFACE ADMM_UNREGISTER SUBROUTINE ADMM_UNREGISTER ( base , nbelem ) BIND ( c , name = & & 'ADMM_unregister' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base INTEGER :: nbelem END SUBROUTINE ADMM_UNREGISTER END INTERFACE ADMM_UNREGISTER INTERFACE ADMM_REBASESHADOWED SUBROUTINE ADMM_REBASESHADOWED ( base , baseb ) BIND ( c , name = & & 'ADMM_rebaseShadowed' ) USE ISO_C_BINDING TYPE ( C_PTR ) :: base , baseb END SUBROUTINE ADMM_REBASESHADOWED END INTERFACE ADMM_REBASESHADOWED INTERFACE ADMM_REBASE SUBROUTINE ADMM_REBASE ( base ) BIND ( c , name = 'ADMM_rebase' ) USE ISO_C_BINDING TYPE ( C_PTR ) :: base END SUBROUTINE ADMM_REBASE END INTERFACE ADMM_REBASE END MODULE ADMM_TAPENADE_INTERFACE","tags":"","url":"sourcefile/admm_tapenade_interface.f90.html"},{"title":"stability.f90 – yaeos","text":"Source Code module yaeos__equilibria_stability !! # Phase Stability module !! Phase stability related calculations. !! !! # Description !! Contains the basics rotuines to make phase stability analysis for !! phase-equilibria detection. !! !! - `tpd(model, z, w, P, T)`: reduced Tangent-Plane-Distance !! - `min_tpd(model, z, P, T, mintpd, w)`: Find minimal tpd for a multicomponent mixture !! !! # Examples !! !! ```fortran !!   ! Obtain the minimal tpd for a binary mixture at z_1 = 0.13 !!   model = PengRobinson76(tc, pc, ac, kij, lij) !! !!   z = [0.13, 1-0.13] !!   w = [0.1, 0.9] !! !!   P = 45.6_pr !!   T = 190._pr !! !!   z = z/sum(z) !! ----------------------------------------------- !! ``` !! !! # References !! 1. Thermodynamic Models: Fundamental and Computational Aspects, Michael L. !! Michelsen, Jørgen M. Mollerup. Tie-Line Publications, Denmark (2004) !! [doi](http://dx.doi.org/10.1016/j.fluid.2005.11.032) use yaeos__constants , only : pr , r use yaeos__models , only : BaseModel , ArModel , GeModel implicit none contains real ( pr ) function tm ( model , z , w , P , T , d , dtpd ) !! # Alternative formulation of tangent-plane-distance !! Michelsen's modified tpd function, tm. !! !! # Description !! Alternative formulation of the reduced tangent plane tpd function, !! where the test phase is defined in moles, which enables for unconstrained !! minimization. !!  !!   tm(W) = 1 + \\sum_i W_i (\\ln W_i + \\ln \\phi_i(W) - d_i - 1) !!  !! !! # Examples !! !! ## Calculation of `tm` !! ```fortran !!  tm = tpd(model, z, w, P, T) !!  --------------------------- !! ``` !! !! ## Using precalculated trial-phase data !! It is possible to calculate externaly the `d_i` vector and use it for !! later calculations. !! ```fortran !! call fugacity_tp(& !!   model, z, T=T, P=P, V=Vz, root_type=\"stable\", lnphip=lnphi_z& !! ) !! lnphi_z = lnphi_z - log(P) !! di = log(z) + lnphi_z !! tm = tpd(model, z, w, P, T, d=di) !!  --------------------------- !! ``` !! !! # References !! 1. Thermodynamic Models: Fundamental and Computational Aspects, Michael L. !! Michelsen, Jørgen M. Mollerup. Tie-Line Publications, Denmark (2004) !! [doi](http://dx.doi.org/10.1016/j.fluid.2005.11.032) class ( BaseModel ), intent ( in ) :: model !! Thermodynamic model real ( pr ), intent ( in ) :: z (:) !! Feed composition real ( pr ), intent ( in ) :: w (:) !! Test-phase mole numbers vector real ( pr ), intent ( in ) :: P !! Pressure [bar] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( in ) :: d (:) !! d_i vector real ( pr ), optional , intent ( out ) :: dtpd (:) real ( pr ) :: di ( size ( z )), vz , vw real ( pr ) :: lnphi_z ( size ( z )), lnphi_w ( size ( z )) select type ( model ) class is ( ArModel ) call model % lnphi_pt (& w , T = T , P = P , V = Vw , root_type = \"stable\" , lnPhi = lnPhi_w & ) if (. not . present ( d )) then call model % lnphi_pt (& z , T = T , P = P , V = Vz , root_type = \"stable\" , lnPhi = lnPhi_z & ) di = log ( z ) + lnphi_z else di = d end if class is ( GeModel ) call model % ln_activity_coefficient ( w , T = T , lngamma = lnPhi_w ) if (. not . present ( d )) then call model % ln_activity_coefficient ( z , T = T , lngamma = lnPhi_z ) di = log ( z ) + lnphi_z else di = d end if end select ! tpd = sum(w * (log(w) + lnphi_w - di)) tm = 1 + sum ( w * ( log ( w ) + lnPhi_w - di - 1 )) if ( present ( dtpd )) then dtpd = log ( w ) + lnPhi_w - di end if end function tm subroutine min_tpd ( model , z , P , T , mintpd , w , all_minima ) class ( BaseModel ), target :: model !! Thermodynamic model real ( pr ), intent ( in ) :: z (:) !! Feed composition real ( pr ), intent ( in ) :: P !! Pressure [bar] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( out ) :: w (:) !! Trial composition real ( pr ), intent ( out ) :: mintpd !! Minimal value of tm real ( pr ), optional , intent ( out ) :: all_minima (:, :) !! All the found minima real ( pr ) :: dx ( size ( w )) real ( pr ) :: lnphi_z ( size ( z )), di ( size ( z )) real ( pr ) :: lnphi_w ( size ( w )) real ( pr ) :: dw ( size ( w )), mins ( size ( w )), ws ( size ( w ), size ( w )), V integer :: i , j integer :: nc , stat nc = size ( z ) dx = 0.001_pr ! Calculate feed di select type ( model ) class is ( ArModel ) call model % lnphi_pt ( z , T = T , P = P , V = V , root_type = \"stable\" , lnPhi = lnPhi_z ) class is ( GeModel ) call model % ln_activity_coefficient ( z , T = T , lngamma = lnPhi_z ) end select di = log ( z ) + lnphi_z ! ============================================================== ! Minimize for each component using each quasi-pure component ! as initialization. ! -------------------------------------------------------------- mins = 10 do i = 1 , nc w = 1e-10 w ( i ) = 1 - 1e-10 dw = 100 do while ( maxval ( abs ( dw )) > 1e-8 . and . abs ( mins ( i )) > 1e-4 ) select type ( model ) class is ( ArModel ) call model % lnphi_pt ( w , T = T , P = P , V = V , root_type = \"stable\" , lnPhi = lnPhi_w ) class is ( GeModel ) call model % ln_activity_coefficient ( w , T = T , lngamma = lnPhi_w ) end select dw = exp ( di - lnphi_w ) - w do while ( any ( dw + w < 0 ) . or . maxval ( abs ( dw )) > 0.01 ) dw = dw / 2 end do w = w + dw mins ( i ) = 1 + sum ( w * ( log ( w ) + lnPhi_w - di - 1 )) end do w = w / sum ( w ) mins ( i ) = tm ( model , z , w , P , T , d = di ) ws ( i , :) = w end do i = minloc ( mins , dim = 1 ) mintpd = mins ( i ) w = ws ( i , :) if ( present ( all_minima )) then do i = 1 , nc all_minima ( i , : nc ) = ws ( i , :) all_minima ( i , nc + 1 ) = mins ( i ) end do end if end subroutine min_tpd end module yaeos__equilibria_stability","tags":"","url":"sourcefile/stability.f90.html"},{"title":"interfaces.f90 – yaeos","text":"Source Code module yaeos__tapenade_interfaces use yaeos__constants , only : pr implicit none interface subroutine pushinteger4 ( i ) integer :: i end subroutine subroutine popinteger4 ( i ) integer :: i end subroutine subroutine pushreal8array ( a , n ) import pr real ( pr ), dimension ( n ) :: a integer :: n end subroutine subroutine pushreal8 ( a ) import pr real ( pr ) :: a end subroutine subroutine POPREAL8 ( a ) import pr real ( pr ) :: a end subroutine subroutine POPREAL8ARRAY ( a , n ) import pr real ( pr ), dimension ( n ) :: a integer :: n end subroutine end interface end module","tags":"","url":"sourcefile/interfaces.f90.html"},{"title":"volume.f90 – yaeos","text":"Source Code module yaeos__models_solvers !! # `models solvers` !! Set of different specialized solvers for different models !! !! # Description !! This module holds specialized solvers for different kind of applications !! and models. !! !! ## Volume solving !! This module holds the routine `volume_michelsen` which is a solver for !! volume that takes advantage over a simple newton on the function of !! pressure by solving the function of pressure over the covolume instead, !! which solution is limited in the range [0, 1]. This solver requires that !! the EoS uses the method `get_v0` to return the covolume. !! !! # Examples !! !! ```fortran !!  A basic code example !! ``` !! !! # References !! use yaeos__constants , only : pr , R , solving_volume use yaeos__models_ar , only : ArModel implicit none contains subroutine volume_michelsen ( eos , n , P , T , V , root_type , max_iters , V0 ) !! Volume solver at a given pressure. !! !! Obtain the volume using the method described by Michelsen and Møllerup. !! While P(V, T) can be obtained with a simple Newton method, a better !! approach is solving P(B/V, T) where B is the EoS covolume. !! This method is easier to solve because: !!  !!    V(P, T) \\in [0, \\infty) !!  !! and !!  !!    \\frac{B}{V}(P, T) \\in [0, 1] !!  !! !! At chapter 3 page 94 of Michelsen and Møllerup's book a more complete !! explanation can be seen use iso_fortran_env , only : error_unit use yaeos__auxiliar , only : optval class ( ArModel ), intent ( in ) :: eos real ( pr ), intent ( in ) :: n (:) !! Mixture moles real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: P !! Pressure [bar] real ( pr ), intent ( out ) :: V !! Volume [L] character ( len =* ), optional , intent ( in ) :: root_type !! Type of root [\"vapor\" | \"liquid\" | \"stable\"] integer , optional , intent ( in ) :: max_iters !! Maxiumum number of iterations, defaults to 100 real ( pr ), optional , intent ( in ) :: V0 !! Specified initial volume character ( len = 10 ) :: root real ( pr ) :: totn real ( pr ) :: B !! Covolume real ( pr ) :: ZETMIN , ZETA , ZETMAX real ( pr ) :: pcalc , AT , AVAP , VVAP integer :: iter , maximum_iterations maximum_iterations = optval ( max_iters , 1000 ) root = optval ( root_type , \"stable\" ) TOTN = sum ( n ) B = eos % get_v0 ( n , p , t ) ITER = 0 ! Limits ZETMIN = 0._pr ZETMAX = 1._pr ZETMAX = 1._pr !- 0.01*T/(10000*B)  ! improvement for cases with heavy components if ( present ( V0 )) then zeta = B / V0 else select case ( root_type ) case ( \"liquid\" ) ZETA = 0.5_pr call solve_point ( eos , n , P , T , V , Pcalc , ZETA , ZETMIN , ZETMAX , AT , iter ) case ( \"vapor\" , \"stable\" ) ZETA = min ( 0.5_pr , B * P / ( TOTN * R * T )) call solve_point ( eos , n , P , T , V , Pcalc , ZETA , ZETMIN , ZETMAX , AT , iter ) if ( root_type == \"stable\" ) then ! Run first for vapor and then for liquid VVAP = V AVAP = AT ZETA = 0.5_pr ZETMAX = 1._pr ZETMAX = 1.D0 !- 0.01*T/(10000*B)  ! improvement for cases with heavy components call solve_point ( eos , n , P , T , V , Pcalc , ZETA , ZETMIN , ZETMAX , AT , iter ) if ( AT . gt . AVAP ) V = VVAP end if case default write ( error_unit , * ) \"ERROR [VCALC]: Wrong specification\" error stop 1 end select end if end subroutine volume_michelsen subroutine solve_point ( eos , n , P , T , V , Pcalc , ZETA , ZETMIN , ZETMAX , AT , iter ) class ( ArModel ), intent ( in ) :: eos real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: P !! Objective pressure [bar] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( out ) :: V !! Obtained volume [L] real ( pr ), intent ( out ) :: Pcalc !! Calculated pressure at V [bar] real ( pr ), intent ( in out ) :: ZETA !! real ( pr ), intent ( inout ) :: ZETMIN real ( pr ), intent ( inout ) :: ZETMAX real ( pr ), intent ( out ) :: AT !! integer , intent ( out ) :: iter real ( pr ) :: del , der , B real ( pr ) :: totn real ( pr ) :: Ar , ArV , ArV2 iter = 0 DEL = 1 pcalc = 2 * p B = eos % get_v0 ( n , p , t ) totn = sum ( n ) do while (& abs ( DEL ) > 1.e-10_pr . and . abs ( Pcalc - P ) / P > 1.e-10 & ) V = B / ZETA iter = iter + 1 solving_volume = . true . call eos % residual_helmholtz ( n , V , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 ) solving_volume = . false . Pcalc = TOTN * R * T / V - ArV if ( Pcalc . gt . P ) then ZETMAX = ZETA else ZETMIN = ZETA end if ! AT is something close to Gr(P,T) AT = ( Ar + V * P ) / ( T * R ) - TOTN * log ( V ) ! this is dPdrho/B DER = ( ArV2 * V ** 2 + TOTN * R * T ) / B DEL = - ( Pcalc - P ) / DER ZETA = ZETA + max ( min ( DEL , 0.1_pr ), - . 1_pr ) if ( ZETA . gt . ZETMAX . or . ZETA . lt . ZETMIN ) then ZETA = 0.5_pr * ( ZETMAX + ZETMIN ) end if end do end subroutine solve_point end module yaeos__models_solvers","tags":"","url":"sourcefile/volume.f90.html"},{"title":"pure_saturation.f90 – yaeos","text":"Source Code module yaeos__equilibria_boundaries_pure_saturation use yaeos__constants , only : pr use yaeos__models_ar , only : ArModel , size use yaeos__math_linalg , only : solve_system use yaeos__math_continuation , only : & continuation , continuation_solver , continuation_stopper use linear_interpolation_module , only : linear_interp_1d implicit none type :: PurePsat real ( pr ), allocatable :: T (:) !! Temperature [K] real ( pr ), allocatable :: P (:) !! Pressure [Pa] real ( pr ), allocatable :: Vx (:) !! Molar volume [L/mol] in the liquid phase real ( pr ), allocatable :: Vy (:) !! Molar volume [L/mol] in the vapor phase type ( linear_interp_1d ), private :: interpolator_get_T type ( linear_interp_1d ), private :: interpolator_get_P contains procedure :: get_T => get_T procedure :: get_P => get_P end type PurePsat contains function pure_saturation_line ( model , component , minP , minT ) result ( pt ) !! # Pure saturation line !! !! Saturation pressures and temperatures for a pure component. !! !! ## Description !! This function calculates the saturation line for a pure component. !! Starting from the pure component critical point, the function traces !! the saturation line using the continuation method. !! The function returns a `PurePsat` object with the saturation !! temperatures and pressures. The object also contains interpolators !! to get the saturation temperature for a given pressure and vice versa. !! ! ======================================================================== use yaeos__auxiliar , only : optval class ( ArModel ), intent ( in ) :: model !! Thermodyanmic model integer , intent ( in ) :: component !! Component index to calculate the line real ( pr ), intent ( in ) :: minP !! Minimum pressure [bar] real ( pr ), intent ( in ) :: minT !! Minimum temperature [K] type ( PurePsat ) :: pt ! ------------------------------------------------------------------------ real ( pr ) :: X ( 4 ) !! Variables [lnVx, lnVy, lnP, lnT] real ( pr ) :: z ( size ( model )) real ( pr ) :: Vc integer :: i integer :: ns real ( pr ) :: Tc , Pc real ( pr ) :: Vx , Vy , T , P real ( pr ) :: dXdS ( 4 ), dS , S , dFdS ( 4 ) real ( pr ) :: F ( 4 ), dF ( 4 , 4 ) integer :: its , nc integer :: points nc = size ( model ) Tc = model % components % Tc ( component ) Pc = model % components % Pc ( component ) z = 0 z ( component ) = 1 call model % volume ( z , P = Pc , T = Tc , V = Vc , root_type = \"vapor\" ) Vx = Vc * 0.995 Vy = Vc * 1.005 X = [ log ( Vx ), log ( Vy ), log ( Pc ), log ( Tc )] ns = 1 S = log ( 0.95 ) dS = - 0.15 allocate ( pt % T ( 0 ), pt % P ( 0 ), pt % Vx ( 0 ), pt % Vy ( 0 )) ! ======================================================================== ! Trace the line using the continuation method. ! ------------------------------------------------------------------------ T = Tc P = Pc points = 0 do while ( T > minT . and . P > minP . and . . not . isnan ( T )) call solve_point ( model , component , nc , X , ns , S , F , dF , dFdS , its ) dXdS = solve_system ( dF , - dFdS ) ns = maxloc ( abs ( dXdS ( 3 : 4 )), dim = 1 ) + 2 dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) do while ( exp ( X ( 4 )) - exp ( X ( 4 ) + dXdS ( 4 ) * dS ) < 3 . and . (( Tc - T ) > 10 . or . ( Pc - P ) > 2 )) dS = dS * 1.5 end do ds = sign ( max ( dS , 0.01_pr ), dS ) Vx = exp ( X ( 1 )) Vy = exp ( X ( 2 )) P = exp ( X ( 3 )) T = exp ( X ( 4 )) if ( isnan ( T )) then exit else pt % T = [ pt % T , T ] pt % P = [ pt % P , P ] pt % Vx = [ pt % Vx , Vx ] pt % Vy = [ pt % Vy , Vy ] points = points + 1 end if X = X + dXdS * dS S = X ( ns ) end do ! Save interpolators to obtain particular values. The interpolator needs ! monothonic increasing values in x, so we need to reverse the arrays. pt % P = pt % P ( points : 1 : - 1 ) pt % T = pt % T ( points : 1 : - 1 ) pt % Vx = pt % Vx ( points : 1 : - 1 ) pt % Vy = pt % Vy ( points : 1 : - 1 ) call pt % interpolator_get_T % initialize ( pt % P , pt % T , i ) call pt % interpolator_get_P % initialize ( pt % T , pt % P , i ) end function pure_saturation_line subroutine solve_point ( model , ncomp , nc , X , ns , S , F , dF , dFdS , its ) !! # Solve point !! !! Solve a saturation point for a pure component. !! !! ## Description !! The set of equations to solve is: !! !!  !! \\begin{align*} !! f_1 &= \\ln f_{z}(V_z, T) - \\ln f_{y}(V_y, T) \\\\ !! f_2 &= \\ln \\left( \\frac{P_z}{P_y} \\right) \\\\ !! f_3 &= \\ln P_z - \\ln P \\\\ !! f_4 &= g(X, ns) !! \\end{align*} !!  !! !! Where f_4 is an specification function defined as: !! !!  !! g(X, ns) = \\left\\{ !! \\begin{array}{lr} !! \\ln \\left( \\frac{V_z}{V_y} \\right) - S & \\text{if } ns = 1 \\text{ or } ns = 2 \\\\ !! X(ns) - S & \\text{otherwise} !! \\end{array} !! \\right\\} !!  !! !! The vector of variables X is equal to !! [ \\ln V_z, \\ln V_y, \\ln P, \\ln T ]. class ( ArModel ), intent ( in ) :: model !! Thermodynamic model integer , intent ( in ) :: ncomp !! Component index integer , intent ( in ) :: nc !! Total number of components real ( pr ), intent ( in out ) :: X ( 4 ) !! Variables [ln V_z, lnV_y, lnP, lnT] integer , intent ( in ) :: ns !! Variable index to solve. If the real ( pr ), intent ( in ) :: S !! Variable value specified to solve real ( pr ), intent ( out ) :: F ( 4 ) !! Function real ( pr ), intent ( out ) :: dF ( 4 , 4 ) !! Jacobian real ( pr ), intent ( out ) :: dFdS ( 4 ) !! Derivative of the function with respect to S integer , intent ( out ) :: its !! Number of iterations real ( pr ) :: z ( nc ) real ( pr ) :: lnfug_z ( nc ), lnfug_y ( nc ) real ( pr ) :: dlnfdv_z ( nc ), dlnfdv_y ( nc ) real ( pr ) :: dlnfdt_z ( nc ), dlnfdt_y ( nc ) real ( pr ) :: dPdTz , dPdTy real ( pr ) :: dPdVz , dPdVy real ( pr ) :: Vz , Vy real ( pr ) :: T real ( pr ) :: Pz , Py real ( pr ) :: dX ( 4 ), B real ( pr ) :: Xnew ( 4 ) integer :: i i = ncomp dX = 1 F = 1 z = 0 z ( i ) = 1 B = model % get_v0 ( z , 1._pr , 15 0._pr ) its = 0 do while (( maxval ( abs ( dX )) > 1e-7 . and . maxval ( abs ( F )) > 1e-7 )) its = its + 1 call isofugacity ( X , F , dF , dFdS ) if ( any ( isnan ( F ))) exit dX = solve_system ( dF , - F ) Xnew = X + dX X = Xnew end do contains subroutine isofugacity ( X , F , dF , dFdS ) real ( pr ), intent ( inout ) :: X ( 4 ) real ( pr ), intent ( out ) :: F ( 4 ) real ( pr ), intent ( out ) :: dF ( 4 , 4 ) real ( pr ), intent ( out ) :: dFdS ( 4 ) F = 0 dF = 0 Vz = exp ( X ( 1 )) Vy = exp ( X ( 2 )) !lnP = X(3) T = exp ( X ( 4 )) call model % lnfug_vt ( z , V = Vz , T = T , P = Pz , lnf = lnfug_z , dlnfdV = dlnfdv_z , dlnfdT = dlnfdT_z , dPdV = dPdVz , dPdT = dPdTz ) call model % lnfug_vt ( z , V = Vy , T = T , P = Py , lnf = lnfug_y , dlnfdV = dlnfdv_y , dlnfdT = dlnfdT_y , dPdV = dPdVy , dPdT = dPdTy ) F ( 1 ) = lnfug_z ( i ) - lnfug_y ( i ) F ( 2 ) = log ( Pz / Py ) F ( 3 ) = X ( 3 ) - log ( Pz ) if ( ns == 1 . or . ns == 2 ) then F ( 4 ) = log ( Vz / Vy ) - S ! X(ns) - S else F ( 4 ) = X ( ns ) - S end if dF = 0 dF ( 1 , 1 ) = Vz * dlnfdv_z ( i ) dF ( 1 , 2 ) = - Vy * dlnfdv_y ( i ) dF ( 1 , 3 ) = 0 dF ( 1 , 4 ) = T * ( dlnfdT_z ( i ) - dlnfdT_y ( i )) dF ( 2 , 1 ) = Vz / Pz * dPdVz dF ( 2 , 2 ) = - Vy / Py * dPdVy dF ( 2 , 4 ) = T * ( dPdTz / Pz - dPdTy / Py ) dF ( 3 , 1 ) = - Vz / Pz * dPdVz dF ( 3 , 2 ) = 0 dF ( 3 , 3 ) = 1 dF ( 3 , 4 ) = - T / Pz * dPdTz if ( ns == 1 . or . ns == 2 ) then dF ( 4 , 1 ) = 1 dF ( 4 , 2 ) = - 1 else dF ( 4 , ns ) = 1 end if dFdS = 0 dFdS ( 4 ) = - 1 end subroutine isofugacity end subroutine solve_point real ( pr ) function get_T ( pt , P ) result ( T ) !! # Get temperature !! !! Get the saturation temperature for a given pressure. !! !! ## Description !! This function returns the saturation temperature for a given pressure. !! The function uses an interpolator to get the required value. !! !! ## Examples !! ```fortran !! T = pt%get_T(P) !! ``` class ( PurePsat ), intent ( in out ) :: pt real ( pr ), intent ( in ) :: P call pt % interpolator_get_T % evaluate ( P , T ) end function get_T real ( pr ) function get_P ( pt , T ) result ( P ) !! # Get pressure !! !! Get the saturation pressure for a given temperature. !! !! ## Description !! This function returns the saturation pressure for a given temperature. !! The function uses an interpolator to get the required value. !! !! ## Examples !! ```fortran !! P = pt%get_P(T) !! ``` class ( PurePsat ), intent ( in out ) :: pt real ( pr ), intent ( in ) :: T call pt % interpolator_get_P % evaluate ( T , P ) end function get_P end module yaeos__equilibria_boundaries_pure_saturation","tags":"","url":"sourcefile/pure_saturation.f90.html"},{"title":"phase_envelopes_pt_mp.f90 – yaeos","text":"Source Code module yaeos__equilibria_boundaries_phase_envelopes_mp !! Multiphase PT envelope calculation module. !! !! This module contains the functions to calculate the PT envelope of a !! mixture with multiple phases. use yaeos__constants , only : pr , R use yaeos__equilibria_equilibrium_state , only : EquilibriumState use yaeos__models_ar , only : ArModel use yaeos__math , only : solve_system implicit none private public :: PTEnvelMP public :: pt_F_NP public :: pt_envelope type :: PTEnvelMP !! Multiphase PT envelope. type ( MPPoint ), allocatable :: points (:) !! Array of converged points. contains procedure :: write => write_envelope_PT_MP procedure , nopass :: solve_point procedure , nopass :: get_values_from_X end type PTEnvelMP type :: MPPoint !! Multiphase equilibria point. integer :: np !! Number of phases integer :: nc !! Number of components real ( pr ) :: beta_w !! Fraction of the reference (incipient) phase. real ( pr ), allocatable :: betas (:) !! Fractions of the main phases. real ( pr ) :: P !! Pressure [bar] real ( pr ) :: T !! Temperature [K] real ( pr ), allocatable :: x_l (:, :) !! Mole fractions of the main phases. real ( pr ), allocatable :: w (:) !! Mole fractions of the incipient phase. integer :: iters !! Number of iterations needed to converge the point. integer :: ns !! Number of the specified variable. end type MPPoint contains type ( PTEnvelMP ) function pt_envelope (& model , z , np , x_l0 , w0 , betas0 , P0 , T0 , ns0 , dS0 , beta_w , points , & max_pressure & ) !! # `pt_envelope` !! Calculation of a multiphase PT envelope. !! !! # Description !! Calculates a PT envelope is calculated using the continuation method. !! The envelope is calculated by solving the system of equations for each !! point of the envelope. The system of equations is solved using the !! Newton-Raphson method. !! !! This function requires the system specification conditions, which are !! the fluid composition (\\z, the number of phases that are not !! incipient; defined as np, proper intialization values, the !! variables that end with `0` are the initial guess; the mole fraction !! of the reference phase `beta_w` which when it is equal to 0 means that !! we are calculating a phase boundary. use yaeos__auxiliar , only : optval class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z (:) !! Mixture global composition. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in ) :: x_l0 ( np , size ( z )) !! Initial guess for the mole fractions of each phase. arranged as !! an array of size `(np, nc)`, where nc is the number of components !! and `np` the number of main phases. Each row correspond to the !! composition of each main phaase. real ( pr ), intent ( in ) :: w0 ( size ( z )) !! Initial guess for the mole fractions of the !! reference/incipient phase. real ( pr ), intent ( in ) :: betas0 ( np ) !! Initial guess for the fractions of the main phases. arranged as !! an array of size `(np)`, where `np` is the number of main phases. real ( pr ), intent ( in ) :: P0 !! Initial guess for the pressure [bar]. real ( pr ), intent ( in ) :: T0 !! Initial guess for the temperature [K]. integer , intent ( in ) :: ns0 !! Number of the specified variable. !! The variable to be specified. This is the variable that will be !! used to calculate the first point of the envelope. The variable !! can be any of the variables in the vector X, but it is recommended !! to use the temperature or pressure. The variables are aranged as !! follows: !! !! - `X(1:nc*np) = ln(K_i&#94;l)`: \\frac{x_i&#94;l}{w_i} !! - `X(nc*np+1:nc*np+np) = \\beta_i&#94;l`: Fraction of each main phase. !! - `X(nc*np+np+1) = ln(P)`: Pressure [bar]. !! - `X(nc*np+np+2) = ln(T)`: Temperature [K]. real ( pr ), intent ( in ) :: dS0 !! Step size of the specification for the next point. !! This is the step size that will be used to calculate the next point. !! Inside the algorithm this value is modified to adapt the step size !! to facilitate the convergence of each point. real ( pr ), intent ( in ) :: beta_w !! Fraction of the reference (incipient) phase. integer , optional , intent ( in ) :: points !! Number of points to calculate. real ( pr ), optional , intent ( in ) :: max_pressure !! Maximum pressure [bar] to calculate. !! If the pressure of the point is greater than this value, the !! calculation is stopped. !! This is useful to avoid calculating envelopes that go to infinite !! values of pressure. type ( MPPoint ), allocatable :: env_points (:) !! Array of converged points. type ( MPPoint ) :: point !! Converged point. real ( pr ) :: max_P !! Maximum pressure [bar] to calculate. real ( pr ) :: F ( size ( z ) * np + np + 2 ) !! Vector of functions valuated. real ( pr ) :: dF ( size ( z ) * np + np + 2 , size ( z ) * np + np + 2 ) !! Jacobian matrix. real ( pr ) :: dXdS ( size ( z ) * np + np + 2 ) !! Sensitivity of the variables wrt the specification. real ( pr ) :: X ( size ( z ) * np + np + 2 ) !! Vector of variables. real ( pr ) :: dX ( size ( z ) * np + np + 2 ) !! Step for next point estimation. integer :: nc !! Number of components. integer :: its !! Number of iterations to solve the current point. integer :: max_iterations = 10 !! Maximum number of iterations to solve the point. integer :: number_of_points !! Number of points to calculate. real ( pr ) :: x_l ( np , size ( z )) !! Mole fractions of the main phases. real ( pr ) :: w ( size ( z )) !! Mole fractions of the incipient phase. real ( pr ) :: betas ( np ) !! Fractions of the main phases. real ( pr ) :: P !! Pressure [bar]. real ( pr ) :: T !! Temperature [K]. integer :: i !! Point calculation index integer :: iT !! Index of the temperature variable. integer :: iP !! Index of the pressure variable. integer :: lb !! Lower bound, index of the first component of a phase integer :: ub !! Upper bound, index of the last component of a phase integer :: inner !! Number of times a failed point is retried to converge integer :: ns !! Number of the specified variable real ( pr ) :: dS !! Step size of the specification for the next point real ( pr ) :: S !! Specified value real ( pr ) :: X0 ( size ( X )) !! Initial guess for the point nc = size ( z ) iP = np * nc + np + 1 iT = np * nc + np + 2 number_of_points = optval ( points , 1000 ) max_P = optval ( max_pressure , 200 0._pr ) do i = 1 , np lb = ( i - 1 ) * nc + 1 ub = i * nc X ( lb : ub ) = log ( x_l0 ( i , :) / w0 ) end do X ( np * nc + 1 : np * nc + np ) = betas0 X ( np * nc + np + 1 ) = log ( P0 ) X ( np * nc + np + 2 ) = log ( T0 ) ns = ns0 S = X ( ns ) dS = dS0 allocate ( env_points ( 0 )) F = 1 its = 0 X0 = X call solve_point (& model , z , np , beta_w , X , ns , S , dXdS , & F , dF , its , 1000 & ) do i = 1 , number_of_points X0 = X call solve_point (& model , z , np , beta_w , X , ns , S , dXdS , & F , dF , its , max_iterations & ) ! The point might not converge, in this case we try again with an ! initial guess closer to the previous (converged) point. inner = 0 do while ( i > 1 . and . its >= max_iterations . and . inner < 10 ) inner = inner + 1 X = X0 - ( 1 - real ( inner , pr ) / 1 0._pr ) * dX S = X ( ns ) call solve_point (& model , z , np , beta_w , X , ns , S , dXdS , & F , dF , its , max_iterations & ) end do ! Convert the values of the vector of variables into human-friendly ! variables. call get_values_from_X ( X , np , z , x_l , w , betas , P , T ) ! If the point did not converge, stop the calculation if (& any ( isnan ( F )) . or . its > max_iterations & . or . exp ( X ( nc * np + np + 1 )) < 1e-5 & . or . P > max_P & ) exit ! Attach the new point to the envelope. point = MPPoint (& np = np , nc = nc , betas = betas , P = P , T = T , x_l = x_l , w = w , beta_w = beta_w , & iters = its , ns = ns & ) env_points = [ env_points , point ] ! Update the specification for the next point. call update_specification ( its , nc , np , X , dF , dXdS , ns , dS ) ! Check if the system is close to a critical point, and try to jump ! over it. call detect_critical ( nc , np , X , dXdS , ns , dS , S ) ! Next point estimation. dX = dXdS * dS do while ( abs ( exp ( X ( iT )) - exp ( X ( iT ) + dX ( iT ))) > 7 ) dX = dX / 2 end do do while ( abs ( exp ( X ( iP )) - exp ( X ( iP ) + dX ( iP ))) > 5 ) dX = dX / 2 end do X = X + dX S = X ( ns ) end do ! This moves the locally saved points to the output variable. call move_alloc ( env_points , pt_envelope % points ) end function pt_envelope subroutine pt_F_NP ( model , z , np , beta_w , X , ns , S , F , dF ) !! Function to solve at each point of a multi-phase envelope. use iso_fortran_env , only : error_unit class ( ArModel ), intent ( in ) :: model !! Model to use. real ( pr ), intent ( in ) :: z (:) !! Mixture global composition. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in ) :: beta_w !! Fraction of the reference (incipient) phase. real ( pr ), intent ( in ) :: X (:) !! Vector of variables. integer , intent ( in ) :: ns !! Number of specification. real ( pr ), intent ( in ) :: S !! Specification value. real ( pr ), intent ( out ) :: F ( size ( X )) !! Vector of functions valuated. real ( pr ), intent ( out ) :: df ( size ( X ), size ( X )) !! Jacobian matrix. ! X variables real ( pr ) :: K ( np , size ( z )) real ( pr ) :: P real ( pr ) :: T real ( pr ) :: betas ( np ) ! Main phases variables real ( pr ) :: moles ( size ( z )) real ( pr ) :: Vl ( np ) real ( pr ), dimension ( np , size ( z )) :: x_l , lnphi_l , dlnphi_dt_l , dlnphi_dp_l real ( pr ), dimension ( np , size ( z ), size ( z )) :: dlnphi_dn_l real ( pr ) :: lnphi ( size ( z )), dlnphi_dt ( size ( z )), dlnphi_dp ( size ( z )) real ( pr ), dimension ( size ( z ), size ( z )) :: dlnphi_dn ! Incipient phase variables real ( pr ) :: Vw real ( pr ), dimension ( size ( z )) :: w , lnphi_w , dlnphi_dt_w , dlnphi_dp_w real ( pr ), dimension ( size ( z ), size ( z )) :: dlnphi_dn_w ! Derivatives of w wrt beta and K real ( pr ) :: dwdb ( np , size ( z )) real ( pr ) :: dwdlnK ( np , size ( z )) real ( pr ) :: denom ( size ( z )) real ( pr ) :: denomdlnK ( np , size ( z ), size ( z )) real ( pr ) :: dx_l_dlnK ( np , np , size ( z )) integer :: i , j , l , phase , nc integer :: lb , ub integer :: idx_1 , idx_2 nc = size ( z ) ! ======================================================================== ! Extract variables from the vector X ! ------------------------------------------------------------------------ do l = 1 , np lb = ( l - 1 ) * nc + 1 ub = l * nc K ( l , :) = exp ( X ( lb : ub )) end do betas = X ( np * nc + 1 : np * nc + np ) P = exp ( X ( np * nc + np + 1 )) T = exp ( X ( np * nc + np + 2 )) denom = 0 denom = matmul ( betas , K ) + beta_w denomdlnK = 0 do i = 1 , nc denomdlnK (:, i , i ) = betas (:) * K (:, i ) end do w = z / denom ! ======================================================================== ! Calculation of fugacities coeficients and their derivatives ! ------------------------------------------------------------------------ call model % lnphi_pt (& w , P , T , V = Vw , root_type = \"stable\" , lnphi = lnphi_w , & dlnphidp = dlnphi_dp_w , dlnphidt = dlnphi_dt_w , dlnphidn = dlnphi_dn_w & ) do l = 1 , np x_l ( l , :) = K ( l , :) * w call model % lnphi_pt (& x_l ( l , :), P , T , V = Vl ( l ), root_type = \"stable\" , lnphi = lnphi , & dlnphidp = dlnphi_dp , dlnphidt = dlnphi_dt , dlnphidn = dlnphi_dn & ) lnphi_l ( l , :) = lnphi dlnphi_dn_l ( l , :, :) = dlnphi_dn dlnphi_dt_l ( l , :) = dlnphi_dt dlnphi_dp_l ( l , :) = dlnphi_dp end do ! ======================================================================== ! Calculation of the system of equations ! ------------------------------------------------------------------------ do l = 1 , np ! Select the limits of the function lb = ( l - 1 ) * nc + 1 ub = l * nc F ( lb : ub ) = X ( lb : ub ) + lnphi_l ( l , :) - lnphi_w F ( nc * np + l ) = sum ( x_l ( l , :) - w ) end do F ( nc * np + np + 1 ) = sum ( betas ) + beta_w - 1 F ( nc * np + np + 2 ) = X ( ns ) - S ! ======================================================================== ! Derivatives and Jacobian Matrix of the whole system ! ------------------------------------------------------------------------ df = 0 dwdlnK = 0 do l = 1 , np ! Save the derivatives of w wrt beta and K of the incipient phase dwdb ( l , :) = - z * K ( l , :) / denom ** 2 dwdlnK ( l , :) = - K ( l , :) * betas ( l ) * z / denom ** 2 end do do l = 1 , np do phase = 1 , np dx_l_dlnK ( phase , l , :) = dwdlnK ( l , :) * K ( phase , :) if ( phase == l ) then dx_l_dlnK ( phase , l , :) = dx_l_dlnK ( phase , l , :) + w * K ( l , :) end if end do end do do l = 1 , np ! Derivatives of the isofugacity equations ! wrt lnK do phase = 1 , np do i = 1 , nc do j = 1 , nc idx_1 = i + ( phase - 1 ) * nc idx_2 = j + ( l - 1 ) * nc df ( idx_1 , idx_2 ) = & dlnphi_dn_l ( phase , i , j ) * dx_l_dlnK ( phase , l , j ) & - dlnphi_dn_w ( i , j ) * dwdlnK ( l , j ) if ( i == j . and . phase == l ) then df ( idx_1 , idx_2 ) = df ( idx_1 , idx_2 ) + 1 end if end do end do end do ! wrt betas do j = 1 , np lb = ( j - 1 ) * nc + 1 ub = j * nc do i = 1 , nc df ( lb + i - 1 , np * nc + l ) = & sum ( K ( j , :) * dlnphi_dn_l ( j , i , :) * dwdb ( l , :) & - dlnphi_dn_w ( i , :) * dwdb ( l , :)) end do end do ! wrt T,p do i = 1 , nc lb = ( l - 1 ) * nc + i df ( lb , nc * np + np + 1 ) = P * ( dlnphi_dp_l ( l , i ) - dlnphi_dp_w ( i )) df ( lb , nc * np + np + 2 ) = T * ( dlnphi_dt_l ( l , i ) - dlnphi_dt_w ( i )) end do ! Derivatives of the sum of mole fractions ! wrt lnK do phase = 1 , np do j = 1 , nc lb = nc * np + phase ub = j + ( l - 1 ) * nc df ( lb , ub ) = df ( lb , ub ) + ( dx_l_dlnK ( phase , l , j ) - dwdlnK ( l , j )) end do end do ! wrt beta do j = 1 , np lb = nc * np + j df ( lb , np * nc + l ) = sum ( K ( j , :) * dwdb ( l , :) - dwdb ( l , :)) end do ! Derivatives of sum(beta)==1 df ( nc * np + np + 1 , np * nc + l ) = 1 end do df ( nc * np + np + 2 , ns ) = 1 end subroutine pt_F_NP subroutine solve_point ( model , z , np , beta_w , X , ns , S , dXdS , F , dF , iters , max_iterations ) use iso_fortran_env , only : error_unit use yaeos__math , only : solve_system class ( ArModel ), intent ( in ) :: model !! Model to use. real ( pr ), intent ( in ) :: z (:) !! Mixture global composition. integer , intent ( in ) :: np !! Number of main phases real ( pr ), intent ( in ) :: beta_w !! Fraction of the reference (incipient) phase real ( pr ), intent ( in out ) :: X (:) !! Vector of variables integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( in ) :: dXdS ( size ( X )) real ( pr ), intent ( out ) :: F ( size ( X )) !! Vector of functions valuated real ( pr ), intent ( out ) :: df ( size ( X ), size ( X )) !! Jacobian matrix integer , intent ( in ) :: max_iterations !! Maximum number of iterations to solve the point integer , intent ( out ) :: iters !! Number of iterations to solve the current point integer :: i integer :: iT integer :: iP integer :: iBetas ( np ) integer :: nc real ( pr ) :: X0 ( size ( X )) real ( pr ) :: dX ( size ( X )) logical :: can_solve nc = size ( z ) iP = np * nc + np + 1 iT = np * nc + np + 2 X0 = X can_solve = . true . iBetas = [( i , i = np * nc + 1 , np * nc + np )] do iters = 1 , max_iterations call pt_F_NP ( model , z , np , beta_w , x , ns , S , F , dF ) if ( any ( isnan ( F )) . and . can_solve ) then X = X - 0.9 * dX can_solve = . false . cycle end if dX = solve_system ( dF , - F ) do while ( abs ( dX ( iT )) > 0.1 ) dX = dX / 2 end do do while ( abs ( dX ( iP )) > 0.1 ) dX = dX / 2 end do if (. not . any ( X ( iBetas ) == 0 )) then do while ( maxval ( abs ( dX ( iBetas ) / X ( iBetas ))) > 0.5 ) dX = dX / 2 end do end if if ( maxval ( abs ( F )) < 1e-6_pr ) exit X = X + dX end do end subroutine solve_point subroutine update_specification ( its , nc , np , X , dF , dXdS , ns , dS ) !! # update_specification !! Change the specified variable for the next step. !! !! # Description !! Using the information of a converged point and the Jacobian matrix of !! the function. It is possible to determine the sensitivity of the !! variables with respect to the specification. This information is used !! to update the specification for the next point. Choosing the variable !! with the highest sensitivity. !! This can be done by solving the system of equations: !! !!  !! J \\frac{dX}{dS} + \\frac{dF}{dS} = 0 !!  !! !! for the  \\frac{dX}{dS}  vector. The variable with the highest value !! of  \\frac{dX}{dS}  is chosen as the new specification. !! !! # References !! integer , intent ( in ) :: its !! Iterations to solve the current point. integer , intent ( in ) :: nc !! Number of components in the mixture. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables. real ( pr ), intent ( in out ) :: dF (:, :) !! Jacobian matrix. real ( pr ), intent ( in out ) :: dXdS (:) !! Sensitivity of the variables wrt the specification. integer , intent ( in out ) :: ns !! Number of the specified variable. real ( pr ), intent ( in out ) :: dS !! Step size of the specification for the next point. real ( pr ) :: dFdS ( size ( X )) !! Sensitivity of the functions wrt the specification. integer :: i integer :: lb !! Lower bound of each phase integer :: ub !! Upper bound of each phase integer :: iT integer :: iP integer :: iBetas ( np ) real ( pr ) :: dT , dP iBetas = [( i , i = np * nc + 1 , np * nc + np )] iP = size ( X ) - 1 iT = size ( X ) dFdS = 0 dFdS ( size ( X )) = - 1 dXdS = solve_system ( dF , - dFdS ) ns = maxloc ( abs ( dXdS ), dim = 1 ) ! ======================================================================== ! For each phase, check if the mole fractions are too low. ! this can be related to criticality and it is useful to force the ! specification of compositions. ! ------------------------------------------------------------------------ do i = 1 , np lb = ( i - 1 ) * nc + 1 ub = i * nc if ( maxval ( abs ( X ( lb : ub ))) < 0.1 ) then ns = lb + maxloc ( abs ( X ( lb : ub )), dim = 1 ) - 1 dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) dS = sign ( min ( 0.01_pr , abs ( dS )), dS ) exit end if end do dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) do while ( maxval ( abs ( dXdS (: nc * np ) * dS )) > 0.1_pr ) dS = dS / 2 end do do while ( minval ( abs ( dXdS (: nc * np ) * dS )) < 1e-5_pr ) dS = dS * 1.1 end do do while ( abs ( dXdS ( iT ) * dS ) < 1e-2 . and . abs ( dXdS ( iP ) * dS ) < 1e-2 ) dS = dS * 1.1 end do !dT = abs(exp(X(iT))  - exp(X(it) + dXdS(iT)*dS)) !dP = abs(exp(X(iP))  - exp(X(it) + dXdS(iP)*dS)) !do while(& !   dT > 7._pr & !   .or. dP > 7._pr & !   .or. maxval(abs(dXdS(iBetas) * dS)/X(iBetas)) > 0.1_pr & !   ) !   dS = dS * 0.75 !   dT = abs(exp(X(iT))  - exp(X(it) + dXdS(iT)*dS)) !   dP = abs(exp(X(iP))  - exp(X(it) + dXdS(iP)*dS)) !end do end subroutine update_specification subroutine detect_critical ( nc , np , X , dXdS , ns , dS , S ) !! # detect_critical !! Detect if the system is close to a critical point. !! !! # Description !! When the system is close to a critical point, the \\ln K_i&#94;l values !! are close to zero, since the composition of the incipient phase and the !! l phase are similar (equal in the critical point). This can be used !! to detect if the system is close to a critical point and force a jump !! above it. !! !! # References !! integer , intent ( in ) :: nc !! Number of components in the mixture. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables. real ( pr ), intent ( in out ) :: dXdS (:) !! Sensitivity of the variables wrt the specification. integer , intent ( in out ) :: ns !! Number of the specified variable. real ( pr ), intent ( in out ) :: dS !! Step size of the specification for the next point. real ( pr ), intent ( in out ) :: S !! Specification value. integer :: i , lb , ub do i = 1 , np lb = ( i - 1 ) * nc + 1 ub = i * nc do while ( maxval ( abs ( X ( lb : ub ))) < 0.01 ) X = X + dXdS * dS end do end do end subroutine detect_critical subroutine get_values_from_X ( X , np , z , x_l , w , betas , P , T ) !! # get_values_from_X !! Extract the values of the variables from the vector X. !! real ( pr ), intent ( in ) :: X (:) !! Vector of variables. integer , intent ( in ) :: np !! Number of main phases. real ( pr ), intent ( in ) :: z (:) !! Mixture composition. real ( pr ), intent ( out ) :: x_l ( np , size ( z )) !! Mole fractions of the main phases. real ( pr ), intent ( out ) :: w ( size ( z )) !! Mole fractions of the incipient phase. real ( pr ), intent ( out ) :: betas ( np ) !! Fractions of the main phases. real ( pr ), intent ( out ) :: P !! Pressure [bar]. real ( pr ), intent ( out ) :: T !! Temperature [K]. integer :: nc !! Number of components. integer :: i !! Loop index. integer :: lb !! Lower bound of each phase. integer :: ub !! Upper bound of each phase. nc = size ( z ) betas = X ( np * nc + 1 : np * nc + np ) P = exp ( X ( np * nc + np + 1 )) T = exp ( X ( np * nc + np + 2 )) ! Extract the K values from the vector of variables do i = 1 , np lb = ( i - 1 ) * nc + 1 ub = i * nc x_l ( i , :) = exp ( X ( lb : ub )) end do ! Calculate the mole fractions of the incipient phase w = z / matmul ( betas , x_l ) ! Calculate the mole fractions of the main phases with the previously ! calculated K values do i = 1 , np x_l ( i , :) = x_l ( i , :) * w end do end subroutine get_values_from_X subroutine write_envelope_PT_MP ( env , unit ) class ( PTEnvelMP ), intent ( in ) :: env integer , intent ( in ) :: unit integer :: i , j integer :: np , nc real ( pr ) :: P , T real ( pr ), allocatable :: betas (:) real ( pr ), allocatable :: w (:) real ( pr ), allocatable :: x_l (:, :) np = size ( env % points ) nc = size ( env % points ( 1 )% w ) do i = 1 , np P = env % points ( i )% P T = env % points ( i )% T betas = env % points ( i )% betas w = env % points ( i )% w x_l = env % points ( i )% x_l write ( unit , \"(*(E15.5,2x))\" ) P , T , betas , w , ( x_l ( j , :), j = 1 , size ( x_l , dim = 1 )) end do end subroutine write_envelope_PT_MP end module yaeos__equilibria_boundaries_phase_envelopes_mp","tags":"","url":"sourcefile/phase_envelopes_pt_mp.f90.html"},{"title":"base.f90 – yaeos","text":"Source Code module yaeos__models_base !! Basic element of a thermodynamic model. use yaeos__substance , only : Substances implicit none type , abstract :: BaseModel !! Base model type. !! !! Contains the important parts of most models and other procedures. type ( Substances ) :: components !! Substances contained in the module end type end module","tags":"","url":"sourcefile/base.f90~2.html"},{"title":"tapenade_ar_api.f90 – yaeos","text":"Source Code module yaeos__tapenade_ar_api !! Module that wraps tapenade generated routines to calculate ! !! Ar and derivatives. use yaeos__constants , only : pr use yaeos__models_ar , only : ArModel implicit none private public :: ArModelTapenade type , abstract , extends ( ArModel ) :: ArModelTapenade contains procedure ( tapenade_ar ), deferred :: ar procedure ( tapenade_ar_d ), deferred :: ar_d procedure ( tapenade_ar_b ), deferred :: ar_b procedure ( tapenade_ar_d_b ), deferred :: ar_d_b procedure ( tapenade_ar_d_d ), deferred :: ar_d_d procedure :: residual_helmholtz => residual_helmholtz end type abstract interface subroutine tapenade_ar ( model , n , v , t , arval ) import pr , ArModelTapenade class ( ArModelTapenade ), intent ( in ) :: model real ( pr ), intent ( in ) :: n (:), v , t real ( pr ), intent ( out ) :: arval end subroutine subroutine tapenade_ar_d ( model , n , nd , v , vd , t , td , arval , arvald ) import pr , ArModelTapenade class ( ArModelTapenade ), intent ( in ) :: model real ( pr ), intent ( in ) :: n (:), v , t real ( pr ), intent ( in ) :: nd (:), vd , td real ( pr ), intent ( out ) :: arval , arvald end subroutine subroutine tapenade_ar_b ( model , n , nb , v , vb , t , tb , arval , arvalb ) import pr , ArModelTapenade class ( ArModelTapenade ), intent ( in ) :: model real ( pr ), intent ( in ) :: n (:), v , t real ( pr ) :: arvalb real ( pr ) :: nb (:), vb , tb real ( pr ) :: arval end subroutine subroutine tapenade_ar_d_b ( model , & n , nb , nd , ndb , v , vb , vd , vdb , t , tb , td , tdb , & arval , arvalb , arvald , arvaldb ) import pr , ArModelTapenade class ( ArModelTapenade ), intent ( in ) :: model real ( pr ), intent ( in ) :: n (:), v , t real ( pr ) :: arval real ( pr ), intent ( in ) :: nd (:), vd , td real ( pr ) :: arvald real ( pr ) :: nb (:), vb , tb real ( pr ) :: arvalb real ( pr ) :: ndb (:), vdb , tdb real ( pr ) :: arvaldb end subroutine subroutine tapenade_ar_d_d ( model , n , nd , v , vd0 , vd , t , td0 , td , & arval , arvald0 , arvald , arvaldd ) import pr , ArModelTapenade class ( ArModelTapenade ), intent ( in ) :: model real ( pr ), intent ( in ) :: n (:), v , t real ( pr ), intent ( in ) :: vd0 , td0 real ( pr ), intent ( in ) :: nd (:), vd , td real ( pr ), intent ( out ) :: arval , arvald0 , arvald , arvaldd end subroutine end interface contains subroutine residual_helmholtz (& self , n , v , t , Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) !! Residual Helmholtz model generic interface class ( ArModelTapenade ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: v , t real ( pr ), optional , intent ( out ) :: Ar , ArV , ArT , ArT2 , ArTV , ArV2 real ( pr ), optional , dimension ( size ( n )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) real ( pr ) :: df ( size ( n ) + 2 ), df2 ( size ( n ) + 2 , size ( n ) + 2 ) real ( pr ) :: nb ( size ( n )), nd ( size ( n )), ndb ( size ( n )) real ( pr ) :: vb , vd , vdb , vd0 real ( pr ) :: tb , td , tdb , td0 real ( pr ) :: arval , arvalb , arvald , arvaldb , arvald0 , arvaldd integer :: i , nc nc = size ( n ) if ( present ( Arn2 )) then do i = 1 , nc call reset_vars arvaldb = 1 if ( i <= nc ) then nd ( i ) = 1 end if call self % ar_d_b (& n , nb , nd , ndb , & v , vb , vd , vdb , & t , tb , td , tdb , & arval , arvalb , arvald , arvaldb & ) Arn2 ( i , :) = nb end do if ( present ( Arn )) Arn = ndb if ( present ( ArV )) ArV = vdb if ( present ( ArT )) ArT = tdb else if ( present ( Arn )) then call reset_vars arvalb = 1 call self % ar_b ( n , nb , v , vb , t , tb , arval , arvalb ) Arn = nb if ( present ( ArT )) ArT = tb if ( present ( ArV )) ArV = vb end if end if if ( present ( ArTn )) ArTn = get_ArnX ( \"T\" ) if ( present ( ArVn )) ArVn = get_ArnX ( \"V\" ) if ( present ( ArTV )) ArTV = get_dArdX2 ( \"TV\" ) if ( present ( ArT2 )) ArT2 = get_dArdX2 ( \"T2\" ) if ( present ( ArV2 )) ArV2 = get_dArdX2 ( \"V2\" ) if ( present ( Ar )) Ar = arval contains subroutine reset_vars nb = 0 nd = 0 ndb = 0 vb = 0 vd = 0 vd0 = 0 vdb = 0 tb = 0 td = 0 td0 = 0 tdb = 0 arval = 0 arvalb = 0 arvald = 0 arvald0 = 0 arvaldb = 0 end subroutine function get_dArdX2 ( var ) character ( len =* ), intent ( in ) :: var real ( pr ) :: get_dArdX2 call reset_vars select case ( var ) case ( \"TV\" ) vd = 1 td0 = 1 case ( \"V2\" ) vd = 1 vd0 = 1 case ( \"T2\" ) td = 1 td0 = 1 end select call self % ar_d_d (& n , nd , v , vd0 , vd , t , td0 , td , & arval , arvald0 , arvald , arvaldd & ) get_dArdX2 = arvaldd end function function get_ArnX ( var ) character ( len =* ), intent ( in ) :: var real ( pr ) :: get_ArnX ( size ( n )) call reset_vars arvaldb = 1 select case ( var ) case ( \"V\" ) vd = 1 case ( \"T\" ) td = 1 end select call self % ar_d_b (& n , nb , nd , ndb , & v , vb , vd , vdb , & t , tb , td , tdb , & arval , arvalb , arvald , arvaldb & ) get_ArnX = nb end function end subroutine end module","tags":"","url":"sourcefile/tapenade_ar_api.f90.html"},{"title":"models.f90 – yaeos","text":"Source Code module yaeos__models !! `yaeos` thermodynamic models !! !! On `yaeos` there are implemented a series of both residual Helmholtz !! energy (A_r) and excess Gibbs energy (G&#94;E) models. !! !! This module takes all the relevant procedures and derived types !! related to them. !! !! - Residual Helmholtz model base type `ArModel` base derived type !!   that provides the basic structure that a residual Helmholtz model !!   should provide. !! - **Cubic Equations of state**: !!    - `AlphaFunction` type !!    - `CubicEos` type that extends `ArModel` to use a generic !!      two-parameter EoS. Implemented models that use this type can be !!      seen at [[yaeos__models_ar_cubic_implementations(module)]] !!    - `QMR` (Quadratic Mixing Rule) type: extensible derived type that !!       defaults to classic vdW mixing rules. !!    - `MHV` (Modified Huron-Vidal) type: Michelsens first order modified !!       Huron-Vidal mixing rule. !! - **GERG2008 Equation of State**: !!    - GERG2008 multifluid equation of state ! Base model structure use yaeos__models_base , only : BaseModel ! Residual Helmholtz Models use yaeos__models_ar , only : ArModel , size ! GERG2008 use yaeos__models_ar_gerg2008 , only : & Gerg2008 , Gerg2008Binary , G2008Components , gerg_2008 ! Cubic EoS models use yaeos__models_ar_genericcubic , only : & CubicEoS , GenericCubic_Ar , AlphaFunction , CubicMixRule ! Alpha functions use yaeos__models_ar_cubic_alphas ! Mixing Rules use yaeos__models_ar_cubic_quadratic_mixing use yaeos__models_cubic_mixing_rules_huron_vidal ! Implemented models use yaeos__models_ar_cubic_implementations ! Ge Models use yaeos__models_ge , only : GeModel ! Implemented models use yaeos__models_ge_implementations end module yaeos__models","tags":"","url":"sourcefile/models.f90.html"},{"title":"tapenade_ge_api.f90 – yaeos","text":"Source Code module yaeos__tapenade_ge_api !! Module that wraps tapenade generated routines to calculate ! !! Ge and derivatives. use yaeos__constants , only : pr , R use yaeos__models_ge , only : GeModel implicit none private public :: GeModelTapenade type , abstract , extends ( GeModel ) :: GeModelTapenade contains procedure ( tapenade_ge ), deferred :: ge procedure ( tapenade_ge_d ), deferred :: ge_d procedure ( tapenade_ge_b ), deferred :: ge_b procedure ( tapenade_ge_d_b ), deferred :: ge_d_b procedure ( tapenade_ge_d_d ), deferred :: ge_d_d procedure :: excess_gibbs => excess_gibbs end type abstract interface subroutine tapenade_ge ( model , n , t , ge ) import GeModelTapenade , pr class ( GeModelTapenade ) :: model real ( pr ), intent ( in ) :: n (:), t real ( pr ), intent ( out ) :: ge end subroutine subroutine tapenade_ge_d ( model , n , nd , t , td , ge , ged ) import pr , GeModelTapenade class ( GeModelTapenade ) :: model real ( pr ), intent ( in ) :: n (:), t real ( pr ), intent ( in ) :: nd (:), td real ( pr ), intent ( out ) :: ge , ged end subroutine subroutine tapenade_ge_b ( model , n , nb , t , tb , ge , geb ) import pr , GeModelTapenade class ( GeModelTapenade ) :: model real ( pr ), intent ( in ) :: n (:), t real ( pr ) :: geb real ( pr ) :: nb (:), tb real ( pr ) :: ge end subroutine subroutine tapenade_ge_d_b ( model , & n , nb , nd , ndb , t , tb , td , tdb , & ge , geb , ged , gedb ) import pr , GeModelTapenade class ( GeModelTapenade ) :: model real ( pr ), intent ( in ) :: n (:), t real ( pr ) :: ge real ( pr ), intent ( in ) :: nd (:), td real ( pr ) :: ged real ( pr ) :: nb (:), tb real ( pr ) :: geb real ( pr ) :: ndb (:), tdb real ( pr ) :: gedb end subroutine subroutine tapenade_ge_d_d ( model , n , nd , t , td0 , td , ge , ged0 , ged , gedd ) import pr , GeModelTapenade class ( GeModelTapenade ) :: model real ( pr ), intent ( in ) :: n (:), t real ( pr ), intent ( in ) :: td0 real ( pr ), intent ( in ) :: nd (:), td real ( pr ), intent ( out ) :: ge , ged0 , ged , gedd end subroutine end interface contains subroutine excess_gibbs (& self , n , t , Ge , GeT , GeT2 , Gen , GeTn , Gen2 & ) !! Excess Gibbs model generic interface class ( GeModelTapenade ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: t real ( pr ), optional , intent ( out ) :: Ge , GeT , GeT2 real ( pr ), optional , dimension ( size ( n )), intent ( out ) :: Gen , GeTn real ( pr ), optional , intent ( out ) :: Gen2 ( size ( n ), size ( n )) real ( pr ) :: nb ( size ( n )), nd ( size ( n )), ndb ( size ( n )) real ( pr ) :: tb , td , tdb , td0 real ( pr ) :: geb , ged , gedb , ged0 , gedd integer :: i , nc nc = size ( n ) if ( present ( Gen2 )) then do i = 1 , nc call reset_vars gedb = 1 if ( i <= nc ) then nd ( i ) = 1 end if call self % ge_d_b (& n , nb , nd , ndb , & t , tb , td , tdb , & ge , geb , ged , gedb & ) Gen2 ( i , :) = nb end do if ( present ( Gen )) Gen = ndb if ( present ( GeT )) GeT = tdb else if ( present ( Gen )) then call reset_vars geb = 1 call self % ge_b ( n , nb , t , tb , ge , geb ) Gen = nb if ( present ( GeT )) GeT = tb else if ( present ( GeT )) GeT = get_dGedT () end if if ( present ( GeTn )) GeTn = get_GenT () if ( present ( GeT2 )) GeT2 = get_dGedT2 () call reset_vars if ( present ( Ge )) call self % ge ( n , t , ge ) contains subroutine reset_vars nb = 0 nd = 0 ndb = 0 tb = 0 td = 0 td0 = 0 tdb = 0 ge = 0 geb = 0 ged = 0 ged0 = 0 gedb = 0 end subroutine function get_dGedT2 () real ( pr ) :: get_dGedT2 call reset_vars td = 1 td0 = 1 call self % ge_d_d (& n , nd , t , td0 , td , & ge , ged0 , ged , gedd & ) get_dGedT2 = gedd end function function get_dGedT () real ( pr ) :: get_dGedT call reset_vars td = 1 call self % ge_d (& n , nd , t , td , ge , ged & ) get_dGedT = ged end function function get_GenT () real ( pr ) :: get_GenT ( size ( n )) call reset_vars gedb = 1 td = 1 call self % ge_d_b (& n , nb , nd , ndb , & t , tb , td , tdb , & ge , geb , ged , gedb & ) get_GenT = nb end function end subroutine end module","tags":"","url":"sourcefile/tapenade_ge_api.f90.html"},{"title":"unifac.f90 – yaeos","text":"Source Code module yaeos__models_ge_group_contribution_unifac !! # UNIFAC module !! Classic liquid-vapor UNIFAC model implementation module. !! !! # Description !! Classic liquid-vapor UNIFAC model implementation module. The !! implementation is based on the Thermopack library (SINTEF) implementation. !! !! # Examples !! !! ```fortran !!  ! Instantiate an UNIFAC model with ethanol-water mix and calculate gammas !!  use yaeos, only: pr, Groups, setup_unifac, UNIFAC !! !!  type(UNIFAC) :: model !!  type(Groups) :: molecules(2) !!  real(pr) :: ln_gammas(2) !! !!  ! Ethanol definition [CH3, CH2, OH] !!  molecules(1)%groups_ids = [1, 2, 14] ! Subgroups ids !!  molecules(1)%number_of_groups = [1, 1, 1] ! Subgroups occurrences !! !!  ! Water definition [H2O] !!  molecules(2)%groups_ids = [16] !!  molecules(2)%number_of_groups = [1] !! !!  ! Model setup !!  model = setup_unifac(molecules) !! !!  ! Calculate ln_gammas !!  call model%ln_activity_coefficient([0.5_pr, 0.5_pr], 298.0_pr, ln_gammas) !! !!  print *, ln_gammas ! result: 0.18534142000449058    0.40331395945417559 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.ddbst !! .com/published-parameters-unifac.html) !! 2. Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975). !! Group‐contribution estimation of activity coefficients in nonideal liquid !! mixtures. AIChE Journal, 21(6), 1086–1099. !! [https://doi.org/10.1002/aic.690210607](https://doi.org/10.1002/aic.690210607) !! 3. Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979). !! Vapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and !! Extension. Industrial & Engineering Chemistry Process Design and !! Development, 18(4), 714–722. !! [https://doi.org/10.1021/i260072a024](https://doi.org/10.1021/i260072a024) !! 4. Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid !! equilibriums by UNIFAC group contribution. Revision and extension. 2. !! Industrial & Engineering Chemistry Process Design and Development, 21(1), !! 118–127. !! [https://doi.org/10.1021/i200016a021](https://doi.org/10.1021/i200016a021) !! 5. Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983). !! Vapor-liquid equilibriums by UNIFAC group contribution. Revision and !! extension. 3. Industrial & Engineering Chemistry Process Design and !! Development, 22(4), 676–678. !! [https://doi.org/10.1021/i200023a023](https://doi.org/10.1021/i200023a023) !! 6. Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987). !! Vapor-liquid equilibria by UNIFAC group contribution. 4. Revision and !! extension. Industrial & Engineering Chemistry Research, 26(1), 159–161. !! [https://doi.org/10.1021/ie00061a030](https://doi.org/10.1021/ie00061a030) !! 7. Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., & !! Gmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group !! contribution. 5. Revision and extension. Industrial & Engineering !! Chemistry Research, 30 (10), 2352–2355. !! [https://doi.org/10.1021/ie00058a017](https://doi.org/10.1021/ie00058a017) !! 8. Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria !! by UNIFAC Group Contribution. 6. Revision and Extension. Industrial & !! Engineering Chemistry Research, 42(1), 183–188. !! [https://doi.org/10.1021/ie020506l](https://doi.org/10.1021/ie020506l) !! 9. [SINTEF - Thermopack](https://github.com/thermotools/thermopack) !! use yaeos__constants , only : pr , R use yaeos__models_ge , only : GeModel use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters use yaeos__models_ge_gc_td , only : PsiFunction , UNIFACPsi use yaeos__models_ge_group_contribution_groups , only : Groups implicit none type , extends ( GeModel ) :: UNIFAC !! # UNIFAC model !! Classic liquid-vapor UNIFAC model derived type !! !! # Description !! This type holds the needed parameters for using a UNIFAC G&#94;E model !! mainly group areas, volumes and what temperature dependence function !! \\psi(T) to use. !! !! It also holds the individual molecules of a particular system and !! the set of all groups in the system as a \"stew\" of groups instead of !! being them included in particular molecules. !! !! # Examples !! !! ```fortran !!  ! UNIFAC model with ethanol-formic acid mix and calculate gammas !!  use yaeos, only: pr, Groups, setup_unifac, UNIFAC !! !!  type(UNIFAC) :: model !!  type(Groups) :: molecules(2) !!  real(pr) :: ln_gammas(2) !! !!  ! Ethanol definition [CH3, CH2, OH] !!  molecules(1)%groups_ids = [1, 2, 14] ! Subgroups ids !!  molecules(1)%number_of_groups = [1, 1, 1] ! Subgroups occurrences !! !!  ! formic acid definition [HCOOH] !!  molecules(2)%groups_ids = [43] !!  molecules(2)%number_of_groups = [1] !! !!  ! Model setup !!  model = setup_unifac(molecules) !! !!  ! Calculate ln_gammas !!  call model%ln_activity_coefficient([0.5_pr, 0.5_pr], 298.0_pr, ln_gammas) !! !!  print *, ln_gammas ! result: 0.10505475697637946   0.28073129552766890 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.ddbst !! .com/published-parameters-unifac.html) !! 2. Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975). !! Group‐contribution estimation of activity coefficients in nonideal liquid !! mixtures. AIChE Journal, 21(6), 1086–1099. !! [https://doi.org/10.1002/aic.690210607](https://doi.org/10.1002/aic.690210607) !! 3. Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979). !! Vapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and !! Extension. Industrial & Engineering Chemistry Process Design and !! Development, 18(4), 714–722. !! [https://doi.org/10.1021/i260072a024](https://doi.org/10.1021/i260072a024) !! 4. Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid !! equilibriums by UNIFAC group contribution. Revision and extension. 2. !! Industrial & Engineering Chemistry Process Design and Development, 21(1), !! 118–127. !! [https://doi.org/10.1021/i200016a021](https://doi.org/10.1021/i200016a021) !! 5. Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983). !! Vapor-liquid equilibriums by UNIFAC group contribution. Revision and !! extension. 3. Industrial & Engineering Chemistry Process Design and !! Development, 22(4), 676–678. !! [https://doi.org/10.1021/i200023a023](https://doi.org/10.1021/i200023a023) !! 6. Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987). !! Vapor-liquid equilibria by UNIFAC group contribution. 4. Revision and !! extension. Industrial & Engineering Chemistry Research, 26(1), 159–161. !! [https://doi.org/10.1021/ie00061a030](https://doi.org/10.1021/ie00061a030) !! 7. Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., & !! Gmehling, J. (1991). Vapor-liquid equilibria by UNIFAC group !! contribution. 5. Revision and extension. Industrial & Engineering !! Chemistry Research, 30 (10), 2352–2355. !! [https://doi.org/10.1021/ie00058a017](https://doi.org/10.1021/ie00058a017) !! 8. Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria !! by UNIFAC Group Contribution. 6. Revision and Extension. Industrial & !! Engineering Chemistry Research, 42(1), 183–188. !! [https://doi.org/10.1021/ie020506l](https://doi.org/10.1021/ie020506l) !! 9. [SINTEF - Thermopack](https://github.com/thermotools/thermopack) !! integer :: ngroups !! Total number of individual groups in the mixture integer :: nmolecules !! Total number of molecules in the mixture real ( pr ) :: z = 1 0.0_pr !! Model constant z real ( pr ) :: d = 1.0_pr !! Model constant d, exponent of the group volume in Flory-Huggins real ( pr ), allocatable :: group_area (:) !! Group areas Q_k real ( pr ), allocatable :: group_volume (:) !! Group volumes R_k real ( pr ), allocatable :: thetas_ij (:, :) !! Area fractions of the groups j on molecules i real ( pr ), allocatable :: vij (:,:) !! Ocurrences of each group j on each molecule i real ( pr ), allocatable :: qk (:) !! Area of each group k class ( PsiFunction ), allocatable :: psi_function !! Temperature dependance function of the model type ( Groups ), allocatable :: molecules (:) !! Substances present in the system type ( Groups ) :: groups_stew !! All the groups present in the system contains procedure :: excess_gibbs procedure :: Ge_combinatorial procedure :: Ge_residual end type UNIFAC contains subroutine excess_gibbs ( self , n , T , Ge , GeT , GeT2 , Gen , GeTn , Gen2 ) !! # Excess Gibbs energy !! Calculate the Gibbs excess energy of the UNIFAC model !! !! # Description !! Calculate the Gibbs excess energy of the UNIFAC model and its !! derivatives. !! !! # Examples !! !! ```fortran !!  ! Gibbs excess of ethane-ethanol-methyl amine mixture. !!  use yaeos, only: R, pr, Groups, setup_unifac, UNIFAC !! !!  type(UNIFAC) :: model !! !!  integer, parameter :: nc = 3, ng = 4 !! !!  type(Groups) :: molecules(nc) !! !!  real(pr) :: Ge, Gen(nc), GeT, GeT2, GeTn(nc), Gen2(nc, nc) !! !!  real(pr) :: n(nc), ln_gammas(nc), T !! !!  T = 150.0_pr !!  n = [2.0_pr, 7.0_pr, 1.0_pr] !! !!  ! Ethane [CH3] !!  molecules(1)%groups_ids = [1] !!  molecules(1)%number_of_groups = [2] !! !!  ! Ethanol [CH3, CH2, OH] !!  molecules(2)%groups_ids = [1, 2, 14] !!  molecules(2)%number_of_groups = [1, 1, 1] !! !!  ! Methylamine [H3C-NH2] !!  molecules(3)%groups_ids = [28] !!  molecules(3)%number_of_groups = [1] !! !!  ! setup UNIFAC model !!  model = setup_unifac(molecules) !! !!  ! Call all Ge and derivatives !!  call model%excess_gibbs(model, n, T, Ge, GeT, GeT2, Gen, GeTn, Gen2) !! !!  print *, \"Ge: \", Ge !!  print *, \"GeT: \", GeT !!  print *, \"GeT2: \", GeT2 !!  print *, \"Gen: \", Gen !!  print *, \"GeTn: \", GeTn !!  print *, \"Gen2:\" !!  print *, Gen2(1,:) !!  print *, Gen2(2,:) !!  print *, Gen2(3,:) !! !!  ! If you want the ln_gammas from \"Gen\" derivative: !!  print *, \"ln_gammas: \", Gen / R / T !! !!  ! Or !!  call model%ln_activity_coefficient(n, T, ln_gammas) !!  print *, \"ln_gammas: \", ln_gammas !! ``` !! class ( UNIFAC ), intent ( in ) :: self !! UNIFAC model real ( pr ), intent ( in ) :: n (:) !! Moles vector [mol] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: Ge !! Excess Gibbs energy real ( pr ), optional , intent ( out ) :: GeT !! \\frac{dG&#94;E}{dT} real ( pr ), optional , intent ( out ) :: GeT2 !! \\frac{d&#94;2G&#94;E}{dT&#94;2} real ( pr ), optional , intent ( out ) :: Gen ( size ( n )) !! \\frac{dG&#94;E}{dn} real ( pr ), optional , intent ( out ) :: GeTn ( size ( n )) !! \\frac{d&#94;2G&#94;E}{dTdn} real ( pr ), optional , intent ( out ) :: Gen2 ( size ( n ), size ( n )) !! \\frac{d&#94;2G&#94;E}{dn&#94;2} ! Combinatorial real ( pr ) :: Ge_c real ( pr ) :: dGe_c_dn ( self % nmolecules ) real ( pr ) :: dGe_c_dn2 ( self % nmolecules , self % nmolecules ) ! logical logical :: pge , dn , dn2 ! Residual calling call self % Ge_residual ( n , T , Ge , Gen , Gen2 , GeT , GeT2 , GeTn ) ! Individual combinatorial calling pge = present ( Ge ) dn = present ( Gen ) dn2 = present ( Gen2 ) if ( dn . and . . not . dn2 ) then call self % Ge_combinatorial ( n , T , Ge = Ge_c , dGe_dn = dGe_c_dn ) elseif ( dn2 . and . . not . dn ) then call self % Ge_combinatorial ( n , T , Ge = Ge_c , dGe_dn2 = dGe_c_dn2 ) else call self % Ge_combinatorial (& n , T , Ge = Ge_c , dGe_dn = dGe_c_dn , dGe_dn2 = dGe_c_dn2 & ) end if if ( present ( Ge )) Ge = Ge_c + Ge if ( present ( Gen )) Gen = dGe_c_dn + Gen if ( present ( Gen2 )) Gen2 = dGe_c_dn2 + Gen2 if ( present ( GeT )) GeT = Ge_c / T + GeT if ( present ( GeT2 )) GeT2 = GeT2 if ( present ( GeTn )) GeTn = dGe_c_dn / T + GeTn end subroutine excess_gibbs subroutine Ge_combinatorial ( self , n , T , Ge , dGe_dn , dGe_dn2 ) !! # UNIFAC combinatorial term !! Calculate the UNIFAC combinatorial term of Gibbs excess energy !! !! # Description !! Calculate the UNIFAC combinatorial term of reduced Gibbs excess !! energy. The subroutine uses the Flory-Huggins and !! Staverman-Guggenheim. !! !! # References !! 1. [SINTEF - Thermopack](https://github.com/thermotools/thermopack) class ( UNIFAC ) :: self real ( pr ), intent ( in ) :: n ( self % nmolecules ) !! Moles vector [mol] real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: Ge !! Combinatorial Gibbs excess energy real ( pr ), optional , intent ( out ) :: dGe_dn ( self % nmolecules ) !! \\frac{dGe}{dn} real ( pr ), optional , intent ( out ) :: dGe_dn2 ( self % nmolecules , self % nmolecules ) !! \\frac{d&#94;2Ge}{dn&#94;2} ! Flory-Huggins variables real ( pr ) :: Ge_fh real ( pr ) :: dGe_fh_dn ( self % nmolecules ) real ( pr ) :: dGe_fh_dn2 ( self % nmolecules , self % nmolecules ) ! Staverman-Guggenheim variables real ( pr ) :: Ge_sg real ( pr ) :: dGe_sg_dn ( self % nmolecules ) real ( pr ) :: dGe_sg_dn2 ( self % nmolecules , self % nmolecules ) ! utility real ( pr ) :: nq , nr , nrp , n_t integer :: i , j associate (& q => self % molecules % surface_area ,& r => self % molecules % volume ,& z => self % z , & d => self % d & ) nr = dot_product ( n , r ) nrp = dot_product ( n , r ** d ) nq = dot_product ( n , q ) n_t = sum ( n ) if ( present ( Ge )) then Ge_fh = sum ( n * log ( r ** d )) - n_t * log ( nrp ) + n_t * log ( n_t ) Ge_sg = z / 2 * sum ( n * q * ( log ( q / r ) - log ( nq ) + log ( nr ))) end if if ( present ( dGe_dn )) then dGe_fh_dn = log ( r ** d ) - log ( nrp ) + log ( n_t ) + 1.0_pr - n_t * r ** d / nrp dGe_sg_dn = z / 2 * q * ( - log (( r * nq ) / ( q * nr )) - 1.0_pr + ( r * nq ) / ( q * nr )) end if if ( present ( dGe_dn2 )) then dGe_fh_dn2 = 0.0_pr dGe_sg_dn2 = 0.0_pr do concurrent ( i = 1 : size ( n ), j = 1 : size ( n )) dGe_fh_dn2 ( i , j ) = - ( r ( i ) ** d + r ( j ) ** d ) / nrp + 1.0_pr / n_t + n_t * r ( i ) ** d * r ( j ) ** d / nrp ** 2 dGe_sg_dn2 ( i , j ) = z / 2.0_pr * ( - q ( i ) * q ( j ) / nq + ( q ( i ) * r ( j ) + q ( j ) * r ( i )) / nr - r ( i ) * r ( j ) * nq / nr ** 2 ) end do end if end associate if ( present ( Ge )) Ge = ( Ge_fh + Ge_sg ) * R * T if ( present ( dGe_dn )) dGe_dn = ( dGe_fh_dn + dGe_sg_dn ) * R * T if ( present ( dGe_dn2 )) dGe_dn2 = ( dGe_fh_dn2 + dGe_sg_dn2 ) * R * T end subroutine Ge_combinatorial subroutine Ge_residual ( self , n , T , Ge , dGe_dn , dGe_dn2 , dGe_dT , dGe_dT2 , dGe_dTn ) !! # UNIFAC residual term !! Evaluate the UNIFAC residual term !! !! # References !! 1. [SINTEF - Thermopack](https://github.com/thermotools/thermopack) class ( UNIFAC ) :: self real ( pr ), intent ( in ) :: n ( self % nmolecules ) !! Moles vector real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), optional , intent ( out ) :: Ge !! Residual Gibbs excess energy real ( pr ), optional , intent ( out ) :: dGe_dn ( self % nmolecules ) !! \\frac{\\partial G&#94;{E,R}}{\\partial n}  real ( pr ), optional , intent ( out ) :: dGe_dn2 ( self % nmolecules , self % nmolecules ) !! \\frac{\\partial&#94;2 G&#94;{E,R}}{\\partial n&#94;2}  real ( pr ), optional , intent ( out ) :: dGe_dT !! \\frac{\\partial G&#94;{E,R}}{\\partial T}  real ( pr ), optional , intent ( out ) :: dGe_dT2 !! \\frac{\\partial&#94;2 G&#94;{E,R}}{\\partial T&#94;2}  real ( pr ), optional , intent ( out ) :: dGe_dTn ( self % nmolecules ) !! \\frac{\\partial&#94;2 G&#94;{E,R}}{\\partial n \\partial T}  ! Thetas variables real ( pr ) :: theta_j ( self % ngroups ) ! Ejk variables real ( pr ) :: Ejk ( self % ngroups , self % ngroups ) real ( pr ) :: dEjk_dt ( self % ngroups , self % ngroups ) real ( pr ) :: dEjk_dt2 ( self % ngroups , self % ngroups ) ! Lambdas variables real ( pr ) :: lambda_k ( self % ngroups ) real ( pr ) :: dlambda_k_dT ( self % ngroups ) real ( pr ) :: dlambda_k_dT2 ( self % ngroups ) real ( pr ) :: dlambda_k_dn ( self % nmolecules , self % ngroups ) real ( pr ) :: dlambda_k_dn2 ( self % nmolecules , self % nmolecules , self % ngroups ) real ( pr ) :: dlambda_k_dndT ( self % nmolecules , self % ngroups ) real ( pr ) :: lambda_ik ( self % nmolecules , self % ngroups ) real ( pr ) :: dlambda_ik_dT ( self % nmolecules , self % ngroups ) real ( pr ) :: dlambda_ik_dT2 ( self % nmolecules , self % ngroups ) ! Auxiliars real ( pr ) :: Ge_aux , dGe_dT_aux , dGe_dn_aux ( self % nmolecules ) real ( pr ) :: sum_vij_Qj_Ejk ( self % nmolecules , self % ngroups ) real ( pr ) :: sum_ni_vij_Qj_Ejk ( self % ngroups ) real ( pr ) :: sum_vik_Qk ( self % nmolecules ) real ( pr ) :: sum_vQ_Lambda ( self % nmolecules ) real ( pr ) :: sum_nl_vlj ( self % ngroups ) real ( pr ) :: sum_ni_vik_Qk real ( pr ) :: aux_sum ( self % nmolecules ) real ( pr ) :: sum_Q_v_dlambda_k_dn ( self % nmolecules , self % nmolecules ) real ( pr ) :: aux_sum2 real ( pr ) :: sum_vij_Qj_dEjk_dT ( self % nmolecules , self % ngroups ) real ( pr ) :: sum_vij_Qj_dEjk_dT2 ( self % nmolecules , self % ngroups ) real ( pr ) :: sum_ni_vij_Qj_dEjk_dT ( self % ngroups ) real ( pr ) :: sum_vij_Qj_dlambdas_dT ( self % nmolecules ) real ( pr ) :: sum_vij_Qj_dlambdas_dT2 ( self % nmolecules ) ! Indexes used for groups integer :: j , k ! Indexes used for components integer :: i , l ! logicals logical :: pge , dn , dn2 , dt , dt2 , dtn pge = present ( Ge ) dn = present ( dGe_dn ) dn2 = present ( dGe_dn2 ) dt = present ( dGe_dT ) dt2 = present ( dGe_dT2 ) dtn = present ( dGe_dTn ) ! ======================================================================== ! Ejk ! ------------------------------------------------------------------------ if (( dt . or . dtn ) . and . . not . dt2 ) then call self % psi_function % psi (& self % groups_stew , T , psi = Ejk , dpsi_dt = dEjk_dt & ) elseif ( dt2 . and . . not . ( dt . or . dtn )) then call self % psi_function % psi (& self % groups_stew , T , psi = Ejk , dpsi_dt2 = dEjk_dt2 & ) else call self % psi_function % psi (& self % groups_stew , T , psi = Ejk , dpsi_dt = dEjk_dt , dpsi_dt2 = dEjk_dt2 & ) end if ! ======================================================================== ! Auxiliars ! ------------------------------------------------------------------------ do i = 1 , self % nmolecules sum_vik_Qk ( i ) = sum ( self % vij ( i ,:) * self % qk ) end do sum_ni_vik_Qk = sum ( n * sum_vik_Qk ) if ( dtn . or . dt2 . or . dt ) then do concurrent ( i = 1 : self % nmolecules , k = 1 : self % ngroups ) sum_vij_Qj_dEjk_dT ( i , k ) = sum ( self % vij ( i ,:) * self % qk * dEjk_dT (:, k )) sum_vij_Qj_dEjk_dT2 ( i , k ) = sum ( self % vij ( i ,:) * self % qk * dEjk_dT2 (:, k )) end do end if ! ======================================================================== ! Thetas ! ------------------------------------------------------------------------ do j = 1 , self % ngroups sum_nl_vlj ( j ) = sum ( n * self % vij (:, j )) theta_j ( j ) = sum_nl_vlj ( j ) * self % qk ( j ) / sum_ni_vik_Qk end do ! ======================================================================== ! Lambda_k ! ------------------------------------------------------------------------ ! Lambda_k if ( pge . or . dn . or . dt . or . dtn ) then do k = 1 , self % ngroups lambda_k ( k ) = log ( sum ( theta_j * Ejk (:, k ))) end do end if ! Lambda_k first compositional derivatives if ( dn . or . dt . or . dt2 . or . dtn . or . dn2 ) then do concurrent ( i = 1 : self % nmolecules , k = 1 : self % ngroups ) sum_vij_Qj_Ejk ( i , k ) = sum ( self % vij ( i ,:) * self % qk * Ejk (:, k )) end do do k = 1 , self % ngroups sum_ni_vij_Qj_Ejk ( k ) = sum ( n * sum_vij_Qj_Ejk (:, k )) end do do i = 1 , self % nmolecules dlambda_k_dn ( i ,:) = sum_vij_Qj_Ejk ( i ,:) / sum_ni_vij_Qj_Ejk - sum_vik_Qk ( i ) / sum_ni_vik_Qk end do end if ! Lambda_k second compositional derivatives if ( dn2 ) then do concurrent ( i = 1 : self % nmolecules , l = 1 : self % nmolecules ) sum_Q_v_dlambda_k_dn ( i , l ) = sum ( self % qk * self % vij ( l ,:) * dlambda_k_dn ( i ,:)) dlambda_k_dn2 ( i , l ,:) = (& - sum_vij_Qj_Ejk ( i ,:) * sum_vij_Qj_Ejk ( l ,:) / sum_ni_vij_Qj_Ejk ** 2 & + sum_vik_Qk ( i ) * sum_vik_Qk ( l ) / sum_ni_vik_Qk ** 2 & ) end do end if ! Temperature derivatives if ( dt . or . dtn . or . dt2 ) then do k = 1 , self % ngroups sum_ni_vij_Qj_dEjk_dT ( k ) = sum ( n * sum_vij_Qj_dEjk_dT (:, k )) dlambda_k_dT ( k ) = sum ( theta_j * dEjk_dt (:, k )) / sum ( theta_j * Ejk (:, k )) dlambda_k_dT2 ( k ) = sum ( n * sum_vij_Qj_dEjk_dT2 (:, k )) / sum_ni_vij_Qj_Ejk ( k ) - dlambda_k_dT ( k ) ** 2 end do end if if ( dtn ) then do i = 1 , self % nmolecules dlambda_k_dndT ( i ,:) = (& sum_vij_Qj_dEjk_dT ( i ,:) / sum_ni_vij_Qj_Ejk & - sum_vij_Qj_Ejk ( i ,:) * sum_ni_vij_Qj_dEjk_dT / sum_ni_vij_Qj_Ejk ** 2 & ) end do end if ! ======================================================================== ! Lambda_ik ! ------------------------------------------------------------------------ if ( pge . or . dn . or . dt . or . dtn ) then lambda_ik = 0.0_pr do concurrent ( i = 1 : self % nmolecules , k = 1 : self % ngroups ) if ( self % vij ( i , k ) /= 0 ) then lambda_ik ( i , k ) = log ( sum ( self % thetas_ij ( i , :) * Ejk (:, k ))) end if end do end if ! Temperature derivatives if ( dt . or . dt2 . or . dtn ) then dlambda_ik_dT = 0.0_pr do concurrent ( i = 1 : self % nmolecules , k = 1 : self % ngroups ) if ( self % vij ( i , k ) /= 0 ) then dlambda_ik_dT ( i , k ) = sum ( self % thetas_ij ( i ,:) * dEjk_dt (:, k )) / sum ( self % thetas_ij ( i ,:) * Ejk (:, k )) end if end do if ( dt2 ) dlambda_ik_dT2 = sum_vij_Qj_dEjk_dT2 / sum_vij_Qj_Ejk - dlambda_ik_dT * dlambda_ik_dT end if ! ======================================================================== ! Ge ! ------------------------------------------------------------------------ if ( pge . or . dn . or . dt . or . dtn ) then do i = 1 , self % nmolecules sum_vQ_Lambda ( i ) = sum ( self % vij ( i ,:) * self % qk * ( lambda_k - lambda_ik ( i ,:))) end do Ge_aux = - sum ( n * sum_vQ_Lambda ) end if ! ======================================================================== ! dGe_dn ! ------------------------------------------------------------------------ if ( dn . or . dtn ) then do i = 1 , self % nmolecules aux_sum ( i ) = sum ( sum_nl_vlj * self % qk * dlambda_k_dn ( i ,:)) end do dGe_dn_aux = - sum_vQ_Lambda - aux_sum end if ! ======================================================================== ! dGe_dn2 ! ------------------------------------------------------------------------ if ( dn2 ) then do concurrent ( i = 1 : self % nmolecules , l = 1 : self % nmolecules ) aux_sum2 = sum ( sum_nl_vlj * dlambda_k_dn2 ( i , l ,:) * self % qk ) dGe_dn2 ( i , l ) = - ( sum_Q_v_dlambda_k_dn ( i , l ) + sum_Q_v_dlambda_k_dn ( l , i )) - aux_sum2 end do end if ! ======================================================================== ! dGe_dT, dGe_dT2, dGE_dnT ! ------------------------------------------------------------------------ if ( dt . or . dt2 . or . dtn ) then do i = 1 , self % nmolecules sum_vij_Qj_dlambdas_dT ( i ) = sum ( self % vij ( i ,:) * self % qk * ( dlambda_k_dT - dlambda_ik_dT ( i ,:))) end do dGe_dT_aux = - sum ( n * sum_vij_Qj_dlambdas_dT ) end if if ( dt2 ) then do i = 1 , self % nmolecules sum_vij_Qj_dlambdas_dT2 ( i ) = sum ( self % vij ( i ,:) * self % qk * ( dlambda_k_dT2 - dlambda_ik_dT2 ( i ,:))) end do dGe_dT2 = - sum ( n * sum_vij_Qj_dlambdas_dT2 ) end if if ( dtn ) then do i = 1 , self % nmolecules aux_sum ( i ) = sum ( sum_nl_vlj * self % qk * dlambda_k_dndT ( i ,:)) end do dGe_dTn = - sum_vij_Qj_dLambdas_dT - aux_sum end if ! ======================================================================== ! From reduced Ge to Ge ! ------------------------------------------------------------------------ if ( present ( Ge )) then Ge = Ge_aux * R * T end if if ( present ( dGe_dT )) then dGe_dT = R * ( Ge_aux + dGe_dT_aux * T ) end if if ( present ( dGe_dT2 )) then dGe_dT2 = R * ( 2.0 * dGe_dT_aux + T * dGe_dT2 ) end if if ( present ( dGe_dTn )) then dGe_dTn = R * ( dGe_dn_aux + dGe_dTn * T ) end if if ( present ( dGe_dn )) then dGe_dn = dGe_dn_aux * R * T end if if ( present ( dGe_dn2 )) then dGe_dn2 = dGe_dn2 * R * T end if end subroutine Ge_residual function thetas_i ( nm , ng , parameters , stew , molecules ) result ( thetas_ij ) !! # \\Theta_i  calculation !! Calculate the area fraciton of each froup on each molecule. !! !! # Description !! Calculate the area fraciton of each froup on each molecule. The values !! are obtained on the setup_unifac function and stored on the UNIFAC !! type, since the values can be reused (no compositional or temperature !! dependence) !! !! # References !! 1. [SINTEF - Thermopack](https://github.com/thermotools/thermopack) integer , intent ( in ) :: nm !! Number of molecules integer , intent ( in ) :: ng !! Number of groups type ( GeGCModelParameters ), intent ( in ) :: parameters !! UNIFAC parameters type ( Groups ), intent ( in ) :: stew !! All the groups present in the system type ( Groups ), intent ( in ) :: molecules (:) !! Molecules real ( pr ) :: thetas_ij ( nm , ng ) !! Group j area fraction on molecule i real ( pr ) :: total_area_i ( nm ) real ( pr ) :: qki_contribution integer :: gi integer :: i , j , k thetas_ij = 0.0_pr total_area_i = 0.0_pr ! Obtain the total area of each molecule do i = 1 , size ( molecules ) do k = 1 , size ( molecules ( i )% number_of_groups ) gi = molecules ( i )% groups_ids ( k ) ! Contribution of the group k to the molecule i area. qki_contribution = (& parameters % get_subgroup_Q ( gi ) * molecules ( i )% number_of_groups ( k )& ) ! Adding to the total area of each molecule total_area_i ( i ) = total_area_i ( i ) + qki_contribution end do end do ! Calculate the fraction of each group on each molecule thetas_ij = 0.0_pr do i = 1 , size ( molecules ) do k = 1 , size ( molecules ( i )% number_of_groups ) gi = molecules ( i )% groups_ids ( k ) j = findloc ( stew % groups_ids , gi , dim = 1 ) thetas_ij ( i , j ) = (& parameters % get_subgroup_Q ( gi ) & * molecules ( i )% number_of_groups ( k ) & / total_area_i ( i ) & ) end do end do end function thetas_i type ( UNIFAC ) function setup_unifac ( molecules , parameters ) !! # Setup UNIFAC !! Instantiate a UNIFAC model !! !! # Description !! Subroutine used to instantiate a UNIFAC model. !! !! # Examples !! !! ```fortran !!  ! Instantiate an UNIFAC model with ethanol-water mix and calculate gammas !!  use yaeos, only: pr, Groups, setup_unifac, UNIFAC !! !!  type(UNIFAC) :: model !!  type(Groups) :: molecules(2) !!  real(pr) :: ln_gammas(2) !! !!  ! Ethanol definition [CH3, CH2, OH] !!  molecules(1)%groups_ids = [1, 2, 14] ! Subgroups ids !!  molecules(1)%number_of_groups = [1, 1, 1] ! Subgroups occurrences !! !!  ! Water definition [H2O] !!  molecules(2)%groups_ids = [16] !!  molecules(2)%number_of_groups = [1] !! !!  ! Model setup !!  model = setup_unifac(molecules) !! !!  ! Calculate ln_gammas !!  call model%ln_activity_coefficient([0.5_pr, 0.5_pr], 298.0_pr, ln_gammas) !! !!  print *, ln_gammas ! result: 0.18534142000449058    0.40331395945417559 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.ddbst !! .com/published-parameters-unifac.html) !! type ( Groups ), intent ( in ) :: molecules (:) !! Molecules (Group type) objects type ( GeGCModelParameters ), optional , intent ( in ) :: parameters !! UNIFAC parameters type ( Groups ) :: soup type ( UNIFACPsi ) :: psi_function ! UNIFAC parameters type ( GeGCModelParameters ) :: params ! Usefull matrixes to store integer , allocatable :: vij (:, :) real ( pr ), allocatable :: qks (:), Aij (:, :) integer :: gi , i , j , k setup_unifac % molecules = molecules allocate ( soup % groups_ids ( 0 )) allocate ( soup % number_of_groups ( 0 )) ! ======================================================================== ! Load default UNIFAC parameters if not provided ! ------------------------------------------------------------------------ if (. not . present ( parameters )) then params = UNIFACParameters () else params = parameters end if call params % check_consistency ! ======================================================================== ! Count all the individual groups and each molecule volume and area ! ------------------------------------------------------------------------ associate (& r => setup_unifac % molecules % volume , & q => setup_unifac % molecules % surface_area & ) ! Get all the groups indexes and counts into a single stew of groups. do i = 1 , size ( molecules ) r ( i ) = 0 q ( i ) = 0 do j = 1 , size ( molecules ( i )% groups_ids ) gi = molecules ( i )% groups_ids ( j ) ! Calculate molecule i volume and area r ( i ) = r ( i ) + molecules ( i )% number_of_groups ( j ) * params % get_subgroup_R ( gi ) q ( i ) = q ( i ) + molecules ( i )% number_of_groups ( j ) * params % get_subgroup_Q ( gi ) if ( all ( soup % groups_ids - gi /= 0 )) then ! Add group if it wasn't included yet soup % groups_ids = [ soup % groups_ids , gi ] soup % number_of_groups = [ soup % number_of_groups , 0 ] end if ! Find where is the group located in the main soup of ! groups. gi = findloc ( soup % groups_ids - gi , 0 , dim = 1 ) soup % number_of_groups ( gi ) = soup % number_of_groups ( gi ) & + molecules ( i )% number_of_groups ( j ) end do end do end associate ! ======================================================================== ! Build vij matrix (occurrence of each group of the soup on each molecule) ! ------------------------------------------------------------------------ allocate ( vij ( size ( molecules ), size ( soup % number_of_groups ))) vij = 0 do i = 1 , size ( molecules ) do k = 1 , size ( molecules ( i )% number_of_groups ) gi = molecules ( i )% groups_ids ( k ) ! Index of group for Area j = findloc ( soup % groups_ids , gi , dim = 1 ) vij ( i , j ) = molecules ( i )% number_of_groups ( k ) end do end do ! ======================================================================== ! Build qk vector (area of each group in the soup) ! ------------------------------------------------------------------------ allocate ( qks ( size ( soup % number_of_groups ))) qks = 0.0_pr do k = 1 , size ( soup % groups_ids ) qks ( k ) = params % get_subgroup_Q ( soup % groups_ids ( k )) end do ! ======================================================================== ! Build Aij matrix (interaction of the soup's subgroups) ! ------------------------------------------------------------------------ allocate ( Aij ( size ( soup % groups_ids ), size ( soup % groups_ids ))) Aij = 0.0_pr do i = 1 , size ( soup % groups_ids ) do j = 1 , size ( soup % groups_ids ) Aij ( i , j ) = params % get_subgroups_aij (& soup % groups_ids ( i ), soup % groups_ids ( j ) & ) end do end do ! ======================================================================== psi_function % Aij = Aij setup_unifac % groups_stew = soup setup_unifac % ngroups = size ( soup % number_of_groups ) setup_unifac % nmolecules = size ( molecules ) setup_unifac % psi_function = psi_function setup_unifac % group_area = params % subgroups_Qs setup_unifac % group_volume = params % subgroups_Rs setup_unifac % thetas_ij = thetas_i (& size ( molecules ), size ( soup % number_of_groups ), params , soup , molecules ) setup_unifac % vij = vij setup_unifac % qk = qks end function setup_unifac end module yaeos__models_ge_group_contribution_unifac","tags":"","url":"sourcefile/unifac.f90.html"},{"title":"ar_interface.f90 – yaeos","text":"Source Code module ar_interface !-| Generic interfaces to an ArModel compatible with legacy codes, using !   pointers. use yaeos__constants , only : pr , R use iso_fortran_env , only : error_unit implicit none procedure ( Ares ), pointer :: ar_fun procedure ( initial_volume ), pointer :: vinit abstract interface subroutine Ares ( z , v , t , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) !| Residual Helmholtz model interface import pr real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( in ) :: v , t real ( pr ), intent ( out ) :: Ar , ArV , ArTV , ArV2 real ( pr ), dimension ( size ( z )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) end subroutine function initial_volume ( z , p , t ) import pr real ( pr ) :: z (:) real ( pr ) :: p real ( pr ) :: t real ( pr ) :: initial_volume end function end interface end module","tags":"","url":"sourcefile/ar_interface.f90.html"},{"title":"math.f90 – yaeos","text":"Source Code module yaeos__math !! # Mathematical methods for `yaeos` !! !! # Description !! This module provides all the relevant mathematical functions used in this !! library. Most important ones are: !! !! - newton: Newton solving method !! - solve_system: Solving linear system Ax = b !! - continuation: Continuation method for line tracing !! !! # Examples !! !! ## Squared error calculation !! ```fortran !!  use yaeos__math, only: sq_error !!  real(pr) :: x = 2.5, y = 3.0, error !!  print *, sq_error(2.5, 3.0) !! ------------------------------------ !! ``` !! !! ```fortran !!  use yaeos__math, only: sq_error !!  real(pr) :: x = [2.5, 5.0], y = [3.0, 4.5], error !!  ! It also works with arrays !!  print *, sq_error(x, y) !! ``` use yaeos__math_continuation , only : continuation use yaeos__math_linalg , only : solve_system , cubic_roots use yaeos__constants , only : pr implicit none abstract interface subroutine f_1d ( x , f , df ) import pr real ( pr ), intent ( in ) :: x real ( pr ), intent ( out ) :: f real ( pr ), intent ( out ) :: df end subroutine f_1d end interface interface newton module procedure :: newton_1d end interface newton contains elemental real ( pr ) function sq_error ( exp , pred ) !! # Squared error between two values. !! !! # Description !! ... !! !! # Examples !! !! ```fortran !!  error = sq_error(true_value, model_value) !! ``` use yaeos__constants , only : pr real ( pr ), intent ( in ) :: exp real ( pr ), intent ( in ) :: pred sq_error = (( exp - pred ) / exp ) ** 2 end function sq_error function dx_to_dn ( x , dx ) result ( dn ) !! # dx_to_dn !! !! # Description !! Convert the mole fraction derivatives of a quantity (calculated !! so they do not sum to 1) to mole number derivatives (where the mole !! fractions do sum to one). Requires the derivatives and the mole fractions !! of the mixture. !! From [https://chemicals.readthedocs.io/chemicals.utils.html?highlight=dxs_to_dns#chemicals.utils.dxs_to_dns](Chemicals (Python)) use yaeos__constants , only : pr real ( pr ), intent ( in ) :: x (:) real ( pr ), intent ( in ) :: dx (:) real ( pr ) :: dn ( size ( x )) real ( pr ) :: sum_xdx dn = 0 sum_xdx = sum ( x * dx ) dn = dx - sum_xdx end function dx_to_dn function derivative_dxk_dni ( n ) result ( dxk_dni ) !! # derivative_dxk_dni !! !! # Description !! Calculate the mole fraction first derivatives respect to mole numbers !! real ( pr ), intent ( in ) :: n (:) real ( pr ) :: dxk_dni ( size ( n ), size ( n )) real ( pr ) :: n_tot integer :: nc , k , i n_tot = sum ( n ) nc = size ( n ) dxk_dni = 0.0_pr do concurrent ( k = 1 : nc , i = 1 : nc ) if ( k == i ) then dxk_dni ( k , i ) = ( n_tot - n ( i )) / n_tot ** 2 else dxk_dni ( k , i ) = - n ( k ) / n_tot ** 2 end if end do end function derivative_dxk_dni function derivative_d2xk_dnidnj ( n ) result ( d2xk_dnidnj ) !! # derivative_d2xk_dnidnj !! !! # Description !! Calculate the mole fraction second derivatives respect to mole numbers !! real ( pr ), intent ( in ) :: n (:) real ( pr ) :: d2xk_dnidnj ( size ( n ), size ( n ), size ( n )) real ( pr ) :: n_tot integer :: nc , k , i , j n_tot = sum ( n ) nc = size ( n ) d2xk_dnidnj = 0.0_pr do concurrent ( k = 1 : nc , i = 1 : nc , j = 1 : nc ) if ( i == k . and . j == k ) then d2xk_dnidnj ( k , i , j ) = - 2 * ( n_tot - n ( i )) / n_tot ** 3 else if ( i == k ) then d2xk_dnidnj ( k , i , j ) = ( 2 * n ( i ) - n_tot ) / n_tot ** 3 else if ( j == k ) then d2xk_dnidnj ( k , i , j ) = ( 2 * n ( j ) - n_tot ) / n_tot ** 3 else d2xk_dnidnj ( k , i , j ) = 2 * n ( k ) / n_tot ** 3 end if end do end function derivative_d2xk_dnidnj subroutine newton_1d ( f , x , tol , max_iters ) procedure ( f_1d ) :: f real ( pr ), intent ( in out ) :: x real ( pr ), intent ( in ) :: tol integer , intent ( in ) :: max_iters integer :: i real ( pr ) :: fval , df , step fval = 10 step = 10 do i = 1 , max_iters if ( abs ( fval ) < tol . or . abs ( step ) < tol ) exit call f ( x , fval , df ) step = fval / df do while ( abs ( step ) > 0.5 * abs ( x )) step = step / 2 end do x = x - step end do end subroutine newton_1d elemental function interpol ( x1 , x2 , y1 , y2 , x_obj ) result ( y ) !! Linear interpolation. !! !! Calculates the linear interpolation between two points at a desired !! x value with the equation: !!  !!    y = \\frac{y_2 - y_1}{x_2 - x_1} \\cdot (x_{obj})  - x_1 + y_1 !!  !! !! Since this function is defined as `elemental` it will also interpolate !! a set of vectors. !! !! Examples of usage: !! !! ```fortran !! x1 = 2 !! x2 = 5 !! y1 = 2 !! y2 = 9 !! y = interpol(x1, x2, y1, y2, 2.3) !! ``` !! !! ```fortran !! x1 = 2 !! x2 = 5 !! y1 = [2, 6] !! y2 = [9, 15] !! y = interpol(x1, x2, y1, y2, 2.3) !! ``` real ( pr ), intent ( in ) :: x1 !! First point x value real ( pr ), intent ( in ) :: x2 !! Second point x value real ( pr ), intent ( in ) :: y1 !! First point y value real ( pr ), intent ( in ) :: y2 !! Second point y value real ( pr ), intent ( in ) :: x_obj !! Desired x value to interpolate real ( pr ) :: y !! y value at `x_obj` y = ( y2 - y1 ) / ( x2 - x1 ) * ( x_obj - x1 ) + y1 end function interpol end module yaeos__math","tags":"","url":"sourcefile/math.f90.html"},{"title":"binaries.f90 – yaeos","text":"Source Code module yaeos__equilibria_binaries !! Module with routines particular to binary mixtures. use yaeos__constants , only : pr use yaeos__models , only : ArModel private public :: find_llcl contains subroutine find_llcl ( model , z0 , zi , P , a , V , T ) !! # `find_llcl` !! Find an initial guess for the critical L-L line of a binary mixture. !! !! # Description !! !! !! # Examples !! !! !! # References !! [1] M. Cismondi, M.L. Michelsen, Global phase equilibrium !! calculations: !! Critical lines, critical end points and liquid–liquid–vapour !! equilibrium in binary mixtures, The Journal of Supercritical Fluids 39 !!  (2007) 287–295. https://doi.org/10.1016/j.supflu.2006.03.011. implicit none class ( ArModel ), intent ( in ) :: model real ( kind = pr ), intent ( in ) :: P !! Pressure [bar] real ( kind = pr ), intent ( in ) :: z0 ( 2 ) !! Mole fractions of original fluid real ( kind = pr ), intent ( in ) :: zi ( 2 ) !! Mole fractions of new fluid real ( kind = pr ), intent ( out ) :: a !! Mole fraction of new fluid real ( kind = pr ), intent ( out ) :: V !! Volume [L/mol] real ( kind = pr ), intent ( in out ) :: T !! Temperature [K] real ( kind = pr ) :: z ( 2 ), lnphi ( 2 ), dlnphidn ( 2 , 2 ) integer :: i integer :: tries real ( kind = pr ) :: as ( 50 ) real ( kind = pr ) :: lambdas ( 50 ) do tries = 1 , 2 do i = 1 , 50 a = real ( i , pr ) / 5 1. z = a * zi + ( 1 - a ) * z0 call model % lnphi_pt (& z , P = P , T = T , V = V , lnPhi = lnPhi , dlnphidn = dlnphidn , root_type = & \"liquid\" ) lambdas ( i ) = 1 - dlnphidn ( 1 , 2 ) as ( i ) = a end do i = minloc ( lambdas , dim = 1 ) a = as ( i ) z = a * zi + ( 1 - a ) * z0 if ( lambdas ( i ) > 0 ) then do while ( lambdas ( i ) > 0 ) T = T - 1 call model % lnphi_pt ( z , P = P , T = T , V = V , lnPhi = lnPhi , dlnphidn = & dlnphidn , root_type = \"liquid\" ) lambdas ( i ) = 1 - dlnphidn ( 1 , 2 ) end do else do while ( lambdas ( i ) < 0 ) T = T + 1 call model % lnphi_pt ( z , P = P , T = T , V = V , lnPhi = lnPhi , dlnphidn = & dlnphidn , root_type = \"liquid\" ) lambdas ( i ) = 1 - dlnphidn ( 1 , 2 ) end do end if end do end subroutine find_llcl end module yaeos__equilibria_binaries","tags":"","url":"sourcefile/binaries.f90.html"},{"title":"critical.f90 – yaeos","text":"Source Code module yaeos__equilibria_critical use yaeos__constants , only : pr use yaeos__models , only : ArModel use yaeos__equilibria_equilibrium_state , only : EquilibriumState implicit none private public :: critical_line public :: critical_point public :: CriticalLine public :: spec_CP public :: lambda1 public :: F_critical public :: df_critical type :: CriticalLine !! # CriticalLine !! !! ## Description !! This derived type is used to store a critical line between two fluids. !! The critical line is calculated using the `critical_line` function. It !! uses the continuation method. !! !! ## Examples !! A critical line can be calculated between two fluids using the !! `critical_line` function. !! In this example we calculate the critical of a binary mixture of !! carbon dioxide and bicyclohexyl. !! !! ```fortran !! use yaeos !! implicit none !! type(CubicEoS) :: model !! type(CriticalLine) :: cl !! real(pr) :: z0(2), zi(2) !! !! z0 = [1, 0] ! Pure carbon dioxide !! zi = [0, 1] ! Pure bicyclohexyl !! !! ! Setup the model !! tc = [304.21_pr, 727.0_pr] !! pc = [73.83_pr, 25.6_pr] !! w = [0.223621_pr, 0.427556_pr] !! model = PengRobinson76(tc, pc, w) !! ! Calculate the critical line !! cl = critical_line(model, a0=0.99_pr, z0=z0, zi=zi, dS0=-0.01_pr) !! ``` real ( pr ), allocatable :: a (:) !! Molar fraction of the second fluid real ( pr ), allocatable :: z0 (:) !! Molar fractions of the first fluid real ( pr ), allocatable :: zi (:) !! Molar fractions of the second fluid real ( pr ), allocatable :: P (:) !! Pressure [bar] real ( pr ), allocatable :: V (:) !! Volume [L/mol] real ( pr ), allocatable :: T (:) !! Temperature [K] integer , allocatable :: ns (:) !! Specified variable integer , allocatable :: iters (:) !! Iterations needed for this point type ( EquilibriumState ) :: CEP !! Critical End Point end type CriticalLine type , private :: CPSpecs !! Enumerator to handle the possible specifications for a critical point. integer :: a = 1 !! Specify  \\alpha  integer :: V = 2 !! Specify  V  integer :: T = 3 !! Specify  T  integer :: P = 4 !! Specify  P  end type CPSpecs type ( CPSpecs ), parameter :: spec_CP = CPSpecs () !! Specification variables for a critical point or critical line !! calculation. contains type ( CriticalLine ) function critical_line (& model , a0 , z0 , zi , ns0 , S0 , dS0 , & v0 , t0 , p0 , & max_points , maxP , first_point , & stability_analysis & ) !! # critical_line !! !! ## Description !! Calculates the critical line between two mixtures using the !! continuation method. The two mixtures compositions are restricted to !! the relation between them, by a parameter \\alpha, which represents !! the molar fraction of the second fluid with respect to the whole !! mixture. use yaeos__math_continuation , only : continuation use yaeos__math , only : solve_system use yaeos__equilibria_equilibrium_state , only : EquilibriumState class ( ArModel ), intent ( in ) :: model !! Equation of state model real ( pr ), intent ( in ) :: a0 !! Initial \\alpha value real ( pr ), intent ( in ) :: z0 (:) !! Molar fractions of the first fluid real ( pr ), intent ( in ) :: zi (:) !! Molar fractions of the second fluid integer , intent ( in ) :: ns0 !! Position of the specification variable real ( pr ), intent ( in ) :: S0 !! Specified value real ( pr ), intent ( in ) :: dS0 !! Initial step size real ( pr ), optional , intent ( in ) :: v0 !! Initial volume [L/mol] real ( pr ), optional , intent ( in ) :: t0 !! Initial temperature [K] real ( pr ), optional , intent ( in ) :: p0 !! Initial pressure [bar] integer , optional , intent ( in ) :: max_points !! Maximum number of points real ( pr ), optional , intent ( in ) :: maxP !! Maximum pressure type ( EquilibriumState ), optional , intent ( in ) :: first_point logical , optional :: stability_analysis real ( pr ) :: u ( size ( z0 )) !! eigen-vector real ( pr ) :: u_new ( size ( z0 )) !! eigen-vector real ( pr ), allocatable :: XS_i (:), XS (:, :) !! Full set of solved points integer :: ns real ( pr ) :: S real ( pr ) :: X0 ( 4 ), T , P , V , a , z ( size ( z0 )) integer :: i , npoints real ( pr ) :: max_P real ( pr ) :: y_cep ( size ( z0 )) real ( pr ) :: V_cep logical :: stab_anal logical :: found_cep ! ======================================================================== ! Handle the input ! ------------------------------------------------------------------------ if ( present ( max_points )) then npoints = max_points else npoints = 1000 end if if ( present ( maxP )) then max_P = maxP else max_P = 2500 end if if (. not . present ( stability_analysis )) then stab_anal = . false . else stab_anal = stability_analysis end if u = ( z0 + zi ) / sum ( z0 + zi ) z = a0 * zi + ( 1 - a0 ) * z0 if ( present ( t0 )) then T = t0 else T = sum ( model % components % Tc * z ) end if if ( present ( p0 )) then P = p0 else P = sum ( model % components % Pc * z ) end if if ( present ( v0 )) then V = v0 else call model % volume ( n = z , P = P , T = T , V = V , root_type = \"vapor\" ) end if X0 = [ set_a ( a0 ), log ([ v , T , P ])] if ( present ( first_point )) then X0 = [& first_point % x ( 2 ), & log ([ first_point % Vx , first_point % T , first_point % P ])] end if if ( ns0 == spec_CP % a ) then X0 ( ns0 ) = set_a ( S0 ) else X0 ( ns0 ) = S0 end if ns = ns0 ! ======================================================================== ! Calculate the points ! ------------------------------------------------------------------------ allocate ( critical_line % ns ( 0 ), critical_line % iters ( 0 )) allocate ( critical_line % P ( 0 ), critical_line % T ( 0 ), critical_line % V ( 0 ), critical_line % a ( 0 )) solve_points : block use yaeos__math , only : solve_system use yaeos__math_continuation , only : full_newton real ( pr ) :: X ( 4 ), dX ( 4 ), dS , F ( 4 ), dF ( 4 , 4 ), dFdS ( 4 ), dXdS ( 4 ) real ( pr ) :: u_new ( size ( z0 )), l1 , Si integer :: its , real_its if ( exp ( X ( 4 )) > max_P ) then max_P = exp ( X ( 4 )) + 100 end if X = X0 dS = dS0 S = X ( ns ) do i = 1 , npoints dX = 1 F = 10 X0 = X Si = X0 ( ns ) its = 0 real_its = 0 do while (& ( maxval ( abs ( dX )) > 1e-5 & . or . maxval ( abs ( F )) > 1e-5 ) & . and . real_its < 500 ) its = its + 1 real_its = real_its + 1 F = F_critical ( model , X , ns , Si , z0 , zi , u ) dF = df_critical ( model , X , ns , Si , z0 , zi , u ) dX = solve_system ( dF , - F ) do while ( abs ( maxval ( dX (:))) > 0.01 ) dX = dX / 2 end do X = X + dX l1 = lambda1 ( model = model , X = X , s = 0.0_pr , z0 = z0 , zi = zi , u = u , u_new = u_new ) u = u_new end do ! ============================================================== ! Cases where the line must be stopped ! -------------------------------------------------------------- if ( real_its == 500 ) exit if ( any ( isnan ( X ))) exit if ( exp ( X ( spec_CP % P )) > max_P ) exit a = get_a ( X ( 1 )) V = exp ( X ( 2 )) T = exp ( X ( 3 )) P = exp ( X ( 4 )) ! ============================================================== ! Stability analysis ! -------------------------------------------------------------- if ( stab_anal ) then call look_for_cep ( model , z0 , zi , P , V , T , a , u , found_cep , critical_line % CEP ) if ( found_cep ) then exit solve_points end if end if ! ============================================================== ! Save point ! -------------------------------------------------------------- critical_line % a = [ critical_line % a , a ] critical_line % V = [ critical_line % V , V ] critical_line % T = [ critical_line % T , T ] critical_line % P = [ critical_line % P , P ] critical_line % ns = [ critical_line % ns , ns ] critical_line % iters = [ critical_line % iters , its ] ! ============================================================== ! Determination of new specification ! -------------------------------------------------------------- dFdS = [ 0 , 0 , 0 , - 1 ] dXdS = solve_system ( dF , - dFdS ) ns = maxloc ( abs ( dXdS ), dim = 1 ) dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) ! dS = sign(min(abs(dS * 3./its), dS0), dS) ! ============================================================== ! Avoid big steps in pressure ! -------------------------------------------------------------- ! do while(abs(exp(X(4) + dXdS(4) * dS) - exp(X(4))) > 20) !    dS = dS * 0.9 ! end do ! Next step z = a * zi + ( 1 - a ) * z0 X = X + dXdS * dS end do end block solve_points critical_line % z0 = z0 critical_line % zi = zi end function critical_line subroutine look_for_cep ( model , z0 , zi , Pc , Vc , Tc , a , u , found , CEP ) use yaeos__math , only : solve_system class ( ArModel ), intent ( in ) :: model !! Equation of state model real ( pr ), intent ( in ) :: z0 (:) !! Molar fractions of the first fluid real ( pr ), intent ( in ) :: zi (:) !! Molar fractions of the second fluid real ( pr ), intent ( in ) :: Pc !! Pressure [bar] real ( pr ), intent ( in ) :: Vc !! Volume [L/mol] real ( pr ), intent ( in ) :: Tc !! Temperature [K] real ( pr ), intent ( in ) :: a !! Molar fraction of the second fluid logical , intent ( out ) :: found !! Found a Critical End Point real ( pr ), intent ( in out ) :: u (:) !! Eigen-vector type ( EquilibriumState ), intent ( out ) :: CEP !! Critical End Point real ( pr ) :: y_cep ( size ( z0 )), V_cep real ( pr ) :: Xcep ( size ( z0 ) + 4 ), Fcep ( size ( z0 ) + 4 ), dFcep ( size ( z0 ) + 4 , size ( z0 ) + 4 ), dXcep ( size ( z0 ) + 4 ) found = . false . y_cep = 0 V_cep = 0 call stability_check ( model , z0 , zi , Pc , Vc , Tc , a , found , y_cep , V_cep ) if ( found ) then Fcep = 1 Xcep = [ log ( y_cep ), log ( V_cep ), log ( Vc ), log ( Tc ), set_a ( a )] do while ( maxval ( abs ( Fcep )) > 1e-5 ) Fcep = F_cep ( model , 2 , X = Xcep , z0 = z0 , zi = zi , u = u ) dFcep = df_cep ( model , 2 , X = Xcep , z0 = z0 , zi = zi , u = u ) dXcep = solve_system ( dFcep , - Fcep ) do while ( abs ( dXcep ( 2 + 4 )) > 0.01 ) dXcep ( 2 + 4 ) = dXcep ( 2 + 4 ) / 2 end do Xcep = Xcep + dXcep end do CEP % y = exp ( Xcep (: 2 )) CEP % Vy = exp ( Xcep ( 3 )) CEP % Vx = exp ( Xcep ( 4 )) CEP % T = exp ( Xcep ( 5 )) call model % pressure ( n = CEP % y , V = CEP % Vy , T = CEP % T , P = CEP % P ) CEP % x = zi * get_a ( Xcep ( 6 )) + ( 1 - get_a ( Xcep ( 6 ))) * z0 CEP % kind = \"CEP\" CEP % beta = 0 end if end subroutine look_for_cep subroutine stability_check ( model , z0 , zi , Pc , Vc , Tc , a , unstable , y_other , V_other ) !! # stability_check !! !! ## Description !! Check the stability of a point in the critical line. The stability is !! determined by `tpd` analysis. use yaeos__equilibria_stability , only : min_tpd class ( ArModel ), intent ( in ) :: model !! Equation of state model real ( pr ), intent ( in ) :: z0 (:) !! Molar fractions of the first fluid real ( pr ), intent ( in ) :: zi (:) !! Molar fractions of the second fluid real ( pr ), intent ( in ) :: Pc !! Pressure [bar] real ( pr ), intent ( in ) :: Vc !! Volume [L/mol] real ( pr ), intent ( in ) :: Tc !! Temperature [K] real ( pr ), intent ( in ) :: a !! Molar fraction of the second fluid logical , intent ( out ) :: unstable !! Stability of the point) real ( pr ), intent ( out ) :: V_other !! Volume [L/mol] real ( pr ), intent ( out ) :: y_other (:) !! Molar fractions of the second fluid real ( pr ) :: z ( 2 ) real ( pr ) :: y ( 2 ), dy real ( pr ) :: fug_z ( 2 ), fug_y ( 2 ), P integer :: istab , istab0 real ( pr ) :: tpd logical :: first , possible if ( size ( z0 ) /= 2 ) then error stop \"Stability check only for binary mixtures\" end if z = a * zi + ( 1 - a ) * z0 call model % lnfug_vt ( n = z , V = Vc , T = Tc , lnf = fug_z ) unstable = . false . first = . true . istab0 = 1 ! TODO #optimization: Make an adaptative step of this possible = . false . istab0 = 0 y ( 1 ) = 0 y ( 2 ) = 1 dy = 0.01_pr ! do while (istab0 < 2) !    istab = istab0 do while ( y ( 1 ) < 1 - dy ) y ( 1 ) = y ( 1 ) + dy y ( 2 ) = 1 - y ( 1 ) call model % volume ( n = y , P = Pc , T = Tc , V = V_other , root_type = \"stable\" ) call model % lnfug_vt ( n = y , V = V_other , T = Tc , lnf = fug_y , P = P ) tpd = sum ( y * ( fug_y - fug_z )) if ( tpd < - 1e-2 ) then ! TODO: This should be finding the mimima unstable = . true . y_other = y return end if end do end subroutine stability_check real ( pr ) function lambda1 ( model , X , s , z0 , zi , u , u_new , P ) !! # lambda1 !! !! Calculation of the first restriction of a critical point. !! !!  !!  \\lambda_1(s=0, \\mathbf{n}, V, T) = \\frac{d&#94;2tpd}{ds&#94;2} = 0 !!  !! !! \\lambda_1 is the smallest eigen-value for the matrix: !! !!  !! M_{ij} = \\sqrt{z_i z_j} \\frac{d \\ln f_i}{dn_j}(\\mathbf{n}, V, T) !!  !! !! Where !!  !! \\mathbf{n} = \\mathbf{z} + s \\mathbf{u} \\sqrt{\\mathbf{z}} !!  !! And  \\mathbf{u}  should be the eigen-vector corresponding to the !! smallest eigen-value when s = 0 use yaeos__math_linalg , only : eigen class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z0 (:) !! Molar fractions of the first fluid real ( pr ), intent ( in ) :: zi (:) !! Molar fractions of the second fluid real ( pr ), intent ( in ) :: s !! Distance between the two fluids compositions to the main composition real ( pr ), intent ( in ) :: X ( 4 ) !! Vector of variables real ( pr ), intent ( in ) :: u (:) !! Eigen-vector that defines the direction between the two compositions !!  n_i = z_i + s  u_i \\sqrt{z_i}  real ( pr ), optional , intent ( out ) :: u_new (:) !! Eigen-vector corresponding to the smallest eigenvalue of the matrix !!  M_{ij} = \\sqrt{z_i z_j} \\frac{\\partial \\ln f_i}{\\partial n_j}  real ( pr ), optional , intent ( out ) :: P !! Pressure of the system [bar] real ( pr ) :: n ( size ( z0 )), V , T real ( pr ) :: dlnf_dn ( size ( z0 ), size ( z0 )) real ( pr ) :: lambda ( size ( z0 )), vectors ( size ( z0 ), size ( z0 )) ! type(linalg_state_type) :: stat integer :: i , j , nc real ( pr ) :: M ( size ( z0 ), size ( z0 )), z ( size ( z0 )), Pin real ( pr ) :: a nc = size ( z0 ) a = get_a ( X ( 1 )) z = a * zi + ( 1 - a ) * z0 n = z + s * u * sqrt ( z ) V = exp ( X ( 2 )) T = exp ( X ( 3 )) call model % lnfug_vt ( n = n , V = V , T = T , dlnfdn = dlnf_dn , P = Pin ) do i = 1 , nc do j = 1 , nc M ( i , j ) = sqrt ( z ( i ) * z ( j )) * dlnf_dn ( i , j ) end do end do call eigen ( A = M , eigenvalues = lambda , eigenvectors = vectors ) lambda1 = lambda ( minloc ( abs ( lambda ), dim = 1 )) if ( present ( u_new )) then u_new = vectors (:, minloc ( abs ( lambda ), dim = 1 )) u_new = u_new / sqrt ( sum ( u_new ** 2 )) end if if ( present ( P )) P = Pin end function lambda1 function F_critical ( model , X , ns , S , z0 , zi , u ) !! # F_critical !! !! ## Description !! Function that should be equal to zero at a critical point is found. !! The second criticality condition is calculated as a numerical !! derivative with `eps=1e-4`. !! !!  !! F = \\begin{bmatrix} !!   \\lambda_1(s) \\\\ !!   \\frac{\\partial \\lambda_1(s+\\epsilon) - \\lambda_1(s-\\epsilon)}{2\\epsilon} \\\\ !!   \\ln P - X_4 \\\\ !!   X_{ns} - S !! \\end{bmatrix} = 0 !!  !! !! The vector of varibles is !! !!  !! X = [\\alpha, \\ln V, \\ln T, \\ln P] !!  !! !! Including internally the extra equation: !!  \\mathbf{z} = \\alpha \\mathbf{z_i} + (1-\\alpha) \\mathbf{z_0}  class ( ArModel ), intent ( in ) :: model !! Equation of state model real ( pr ), intent ( in ) :: X ( 4 ) !! Vector of variables integer , intent ( in ) :: ns !! Position of the specification variable real ( pr ), intent ( in ) :: S !! Specification variable value real ( pr ), intent ( in ) :: z0 (:) !! Molar fractions of the first fluid real ( pr ), intent ( in ) :: zi (:) !! Molar fractions of the second fluid real ( pr ), intent ( in out ) :: u (:) !! Eigen-vector real ( pr ) :: u_new ( size ( u )) real ( pr ) :: F_critical ( 4 ) real ( pr ) :: z ( size ( u )) real ( pr ) :: a , V , T , P real ( pr ), parameter :: eps = 1e-4_pr integer :: i real ( pr ) :: eps_df , F1 ( 4 ), F2 ( 4 ), dx ( 4 ) a = get_a ( X ( 1 )) V = exp ( X ( 2 )) T = exp ( X ( 3 )) z = a * zi + ( 1 - a ) * z0 ! if(any(z < 0) ) return F_critical ( 1 ) = lambda1 ( model = model , X = X , s = 0.0_pr , z0 = z0 , zi = zi , u = u , P = P , u_new = u_new ) if ( size ( z ) == 2 ) u = u_new F_critical ( 2 ) = (& lambda1 ( model = model , X = X , s = eps , zi = zi , z0 = z0 , u = u ) & - lambda1 ( model = model , X = X , s =- eps , zi = zi , z0 = z0 , u = u )) / ( 2 * eps ) F_critical ( 3 ) = log ( P ) - X ( 4 ) F_critical ( 4 ) = X ( ns ) - S end function F_critical function df_critical ( model , X , ns , S , z0 , zi , u ) !! # df_critical !! !! ## Description !! Calculates the Jacobian of the critical point function `F_critical`. class ( ArModel ), intent ( in ) :: model !! Equation of state model real ( pr ), intent ( in ) :: X ( 4 ) !! Vector of variables integer , intent ( in ) :: ns !! Position of the specification variable real ( pr ), intent ( in ) :: S !! Specification variable value real ( pr ), intent ( in ) :: z0 (:) !! Molar fractions of the first fluid real ( pr ), intent ( in ) :: zi (:) !! Molar fractions of the second fluid real ( pr ), intent ( in out ) :: u (:) !! Eigen-vector real ( pr ) :: df_critical ( 4 , 4 ) !! Jacobian of the critical point function real ( pr ) :: eps , a real ( pr ) :: dx ( 4 ), F1 ( 4 ), F2 ( 4 ) integer :: i ! if (any(X(1)*zi + (1-X(1))*z0 > 0.99)) then !    eps = 1e-3_pr ! else !    eps = 1e-6_pr ! end if a = get_a ( X ( 1 )) if ( size ( zi ) == 2 ) then eps = 1e-10 else if ( any ( a * zi + ( 1 - a ) * z0 > 0.99 )) then eps = 1e-3_pr else eps = 1e-6_pr end if end if df_critical = 0 do i = 1 , 4 dx = 0 dx ( i ) = max ( abs ( eps * X ( i )), eps ) F2 = F_critical ( model , X + dx , ns , S , z0 , zi , u ) F1 = F_critical ( model , X - dx , ns , S , z0 , zi , u ) df_critical (:, i ) = ( F2 - F1 ) / ( 2 * dx ( i )) end do end function df_critical function F_cep ( model , nc , X , z0 , zi , u ) class ( ArModel ), intent ( in ) :: model !! Equation of state model real ( pr ), intent ( in ) :: z0 ( nc ) !! Molar fractions of the first fluid real ( pr ), intent ( in ) :: X ( nc + 4 ) !! Vector of variables real ( pr ), intent ( in ) :: zi ( nc ) !! Molar fractions of the second fluid real ( pr ), intent ( in out ) :: u ( nc ) !! Eigen-vector real ( pr ) :: F_cep ( nc + 4 ) real ( pr ) :: z ( nc ) real ( pr ) :: V , T , P real ( pr ) :: Xcp ( nc + 4 ) real ( pr ) :: Vc , Pc , lnf_z ( nc ) real ( pr ) :: y ( nc ) real ( pr ) :: Vy , Py real ( pr ) :: lnf_y ( nc ) real ( pr ), parameter :: eps = 1e-5_pr real ( pr ) :: a , u_new ( nc ) integer , intent ( in ) :: nc ! nc = size(z0) y = exp ( X (: nc )) Vy = exp ( X ( nc + 1 )) Vc = exp ( X ( nc + 2 )) T = exp ( X ( nc + 3 )) a = get_a ( X ( nc + 4 )) z = a * zi + ( 1 - a ) * z0 if ( any ( z < 0 ) ) return call model % lnfug_vt ( n = y , V = Vy , T = T , P = Py , lnf = lnf_y ) call model % lnfug_vt ( n = z , V = Vc , T = T , P = Pc , lnf = lnf_z ) Xcp ( 1 ) = X ( nc + 4 ) Xcp ( 2 ) = log ( Vc ) Xcp ( 3 ) = log ( T ) Xcp ( 4 ) = log ( Pc ) F_cep ( 1 ) = lambda1 ( model = model , X = Xcp , s = 0._pr , z0 = z0 , zi = zi , u = u , P = Pc , u_new = u_new ) u = u_new F_cep ( 2 ) = (& lambda1 ( model = model , X = Xcp , s = eps , zi = zi , z0 = z0 , u = u ) & - lambda1 ( model = model , X = Xcp , s =- eps , zi = zi , z0 = z0 , u = u )) / ( 2 * eps ) F_cep ( 3 ) = log ( Pc ) - log ( Py ) F_cep ( 4 : nc + 3 ) = lnf_y - lnf_z F_cep ( nc + 4 ) = sum ( y ) - 1 end function F_cep function df_cep ( model , nc , X , z0 , zi , u ) !! # df_critical !! !! ## Description !! Calculates the Jacobian of the critical point function `F_critical`. class ( ArModel ), intent ( in ) :: model !! Equation of state model integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: z0 ( nc ) !! Molar fractions of the first fluid real ( pr ), intent ( in ) :: X ( nc + 4 ) !! Vector of variables real ( pr ), intent ( in ) :: zi ( nc ) !! Molar fractions of the second fluid real ( pr ), intent ( in out ) :: u ( nc ) !! Eigen-vector real ( pr ) :: df_cep ( nc + 4 , nc + 4 ) !! Jacobian of the critical point function real ( pr ) :: eps real ( pr ) :: dx ( nc + 4 ), F1 ( nc + 4 ), F2 ( nc + 4 ) real ( pr ) :: a integer :: i a = get_a ( X ( 1 )) if ( any ( a * zi + ( 1 - a ) * z0 > 0.99 )) then eps = 1e-3_pr else eps = 1e-6_pr end if eps = 1e-10 df_cep = 0 do i = 1 , size ( df_cep , 1 ) dx = 0 dx ( i ) = eps F2 = F_cep ( model , nc , X + dx , z0 , zi , u ) F1 = F_cep ( model , nc , X - dx , z0 , zi , u ) df_cep (:, i ) = ( F2 - F1 ) / ( 2 * eps ) end do end function df_cep type ( EquilibriumState ) function critical_point (& model , z0 , zi , spec , S , max_iters , V0 , T0 , a0 , P0 & ) !! # critical_point !! !! ## Description !! Calculates a single critical point of a mixture using a Newton-Raphson !! method. It is possible to specify different variables to be fixed with !! the `spec` argument, the `spec_CP` variable helps when selecting the !! specified variable. !! !! ## Examples !! !! ### Default behaviour !! !! ```fortran !!   cp = critical_point(& !!        model, z0, zi, S=0.5_pr, spec=spec_CP%a, max_iters=1000) !! ``` !! !! ### Specifiying another variable !! The natural variables are a, lnV, lnT and lnP. So it is important to !! specify the variable in logaritmic scale if that is the case. !! !! ```fortran !!   cp = critical_point(model, z0, zi, S=log(200._pr), spec=spec_CP%P, max_iters=1000) !! ``` use yaeos__math , only : solve_system class ( ArModel ), intent ( in ) :: model !! Equation of state model real ( pr ), intent ( in ) :: z0 (:) !! Molar fractions of the first fluid real ( pr ), intent ( in ) :: zi (:) !! Molar fractions of the second fluid integer , intent ( in ) :: spec !! Specification `[1:\"z\", 2:\"V\", 3:\"T\", 4:\"P\"]` real ( pr ), intent ( in ) :: S !! Specification value integer , intent ( in ) :: max_iters !! Maxiumum number of iterations real ( pr ), optional , intent ( in ) :: V0 !! Initial volume [L/mol]. real ( pr ), optional , intent ( in ) :: T0 !! Initial temperature [K]. real ( pr ), optional , intent ( in ) :: a0 !! Initial \\alpha value real ( pr ), optional , intent ( in ) :: P0 !! Initial Pressure [bar] real ( pr ) :: X ( 4 ) integer :: ns real ( pr ) :: F ( 4 ), df ( 4 , 4 ), dX ( 4 ), u ( size ( z0 )) real ( pr ) :: z ( size ( z0 )), u_new ( size ( z0 )), l , a real ( pr ) :: Sin integer :: i ! ======================================================================== ! Handle the input ! ------------------------------------------------------------------------ if ( present ( a0 )) then X ( 1 ) = set_a ( a0 ) else if ( spec == spec_CP % a ) then X ( 1 ) = set_a ( S ) else X ( 1 ) = log ( 0.5_pr ) end if a = get_a ( X ( 1 )) z = a * zi + ( 1 - a ) * z0 if ( present ( T0 )) then X ( 3 ) = log ( T0 ) else X ( 3 ) = log ( sum ( model % components % Tc * z )) end if if ( ns == spec_CP % P ) then X ( 4 ) = S else if ( present ( P0 )) then X ( 4 ) = log ( P0 ) else X ( 4 ) = log ( sum ( model % components % Pc * z )) end if if ( present ( V0 )) then X ( 2 ) = log ( V0 ) else call model % volume ( n = z , P = exp ( X ( 4 )), T = exp ( X ( 3 )), V = X ( 2 ), root_type = \"stable\" ) X ( 2 ) = log ( X ( 2 )) end if ns = spec if ( ns == spec_CP % a ) then Sin = set_a ( S ) X ( ns ) = Sin else Sin = S X ( ns ) = Sin end if ! ======================================================================== ! Solve the system of equations ! ------------------------------------------------------------------------ do i = 1 , max_iters l = lambda1 ( model = model , X = X , s = 0.0_pr , z0 = z0 , zi = zi , u = u , u_new = u_new ) u = u_new F = F_critical ( model , X , ns , Sin , z0 , zi , u ) df = df_critical ( model , X , ns , Sin , z0 , zi , u ) dX = solve_system ( A = df , b =- F ) do while ( maxval ( abs ( dX )) > 2e-2 ) dX = dX * 0.99 end do do while (( get_a ( X ( 1 ) + dX ( 1 )) > 1 . or . get_a ( X ( 1 ) + dX ( 1 )) < 0 ) . and . size ( z0 ) == 2 ) dX = dX / 2 end do if ( maxval ( abs ( F )) < 1e-8 ) exit X = X + dX critical_point % iters = i end do a = get_a ( X ( 1 )) z = a * zi + ( 1 - a ) * z0 critical_point % x = z critical_point % y = z critical_point % beta = 0 critical_point % Vx = exp ( X ( 2 )) critical_point % Vy = exp ( X ( 2 )) critical_point % T = exp ( X ( 3 )) call model % pressure ( n = z , V = critical_point % Vx , T = critical_point % T , P = critical_point % P ) critical_point % kind = \"critical\" end function critical_point real ( pr ) function get_a ( X ) real ( pr ), intent ( in ) :: X get_a = X !(X)**2 end function get_a real ( pr ) function set_a ( a ) real ( pr ), intent ( in ) :: a set_a = a !sqrt(a) end function set_a end module yaeos__equilibria_critical","tags":"","url":"sourcefile/critical.f90.html"},{"title":"model_parameters.f90 – yaeos","text":"Source Code module yaeos__models_ge_group_contribution_model_parameters !! # G&#94;E group contribution model parameters !! G&#94;E group contribution model parameters module. !! !! # Description !! This module contrains the GeGCModelParameters type that allows to store !! the subgroups ids, maingroups ids, subgroups Rs, subgroups Qs, !! subgroups maingroups, and maingroups interaction parameters for UNIFAC !! like models (UNIFAC, LL-UNIFAC, Dortmund UNIFAC, PSRK, etc) !! use yaeos__constants , only : pr implicit none type :: GeGCModelParameters !! # GeGCModelParameters !! G&#94;E group contribution model parameters container !! !! # Description !! Type to represent a UNIFAC like models parameters. The type must be !! provided with the subgroups ids, maingroups ids, subgroups Rs, !! subgroups Qs, subgroups maingroups, and maingroups interaction !! parameters. Specifically, the type requires a_{ij}, b_{ij}, and !! c_{ij} for the maingroups interaction parameters. In the case of !! the classic UNIFAC model that only requires a_{ij} parameters, the !! b_{ij} and c_{ij} must be set as null matrixes. !! The documentation and source code of `yaeos` [[UNIFACParameters]] !! function could be consulted to understand how to instantiate a !! [[GeGCModelParameters]] object with the classic liquid-vapor UNIFAC !! parameters defined in DDBST. !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! integer , allocatable :: subgroups_ids (:) !! ID of each model's subgroup integer , allocatable :: maingroups_ids (:) !! ID of each model's maingroup integer , allocatable :: subgroups_maingroups (:) !! Maingroup of each subgroup real ( pr ), allocatable :: subgroups_Rs (:) !! R  value of each subgroup real ( pr ), allocatable :: subgroups_Qs (:) !! Q  value of each subgroup real ( pr ), allocatable :: maingroups_aij (:,:) !! Maingroup a_{ij}  interaction parameters matrix real ( pr ), allocatable :: maingroups_bij (:,:) !! Maingroup b_{ij}  interaction parameters matrix real ( pr ), allocatable :: maingroups_cij (:,:) !! Maingroup c_{ij}  interaction parameters matrix contains procedure :: get_subgroup_index => get_subgroup_index procedure :: get_maingroup_index => get_maingroup_index procedure :: get_subgroup_maingroup => get_subgroup_maingroup procedure :: get_subgroup_R => get_subgroup_R procedure :: get_subgroup_Q => get_subgroup_Q procedure :: get_maingroups_aij => get_maingroups_aij procedure :: get_maingroups_bij => get_maingroups_bij procedure :: get_maingroups_cij => get_maingroups_cij procedure :: get_subgroups_aij => get_subgroups_aij procedure :: get_subgroups_bij => get_subgroups_bij procedure :: get_subgroups_cij => get_subgroups_cij procedure :: check_consistency end type GeGCModelParameters contains subroutine check_consistency ( self ) class ( GeGCModelParameters ), intent ( in ) :: self integer :: n_subgroups , n_maingroups n_subgroups = size ( self % subgroups_ids ) n_maingroups = size ( self % maingroups_ids ) ! ============================================================== ! Subgroups and maingroups sizes ! -------------------------------------------------------------- if ( n_subgroups /= size ( self % subgroups_maingroups )) then error stop 'Subgroups and maingroups sizes mismatch' end if ! ============================================================== ! Size parameters ! -------------------------------------------------------------- if ( n_subgroups /= size ( self % subgroups_Rs )) then error stop 'Subgroups and Rs sizes mismatch' end if if ( n_subgroups /= size ( self % subgroups_Qs )) then error stop 'Subgroups and Qs sizes mismatch' end if ! ============================================================== ! Interaction matrices ! -------------------------------------------------------------- if ( n_maingroups /= size ( self % maingroups_aij , 1 )) then error stop 'Maingroups and aij sizes mismatch' end if if ( n_maingroups /= size ( self % maingroups_aij , 2 )) then error stop 'Maingroups and aij sizes mismatch' end if if ( n_maingroups /= size ( self % maingroups_bij , 1 )) then error stop 'Maingroups and bij sizes mismatch' end if if ( n_maingroups /= size ( self % maingroups_bij , 2 )) then error stop 'Maingroups and bij sizes mismatch' end if if ( n_maingroups /= size ( self % maingroups_cij , 1 )) then error stop 'Maingroups and cij sizes mismatch' end if if ( n_maingroups /= size ( self % maingroups_cij , 2 )) then error stop 'Maingroups and cij sizes mismatch' end if end subroutine function get_subgroup_index ( self , subgroup_id ) result ( subgroup_idx ) !! # get_subgroup_index !! Get index of the subgroup with id: `subgroup_id` !! !! # Description !! Get index of the subgroup with id: `subgroup_id`. Gets the index of the !! subgroup in the `self%subgroups_ids` vector. !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  ! Default parameters of UNIFAC (ddbst) !!  parameters = UNIFACParameters() !! !!  ! Get index of the subgroup with id 178 (IMIDAZOL) !!  print *, parameters%get_subgroup_index(178) ! Will print: 112 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! class ( GeGCModelParameters ) :: self integer , intent ( in ) :: subgroup_id !! ID of the subgroup integer :: subgroup_idx !! Index of the subgroup on the `self%subgroups_ids` vector subgroup_idx = findloc ( self % subgroups_ids , subgroup_id , dim = 1 ) end function get_subgroup_index function get_maingroup_index ( self , maingroup_id ) result ( maingroup_idx ) !! # get_maingroup_index !! Get index of the maingoup with id: `maingoup_id` !! !! # Description !! Get index of the maingoup with id: `maingoup_id`. Gets the index of the !! maingoup in the `self%maingoups_ids` vector. !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  parameters = UNIFACParameters() !! !!  ! Get index of the maingroup with id 55 (Sulfones: [118](CH2)2SU [119]CH2CHSU) !!  print *, parameters%get_maingroup_index(55) ! Will print: 52 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! class ( GeGCModelParameters ) :: self integer , intent ( in ) :: maingroup_id !! ID of the subgroup integer :: maingroup_idx !! Index of the maingroup on the `self%maingroups_ids` vector maingroup_idx = findloc ( self % maingroups_ids , maingroup_id , dim = 1 ) end function get_maingroup_index function get_subgroup_maingroup ( self , subgroup_id ) result ( subgroup_maingroup ) !! # get_subgroup_maingroup !! Get the subgroup's maingroup !! !! # Description !! Uses the `self%subgroups_maingroups` attribute to locate the maingroup !! where the subgroup with id `subgroup_id` belongs !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  parameters = UNIFACParameters() !! !!  ! Get the maingroup of the subgroup with id 16 (H2O) !!  print *, parameters%get_subgroup_maingroup(16) ! Will print: 7 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! class ( GeGCModelParameters ) :: self integer , intent ( in ) :: subgroup_id !! ID of the subgroup integer :: subgroup_maingroup !! Maingroup of the subgroup integer :: subgroup_idx subgroup_idx = self % get_subgroup_index ( subgroup_id ) subgroup_maingroup = self % subgroups_maingroups ( subgroup_idx ) end function get_subgroup_maingroup function get_subgroup_R ( self , subgroup_id ) result ( subgroup_R ) !! # get_subgroup_R !! Get the subgroup's R  value !! !! # Description !! Uses the `self%subgroups_Rs` attribute to locate the subgroup R  !! value. !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  parameters = UNIFACParameters() !! !!  ! Get the subgroup, with id 1 (CH3), R value !!  print *, parameters%get_subgroup_R(1) ! Will print: 0.9011 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! class ( GeGCModelParameters ) :: self integer , intent ( in ) :: subgroup_id !! ID of the subgroup real ( pr ) :: subgroup_R !! R  value of the subgroup integer :: subgroup_idx subgroup_idx = self % get_subgroup_index ( subgroup_id ) subgroup_R = self % subgroups_Rs ( subgroup_idx ) end function get_subgroup_R function get_subgroup_Q ( self , subgroup_id ) result ( subgroup_Q ) !! # get_subgroup_Q !! Get the subgroup's Q  value !! !! # Description !! Uses the `self%subgroups_Qs` attribute to locate the subgroup Q  !! value. !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  parameters = UNIFACParameters() !! !!  ! Get the subgroup, with id 1 (CH3), Q value !!  print *, parameters%get_subgroup_Q(1) ! Will print: 0.8480 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! class ( GeGCModelParameters ) :: self integer , intent ( in ) :: subgroup_id !! ID of the subgroup real ( pr ) :: subgroup_Q !! Q  value of the subgroup integer :: subgroup_idx subgroup_idx = self % get_subgroup_index ( subgroup_id ) subgroup_Q = self % subgroups_Qs ( subgroup_idx ) end function get_subgroup_Q function get_maingroups_aij ( self , maingroup_i_id , maingroup_j_id ) result ( aij ) !! # get_maingroups_aij !! Get the interaction parameter a_{ij} !! !! # Description !! Get the interaction parameter a_{ij} of the maingroups `i` and `j` !! ids. !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  parameters = UNIFACParameters() !! !!  ! Get the maingroups i:1, j:7 interaction parameter aij (CH2-H2O) !!  print *, parameters%get_maingroups_aij(1, 7) ! prints: 1318.0000 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! class ( GeGCModelParameters ) :: self integer , intent ( in ) :: maingroup_i_id !! ID of the maingroup `i` integer , intent ( in ) :: maingroup_j_id !! ID of the maingroup `j` real ( pr ) :: aij !! Interaction parameter a_{ij} integer :: i , j i = self % get_maingroup_index ( maingroup_i_id ) j = self % get_maingroup_index ( maingroup_j_id ) aij = self % maingroups_aij ( i , j ) end function get_maingroups_aij function get_maingroups_bij ( self , maingroup_i_id , maingroup_j_id ) result ( bij ) !! # get_maingroups_bij !! Get the interaction parameter b_{ij} !! !! # Description !! Get the interaction parameter b_{ij} of the maingroups `i` and `j` !! ids. !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  parameters = UNIFACParameters() !! !!  ! Get the maingroups i:1, j:7 interaction parameter bij (CH2-H2O) !!  print *, parameters%get_maingroups_bij(1, 7) ! prints: 0.0 !! ``` !! !! In the example we obtain 0.0 because UNIFAC only have a_{ij} !! parameters !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! class ( GeGCModelParameters ) :: self integer , intent ( in ) :: maingroup_i_id !! ID of the maingroup `i` integer , intent ( in ) :: maingroup_j_id !! ID of the maingroup `j` real ( pr ) :: bij !! Interaction parameter b_{ij} integer :: i , j i = self % get_maingroup_index ( maingroup_i_id ) j = self % get_maingroup_index ( maingroup_j_id ) bij = self % maingroups_bij ( i , j ) end function get_maingroups_bij function get_maingroups_cij ( self , maingroup_i_id , maingroup_j_id ) result ( cij ) !! # get_maingroups_cij !! Get the interaction parameter c_{ij} !! !! # Description !! Get the interaction parameter c_{ij} of the maingroups `i` and `j` !! ids. !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  parameters = UNIFACParameters() !! !!  ! Get the maingroups i:1, j:7 interaction parameter cij (CH2-H2O) !!  print *, parameters%get_maingroups_cij(1, 7) ! prints: 0.0 !! ``` !! !! In the example we obtain 0.0 because UNIFAC only have a_{ij}  !! parameters !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! class ( GeGCModelParameters ) :: self integer , intent ( in ) :: maingroup_i_id !! ID of the maingroup `i` integer , intent ( in ) :: maingroup_j_id !! ID of the maingroup `j` real ( pr ) :: cij !! Interaction parameter c_{ij} integer :: i , j i = self % get_maingroup_index ( maingroup_i_id ) j = self % get_maingroup_index ( maingroup_j_id ) cij = self % maingroups_cij ( i , j ) end function get_maingroups_cij function get_subgroups_aij ( self , subgroup_i_id , subgroup_j_id ) result ( aij ) !! # get_subgroups_aij !! Get the interaction parameter a_{ij} !! !! # Description !! Get the interaction parameter a_{ij} of the subgroups `i` and `j` !! ids. !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  parameters = UNIFACParameters() !! !!  ! Get the subgroups i:1, j:16 interaction parameter aij (CH3-H2O) !!  ! with maingroups 1 and 7 respectively. !!  print *, parameters%get_subgroups_aij(1, 16) ! prints: 1318.0000 !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! class ( GeGCModelParameters ) :: self integer , intent ( in ) :: subgroup_i_id !! ID of the subgroup `i` integer , intent ( in ) :: subgroup_j_id !! ID of the subgroup `j` real ( pr ) :: aij !! Interaction parameter a_{ij} integer :: mi_id , mj_id , i , j mi_id = self % get_subgroup_maingroup ( subgroup_i_id ) mj_id = self % get_subgroup_maingroup ( subgroup_j_id ) i = self % get_maingroup_index ( mi_id ) j = self % get_maingroup_index ( mj_id ) aij = self % maingroups_aij ( i , j ) end function get_subgroups_aij function get_subgroups_bij ( self , subgroup_i_id , subgroup_j_id ) result ( bij ) !! # get_subgroups_bij !! Get the interaction parameter b_{ij} !! !! # Description !! Get the interaction parameter b_{ij} of the subgroups `i` and `j` !! ids. !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  parameters = UNIFACParameters() !! !!  ! Get the subgroups i:1, j:16 interaction parameter bij (CH3-H2O) !!  ! with maingroups 1 and 7 respectively. !!  print *, parameters%get_subgroups_bij(1, 16) ! prints: 0.0000 !! ``` !! !! In the example we obtain 0.0 because UNIFAC only have a_{ij}  !! parameters !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! class ( GeGCModelParameters ) :: self integer , intent ( in ) :: subgroup_i_id !! ID of the subgroup `i` integer , intent ( in ) :: subgroup_j_id !! ID of the subgroup `j` real ( pr ) :: bij !! Interaction parameter b_{ij} integer :: mi_id , mj_id , i , j mi_id = self % get_subgroup_maingroup ( subgroup_i_id ) mj_id = self % get_subgroup_maingroup ( subgroup_j_id ) i = self % get_maingroup_index ( mi_id ) j = self % get_maingroup_index ( mj_id ) bij = self % maingroups_bij ( i , j ) end function get_subgroups_bij function get_subgroups_cij ( self , subgroup_i_id , subgroup_j_id ) result ( cij ) !! # get_subgroups_cij !! Get the interaction parameter c_{ij} !! !! # Description !! Get the interaction parameter c_{ij} of the subgroups `i` and `j` !! ids. !! !! # Examples !! !! ```fortran !!  use yaeos__models_ge_group_contribution_unifac_parameters, only: UNIFACParameters !!  use yaeos__models_ge_group_contribution_model_parameters, only: GeGCModelParameters !! !!  type(GeGCModelParameters) :: parameters !! !!  parameters = UNIFACParameters() !! !!  ! Get the subgroups i:1, j:16 interaction parameter cij (CH3-H2O) !!  ! with maingroups 1 and 7 respectively. !!  print *, parameters%get_subgroups_cij(1, 16) ! prints: 0.0000 !! ``` !! !! In the example we obtain 0.0 because UNIFAC only have a_{ij}  !! parameters !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.dd !! bst.com/published-parameters-unifac.html) !! class ( GeGCModelParameters ) :: self integer , intent ( in ) :: subgroup_i_id !! ID of the subgroup `i` integer , intent ( in ) :: subgroup_j_id !! ID of the subgroup `j` real ( pr ) :: cij !! Interaction parameter c_{ij} integer :: mi_id , mj_id , i , j mi_id = self % get_subgroup_maingroup ( subgroup_i_id ) mj_id = self % get_subgroup_maingroup ( subgroup_j_id ) i = self % get_maingroup_index ( mi_id ) j = self % get_maingroup_index ( mj_id ) cij = self % maingroups_cij ( i , j ) end function get_subgroups_cij end module yaeos__models_ge_group_contribution_model_parameters","tags":"","url":"sourcefile/model_parameters.f90.html"},{"title":"consistency_gemodel.f90 – yaeos","text":"Source Code module yaeos__consistency_gemodel !! # yaeos__consistency_gemodel !! Consistency checks of Helmholtz free energy models ([[GeModel]]). !! !! # Description !! This module contains tools to validate the analityc derivatives of !! implmented excess Gibbs free energy models ([[GeModel]]). Also, allows to !! evaluate the consistency tests described in Thermodynamic Models: !! Fundamentals & Computational Aspects 2 ed. by Michelsen and Mollerup !! Chapter 5 section 4. !! !! Available tools: !! !! - [[numeric_ge_derivatives]]: From an instantiated [[GeModel]] evaluate !! all the excess Gibbs free energy derivatives from the central finite !! difference method. !! !! - [[ge_consistency]]: From an instantiated GeModel evaluate all the !! Michelsen and Mollerup consistency tests !! !! # References !! 1. Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models: !! Fundamentals & computational aspects (2. ed). Tie-Line Publications. !! use yaeos__constants , only : pr , R use yaeos__models_ge , only : GeModel implicit none contains subroutine ge_consistency ( model , n , t , eq58 , eq59 , eq60 , eq61 ) !! # ge_consistency !! G&#94;E models consistency tests !! !! # Description !! Evaluate the G&#94;E models consistency tests described in !! Thermodynamic Models: Fundamentals & Computational Aspects 2 ed. by !! Michelsen and Mollerup (MM) Chapter 5 section 4. The \"eq\" are !! evaluations of the left hand side of the following expressions: !! !! Equation 58 !! !!   !!   \\sum_i&#94;{NC} n_i \\text{ln} \\gamma_i - \\frac{G&#94;E}{RT} = 0 !!   !! !! Equation 59 !! !!   !!   \\text{ln} \\gamma_i - \\frac{1}{RT} !!   \\frac{\\partial G&#94;E}{\\partial n_i} = 0 !!   !! !! Equation 60 !! !!   !!   \\frac{\\partial \\text{ln} \\gamma_i}{\\partial n_j} - !!   \\frac{\\partial \\text{ln} \\gamma_j}{\\partial n_i} = 0 !!   !! !! Equation 61 !! !!   !!   \\sum_i&#94;{NC} n_i !!   \\frac{\\partial \\text{ln} \\gamma_i}{\\partial n_j} = 0 !!   !! !! # Examples !! !! ```fortran !!  use yaeos, only: pr !!  use yaeos, only: Groups, setup_unifac, UNIFAC !!  use yaeos__consistency_gemodel, only: ge_consistency !! !!  type(UNIFAC) :: model !! !!  integer, parameter :: nc = 4, ng = 4 !! !!  type(Groups) :: molecules(nc) !! !!  real(pr) :: n(nc), T !!  real(pr) :: dt, dn !! !!  real(pr) :: eq58, eq59(nc), eq60(nc,nc), eq61(nc) !! !!  T = 303.15 !!  n = [400.0, 100.0, 300.0, 200.0] !! !!  ! Hexane [CH3, CH2] !!  molecules(1)%groups_ids = [1, 2] !!  molecules(1)%number_of_groups = [2, 4] !! !!  ! Ethanol [CH3, CH2, OH] !!  molecules(2)%groups_ids = [1, 2, 14] !!  molecules(2)%number_of_groups = [1, 1, 1] !! !!  ! Toluene [ACH, ACCH3] !!  molecules(3)%groups_ids = [9, 11] !!  molecules(3)%number_of_groups = [5, 1] !! !!  ! Cyclohexane [CH2] !!  molecules(4)%groups_ids = [2] !!  molecules(4)%number_of_groups = [6] !! !!  model = setup_unifac(molecules) !! !!  ! ==================================================================== !!  ! Consistency tests !!  ! -------------------------------------------------------------------- !!  call ge_consistency(model, n, t, eq58, eq59, eq60, eq61) !! ``` !! !! # References !! 1. Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models: !! Fundamentals & computational aspects (2. ed). Tie-Line Publications. !! class ( GeModel ), intent ( in ) :: model !! G&#94;E model real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), optional , intent ( out ) :: eq58 !! MM Eq. 58 real ( pr ), optional , intent ( out ) :: eq59 ( size ( n )) !! MM Eq. 59 real ( pr ), optional , intent ( out ) :: eq60 ( size ( n ), size ( n )) !! MM Eq. 60 real ( pr ), optional , intent ( out ) :: eq61 ( size ( n )) !! MM Eq. 61 real ( pr ) :: Ge , Gen ( size ( n )), Gen2 ( size ( n ), size ( n )) real ( pr ) :: ln_gammas ( size ( n )) integer i , j call model % excess_gibbs ( n , t , Ge = Ge , Gen = Gen , Gen2 = Gen2 ) call model % ln_activity_coefficient ( n , t , ln_gammas ) ! ======================================================================== ! Equation 58 ! ------------------------------------------------------------------------ if ( present ( eq58 )) then eq58 = sum ( n * ln_gammas ) - Ge / R / T end if ! ======================================================================== ! Equation 59 ! ------------------------------------------------------------------------ if ( present ( eq59 )) then eq59 = Gen / R / T - ln_gammas end if ! ======================================================================== ! Equation 60 ! ------------------------------------------------------------------------ if ( present ( eq60 )) then eq60 = 0.0_pr do i = 1 , size ( n ) do j = 1 , size ( n ) eq60 ( i , j ) = Gen2 ( i , j ) / R / T - Gen2 ( j , i ) / R / T end do end do end if ! ======================================================================== ! Equation 61 ! ------------------------------------------------------------------------ if ( present ( eq61 )) then eq61 = 0.0_pr do j = 1 , size ( n ) eq61 ( j ) = sum ( n * Gen2 (:, j ) / R / T ) end do end if end subroutine ge_consistency subroutine numeric_ge_derivatives (& model , n , t , d_n , d_t , Ge , GeT , Gen , GeT2 , GeTn , Gen2 & ) !! # numeric_ge_derivatives !! Numeric G&#94;E model derivatives !! !! # Description !! Tool to facilitate the development of new [[GeModel]] by testing !! the implementation of analytic derivatives. !! !! # Examples !! !! ```fortran !! use yaeos, only: Groups, setup_unifac, UNIFAC !! use yaeos__consistency_gemodel, only: numeric_ge_derivatives !! !! type(UNIFAC) :: model !! !! integer, parameter :: nc = 4, ng = 4 !! !! type(Groups) :: molecules(nc) !! !! real(pr) :: Ge, Gen(nc), GeT, GeT2, GeTn(nc), Gen2(nc, nc) !! real(pr) :: Ge_n, Gen_n(nc), GeT_n, GeT2_n, GeTn_n(nc), Gen2_n(nc, nc) !! real(pr) :: ln_gammas(nc) !! !! real(pr) :: n(nc), T !! real(pr) :: dt, dn !! !! T = 303.15 !! n = [400.0, 100.0, 300.0, 200.0] ! always test with sum(n) > 1 !! !! dt = 0.1_pr !! dn = 0.1_pr !! !! ! Hexane [CH3, CH2] !! molecules(1)%groups_ids = [1, 2] !! molecules(1)%number_of_groups = [2, 4] !! !! ! Ethanol [CH3, CH2, OH] !! molecules(2)%groups_ids = [1, 2, 14] !! molecules(2)%number_of_groups = [1, 1, 1] !! !! ! Toluene [ACH, ACCH3] !! molecules(3)%groups_ids = [9, 11] !! molecules(3)%number_of_groups = [5, 1] !! !! ! Cyclohexane [CH2] !! molecules(4)%groups_ids = [2] !! molecules(4)%number_of_groups = [6] !! !! model = setup_unifac(molecules) !! !! ! ===================================================================== !! ! Call analytic derivatives !! ! --------------------------------------------------------------------- !! call model%excess_gibbs(n, T, Ge, GeT, GeT2, Gen, GeTn, Gen2) !! !! ! ===================================================================== !! ! Call numeric derivatives !! ! --------------------------------------------------------------------- !! call numeric_ge_derivatives(model, n, T, dn, dt, Ge=Ge_n, GeT=GeT_n) !! call numeric_ge_derivatives(model, n, T, dn, dt, Ge=Ge_n, Gen=Gen_n) !! call numeric_ge_derivatives(model, n, T, dn, dt, Ge=Ge_n, GeT2=GeT2_n) !! call numeric_ge_derivatives(model, n, T, dn, dt, Ge=Ge_n, GeTn=GeTn_n) !! call numeric_ge_derivatives(model, n, T, dn, dt, Ge=Ge_n, Gen2=Gen2_n) !! ``` !! class ( GeModel ), intent ( in ) :: model !! G&#94;E model real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( in ) :: d_n !! Moles finite difference step real ( pr ), intent ( in ) :: d_t !! Temperature finite difference step real ( pr ), intent ( out ) :: Ge !! Residual Helmoltz energy real ( pr ), optional , intent ( out ) :: GeT !! \\frac{dGe}{dT} real ( pr ), optional , intent ( out ) :: Gen ( size ( n )) !! \\frac{dGe}{dn_i} real ( pr ), optional , intent ( out ) :: GeT2 !! \\frac{d&#94;2Ge}{dT&#94;2} real ( pr ), optional , intent ( out ) :: GeTn ( size ( n )) !! \\frac{d&#94;2Ge}{dTdn_i} real ( pr ), optional , intent ( out ) :: Gen2 ( size ( n ), size ( n )) !! \\frac{d&#94;2Ge}{dn_{ij}} ! Auxiliary real ( pr ) :: Ge_aux1 , Ge_aux2 , Ge_aux3 , Ge_aux4 real ( pr ) :: dn_aux1 ( size ( n )), dn_aux2 ( size ( n )) integer :: i , j ! ======================================================================== ! Ar valuations ! ------------------------------------------------------------------------ ! on point valuation call model % excess_gibbs ( n , t , Ge = Ge ) ! ======================================================================== ! Central numeric derivatives ! ------------------------------------------------------------------------ ! Temperature if ( present ( GeT ) . or . present ( GeT2 )) then call model % excess_gibbs ( n , t + d_t , Ge = Ge_aux1 ) call model % excess_gibbs ( n , t - d_t , Ge = Ge_aux2 ) if ( present ( GeT )) GeT = ( Ge_aux1 - Ge_aux2 ) / ( 2 * d_t ) if ( present ( GeT2 )) GeT2 = ( Ge_aux1 - 2 * Ge + Ge_aux2 ) / d_t ** 2 end if ! Mole first derivatives if ( present ( Gen )) then Gen = 0.0_pr do i = 1 , size ( n ), 1 dn_aux1 = 0.0_pr dn_aux1 ( i ) = d_n call model % excess_gibbs ( n + dn_aux1 , t , Ge = Ge_aux1 ) call model % excess_gibbs ( n - dn_aux1 , t , Ge = Ge_aux2 ) Gen ( i ) = ( Ge_aux1 - Ge_aux2 ) / ( 2 * d_n ) end do end if ! ======================================================================== ! Central cross derivatives ! ------------------------------------------------------------------------ ! Temperature - Mole if ( present ( GeTn )) then GeTn = 0.0_pr do i = 1 , size ( n ), 1 dn_aux1 = 0.0_pr dn_aux1 ( i ) = d_n call model % excess_gibbs ( n + dn_aux1 , t + d_t , Ge = Ge_aux1 ) call model % excess_gibbs ( n + dn_aux1 , t - d_t , Ge = Ge_aux2 ) call model % excess_gibbs ( n - dn_aux1 , t + d_t , Ge = Ge_aux3 ) call model % excess_gibbs ( n - dn_aux1 , t - d_t , Ge = Ge_aux4 ) GeTn ( i ) = & ( Ge_aux1 - Ge_aux2 - Ge_aux3 + Ge_aux4 ) / ( 4 * d_t * d_n ) end do end if ! Mole second derivatives if ( present ( Gen2 )) then Gen2 = 0.0_pr do i = 1 , size ( n ), 1 do j = 1 , size ( n ), 1 if ( i . eq . j ) then dn_aux1 = 0.0_pr dn_aux1 ( i ) = d_n call model % excess_gibbs ( n + dn_aux1 , t , Ge = Ge_aux1 ) call model % excess_gibbs ( n - dn_aux1 , t , Ge = Ge_aux2 ) Gen2 ( i , j ) = ( Ge_aux1 - 2 * Ge + Ge_aux2 ) / d_n ** 2 else dn_aux1 = 0.0_pr dn_aux2 = 0.0_pr dn_aux1 ( i ) = d_n dn_aux2 ( j ) = d_n call model % excess_gibbs ( n + dn_aux1 + dn_aux2 , t , Ge = Ge_aux1 ) call model % excess_gibbs ( n + dn_aux1 - dn_aux2 , t , Ge = Ge_aux2 ) call model % excess_gibbs ( n - dn_aux1 + dn_aux2 , t , Ge = Ge_aux3 ) call model % excess_gibbs ( n - dn_aux1 - dn_aux2 , t , Ge = Ge_aux4 ) Gen2 ( i , j ) = & ( Ge_aux1 - Ge_aux2 - Ge_aux3 + Ge_aux4 ) / ( 4 * d_n ** 2 ) end if end do end do end if end subroutine numeric_ge_derivatives end module yaeos__consistency_gemodel","tags":"","url":"sourcefile/consistency_gemodel.f90.html"},{"title":"equilibria.f90 – yaeos","text":"Source Code module yaeos__equilibria !! Module to handle phase equilibria calculations. ! Stability analysis use yaeos__equilibria_stability , only : tm , min_tpd ! Equilibrium State definitions use yaeos__equilibria_equilibrium_state , only : EquilibriumState ! Phase split calculations use yaeos__equilibria_flash , only : flash ! Saturation points use yaeos__equilibria_saturation_points , only :& saturation_pressure , saturation_temperature ! Critical points use yaeos__equilibria_critical , only : & critical_line , CriticalLine , critical_point , spec_CP use yaeos__equilibria_binaries , only : & find_llcl ! Extra use yaeos__equilibria_auxiliar , only : k_wilson , p_wilson ! Phase equilibria boundaries use yaeos__equilibria_boundaries_pure_saturation , only : & PurePsat , pure_saturation_line use yaeos__equilibria_boundaries_phase_envelopes_px , only : & PXEnvel2 , px_envelope_2ph use yaeos__equilibria_boundaries_phase_envelopes_tx , only : & TXEnvel2 , tx_envelope_2ph use yaeos__equilibria_boundaries_phase_envelopes_pt , only : & PTEnvel2 , pt_envelope_2ph , find_hpl use yaeos__equilibria_boundaries_phase_envelopes_pt3 , only : & PTEnvel3 , pt_envelope_3ph use yaeos__equilibria_boundaries_phase_envelopes_px3 , only : & PXEnvel3 , PX_envelope_3ph use yaeos__equilibria_boundaries_phase_envelopes_mp , only : & PTEnvelMP , pt_envelope use yaeos__equilibria_boundaries_phase_envelopes_mp_px , only : & PXEnvelMP , px_envelope use yaeos__equilibria_boundaries_phase_envelopes_mp_tx , only : & TXEnvelMP , tx_envelope end module yaeos__equilibria","tags":"","url":"sourcefile/equilibria.f90.html"},{"title":"alphas.f90 – yaeos","text":"Source Code module yaeos__models_ar_cubic_alphas !! \\alpha functions defined in the library. use yaeos__constants , only : pr use yaeos__substance , only : substances use yaeos__models_ar_genericcubic , only : CubicEoS , AlphaFunction implicit none type , extends ( AlphaFunction ) :: AlphaSoave !! Soave \\alpha function. !!  \\alpha(T_r) = (1 + k (1 - \\sqrt{Tr}))&#94;2  real ( pr ), allocatable :: k (:) !! k parameter. contains procedure :: alpha !! Alpha function end type AlphaSoave type , extends ( AlphaFunction ) :: AlphaRKPR !! RKPR \\alpha function !!  !! \\alpha(T_r) = \\left(\\frac{3}{2 + T_r}\\right)&#94;k !!  real ( pr ), allocatable :: k (:) !! k parameter. contains procedure :: alpha => alpha_rkpr end type AlphaRKPR type , extends ( AlphaFunction ) :: AlphaMathiasCopeman !! Mathias Copeman \\alpha function. real ( pr ), allocatable :: c1 (:) real ( pr ), allocatable :: c2 (:) real ( pr ), allocatable :: c3 (:) contains procedure :: alpha => alpha_mc end type AlphaMathiasCopeman contains subroutine alpha ( self , Tr , a , dadt , dadt2 ) !! Soave \\alpha function and it's derivatives. class ( AlphaSoave ), intent ( in ) :: self real ( pr ), intent ( in ) :: Tr (:) !! Reduced temperature real ( pr ), intent ( out ) :: a (:) !! \\alpha real ( pr ), intent ( out ) :: dadt (:) !! \\frac{d\\alpha}{dT} real ( pr ), intent ( out ) :: dadt2 (:) !! \\frac{d&#94;2\\alpha}{dT&#94;2} associate ( k => self % k ) a = ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 dadT = k * ( k * ( sqrt ( Tr ) - 1 ) - 1 ) / sqrt ( Tr ) dadT2 = ( 1.0_pr / 2.0_pr ) * k * ( k + 1 ) / Tr ** ( 1.5_pr ) end associate end subroutine alpha subroutine alpha_rkpr ( self , Tr , a , dadt , dadt2 ) class ( AlphaRKPR ), intent ( in ) :: self real ( pr ), intent ( in ) :: Tr (:) !! Reduced temperature real ( pr ), intent ( out ) :: a (:) !! \\alpha real ( pr ), intent ( out ) :: dadt (:) !! \\frac{d\\alpha}{dT} real ( pr ), intent ( out ) :: dadt2 (:) !! \\frac{d&#94;2\\alpha}{dT&#94;2} associate ( k => self % k ) a = ( 3 / ( 2 + Tr )) ** k dadT = - k * a / ( 2 + Tr ) dadT2 = - ( k + 1 ) * dadT / ( 2 + Tr ) end associate end subroutine alpha_rkpr subroutine alpha_mc ( self , Tr , a , dadt , dadt2 ) !! MathiasCopeman alpha function definition class ( AlphaMathiasCopeman ), intent ( in ) :: self real ( pr ), intent ( in ) :: Tr (:) real ( pr ), intent ( out ) :: a (:), dadt (:), dadt2 (:) real ( pr ) :: sqrt_Tr ( size ( Tr )) real ( pr ) :: u ( size ( Tr )), dudt ( size ( Tr )), dudt2 ( size ( Tr )) sqrt_Tr = 1 - sqrt ( Tr ) ! The associate statement allows to abreviate the expresions associate ( c1 => self % c1 , c2 => self % c2 , c3 => self % c3 ) where ( Tr > 1 ) a = ( 1 + c1 * ( 1 - sqrt ( Tr ))) ** 2 dadT = c1 * ( c1 * ( sqrt ( Tr ) - 1 ) - 1 ) / sqrt ( Tr ) dadT2 = ( 1.0_pr / 2.0_pr ) * c1 * ( c1 + 1 ) / Tr ** ( 1.5_pr ) elsewhere u = - c1 * ( sqrt ( Tr ) - 1 ) + c2 * ( sqrt ( Tr ) - 1 ) ** 2 - c3 * ( sqrt ( Tr ) - 1 ) ** 3 + 1 dudt = ( 1.0_pr / 2.0_pr ) * ( - c1 + 2 * c2 * ( sqrt ( Tr ) - 1 ) - 3 * c3 * ( sqrt ( Tr ) - 1 ) ** 2 ) / sqrt ( Tr ) dudt2 = ( 1.0_pr / 4.0_pr ) * ( - 3 * Tr * c3 + c1 + 2 * c2 + 3 * c3 ) / Tr ** ( 3.0_pr / 2.0_pr ) a = u ** 2 dadt = 2 * u * dudt dadt2 = 2 * ( dudt ** 2 + u * dudt2 ) end where end associate end subroutine alpha_mc end module yaeos__models_ar_cubic_alphas","tags":"","url":"sourcefile/alphas.f90.html"},{"title":"base.f90 – yaeos","text":"Source Code module yaeos__models_ar_cubic_mixing_base !! # Mixing rules core math !! Procedures of the core calculations of CubicEoS mixing rules. !! !! # Description !! This module holds all the basic math to use mixing rules in other codes. !! Keeping it simple and accesible. !! !! # Examples !! !! ```fortran !! bi = [0.2, 0.3] !! lij = reshape([0.0, 0.2, 0.2, 0], [2,2]) !! !! ! Calculate B parameter with Quadratric Mixing Rules. !! call bmix_qmr(n, bi, lij, b, dbi, dbij) !! !! ``` !! !! # References use yaeos__constants , only : pr , solving_volume implicit none contains pure subroutine bmix_linear ( n , bi , b , dbi , dbij ) real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: bi (:) real ( pr ), intent ( out ) :: b , dbi (:), dbij (:, :) b = sum ( n * bi ) dbi = bi dbij = 0 end subroutine bmix_linear pure subroutine bmix_qmr ( n , bi , lij , b , dbi , dbij ) real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: bi (:) real ( pr ), intent ( in ) :: lij (:, :) real ( pr ), intent ( out ) :: b , dbi (:), dbij (:, :) real ( pr ) :: bij ( size ( n ), size ( n )) real ( pr ) :: totn , aux ( size ( n )) integer :: i , j , nc nc = size ( n ) TOTN = sum ( n ) B = 0 dBi = 0 dBij = 0 aux = 0 do i = 1 , nc do j = 1 , nc bij ( i , j ) = 0.5_pr * ( bi ( i ) + bi ( j )) * ( 1.0_pr - lij ( i , j )) aux ( i ) = aux ( i ) + n ( j ) * bij ( i , j ) end do B = B + n ( i ) * aux ( i ) end do B = B / totn if ( solving_volume ) return do i = 1 , nc dBi ( i ) = ( 2 * aux ( i ) - B ) / totn do j = 1 , i dBij ( i , j ) = ( 2 * bij ( i , j ) - dBi ( i ) - dBi ( j )) / totn dBij ( j , i ) = dBij ( i , j ) end do end do end subroutine bmix_qmr pure subroutine d1mix_rkpr ( n , d1i , d1 , dd1i , dd1ij ) !! RKPR \\delta_1 parameter mixing rule. !! !! The RKPR EoS doesn't have a constant \\delta_1 value for each !! component, so a proper mixing rule should be provided. A linear !! combination is used. !! !!  !!     \\Delta_1 = \\sum_i&#94;N n_i \\delta_{1i} !!  !! real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: d1i (:) real ( pr ), intent ( out ) :: D1 real ( pr ), intent ( out ) :: dD1i (:) real ( pr ), intent ( out ) :: dD1ij (:, :) integer :: i , j , nc real ( pr ) :: totn nc = size ( n ) totn = sum ( n ) D1 = sum ( n * d1i ) / totn if ( solving_volume ) return do i = 1 , nc dD1i ( i ) = ( d1i ( i ) - D1 ) / totn do j = 1 , nc dD1ij ( i , j ) = ( 2 * D1 - d1i ( i ) - d1i ( j )) / totn ** 2 end do end do end subroutine d1mix_rkpr subroutine lamdba_hv ( d1 , dd1i , dd1ij , L , dLi , dLij ) !! Infinite pressure limit parameter \\Lambda !! !!  !! \\Lambda = \\frac{1}{\\delta_1 + \\delta_2} \\ln \\frac{1 + \\delta_1}{1 + \\delta_2} !!  real ( pr ), intent ( in ) :: d1 real ( pr ), intent ( in ) :: dd1i (:) real ( pr ), intent ( in ) :: dd1ij (:, :) real ( pr ), intent ( out ) :: L real ( pr ), intent ( out ) :: dLi (:) real ( pr ), intent ( out ) :: dLij (:, :) real ( pr ) :: f , g , h real ( pr ), dimension ( size ( dd1i )) :: df , dg , dh real ( pr ), dimension ( size ( dd1i ), size ( dd1i )) :: d2f , d2g , d2h integer :: i , j , nc nc = size ( dd1i ) f = d1 + 1 g = ( d1 + 1 ) * d1 + d1 - 1 h = log (( d1 + 1 ) ** 2 / 2 ) L = f / g * h if ( solving_volume ) return df = dd1i dg = 2 * ( d1 + 1 ) * dd1i dh = 2 * dd1i / ( d1 + 1 ) dLi = f / g * dh - f * h * dg / g ** 2 + h * df / g do concurrent ( i = 1 : nc , j = 1 : nc ) d2f ( i , j ) = dd1ij ( i , j ) d2g ( i , j ) = 2 * dd1ij ( i , j ) * ( d1 + 1 ) + 2 * dd1i ( i ) * dd1i ( j ) d2h ( i , j ) = 2 * ( dd1ij ( i , j ) / ( d1 + 1 ) - dd1i ( i ) * dd1i ( j ) / ( d1 + 1 ) ** 2 ) end do ! This derivative probably could be simplifyied do concurrent ( i = 1 : nc , j = 1 : nc ) dLij ( i , j ) = & f * d2h ( i , j ) / g - & f * h * d2g ( i , j ) / g ** 2 - & f * dg ( i ) * dh ( j ) / g ** 2 - & f * dg ( j ) * dh ( i ) / g ** 2 + & 2 * f * h * dg ( i ) * dg ( j ) / g ** 3 + & h * d2f ( i , j ) / g + & df ( i ) * dh ( j ) / g + & df ( j ) * dh ( i ) / g - & h * df ( i ) * dg ( j ) / g ** 2 - & h * df ( j ) * dg ( i ) / g ** 2 end do end subroutine lamdba_hv end module yaeos__models_ar_cubic_mixing_base","tags":"","url":"sourcefile/base.f90~3.html"},{"title":"saturations_points.f90 – yaeos","text":"Source Code module yaeos__equilibria_saturation_points use yaeos__constants , only : pr , R use yaeos__models , only : ArModel use yaeos__equilibria_equilibrium_state , only : EquilibriumState use yaeos__equilibria_auxiliar , only : k_wilson , P_wilson use ieee_arithmetic , only : ieee_is_nan , ieee_is_finite implicit none real ( pr ) :: tol = 1e-6_pr integer :: max_iterations = 2000 integer :: iters_first_step = 15 real ( pr ) :: step_tol = 0.1_pr contains type ( EquilibriumState ) function saturation_pressure ( model , n , t , kind , p0 , y0 , max_iters ) !! # saturation_pressure !! !! Saturation pressure calculation function. !! !! ## Description !! Calculates the saturation pressure of a multicomponent mixture with !! a given molar composition `n`. !! It is possible to calculate: !! !! - Bubble point: `kind=\"bubble\"` !! - Dew point: `kind=\"dew\"` !! - Liquid-Liquid point: `kind=\"liquid-liquid\"` !! !! It will first try to converge a solution using a 1D Newton method to !! solve the equation !!  !!    f(P) = \\sum_i z_i K_i - 1 = 0 !!  !! !! updating K_i at each step as the ratio of fugacities of the phases. !! If the solution does not converge, it will use a full Newton method to !! solve the system of equations using the variables K_i and \\ln P. use yaeos__auxiliar , only : optval use yaeos__m_s_sp , only : solve_TP class ( ArModel ), target , intent ( in ) :: model real ( pr ), intent ( in ) :: n (:) !! Composition vector [moles / molar fraction] real ( pr ), intent ( in ) :: t !! Temperature [K] character ( len =* ), intent ( in ) :: kind !! [bubble|dew|liquid-liquid] real ( pr ), optional , intent ( in ) :: p0 !! Initial pressure [bar] real ( pr ), optional , intent ( in ) :: y0 (:) !! Initial composition integer , optional , intent ( in ) :: max_iters !! Maximum number of iterations real ( pr ) :: P real ( pr ) :: k ( size ( n )), y ( size ( n )), z ( size ( n )), lnk ( size ( n )) real ( pr ) :: lnfug_y ( size ( n )), dlnphi_dp_y ( size ( n )) real ( pr ) :: lnfug_z ( size ( n )), dlnphi_dp_z ( size ( n )) real ( pr ) :: Vz , Vy character ( len = 50 ) :: incipient character ( len = 50 ) :: main real ( pr ) :: f , step integer :: its , iterations ! ======================================================================= ! Handle arguments ! ----------------------------------------------------------------------- z = n / sum ( n ) if ( present ( p0 )) then p = p0 else P = p_wilson ( model , z , T ) end if if ( present ( y0 )) then y = y0 else y = z * k_wilson ( model , T , P ) end if iterations = optval ( max_iters , max_iterations ) select case ( kind ) case ( \"bubble\" ) k = y / z incipient = \"vapor\" main = \"liquid\" case ( \"dew\" ) k = z / y incipient = \"liquid\" main = \"vapor\" case ( \"liquid-liquid\" ) k = y / z incipient = \"liquid\" main = \"liquid\" end select where ( z == 0 ) k = 0 end where ! ======================================================================== ! ======================================================================== !  Solve point ! ------------------------------------------------------------------------ do its = 1 , iters_first_step y = k * z call model % lnphi_pt ( y , P , T , vy , incipient , lnPhi = lnfug_y , dlnphidp = dlnphi_dp_y ) call model % lnphi_pt ( z , P , T , vz , main , lnPhi = lnfug_z , dlnphidp = dlnphi_dp_z ) k = exp ( lnfug_z - lnfug_y ) if ( all ( k < 1e-9_pr ) . or . all ( abs ( k - 1 ) < tol )) exit f = sum ( z * k ) - 1 step = f / sum ( z * k * ( dlnphi_dp_z - dlnphi_dp_y )) do while ( P - step < 0 . or . abs ( step ) > 0.1 * P ) step = step / 2 end do p = p - step if ( abs ( step ) < tol . and . abs ( f ) < tol ) exit end do ! ======================================================================== if ( its > iters_first_step ) then block real ( pr ) :: X ( size ( n ) + 2 ), S integer :: ns , nc nc = size ( n ) X (: nc ) = log ( y / z ) X ( nc + 1 ) = log ( T ) X ( nc + 2 ) = log ( P ) ns = nc + 1 S = X ( ns ) call solve_TP ( model , kind , z , X , ns , S , tol , max_iterations , its ) P = exp ( X ( nc + 2 )) y = z * exp ( X (: nc )) call model % volume ( n = n , P = P , T = T , V = Vz , root_type = main ) call model % volume ( n = y , P = P , T = T , V = Vy , root_type = incipient ) end block end if select case ( kind ) case ( \"bubble\" ) saturation_pressure = EquilibriumState ( kind = \"bubble\" , & iters = its , y = y , x = z , vx = vz , vy = vy , t = t , p = p , beta = 0._pr & ) case ( \"dew\" ) saturation_pressure = EquilibriumState ( kind = \"dew\" , & iters = its , x = y , y = z , vy = vz , vx = vy , t = t , p = p , beta = 1._pr & ) case ( \"liquid-liquid\" ) saturation_pressure = EquilibriumState ( kind = \"liquid-liquid\" , & iters = its , y = y , x = z , vx = vz , vy = vy , t = t , p = p , beta = 0._pr & ) end select end function saturation_pressure type ( EquilibriumState ) function saturation_temperature ( model , n , p , kind , t0 , y0 , max_iters ) !! Saturation temperature calculation function. !! !! Calculates the saturation pressure of a multicomponent mixture with !! a given molar composition `n`. !! It is possible to calculate: !! !! - Bubble point: `kind=\"bubble\"` !! - Dew point: `kind=\"dew\"` !! - Liquid-Liquid point: `kind=\"liquid-liquid\"` !! It will first try to converge a solution using a 1D Newton method to !! solve the equation !!  !!    f(P) = \\sum_i z_i K_i - 1 = 0 !!  !! !! updating K_i at each step as the ratio of fugacities of the phases. !! If the solution does not converge, it will use a full Newton method to !! solve the system of equations using the variables K_i and \\ln T. use yaeos__auxiliar , only : optval use yaeos__m_s_sp , only : solve_TP class ( ArModel ), target , intent ( in ) :: model real ( pr ), intent ( in ) :: n (:) !! Composition vector [moles / molar fraction] real ( pr ), intent ( in ) :: p !! Pressure [bar] character ( len =* ), intent ( in ) :: kind !! [bubble|dew|liquid-liquid] real ( pr ), optional , intent ( in ) :: t0 !! Initial temperature [K] real ( pr ), optional , intent ( in ) :: y0 (:) !! Initial composition integer , optional , intent ( in ) :: max_iters !! Maximum number of iterations real ( pr ) :: t , vy , vz real ( pr ) :: k ( size ( n )), y ( size ( n )), z ( size ( n )), lnk ( size ( n )) real ( pr ) :: lnfug_y ( size ( n )), dlnphi_dt_y ( size ( n )) real ( pr ) :: lnfug_z ( size ( n )), dlnphi_dt_z ( size ( n )) character ( len = 50 ) :: incipient character ( len = 50 ) :: main real ( pr ) :: f , step integer :: its , iterations logical :: is_incipient ( size ( n )) ! ======================================================================= ! Handle arguments ! ----------------------------------------------------------------------- is_incipient = . true . z = n / sum ( n ) if ( present ( t0 )) then t = t0 else t = 25 0._pr end if if ( present ( y0 )) then y = y0 else y = z * k_wilson ( model , T , P ) end if iterations = optval ( max_iters , max_iterations ) select case ( kind ) case ( \"bubble\" ) k = y / z incipient = \"vapor\" main = \"liquid\" case ( \"dew\" ) k = z / y incipient = \"liquid\" main = \"vapor\" case ( \"liquid-liquid\" ) k = y / z incipient = \"liquid\" main = \"liquid\" end select where ( z == 0 ) k = 0 end where where ( y == 0 ) is_incipient = . false . end where ! ======================================================================== !  Solve point ! ------------------------------------------------------------------------ do its = 1 , 5 y = k * z where (. not . is_incipient ) y = 0 endwhere call model % lnphi_pt ( y , P , T , vy , incipient , lnPhi = lnfug_y , dlnphidt = dlnphi_dt_y ) call model % lnphi_pt ( z , P , T , vz , main , lnPhi = lnfug_z , dlnphidt = dlnphi_dt_z ) k = exp ( lnfug_z - lnfug_y ) f = sum ( z * k ) - 1 step = f / sum ( T * z * k * ( dlnphi_dt_z - dlnphi_dt_y )) if (. not . ieee_is_finite ( step ) . or . ieee_is_nan ( step )) exit do while ( T - step < 0 ) if ( isnan ( step )) step = 10 step = step / 2 end do t = t - step if ( abs ( step ) < tol . and . abs ( f ) < tol ) exit end do ! ======================================================================== its = iters_first_step if ( its >= iters_first_step ) then block real ( pr ) :: X ( size ( n ) + 2 ), S integer :: ns , nc nc = size ( n ) X (: nc ) = log ( y / z ) X ( nc + 1 ) = log ( T ) X ( nc + 2 ) = log ( P ) ns = nc + 2 S = X ( ns ) call solve_TP ( model , kind , z , X , ns , S , tol , max_iterations , its ) T = exp ( X ( nc + 1 )) y = z * exp ( X (: nc )) call model % volume ( n = n , P = P , T = T , V = Vz , root_type = main ) call model % volume ( n = y , P = P , T = T , V = Vy , root_type = incipient ) end block end if select case ( kind ) case ( \"bubble\" ) saturation_temperature = EquilibriumState ( kind = \"bubble\" , & iters = its , y = y , x = z , vx = vz , vy = vy , t = t , p = p , beta = 0._pr & ) case ( \"dew\" ) saturation_temperature = EquilibriumState ( kind = \"dew\" , & iters = its , x = y , y = z , vy = vz , vx = vy , t = t , p = p , beta = 1._pr & ) case ( \"liquid-liquid\" ) saturation_temperature = EquilibriumState ( kind = \"liquid-liquid\" , & iters = its , y = y , x = z , vx = vz , vy = vy , t = t , p = p , beta = 0._pr & ) end select end function saturation_temperature end module yaeos__equilibria_saturation_points","tags":"","url":"sourcefile/saturations_points.f90.html"},{"title":"auxiliar.f90 – yaeos","text":"Source Code module yaeos__equilibria_auxiliar !! Auxiliar functions used for phase-equilibria calculation. use yaeos__constants , only : pr use yaeos__models_base , only : BaseModel implicit none contains function k_wilson ( model , T , P ) result ( K ) !! # K_wilson !! !! ## Description !! K-factors regression done by Wilson, used for initialization. class ( BaseModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: T real ( pr ), intent ( in ) :: P real ( pr ) :: K ( size ( model % components % pc )) K = ( model % components % Pc / P ) & * exp ( 5.373_pr * ( 1 + model % components % w )& * ( 1 - model % components % Tc / T )) end function k_wilson real ( pr ) function P_wilson ( model , z , T ) result ( P ) !! # P_wilson !! !! ## Description !! Calculate the pressure at a given T of a mixture using the Wilson !! equation. class ( BaseModel ), intent ( in ) :: model !! Model of the mixture. real ( pr ), intent ( in ) :: z (:) !! Mole fractions of the components. real ( pr ), intent ( in ) :: T !! Temperature [K]. P = 1.0_pr / sum (& z * model % components % Pc & * exp ( 5.373_pr & * ( 1 + model % components % w ) * ( 1 - model % components % Tc / T ))) end function P_wilson end module yaeos__equilibria_auxiliar","tags":"","url":"sourcefile/auxiliar.f90.html"},{"title":"constants.f90 – yaeos","text":"Source Code module yaeos__constants !! Constants used on the whole package use iso_fortran_env , only : real32 , real64 , real128 implicit none integer , parameter :: pr = real64 !! Used precision real ( pr ), parameter :: R = 0.08314462618_pr !! Ideal Gas constant [bar L / (mol K)] character ( len = 254 ) :: database_path = \"database\" !! Path to find database character ( len = 1 ) :: path_sep = \"/\" !! File separator (to preprocess on Win or Mac/linux) real ( pr ), parameter :: NOT_IMPLEMENTED = huge ( R ) logical :: solving_volume = . false . end module","tags":"","url":"sourcefile/constants.f90.html"},{"title":"phase_envelopes_pt_3ph.f90 – yaeos","text":"Source Code module yaeos__equilibria_boundaries_phase_envelopes_pt3 use yaeos__constants , only : pr , R use yaeos__equilibria_equilibrium_state , only : EquilibriumState use yaeos__models_ar , only : ArModel use yaeos__math , only : solve_system implicit none private public :: PTEnvel3 public :: pt_envelope_3ph public :: solve_point public :: get_values_from_X type :: PTEnvel3 integer , allocatable :: its (:) !! Number of needed iterations real ( pr ), allocatable :: beta (:) !! Mole fraction between phase x and phase y real ( pr ), allocatable :: x (:, :) !! Mole fraction of phase x real ( pr ), allocatable :: y (:, :) !! Mole fraction of phase x real ( pr ), allocatable :: w (:, :) !! Mole fraction of phase x real ( pr ), allocatable :: P (:) !! Pressures [bar] real ( pr ), allocatable :: T (:) !! Temperatures [K] integer , allocatable :: ns (:) !! Number of specified variable real ( pr ), allocatable :: S (:) !! Value of specification end type PTEnvel3 real ( pr ), parameter :: lnK_min = 2.0_pr contains type ( PTEnvel3 ) function pt_envelope_3ph (& model , z , x0 , y0 , w0 , beta0 , P0 , T0 , ns0 , dS0 , & points & ) result ( envelope ) class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( in ) :: x0 (:) real ( pr ), intent ( in ) :: y0 (:) real ( pr ), intent ( in ) :: w0 (:) real ( pr ), intent ( in ) :: beta0 real ( pr ), intent ( in ) :: P0 real ( pr ), intent ( in ) :: T0 integer , intent ( in ) :: ns0 real ( pr ), intent ( in ) :: dS0 integer , intent ( in ) :: points real ( pr ) :: kx ( size ( z )) real ( pr ) :: ky ( size ( z )) integer :: i integer :: nc real ( pr ) :: Xvars ( size ( z ) * 2 + 3 ), dX ( size ( z ) * 2 + 3 ) real ( pr ) :: F ( size ( z ) * 2 + 3 ), dF ( size ( z ) * 2 + 3 , size ( z ) * 2 + 3 ) integer :: ns !! Specified variable real ( pr ) :: S !! Specified value real ( pr ) :: dS !! Specified value step for next point extrapolation real ( pr ) :: dXdS ( size ( z ) * 2 + 3 ) real ( pr ) :: x ( points , size ( z )), xi ( size ( z )) real ( pr ) :: y ( points , size ( z )), yi ( size ( z )) real ( pr ) :: w ( points , size ( z )), wi ( size ( z )) real ( pr ) :: beta ( points ) real ( pr ) :: P ( points ) real ( pr ) :: T ( points ) integer :: its , iterations ( points ) integer :: max_iterations max_iterations = 150 nc = size ( z ) ns = ns0 dS = dS0 Kx = x0 / w0 Ky = y0 / w0 Xvars = [ log ( Kx ), log ( Ky ), log ( P0 ), log ( T0 ), beta0 ] S = Xvars ( ns ) allocate ( envelope % S ( 0 ), envelope % ns ( 0 )) ! Let the first point use more iterations call solve_point ( model , z , ns , S , Xvars , F , dF , its , 1000 ) do i = 1 , points call solve_point ( model , z , ns , S , Xvars , F , dF , its , max_iterations ) if ( any ( isnan ( F )) . or . any ( isnan ( Xvars )) . or . its >= max_iterations ) exit envelope % ns = [ envelope % ns , ns ] envelope % S = [ envelope % S , S ] ! Set the values from the X vector. call get_values_from_X ( z , Xvars , xi , yi , wi , P ( i ), T ( i ), beta ( i )) x ( i , :) = xi y ( i , :) = yi w ( i , :) = wi iterations ( i ) = its call update_specification ( its , Xvars , dF , dXdS , ns , dS ) call detect_critical ( Xvars , dXdS , ns , S , dS ) dX = dXdS * dS Xvars = Xvars + dX S = Xvars ( ns ) end do i = i - 1 envelope % x = x (: i , :) envelope % y = y (: i , :) envelope % w = w (: i , :) envelope % P = P (: i ) envelope % T = T (: i ) envelope % beta = beta (: i ) envelope % its = iterations (: i ) end function pt_envelope_3ph subroutine get_values_from_X ( z , Xvars , x , y , w , P , T , beta ) real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( in ) :: Xvars ( size ( z ) * 2 + 3 ) real ( pr ), intent ( out ) :: x ( size ( z )) real ( pr ), intent ( out ) :: y ( size ( z )) real ( pr ), intent ( out ) :: w ( size ( z )) real ( pr ), intent ( out ) :: P real ( pr ), intent ( out ) :: T real ( pr ), intent ( out ) :: beta integer :: nc real ( pr ) :: Kx (( Size ( Xvars ) - 3 ) / 2 ), Ky (( Size ( Xvars ) - 3 ) / 2 ) nc = ( Size ( Xvars ) - 3 ) / 2 Kx = exp ( Xvars ( 1 : nc )) Ky = exp ( Xvars ( nc + 1 : 2 * nc )) P = exp ( Xvars ( 2 * nc + 1 )) T = exp ( Xvars ( 2 * nc + 2 )) beta = Xvars ( 2 * nc + 3 ) w = z / ( beta * Ky + ( 1 - beta ) * Kx ) x = w * Kx y = w * Ky end subroutine get_values_from_X subroutine update_specification ( its , X , dF , dXdS , ns , dS ) integer , intent ( in ) :: its real ( pr ), intent ( in out ) :: X (:) real ( pr ), intent ( in out ) :: dF (:, :) real ( pr ), intent ( in out ) :: dXdS (:) integer , intent ( in out ) :: ns real ( pr ), intent ( in out ) :: dS integer :: nc real ( pr ) :: dFdS ( size ( X )) integer :: first_set (( size ( X ) - 3 ) / 2 ), second_set (( size ( X ) - 3 ) / 2 ), idx (( size ( X ) - 3 ) / 2 ) integer :: i nc = ( size ( X ) - 3 ) / 2 first_set = [( i , i = 1 , nc )] second_set = [( i , i = nc + 1 , 2 * nc )] dFdS = 0 dFdS ( size ( X )) = - 1 dXdS = solve_system ( dF , - dFdS ) if ( all ( abs ( X ( first_set )) < 0.4 )) then ns = maxloc ( abs ( dXdS ( first_set )), dim = 1 ) else if ( all ( abs ( X ( second_set )) < 0.4 )) then ns = maxloc ( abs ( dXdS ( second_set )), dim = 1 ) + nc else ns = maxloc ( abs ( dXdS ), dim = 1 ) end if dXdS = solve_system ( dF , - dFdS ) dXdS = solve_system ( dF , - dFdS ) dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) dS = dS * 3._pr / its do while ( abs ( dS / X ( ns )) < 1e-1 ) dS = 2 * dS end do end subroutine update_specification subroutine detect_critical ( X , dXdS , ns , S , dS ) !! # `detect_critical` !! Critical point detection !! !! # Description !! If the values of lnK (X[:nc]) change sign then a critical point !! Has passed, since for this to happen all variables should pass !! through zero. Near critical points (lnK < 0.05) points are harder !! to converge, so more steps in the extrapolation vector are made to !! jump over the critical point. !! If the critical point is detected then the kind of the point is !! changed and the point is saved using an interpolation knowing that !! !!  !!   X_c = a * X + (1-a)*X_{new} !!  !! !! With X_c is the variables at the critical point, X_{new} !! is the new initialization point of the method and a is the !! parameter to interpolate the values. This subroutine finds the !! value of  a to obtain X_c. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables real ( pr ), intent ( in out ) :: dXdS (:) !! Variation of variables wrt S integer , intent ( in out ) :: ns !! Number of specified variable real ( pr ), intent ( in out ) :: S !! Specification value real ( pr ), intent ( in out ) :: dS !! Step in specification real ( pr ) :: Xc ( size ( X )) !! Value at (near) critical point real ( pr ) :: a !! Parameter for interpolation real ( pr ) :: Xold ( size ( X )) !! Old value of X real ( pr ) :: Xnew ( size ( X )) !! Value of the next initialization logical :: found_critical integer :: nc integer :: first_set (( size ( X ) - 3 ) / 2 ), second_set (( size ( X ) - 3 ) / 2 ), idx (( size ( X ) - 3 ) / 2 ) integer :: i , critical_set (( size ( X ) - 3 ) / 2 ) real ( pr ) :: step ( size ( X )) nc = ( size ( X ) - 3 ) / 2 first_set = [( i , i = 1 , nc )] second_set = [( i , i = nc + 1 , 2 * nc )] Xold = X Xnew = X + dXdS * dS found_critical = . false . do i = 1 , 2 select case ( i ) case ( 1 ) idx = first_set case ( 2 ) idx = second_set end select do while ( maxval ( abs ( Xnew ( idx ))) < 0.4 ) Xnew = Xnew + dXdS * dS end do if ( all ( Xnew ( idx ) * Xold ( idx ) < 0 )) then ! If two steps imply the crossing of a critical point, then ! make those two steps to avoid falling into it found_critical = . true . critical_set = idx Xnew = Xnew + dXdS * dS end if end do if ( found_critical ) then a = critical_interpol ( Xnew , Xold , critical_set ) Xc = a * Xold + ( 1 - a ) * Xnew ! Xnew = Xc ! do while(maxval(abs(Xnew(idx))) < 0.5) !    Xnew = Xnew + dXdS*dS ! end do X = X + ( Xnew - Xold ) end if end subroutine detect_critical real ( pr ) function critical_interpol ( Xnew , Xold , idx ) result ( a ) !! # `critical_interpol` !! Critical point interpolation !! !! # Description !! This function calculates the parameter a to interpolate the !! values of the variables at the critical point. The interpolation !! is done using the equation: !! !!  !!   0 = a*X_{old}(ns) + (1-a)*X_{new}(ns) !!  !! !! Where X_{old} is the old value of the variables and X_{new} !! is the new value of the variables. The critical point is the point !! where the variables change sign, so the interpolation is done to !! find the value of the variables at the critical point. real ( pr ), intent ( in ) :: Xnew (:) !! New value of the variables real ( pr ), intent ( in ) :: Xold (:) !! Old value of the variables integer , intent ( in ) :: idx (:) !! Index of the variables to interpolate integer :: ncomp ! 0 = a*X(ns) + (1-a)*Xnew(ns) < Interpolation equation to get X(ns) = 0 ! Find the component that is changing sign with the highest slope ncomp = maxloc ( abs ( Xold ( idx ) - Xnew ( idx )), dim = 1 ) a = - Xnew ( ncomp ) / ( Xold ( ncomp ) - Xnew ( ncomp )) end function critical_interpol subroutine pt_F_three_phases ( model , z , Xvars , ns , S , F , dF ) !! Function to solve at each point of a three phase envelope. !! !! The vector of variables X corresponds to: !!  X = [lnKx_i, lnKy_i lnP, lnT, \\beta]  !! !! While the equations are: !! !!  F = [ !!        lnKx_i - ln \\phi_i(x, P, T) + ln \\phi_i(w, P, T), !!        lnKy_i - ln \\phi_i(y, P, T) + ln \\phi_i(w, P, T), !!        \\sum_{i=1}&#94;N (w_i) - 1, !!        \\sum_{i=1}&#94;N (x_i - y_i), !!        X_{ns} - S !! ]  use iso_fortran_env , only : error_unit class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( in ) :: Xvars (:) !! Vector of variables integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( out ) :: F ( size ( Xvars )) !! Vector of functions valuated real ( pr ), intent ( out ) :: df ( size ( Xvars ), size ( Xvars )) !! Jacobian matrix ! Xvars variables real ( pr ) :: Kx (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: Ky (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: P real ( pr ) :: T real ( pr ) :: beta ! Main phase 1 variables real ( pr ) :: Vx real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: x , lnphi_x , dlnphi_dt_x , dlnphi_dp_x real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_x ! Main phase 2 variables real ( pr ) :: Vy real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: y , lnphi_y , dlnphi_dt_y , dlnphi_dp_y real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_y ! Incipient phase variables real ( pr ) :: Vw real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: w , lnphi_w , dlnphi_dt_w , dlnphi_dp_w real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_w ! Derivative of w wrt beta real ( pr ) :: dwdb (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: dwdKx (( Size ( Xvars ) - 3 ) / 2 ), dxdKx (( Size ( Xvars ) - 3 ) / 2 ), dydKx (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: dwdKy (( Size ( Xvars ) - 3 ) / 2 ), dxdKy (( Size ( Xvars ) - 3 ) / 2 ), dydKy (( Size ( Xvars ) - 3 ) / 2 ) integer :: i , j , nc nc = ( size ( Xvars ) - 3 ) / 2 Kx = exp ( Xvars ( 1 : nc )) Ky = exp ( Xvars ( nc + 1 : 2 * nc )) P = exp ( Xvars ( 2 * nc + 1 )) T = exp ( Xvars ( 2 * nc + 2 )) beta = Xvars ( 2 * nc + 3 ) w = z / ( beta * Ky + ( 1 - beta ) * Kx ) x = w * Kx y = w * Ky call model % lnphi_pt (& x , P , T , V = Vx , root_type = \"stable\" , lnphi = lnphi_x , & dlnphidp = dlnphi_dp_x , dlnphidt = dlnphi_dt_x , dlnphidn = dlnphi_dn_x & ) call model % lnphi_pt (& y , P , T , V = Vy , root_type = \"stable\" , lnphi = lnphi_y , & dlnphidp = dlnphi_dp_y , dlnphidt = dlnphi_dt_y , dlnphidn = dlnphi_dn_y & ) call model % lnphi_pt (& w , P , T , V = Vw , root_type = \"stable\" , lnphi = lnphi_w , & dlnphidp = dlnphi_dp_w , dlnphidt = dlnphi_dt_w , dlnphidn = dlnphi_dn_w & ) F = 0 df = 0 F ( 1 : nc ) = Xvars ( 1 : nc ) + lnphi_x - lnphi_w F ( nc + 1 : 2 * nc ) = Xvars ( nc + 1 : 2 * nc ) + lnphi_y - lnphi_w F ( 2 * nc + 1 ) = sum ( w ) - 1 F ( 2 * nc + 2 ) = sum ( x - y ) F ( 2 * nc + 3 ) = Xvars ( ns ) - S dwdb = z * ( Kx - Ky ) / (( 1 - beta ) * Kx + beta * Ky ) ** 2 dwdKx = - z * ( 1 - beta ) / ( Ky * beta + ( 1 - beta ) * Kx ) ** 2 dxdKx = Kx * dwdKx + w dydKx = Ky * dwdKx dwdKy = - z * ( beta ) / ( Ky * beta + ( 1 - beta ) * Kx ) ** 2 dxdKy = Kx * dwdKy dydKy = Ky * dwdKy + w do i = 1 , nc do j = 1 , nc df ( i , j ) = Kx ( j ) * ( dlnphi_dn_x ( i , j ) * dxdKx ( j ) & - dlnphi_dn_w ( i , j ) * dwdKx ( j )) df ( i + nc , j ) = Kx ( j ) * ( dlnphi_dn_y ( i , j ) * dydKx ( j ) & - dlnphi_dn_w ( i , j ) * dwdKx ( j )) df ( i , j + nc ) = Ky ( j ) * ( dlnphi_dn_x ( i , j ) * dxdKy ( j ) & - dlnphi_dn_w ( i , j ) * dwdKy ( j )) df ( i + nc , j + nc ) = Ky ( j ) * ( dlnphi_dn_y ( i , j ) * dydKy ( j ) & - dlnphi_dn_w ( i , j ) * dwdKy ( j )) end do ! dlnK_i/dlnK_i df ( i , i ) = df ( i , i ) + 1 df ( i + nc , i + nc ) = df ( i + nc , i + nc ) + 1 df ( i , 2 * nc + 3 ) = sum ( Kx * dlnphi_dn_x ( i , :) * dwdb - dlnphi_dn_w ( i , :) * dwdb ) df ( i + nc , 2 * nc + 3 ) = sum ( Ky * dlnphi_dn_y ( i , :) * dwdb - dlnphi_dn_w ( i , :) * dwdb ) df ( 2 * nc + 1 , i ) = Kx ( i ) * dwdKx ( i ) df ( 2 * nc + 1 , i + nc ) = Ky ( i ) * dwdKy ( i ) df ( 2 * nc + 2 , i ) = Kx ( i ) * dxdKx ( i ) - Kx ( i ) * dydKx ( i ) df ( 2 * nc + 2 , i + nc ) = Ky ( i ) * dxdKy ( i ) - Ky ( i ) * dydKy ( i ) end do ! Derivatives wrt P df (: nc , 2 * nc + 1 ) = P * ( dlnphi_dp_x - dlnphi_dp_w ) df ( nc + 1 : 2 * nc , 2 * nc + 1 ) = P * ( dlnphi_dp_y - dlnphi_dp_w ) ! Derivatives wrt T df (: nc , 2 * nc + 2 ) = T * ( dlnphi_dt_x - dlnphi_dt_w ) df ( nc + 1 : 2 * nc , 2 * nc + 2 ) = T * ( dlnphi_dt_y - dlnphi_dt_w ) ! Derivatives wrt beta df ( 2 * nc + 1 , 2 * nc + 3 ) = sum ( dwdb ) df ( 2 * nc + 2 , 2 * nc + 3 ) = sum ( Kx * dwdb - Ky * dwdb ) ! Derivatives wrt Xs df ( 2 * nc + 3 , :) = 0 df ( 2 * nc + 3 , ns ) = 1 end subroutine pt_F_three_phases subroutine solve_point ( model , z , ns , S , X , F , dF , its , maxits ) class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( in out ) :: X (:) real ( pr ), intent ( out ) :: F (:) real ( pr ), intent ( out ) :: dF (:,:) integer , intent ( in out ) :: its integer , intent ( in ) :: maxits real ( pr ) :: dX ( size ( X )) integer :: nc , i its = 0 F = 1 dX = 1 nc = ( size ( X ) - 3 ) / 2 do while (( maxval ( abs ( F )) > 1e-10 . and . its < maxits )) its = its + 1 call pt_F_three_phases ( model , z , X , ns , S , F , dF ) dX = solve_system ( dF , - F ) do while ( abs ( dX ( 2 * nc + 1 )) > 1 . or . abs ( dX ( 2 * nc + 2 )) > 1 ) dX = dX / 2 end do X = X + dX end do end subroutine solve_point end module yaeos__equilibria_boundaries_phase_envelopes_pt3","tags":"","url":"sourcefile/phase_envelopes_pt_3ph.f90.html"},{"title":"phase_envelopes_pt.f90 – yaeos","text":"Source Code module yaeos__equilibria_boundaries_phase_envelopes_pt !! Phase boundaries line on the PT plane calculation procedures. use yaeos__constants , only : pr use yaeos__models , only : ArModel use yaeos__equilibria_equilibrium_state , only : EquilibriumState use yaeos__equilibria_auxiliar , only : k_wilson use yaeos__math_continuation , only : & continuation , continuation_solver , continuation_stopper implicit none private public :: PTEnvel2 , pt_envelope_2ph , find_hpl type :: CriticalPoint !! Critical point real ( pr ) :: T !! Temperature [K] real ( pr ) :: P !! Pressure [bar] end type CriticalPoint type :: PTEnvel2 !! Two-phase isopleth. !! Phase boundary line of a fluid at constant composition. type ( EquilibriumState ), allocatable :: points (:) !! Each point through the line. type ( CriticalPoint ), allocatable :: cps (:) !! Critical points found along the line. contains procedure , pass :: write => write_PTEnvel2 generic , public :: write ( FORMATTED ) => write end type PTEnvel2 real ( pr ), parameter :: near_critical_K = 0.01 ! Saved volume values real ( pr ), private :: Vz real ( pr ), private :: Vy contains function pt_envelope_2ph (& model , z , first_point , & points , iterations , delta_0 , specified_variable_0 , & solver , stop_conditions , maximum_pressure & ) result ( envelopes ) !! PT two-phase envelope calculation procedure. !! !! Phase envelope calculation using the continuation method. !! Defaults to solving the saturation temperature and continues with !! an increment in it. The variable to specify can be changed by modifying !! `specified_variable_0` with the corresponding variable number. ! ======================================================================== use yaeos__auxiliar , only : optval class ( ArModel ), intent ( in ) :: model !! Thermodyanmic model real ( pr ), intent ( in ) :: z (:) !! Vector of molar fractions type ( EquilibriumState ), intent ( in ) :: first_point !! Initial point of the envelope integer , optional , intent ( in ) :: points !! Maxmimum number of points, defaults to 500 integer , optional , intent ( in ) :: iterations !! Point solver maximum iterations, defaults to 100 real ( pr ), optional , intent ( in ) :: delta_0 !! Initial extrapolation \\Delta integer , optional , intent ( in ) :: specified_variable_0 !! Position of specified variable, since the vector of variables is !! X = [lnK_i, \\dots, lnT, lnP] the values for specification !! will be [1 \\dots nc] for the equilibria constants, nc+1 for !! lnT and nc + 2 for lnT. procedure ( continuation_solver ), optional :: solver !! Specify solver for each point, defaults to a full newton procedure procedure ( continuation_stopper ), optional :: stop_conditions !! Function that returns true if the continuation method should stop real ( pr ), optional , intent ( in ) :: maximum_pressure !! Maximum pressure to calculate [bar] type ( PTEnvel2 ) :: envelopes ! ------------------------------------------------------------------------ integer :: nc !! Number of components integer :: ns !! Number of specified variable real ( pr ) :: dS0 !! Initial specification step real ( pr ) :: S0 !! Initial specification value integer :: max_points !! Maximum number of points integer :: max_iterations !! Maximum number of iterations real ( pr ) :: X ( size ( z ) + 2 ) !! Vector of variables used in the continuation method real ( pr ), allocatable :: XS (:, :) !! All the calculated variables that are returned on the continuation !! method procedure (unused since each point is saved on the fly) character ( len = 14 ) :: kind ! ======================================================================== ! Handle input ! ------------------------------------------------------------------------ kind = first_point % kind nc = size ( z ) max_points = optval ( points , 500 ) max_iterations = optval ( iterations , 100 ) ns = optval ( specified_variable_0 , nc + 1 ) dS0 = optval ( delta_0 , 0.1_pr ) select case ( first_point % kind ) case ( \"bubble\" , \"liquid-liquid\" ) X (: nc ) = log ( first_point % y / z ) case ( \"dew\" ) X (: nc ) = log ( first_point % x / z ) end select where ( z == 0 ) X (: nc ) = 0 end where X ( nc + 1 ) = log ( first_point % T ) X ( nc + 2 ) = log ( first_point % P ) S0 = X ( ns ) allocate ( envelopes % points ( 0 ), envelopes % cps ( 0 )) ! ======================================================================== ! Trace the line using the continuation method. ! ------------------------------------------------------------------------ XS = continuation (& foo , X , ns0 = ns , S0 = S0 , & dS0 = dS0 , max_points = max_points , solver_tol = 1.e-9_pr , & update_specification = update_spec , & solver = solver , stop = stop_conditions & ) contains subroutine foo ( X , ns , S , F , dF , dFdS ) !! Function that needs to be solved at each envelope point real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( out ) :: F (:) real ( pr ), intent ( out ) :: dF (:, :) real ( pr ), intent ( out ) :: dFdS (:) character ( len = 14 ) :: kind_z , kind_y real ( pr ) :: y ( nc ) real ( pr ) :: lnPhi_z ( nc ), lnPhi_y ( nc ) real ( pr ) :: dlnphi_dt_z ( nc ), dlnphi_dt_y ( nc ) real ( pr ) :: dlnphi_dp_z ( nc ), dlnphi_dp_y ( nc ) real ( pr ) :: dlnphi_dn_z ( nc , nc ), dlnphi_dn_y ( nc , nc ) real ( pr ) :: T , P , K ( nc ) integer :: i , j F = 0 dF = 0 K = exp ( X (: nc )) T = exp ( X ( nc + 1 )) P = exp ( X ( nc + 2 )) y = K * z select case ( kind ) case ( \"bubble\" ) kind_z = \"liquid\" kind_y = \"vapor\" case ( \"dew\" ) kind_z = \"vapor\" kind_y = \"liquid\" case ( \"liquid-liquid\" ) kind_z = \"liquid\" kind_y = \"liquid\" case default kind_z = \"stable\" kind_y = \"stable\" end select call model % lnphi_pt (& z , P , T , V = Vz , root_type = kind_z , & lnPhi = lnphi_z , dlnPhidt = dlnphi_dt_z , & dlnPhidp = dlnphi_dp_z , dlnphidn = dlnphi_dn_z & ) call model % lnphi_pt (& y , P , T , V = Vy , root_type = kind_y , & lnPhi = lnphi_y , dlnPhidt = dlnphi_dt_y , & dlnPhidp = dlnphi_dp_y , dlnphidn = dlnphi_dn_y & ) F (: nc ) = X (: nc ) + lnPhi_y - lnPhi_z F ( nc + 1 ) = sum ( y - z ) F ( nc + 2 ) = X ( ns ) - S ! Jacobian Matrix do j = 1 , nc df (: nc , j ) = dlnphi_dn_y (:, j ) * y ( j ) df ( j , j ) = dF ( j , j ) + 1 end do df (: nc , nc + 1 ) = T * ( dlnphi_dt_y - dlnphi_dt_z ) df (: nc , nc + 2 ) = P * ( dlnphi_dp_y - dlnphi_dp_z ) df ( nc + 1 , : nc ) = y df ( nc + 2 , :) = 0 df ( nc + 2 , ns ) = 1 dFdS = 0 dFdS ( nc + 2 ) = - 1 end subroutine foo subroutine update_spec ( X , ns , S , dS , dXdS , step_iters ) !! Update the specification during continuation. real ( pr ), intent ( in out ) :: X (:) !! Vector of variables [lnK_i \\dots , lnT, lnP] integer , intent ( in out ) :: ns !! Number of specified variable in the vector real ( pr ), intent ( in out ) :: S !! Variable specification value real ( pr ), intent ( in out ) :: dS !! Step in specification real ( pr ), intent ( in out ) :: dXdS (:) !! Variation of variables with respect to specification integer , intent ( in ) :: step_iters !! Iterations used in the solver real ( pr ) :: maxdS , dT , dP , Xold ( size ( X )) ! ===================================================================== ! Update specification ! - Dont select T or P near critical points ! - Update dS wrt specification units ! - Set step ! --------------------------------------------------------------------- if ( maxval ( abs ( X (: nc ))) < near_critical_K ) then ns = maxloc ( abs ( dXdS (: nc )), dim = 1 ) maxdS = 0.01_pr else ns = maxloc ( abs ( dXdS ), dim = 1 ) maxdS = 0.05_pr end if dS = dXdS ( ns ) * dS dXdS = dXdS / dXdS ( ns ) dS = sign ( 1.0_pr , dS ) * minval ([ & max ( sqrt ( abs ( X ( ns )) / 1 0._pr ), 0.1_pr ), & abs ( dS ) * 3 / step_iters & ] & ) if ( ns <= nc ) then dS = sign ( minval ([ maxdS , abs ( dS )]), dS ) end if ! Avoid small steps on T or P do while (& abs ( dXdS ( nc + 1 ) * dS ) < 0.005 & . and . abs ( dXdS ( nc + 2 ) * dS ) < 0.005 & . and . dS /= 0 & . and . . not . kind == \"liquid-liquid\" ) dS = dS * 1.01 end do if ( kind == \"liquid-liquid\" ) then do while ( abs ( dXdS ( nc + 2 ) * dS ) > 0.01 . and . dS /= 0 ) dS = dS / 1.1 end do end if do while ( maxval ( abs ( X (: nc ))) <= near_critical_K . and . abs ( dXdS ( ns ) * dS ) > 0.1 ) dS = dS * 0.5 end do if ( present ( maximum_pressure )) then if ( X ( nc + 2 ) > log ( maximum_pressure )) dS = 0 end if call save_point ( X , step_iters ) call detect_critical ( X , dXdS , ns , S , dS ) end subroutine update_spec subroutine save_point ( X , iters ) !! Save the converged point real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: iters type ( EquilibriumState ) :: point real ( pr ) :: y ( nc ), T , P T = exp ( X ( nc + 1 )) P = exp ( X ( nc + 2 )) y = exp ( X (: nc )) * z select case ( kind ) case ( \"bubble\" ) point = EquilibriumState (& kind = \"bubble\" , x = z , Vx = Vz , y = y , Vy = Vy , & T = T , P = P , beta = 0._pr , iters = iters & ) case ( \"dew\" ) point = EquilibriumState (& kind = \"dew\" , x = y , Vx = Vy , y = z , Vy = Vz , & T = T , P = P , beta = 1._pr , iters = iters & ) case default point = EquilibriumState (& kind = kind , x = z , Vx = Vz , y = y , Vy = Vy , & T = T , P = P , beta = 0._pr , iters = iters & ) end select envelopes % points = [ envelopes % points , point ] end subroutine save_point subroutine detect_critical ( X , dXdS , ns , S , dS ) !! # `detect_critical` !! Critical point detection !! !! # Description !! If the values of lnK (X[:nc]) change sign then a critical point !! Has passed, since for this to happen all variables should pass !! through zero. Near critical points (lnK < 0.05) points are harder !! to converge, so more steps in the extrapolation vector are made to !! jump over the critical point. !! If the critical point is detected then the kind of the point is !! changed and the point is saved using an interpolation knowing that !! !!  !!   X_c = a * X + (1-a)*X_{new} !!  !! !! With X_c is the variables at the critical point, X_{new} !! is the new initialization point of the method and a is the !! parameter to interpolate the values. This subroutine finds the !! value of  a to obtain X_c. use yaeos__equilibria_critical , only : critical_point , spec_CP real ( pr ), intent ( in out ) :: X (:) !! Vector of variables real ( pr ), intent ( in out ) :: dXdS (:) !! Variation of variables wrt S integer , intent ( in out ) :: ns !! Number of specified variable real ( pr ), intent ( in out ) :: S !! Specification value real ( pr ), intent ( in out ) :: dS !! Step in specification real ( pr ) :: Xc ( nc + 2 ) !! Value at (near) critical point real ( pr ) :: a !! Parameter for interpolation type ( EquilibriumState ) :: cp real ( pr ) :: Xold ( size ( X )) !! Old value of X real ( pr ) :: Xnew ( size ( X )) !! Value of the next initialization real ( pr ) :: V integer :: inner , ncomp Xold = X inner = 0 do while ( maxval ( abs ( X (: nc ))) < near_critical_K . and . inner < 5000 ) ! If near a critical point, jump over it inner = inner + 1 S = S + dS X = X + dXdS * dS print \"(*(E15.4,x))\" , X (: nc ) end do Xnew = X + 3 * dXdS * dS if ( all ( Xold (: nc ) * ( Xnew (: nc )) < 0 )) then select case ( kind ) case ( \"dew\" ) kind = \"bubble\" case ( \"bubble\" ) kind = \"dew\" case default kind = \"liquid-liquid\" end select ! 0 = a*X(ns) + (1-a)*Xnew(ns) < Interpolation equation to get X(ns) = 0 ncomp = maxloc ( abs ( Xold (: nc ) - Xnew (: nc )), dim = 1 ) a = - Xnew ( ncomp ) / ( X ( ncomp ) - Xnew ( ncomp )) Xc = a * X + ( 1 - a ) * Xnew call model % volume ( z , P = exp ( Xc ( nc + 2 )), T = exp ( Xc ( nc + 1 )), V = V , root_type = \"liquid\" ) cp = critical_point (& model , z , z , spec = spec_CP % a , S = 0._pr , & max_iters = 5000 , T0 = exp ( Xc ( nc + 1 )), P0 = exp ( Xc ( nc + 2 )), V0 = V & ) Xc ( nc + 1 ) = log ( cp % T ) Xc ( nc + 2 ) = log ( cp % P ) envelopes % cps = [& envelopes % cps , CriticalPoint ( T = exp ( Xc ( nc + 1 )), P = exp ( Xc ( nc + 2 ))) & ] X = Xc + dXdS * dS S = X ( ns ) end if end subroutine detect_critical end function pt_envelope_2ph subroutine write_PTEnvel2 ( pt2 , unit , iotype , v_list , iostat , iomsg ) class ( PTEnvel2 ), intent ( in ) :: pt2 integer , intent ( in ) :: unit character ( * ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg integer , allocatable :: cps (:) integer :: cp integer :: i , nc if ( size ( pt2 % points ) == 0 ) return allocate ( cps ( 0 )) do i = 1 , size ( pt2 % cps ) cp = minloc (& ( pt2 % points % T - pt2 % cps ( i )% T ) ** 2 & + ( pt2 % points % P - pt2 % cps ( i )% P ) ** 2 , dim = 1 & ) cps = [ cps , cp ] end do write ( unit , \"(A, /, /)\" , iostat = iostat ) \"#PTEnvel2\" write ( unit , \"(A, /)\" ) \"#\" // pt2 % points ( 1 )% kind do i = 1 , size ( pt2 % points ) - 1 ! Change label if passed a critical point if ( any ( cps - i == 0 ) . and . i < size ( pt2 % points )) then write ( unit , \"(/, /)\" ) write ( unit , \"(A, /)\" ) \"#\" // pt2 % points ( i + 1 )% kind end if write ( unit , * ) pt2 % points ( i ) write ( unit , \"(/)\" ) end do write ( unit , \"(/, /, A, /)\" ) \"#Critical\" do cp = 1 , size ( cps ) write ( unit , * ) pt2 % cps ( cp )% T , pt2 % cps ( cp )% P end do end subroutine write_PTEnvel2 type ( PTEnvel2 ) function find_hpl ( model , z , T0 , P0 , max_points ) !! # find_hpl !! !! ## Description !! Find a liquid-liquid phase boundary on the PT plane. At a specified !! pressure. !! The procedure consists in looking for the temperature at which the !! fugacity of a component in the mixture is higher than the fugacity !! of the same component in a pure phase. This is done for each component !! in the mixture. The component with the highest temperature is selected !! as it should be the first one appearing. If all components have a !! negative difference then the mixture is probably stable at all !! temperatures. class ( ArModel ), intent ( in ) :: model !! Equation of state model real ( pr ), intent ( in ) :: z (:) !! Mole fractions real ( pr ), intent ( in ) :: T0 !! Initial temperature [K] real ( pr ), intent ( in ) :: P0 !! Search pressure [bar] integer , intent ( in ) :: max_points integer :: i real ( pr ) :: y ( size ( z )) real ( pr ) :: lnphi_y ( size ( z )), lnphi_z ( size ( z )) type ( EquilibriumState ) :: fr real ( pr ) :: diffs ( size ( z )), Ts ( size ( z )), T , P integer :: ncomp , nc nc = size ( z ) P = P0 do ncomp = 1 , nc y = 0 y ( ncomp ) = 1 do i = int ( T0 ), 1 , - 10 T = real ( i , pr ) call model % lnphi_pt ( z , P , T , root_type = \"liquid\" , lnPhi = lnphi_z ) call model % lnphi_pt ( y , P , T , root_type = \"liquid\" , lnPhi = lnphi_y ) ! Fugacity of the component ncomp ! eq = z * phi_i_mixture / phi_i_pure ! if eq > 1 then the fugacity in the mixture is above the pure, ! so the component is more stable on another phase diffs ( ncomp ) = log ( z ( ncomp )) + lnphi_z ( ncomp ) - log ( y ( ncomp )) - lnphi_y ( ncomp ) if ( diffs ( ncomp ) > 0 ) exit end do Ts ( ncomp ) = T end do if ( all ( diffs < 0 )) then return end if T = maxval ( Ts , mask = diffs > 0 ) ncomp = findloc ( Ts , T , dim = 1 ) y = 0 y ( ncomp ) = 1 fr % x = z fr % y = y + 1e-5 fr % y = fr % y / sum ( fr % y ) fr % T = T fr % P = P fr % kind = \"liquid-liquid\" find_hpl = pt_envelope_2ph ( & model , z , fr , & specified_variable_0 = nc + 2 , delta_0 =- 5.0_pr , & iterations = 1000 , points = max_points ) end function find_hpl end module yaeos__equilibria_boundaries_phase_envelopes_pt","tags":"","url":"sourcefile/phase_envelopes_pt.f90.html"},{"title":"auxiliar_functions.f90 – yaeos","text":"Source Code module auxiliar_functions use yaeos__constants , only : pr contains elemental function rel_error ( x , y ) real ( pr ), intent ( in ) :: x , y real ( pr ) :: rel_error rel_error = abs ( x - y ) / abs ( x ) end function rel_error function allclose ( x , y , rtol ) real ( pr ), intent ( in ) :: x (:) real ( pr ), intent ( in ) :: y (:) real ( pr ), intent ( in ) :: rtol logical :: allclose allclose = maxval ( rel_error ( x , y )) < rtol end function allclose end module auxiliar_functions","tags":"","url":"sourcefile/auxiliar_functions.f90.html"},{"title":"autodiff.f90 – yaeos","text":"Source Code module yaeos__autodiff !! This module holds the diferent ways of automatic differentiation use hyperdual_mod use yaeos__adiff_hyperdual_ar_api , only : ArModelAdiff implicit none end module","tags":"","url":"sourcefile/autodiff.f90.html"},{"title":"gerg2008.f90 – yaeos","text":"Source Code module yaeos__models_ar_gerg2008 use yaeos__constants , only : Ryaeos => R , pr !! Ideal gas constants used on yaeos use yaeos__adiff_hyperdual_ar_api , only : ArModelAdiff use yaeos__models_ar_cubic_implementations , only : SoaveRedlichKwong use yaeos__models_ar_genericcubic , only : CubicEoS use yaeos__models_ar_multifluid_parameters_gerg2008 , only : Gerg2008Binary , Gerg2008Pure use hyperdual_mod implicit none type , extends ( ArModelAdiff ) :: Gerg2008 type ( Gerg2008Pure ), allocatable :: pures (:) type ( Gerg2008Binary ), allocatable :: binaries (:, :) type ( CubicEoS ) :: srk contains procedure :: ar => arfun procedure :: get_v0 => volume_initalizer end type Gerg2008 type , private :: GERG2008Selector integer :: methane = 1 integer :: nitrogen = 2 integer :: carbon_dioxide = 3 integer :: ethane = 4 integer :: propane = 5 integer :: nbutane = 6 integer :: isobutane = 7 integer :: npentane = 8 integer :: isopentane = 9 integer :: nhexane = 10 integer :: nheptane = 11 integer :: noctane = 12 integer :: nonane = 13 integer :: decane = 14 integer :: hydrogen = 15 integer :: oxygen = 16 integer :: carbon_monoxide = 17 integer :: water = 18 integer :: hydrogen_sulfide = 19 integer :: helium = 20 integer :: argon = 21 end type GERG2008Selector type ( GERG2008Selector ) :: G2008Components contains type ( Gerg2008 ) function gerg_2008 ( ids ) use yaeos__models_ar_multifluid_parameters_gerg2008 , only : get_original_parameters integer , intent ( in ) :: ids (:) type ( Gerg2008Pure ) :: pures ( size ( ids )) type ( Gerg2008Binary ) :: binaries ( size ( ids ), size ( ids )) call get_original_parameters ( ids , pures , binaries , gerg_2008 % components ) gerg_2008 % pures = pures gerg_2008 % binaries = binaries gerg_2008 % srk = SoaveRedlichKwong ( gerg_2008 % components % Tc , gerg_2008 % components % Pc , gerg_2008 % components % w ) end function gerg_2008 subroutine reducing_functions ( self , n , Vr , Tr ) class ( Gerg2008 ), intent ( in ) :: self type ( hyperdual ), intent ( in ) :: n (:) type ( hyperdual ), intent ( out ) :: Vr type ( hyperdual ), intent ( out ) :: Tr type ( hyperdual ) :: X ( size ( n )) real ( 8 ) :: Vc ( size ( n )), Tc ( size ( n )), rho_c ( size ( n )) real ( 8 ) :: Bv ( size ( n ), size ( n )), Gv ( size ( n ), size ( n )) real ( 8 ) :: Bt ( size ( n ), size ( n )), Gt ( size ( n ), size ( n )) integer :: i , j , nc Vc = self % components % Vc Tc = self % components % Tc Bv = self % binaries % Bv Gv = self % binaries % Gv Bt = self % binaries % Bt Gt = self % binaries % Gt rho_c = 1 / Vc X = n / sum ( n ) nc = size ( n ) Vr = sum ( X ** 2 * Vc ) Tr = sum ( X ** 2 * Tc ) do i = 1 , nc do j = i + 1 , nc Vr = Vr + & 2 * X ( i ) * X ( j ) * Bv ( i , j ) * Gv ( i , j ) & * ( X ( i ) + X ( j )) / ( Bv ( i , j ) ** 2 * X ( i ) + X ( j )) & * 1._pr / 8._pr * ( rho_c ( i ) ** ( - 1._pr / 3._pr ) & + rho_c ( j ) ** ( - 1._pr / 3 )) ** 3 Tr = Tr + & 2 * X ( i ) * X ( j ) * Bt ( i , j ) * Gt ( i , j ) & * ( X ( i ) + X ( j )) / ( Bt ( i , j ) ** 2 * X ( i ) + X ( j )) & * sqrt (( Tc ( i ) * Tc ( j ))) end do end do end subroutine reducing_functions subroutine ar_pure ( pure , delta , tau , ar ) type ( Gerg2008Pure ), intent ( in ) :: pure type ( hyperdual ), intent ( in ) :: delta type ( hyperdual ), intent ( in ) :: tau type ( hyperdual ), intent ( out ) :: ar integer :: i , Kpol , Kexp real ( 8 ) :: n_pol ( pure % Kpol ), d_pol ( pure % Kpol ), t_pol ( pure % Kpol ) real ( 8 ) :: n_exp ( pure % Kexp ), d_exp ( pure % Kexp ), t_exp ( pure % Kexp ) real ( 8 ) :: c_exp ( pure % Kexp ) Kpol = pure % Kpol Kexp = pure % Kexp n_pol = pure % n ( 1 : Kpol ) d_pol = pure % d ( 1 : Kpol ) t_pol = pure % t ( 1 : Kpol ) n_exp = pure % n ( Kpol + 1 : Kpol + Kexp ) d_exp = pure % d ( Kpol + 1 : Kpol + Kexp ) t_exp = pure % t ( Kpol + 1 : Kpol + Kexp ) c_exp = pure % c ar = sum ( n_pol * delta ** d_pol * tau ** t_pol ) + & sum ( n_exp * delta ** d_exp * tau ** t_exp * exp ( - delta ** c_exp )) end subroutine ar_pure subroutine ar_ij ( delta , tau , binary , aij ) type ( hyperdual ), intent ( in ) :: delta type ( hyperdual ), intent ( in ) :: tau type ( Gerg2008Binary ), intent ( in ) :: binary type ( hyperdual ), intent ( out ) :: aij integer :: idx_poly , idx_exp real ( 8 ) :: n_pol ( binary % Kpolij ), d_pol ( binary % Kpolij ), t_pol ( binary % Kpolij ) real ( 8 ) :: n_exp ( binary % Kexpij ), d_exp ( binary % Kexpij ), t_exp ( binary % Kexpij ) real ( 8 ) :: etha ( binary % Kexpij ), eps ( binary % Kexpij ), beta ( binary % Kexpij ), gama ( binary % Kexpij ) idx_poly = binary % Kpolij idx_exp = binary % Kexpij + idx_poly n_pol = binary % nij ( 1 : idx_poly ) d_pol = binary % dij ( 1 : idx_poly ) t_pol = binary % tij ( 1 : idx_poly ) n_exp = binary % nij ( idx_poly + 1 : idx_exp ) d_exp = binary % dij ( idx_poly + 1 : idx_exp ) t_exp = binary % tij ( idx_poly + 1 : idx_exp ) etha = binary % ethaij ( 1 : binary % Kexpij ) eps = binary % epsij ( 1 : binary % Kexpij ) beta = binary % betaij ( 1 : binary % Kexpij ) gama = binary % gammaij ( 1 : binary % Kexpij ) aij = sum ( n_pol * delta ** d_pol * tau ** t_pol ) + & sum ( n_exp * delta ** d_exp * tau ** t_exp * exp ( - etha * ( delta - eps ) ** 2 - beta * ( delta - gama ))) end subroutine ar_ij function arfun ( self , n , v , t ) result ( arval ) class ( Gerg2008 ) :: self type ( hyperdual ), intent ( in ) :: n (:), v , t type ( hyperdual ) :: arval type ( hyperdual ) :: Vr , Tr , X ( size ( n )), rho_r type ( hyperdual ) :: delta , tau type ( hyperdual ) :: aij type ( hyperdual ) :: ar_pures ( size ( n )) type ( Gerg2008Pure ) :: pures ( size ( n )) type ( Gerg2008Binary ) :: binary real ( pr ) :: rho_c ( size ( n )) real ( pr ) :: Fij ( size ( n ), size ( n )) integer :: i , j , nc Fij = self % binaries % Fij pures = self % pures nc = size ( n ) X = n / sum ( n ) call reducing_functions ( self , n , Vr , Tr ) rho_r = 1._pr / Vr delta = ( 1._pr / ( V / sum ( n ))) / rho_r tau = Tr / T do i = 1 , nc call ar_pure ( pures ( i ), delta , tau , ar_pures ( i )) end do arval = sum ( x * ar_pures ) do i = 1 , nc do j = 1 , nc !i+1,nc if ( Fij ( i , j ) == 0._pr ) cycle binary = self % binaries ( i , j ) call ar_ij ( delta , tau , binary , aij ) arval = arval + X ( i ) * X ( j ) * Fij ( i , j ) * aij end do end do arval = arval * ( sum ( n ) * ryaeos * t ) end function arfun function volume_initalizer ( self , n , p , t ) result ( v0 ) class ( Gerg2008 ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: p real ( pr ), intent ( in ) :: t real ( pr ) :: v0 v0 = self % srk % get_v0 ( n , p , t ) end function volume_initalizer end module yaeos__models_ar_gerg2008","tags":"","url":"sourcefile/gerg2008.f90.html"},{"title":"hyperdual.f90 – yaeos","text":"Source Code module hyperdual_mod !> Hyperdual number definition & type declaration ! ! Original code provided by Philipp Rehner and Gernot Bauer, ! Institute of Thermodynamics and Thermal Process Engineering (ITT), ! University of Stuttgart, Stuttgart, Germany ! ! #### Hypderdual numbers ! ! Hypderdual numbers extend the idea of additional, non-real ! components from one non-real component (complex numbers) to four ! non-real components: \\f$\\varepsilon_1\\f$, \\f$\\varepsilon_2\\f$ and ! \\f$\\varepsilon_1 \\varepsilon_2\\f$. ! Hyperdual numbers require: \\f$(\\varepsilon_1)&#94;2 = 0\\f$, ! \\f$(\\varepsilon_2)&#94;2 = 0\\f$ and ! \\f$(\\varepsilon_1\\varepsilon_2)&#94;2 = 0\\f$ ! This leads to the fact, that the Taylor series of a function with ! hyperdual arguments can be truncated _exactly_ after the second ! derivative term: ! ! \\f[ !    f(\\mathbf{x} + h_1 \\varepsilon_1 + h_2 \\varepsilon_2 !      + h_1 h_2 \\varepsilon_1 \\varepsilon_2) !    = f(\\mathbf{x}) + h_1 f'(\\mathbf{x}) \\varepsilon_1 !      + h_2 f'(\\mathbf{x}) \\varepsilon_2 !      + h_1 h_2 f''(\\mathbf{x}) \\varepsilon_1 \\varepsilon_2 ! \\f] ! ! Because there is _no truncation error_, all first and second order ! derivatives can be obtained _exactly_, regardless of the step size '' ! \\f$h_1\\f$ and \\f$h_2\\f$. ! The derivatives can be obtained for a function \\f$ f(\\mathbf{x}) \\f$ ! with multiple variables \\f$ \\mathbf{x} \\in \\mathbb{R}&#94;n \\f$ via ! \\f{eqnarray*}{ !   \\frac{\\partial f(\\mathbf{x})}{\\partial x_i} &=& \\frac{ !     \\varepsilon_{1, \\mathrm{part}} \\Big\\{ !     f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e}_i !     + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big\\}} !     {h_1}\\\\ !   \\frac{\\partial f(\\mathbf{x})}{\\partial x_i} &=& \\frac{ !      \\varepsilon_{2, \\mathrm{part}} \\Big\\{ !      f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e}_i !      + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big\\}} !      {h_2}\\\\ !   \\frac{\\partial&#94;2 f(\\mathbf{x})}{\\partial x_i \\partial x_j} &=& !     \\frac{(\\varepsilon_1 \\varepsilon_2)_\\mathrm{part} \\Big\\{ !     f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e}_i !     + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big\\}} !     {h_1 h_2}  \\\\ ! \\f} ! where \\f$\\mathbf{e}_i\\f$ and \\f$\\mathbf{e}_j\\f$ are unit vectors, ! which are all zero except for the \\f$i\\f$-th and \\f$j\\f$-th ! component, respectively. ! ! #### Computation principles for hypderdual numbers ! ! Hyperdual numbers \\f$\\mathbf{x} \\in \\mathbb{HD}\\f$ can be expressed ! as tuples: \\f$\\mathbf{x} = [x_0, x_1, x_2, x_{12}] = x_0 ! + x_1 \\varepsilon_1 + x_2 \\varepsilon_2 ! + x_{12} \\varepsilon_1\\varepsilon_2\\f$. ! By using the Taylor expansion of the function \\f$f(\\mathbf{x})\\f$ ! one gets computation priniple for functions with hyperdual ! arguments from ! ! \\f[ !    f(\\mathbf{x}) = f(x_0) + x_1 f'(x_0) \\varepsilon_1 !    + x_2 f'(x_0) \\varepsilon_2 + \\big( x_{12} f'(x_0) !    + x_1 x_2 f''(x_0) \\big) \\varepsilon_1 \\varepsilon_2 ! \\f] ! ! A hyperdual number derived type is provided by: \\ref hyperdual. ! ! #### References ! ! [[1]](https://doi.org/10.2514/6.2011-886) !      Fike, Alonso: **The Development of Hyper-Dual Numbers for Exact !                      Second-Derivative Calculations.** !      _49th AIAA Aerospace Sciences Meeting including the New !       Horizons Forum and Aerospace Exposition_ (2011) \\n ! [[2]](https://doi.org/10.3389/fceng.2021.758090) !      Rehner, P. and Bauer, G.: **Application of Generalized !                                  (Hyper-) Dual Numbers in Equation !                                  of State Modeling.** !      Frontiers in Chemical Engineering_ (2021) \\n ! use yaeos__constants , only : pr implicit none type , bind ( c ) :: hyperdual !-| Derived type for hyperdual numbers ! !  Hyperdual numbers are represented by the tuple \\f$\\mathbf{f} = !  [f_0, f_1, f_2, f_{12}] = f_0 + f_1 \\varepsilon_1 !  + f_2 \\varepsilon_2 + f_{12} \\varepsilon_1 \\varepsilon_2 \\f$. !  Calculations specificaions are defined in module hyperdual_mod. ! sequence real ( pr ) :: f0 = 0 !! real part of the hyperdual number real ( pr ) :: f1 = 0 !! \\f$\\varepsilon_1\\f$-part of  the hyperdual number real ( pr ) :: f2 = 0 !! \\f$\\varepsilon_2\\f$-part of  the hyperdual number real ( pr ) :: f12 = 0 !! \\f$\\varepsilon_1\\varepsilon_2\\f$-part of the end type hyperdual !--------------------------------------------------------------------- !--- Operator interfaces --------------------------------------------- !--------------------------------------------------------------------- ! Equal assignment interface assignment ( = ) procedure EqualHyperDualHyperDual procedure EqualHyperDualReal end interface ! Unary operator + interface operator ( + ) procedure PlusHyperDualHyperDual end interface ! Addition operator interface operator ( + ) procedure AddHyperDualHyperDual procedure AddHyperDualReal procedure AddRealHyperDual end interface ! Unary operator - interface operator ( - ) procedure MinusHyperDualHyperDual end interface ! Subtraction operator interface operator ( - ) procedure SubtractHyperDualHyperDual procedure SubtractHyperDualReal procedure SubtractRealHyperDual end interface ! Multiplication operator interface operator ( * ) procedure MultiplyHyperDualHyperDual procedure MultiplyHyperDualReal procedure MultiplyRealHyperDual procedure MultiplyHyperDualInt procedure MultiplyIntHyperDual end interface ! Division operator interface operator ( / ) procedure DivideHyperDualHyperDual procedure DivideHyperDualReal procedure DivideRealHyperDual end interface ! Power operator interface operator ( ** ) procedure PowerHyperDualInt procedure PowerHyperDualHyperDual procedure PowerHyperDualReal end interface !--------------------------------------------------------------------- !--- Summation interface --------------------------------------------- !--------------------------------------------------------------------- interface sum module procedure SumHyperDual module procedure SumHyperDual2 end interface sum !--------------------------------------------------------------------- !--- Logical operator interfaces ------------------------------------- !--------------------------------------------------------------------- ! Equal operator. interface operator (. eq .) ! or (==) procedure eq_dd procedure eq_dr procedure eq_rd procedure eq_di procedure eq_id end interface ! Not equal operator. interface operator (. ne .) ! or (/=) procedure ne_dd procedure ne_dr procedure ne_rd procedure ne_di procedure ne_id end interface ! Less than operator. interface operator (. lt .) ! or (<) procedure lt_dd procedure lt_dr procedure lt_rd procedure lt_di procedure lt_id end interface ! Less than or equal operator. interface operator (. le .) ! or (<=) procedure le_dd procedure le_dr procedure le_rd procedure le_di procedure le_id end interface ! Greater than operator. interface operator (. gt .) ! or (>) procedure gt_dd procedure gt_dr procedure gt_rd procedure gt_di procedure gt_id end interface ! Greater than or equal operator. interface operator (. ge .) ! or (>=) procedure ge_dd procedure ge_dr procedure ge_rd procedure ge_di procedure ge_id end interface !--------------------------------------------------------------------- !--- Math function interfaces ---------------------------------------- !--------------------------------------------------------------------- ! Absolute value function interface abs module procedure absHyperDual end interface ! Integer function interface int module procedure intHyperDual end interface ! Nearest integer function interface nint module procedure nintHyperDual end interface ! Real function interface real module procedure realHyperDual end interface ! Sign function interface sign module procedure sign_dd module procedure sign_dr module procedure sign_rd end interface ! Sine function interface sin module procedure sinHyperDual end interface ! Cosine function interface cos module procedure cosHyperDual end interface ! Tangent function interface tan module procedure tanHyperDual end interface ! Sqrt function interface sqrt module procedure sqrtHyperDual end interface ! Log function interface log module procedure logHyperDual end interface ! Log10 function interface log10 module procedure log10HyperDual end interface ! Exp function interface exp module procedure expHyperDual end interface ! Sinh function interface sinh module procedure sinhHyperDual end interface ! Cosh function interface cosh module procedure coshHyperDual end interface ! Tanh function interface tanh module procedure tanhHyperDual end interface ! Acos function interface acos module procedure acosHyperDual end interface ! Asin function interface asin module procedure asinHyperDual end interface ! Atan function interface atan module procedure atanHyperDual end interface ! Atan2 function interface atan2 module procedure atan2HyperDual end interface ! Max function (limited to combinations below, but that ! can be extended) interface max module procedure max_dd module procedure max_ddd module procedure max_dr module procedure max_rd end interface ! Min function (limited for now to 2 arguments, but that ! can be extended) interface min module procedure min_dd module procedure min_dr module procedure min_rd end interface !===================================================================== contains !------------------------------------------------------------------- !--- Functions for the equal assignment. --------------------------- !------------------------------------------------------------------- elemental subroutine EqualHyperDualHyperDual ( res , inp ) implicit none type ( hyperdual ), intent ( out ) :: res type ( hyperdual ), intent ( in ) :: inp res % f0 = inp % f0 res % f1 = inp % f1 res % f2 = inp % f2 res % f12 = inp % f12 end subroutine EqualHyperDualHyperDual elemental subroutine EqualHyperDualReal ( res , inp ) implicit none type ( hyperdual ), intent ( out ) :: res real ( pr ), intent ( in ) :: inp res % f0 = inp res % f1 = 0.0_pr res % f2 = 0.0_pr res % f12 = 0.0_pr end subroutine EqualHyperDualReal !------------------------------------------------------------------- !--- Function for the unary operator +. ---------------------------- !------------------------------------------------------------------- elemental function PlusHyperDualHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 v2 % f0 = v1 % f0 v2 % f1 = v1 % f1 v2 % f2 = v1 % f2 v2 % f12 = v1 % f12 end function PlusHyperDualHyperDual !------------------------------------------------------------------- !--- Functions for the addition operator. -------------------------- !------------------------------------------------------------------- elemental function AddHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 + v2 % f0 v3 % f1 = v1 % f1 + v2 % f1 v3 % f2 = v1 % f2 + v2 % f2 v3 % f12 = v1 % f12 + v2 % f12 end function AddHyperDualHyperDual elemental function AddHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 + v2 v3 % f1 = v1 % f1 v3 % f2 = v1 % f2 v3 % f12 = v1 % f12 end function AddHyperDualReal elemental function AddRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 + v2 % f0 v3 % f1 = v2 % f1 v3 % f2 = v2 % f2 v3 % f12 = v2 % f12 end function AddRealHyperDual !------------------------------------------------------------------- !--- Function for the unary operator -. ---------------------------- !------------------------------------------------------------------- elemental function MinusHyperDualHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 v2 % f0 = - v1 % f0 v2 % f1 = - v1 % f1 v2 % f2 = - v1 % f2 v2 % f12 = - v1 % f12 end function MinusHyperDualHyperDual !------------------------------------------------------------------- !--- Functions for the subtraction operator. ----------------------- !------------------------------------------------------------------- elemental function SubtractHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 - v2 % f0 v3 % f1 = v1 % f1 - v2 % f1 v3 % f2 = v1 % f2 - v2 % f2 v3 % f12 = v1 % f12 - v2 % f12 end function SubtractHyperDualHyperDual elemental function SubtractHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 - v2 v3 % f1 = v1 % f1 v3 % f2 = v1 % f2 v3 % f12 = v1 % f12 end function SubtractHyperDualReal elemental function SubtractRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 - v2 % f0 v3 % f1 = - v2 % f1 v3 % f2 = - v2 % f2 v3 % f12 = - v2 % f12 end function SubtractRealHyperDual !------------------------------------------------------------------- !--- Functions for the multiplication operator. -------------------- !------------------------------------------------------------------- elemental function MultiplyHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 * v2 % f0 v3 % f1 = v1 % f0 * v2 % f1 + v1 % f1 * v2 % f0 v3 % f2 = v1 % f0 * v2 % f2 + v1 % f2 * v2 % f0 v3 % f12 = v1 % f0 * v2 % f12 + v1 % f1 * v2 % f2 + v1 % f2 * v2 % f1 + v1 % f12 * v2 % f0 end function MultiplyHyperDualHyperDual elemental function MultiplyHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 * v2 v3 % f1 = v1 % f1 * v2 v3 % f2 = v1 % f2 * v2 v3 % f12 = v1 % f12 * v2 end function MultiplyHyperDualReal elemental function MultiplyRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 * v2 % f0 v3 % f1 = v1 * v2 % f1 v3 % f2 = v1 * v2 % f2 v3 % f12 = v1 * v2 % f12 end function MultiplyRealHyperDual elemental function MultiplyHyperDualInt ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 integer , intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 * v2 v3 % f1 = v1 % f1 * v2 v3 % f2 = v1 % f2 * v2 v3 % f12 = v1 % f12 * v2 end function MultiplyHyperDualInt elemental function MultiplyIntHyperDual ( v1 , v2 ) result ( v3 ) integer , intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 * v2 % f0 v3 % f1 = v1 * v2 % f1 v3 % f2 = v1 * v2 % f2 v3 % f12 = v1 * v2 % f12 end function MultiplyIntHyperDual !------------------------------------------------------------------- !--- Functions for the division operator. -------------------------- !------------------------------------------------------------------- elemental function DivideHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 = v1 * v2 ** ( - 1 ) end function DivideHyperDualHyperDual elemental function DivideHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ) :: invV2 invV2 = 1.0_pr / v2 v3 = v1 * invV2 end function DivideHyperDualReal elemental function DivideRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: invV2 , v3 invV2 = 1.0_pr * v2 ** ( - 1.0_pr ) v3 = v1 * invV2 end function DivideRealHyperDual !------------------------------------------------------------------- !--- Functions for the power operator. ----------------------------- !------------------------------------------------------------------- elemental function PowerHyperDualInt ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 integer , intent ( in ) :: v2 integer :: i , vv2 type ( hyperdual ) :: v3 v3 = 1.0_pr vv2 = abs ( v2 ) do i = 1 , vv2 v3 = v3 * v1 enddo if ( v2 < 0 ) v3 = 1.0_pr / v3 end function PowerHyperDualInt elemental function PowerHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 , v4 v4 = logHyperDual ( v1 ) v3 = expHyperDual ( v2 * v4 ) end function PowerHyperDualHyperDual elemental function PowerHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ), parameter :: tol = 1.0e-15_pr real ( pr ) :: xval , deriv xval = v1 % f0 if ( abs ( xval ) < tol ) then if ( xval >= 0.0_pr ) then xval = tol else xval = - tol endif endif deriv = v2 * ( xval ** ( v2 - 1.0_pr )) v3 % f0 = ( v1 % f0 ) ** v2 v3 % f1 = v1 % f1 * deriv v3 % f2 = v1 % f2 * deriv v3 % f12 = v1 % f12 * deriv & & + v2 * ( v2 - 1.0_pr ) * v1 % f1 * v1 % f2 * xval ** ( v2 - 2.0_pr ) end function PowerHyperDualReal !------------------------------------------------------------------- !--- Sum ----------------------------------------------------------- !------------------------------------------------------------------- pure type ( hyperdual ) function SumHyperDual ( v1 , mask ) type ( hyperdual ), intent ( in ) :: v1 (:) logical , intent ( in ), optional :: mask (:) integer :: i SumHyperDual = hyperdual ( 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr ) if ( present ( mask )) then do i = 1 , size ( v1 ) if ( mask ( i )) SumHyperDual = SumHyperDual + v1 ( i ) end do else do i = 1 , size ( v1 ) SumHyperDual = SumHyperDual + v1 ( i ) end do end if end function SumHyperDual pure function SumHyperDual2 ( v1 , dim ) type ( hyperdual ), intent ( in ) :: v1 (:,:) integer , intent ( in ) :: dim type ( hyperdual ), allocatable :: SumHyperDual2 (:) integer :: i allocate ( SumHyperDual2 ( size ( v1 ) / size ( v1 , dim ))) SumHyperDual2 = hyperdual ( 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr ) do i = 1 , size ( v1 , dim ) if ( dim == 1 ) then SumHyperDual2 = SumHyperDual2 + v1 ( i ,:) else SumHyperDual2 = SumHyperDual2 + v1 (:, i ) end if end do end function SumHyperDual2 !------------------------------------------------------------------- !--- Functions for the equal operator. ----------------------------- !------------------------------------------------------------------- logical function eq_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs eq_dd = lhs % f0 == rhs % f0 end function eq_dd elemental logical function eq_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs eq_dr = lhs % f0 == rhs end function eq_dr elemental logical function eq_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs eq_rd = lhs == rhs % f0 end function eq_rd logical function eq_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs eq_di = lhs % f0 == rhs end function eq_di logical function eq_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs eq_id = lhs == rhs % f0 end function eq_id !------------------------------------------------------------------- !--- Functions for the not equal operator. ------------------------- !------------------------------------------------------------------- logical function ne_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs ne_dd = lhs % f0 /= rhs % f0 end function ne_dd logical function ne_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs ne_dr = lhs % f0 /= rhs end function ne_dr logical function ne_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ne_rd = lhs /= rhs % f0 end function ne_rd logical function ne_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs ne_di = lhs % f0 /= rhs end function ne_di logical function ne_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ne_id = lhs /= rhs % f0 end function ne_id !------------------------------------------------------------------- !--- Functions for the less than operator. ------------------------- !------------------------------------------------------------------- logical function lt_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs lt_dd = lhs % f0 < rhs % f0 end function lt_dd logical function lt_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs lt_dr = lhs % f0 < rhs end function lt_dr logical function lt_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs lt_rd = lhs < rhs % f0 end function lt_rd logical function lt_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs lt_di = lhs % f0 < rhs end function lt_di logical function lt_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs lt_id = lhs < rhs % f0 end function lt_id !------------------------------------------------------------------- !--- Functions for the less than or equal operator. ---------------- !------------------------------------------------------------------- logical function le_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs le_dd = lhs % f0 <= rhs % f0 end function le_dd logical function le_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs le_dr = lhs % f0 <= rhs end function le_dr logical function le_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs le_rd = lhs <= rhs % f0 end function le_rd logical function le_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs le_di = lhs % f0 <= rhs end function le_di logical function le_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs le_id = lhs <= rhs % f0 end function le_id !------------------------------------------------------------------- !--- Functions for the greater than operator. ---------------------- !------------------------------------------------------------------- logical function gt_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs gt_dd = lhs % f0 > rhs % f0 end function gt_dd logical function gt_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs gt_dr = lhs % f0 > rhs end function gt_dr logical function gt_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs gt_rd = lhs > rhs % f0 end function gt_rd logical function gt_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs gt_di = lhs % f0 > rhs end function gt_di logical function gt_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs gt_id = lhs > rhs % f0 end function gt_id !------------------------------------------------------------------- !--- Functions for the greater than or equal operator. ------------- !------------------------------------------------------------------- logical function ge_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs ge_dd = lhs % f0 >= rhs % f0 end function ge_dd logical function ge_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs ge_dr = lhs % f0 >= rhs end function ge_dr logical function ge_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ge_rd = lhs >= rhs % f0 end function ge_rd logical function ge_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs ge_di = lhs % f0 >= rhs end function ge_di logical function ge_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ge_id = lhs >= rhs % f0 end function ge_id !------------------------------------------------------------------- !--- Math functions. ----------------------------------------------- !------------------------------------------------------------------- ! Absolute value function. elemental function absHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 if ( v1 % f0 >= 0.0 ) then v2 % f0 = v1 % f0 v2 % f1 = v1 % f1 v2 % f2 = v1 % f2 v2 % f12 = v1 % f12 else v2 % f0 = - v1 % f0 v2 % f1 = - v1 % f1 v2 % f2 = - v1 % f2 v2 % f12 = - v1 % f12 endif end function absHyperDual ! Integer function. elemental function intHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 integer :: v2 v2 = int ( v1 % f0 ) end function intHyperDual ! Nearest integer function. elemental function nintHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 integer :: v2 v2 = nint ( v1 % f0 ) end function nintHyperDual ! Real function. elemental function realHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ) :: v2 v2 = v1 % f0 end function realHyperDual ! Functions for the sign function. elemental function sign_dd ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 real ( pr ) :: ssign if ( v2 % f0 < 0.0 ) then ssign = - 1.0 else ssign = 1.0 endif v3 = ssign * v1 end function sign_dd elemental function sign_dr ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ) :: ssign if ( v2 < 0.0 ) then ssign = - 1.0 else ssign = 1.0 endif v3 = ssign * v1 end function sign_dr elemental function sign_rd ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ) :: ssign if ( v2 % f0 < 0.0 ) then ssign = - 1.0 else ssign = 1.0 endif v3 = ssign * v1 end function sign_rd ! Sine function. elemental function sinHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: f , dx f = sin ( v1 % f0 ) dx = cos ( v1 % f0 ) v2 % f0 = f v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * v1 % f12 - f * v1 % f1 * v1 % f2 end function sinHyperDual ! Cosine function. elemental function cosHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: f , dx f = cos ( v1 % f0 ) dx = - sin ( v1 % f0 ) v2 % f0 = f v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * v1 % f12 - f * v1 % f1 * v1 % f2 end function cosHyperDual ! Tangent function. elemental function tanHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: f , dx f = tan ( v1 % f0 ) dx = f * f + 1.0_pr v2 % f0 = f v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * v1 % f12 + v1 % f1 * v1 % f2 * 2.0_pr * f * dx end function tanHyperDual ! Sqrt function elemental function sqrtHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ), parameter :: expo = 3.0_pr / 2.0_pr real ( pr ) :: square square = sqrt ( v1 % f0 ) v2 % f0 = square v2 % f1 = 0.5_pr / square * v1 % f1 v2 % f2 = 0.5_pr / square * v1 % f2 v2 % f12 = 0.5_pr * v1 % f12 / square - 0.25_pr * v1 % f1 * v1 % f2 / ( v1 % f0 ** expo ) end function sqrtHyperDual ! Log function elemental function logHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: dx1 , dx2 dx1 = v1 % f1 / v1 % f0 dx2 = v1 % f2 / v1 % f0 v2 % f0 = log ( v1 % f0 ) v2 % f1 = dx1 v2 % f2 = dx2 v2 % f12 = v1 % f12 / v1 % f0 - ( dx1 * dx2 ) end function logHyperDual ! Log10 function elemental function log10HyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 v2 = log ( v1 ) / log ( 1 0.0_pr ) end function log10HyperDual ! Exp function elemental function expHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: dx dx = exp ( v1 % f0 ) v2 % f0 = dx v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * ( v1 % f12 + v1 % f1 * v1 % f2 ) end function expHyperDual ! Sinh function elemental function sinhHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: t1 , t2 , v2 t1 = exp ( v1 ) t2 = exp ( - v1 ) v2 = 0.5_pr * ( t1 - t2 ) end function sinhHyperDual ! Cosh function elemental function coshHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: t1 , t2 , v2 t1 = exp ( v1 ) t2 = exp ( - v1 ) v2 = 0.5_pr * ( t1 + t2 ) end function coshHyperDual ! Tanh function elemental function tanhHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: t1 , t2 , v2 t1 = exp ( v1 ) t2 = exp ( - v1 ) v2 = ( t1 - t2 ) / ( t1 + t2 ) end function tanhHyperDual ! Acos function elemental function acosHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: deriv , deriv1 deriv1 = 1.0_pr - v1 % f0 * v1 % f0 deriv = - 1.0_pr / sqrt ( deriv1 ) v2 % f0 = acos ( v1 % f0 ) v2 % f1 = deriv * v1 % f1 v2 % f2 = deriv * v1 % f2 v2 % f12 = deriv * v1 % f12 & & + v1 % f1 * v1 % f2 * ( - v1 % f0 * deriv1 ** ( - 1.5_pr )) end function acosHyperDual ! Asin function elemental function asinHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: deriv , deriv1 deriv1 = 1.0_pr - v1 % f0 * v1 % f0 deriv = 1.0_pr / sqrt ( deriv1 ) v2 % f0 = asin ( v1 % f0 ) v2 % f1 = deriv * v1 % f1 v2 % f2 = deriv * v1 % f2 v2 % f12 = deriv * v1 % f12 & & + v1 % f1 * v1 % f2 * ( v1 % f0 * deriv1 ** ( - 1.5_pr )) end function asinHyperDual ! Atan function elemental function atanHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: deriv , deriv1 deriv1 = 1.0_pr + v1 % f0 * v1 % f0 deriv = 1.0_pr / deriv1 v2 % f0 = atan ( v1 % f0 ) v2 % f1 = deriv * v1 % f1 v2 % f2 = deriv * v1 % f2 v2 % f12 = deriv * v1 % f12 & & + v1 % f1 * v1 % f2 * ( - 2.0_pr * v1 % f0 / ( deriv1 * deriv1 )) end function atanHyperDual ! Atan2 function elemental function atan2HyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 real ( pr ) :: a , b , c , d a = v1 % f0 b = v1 % f1 c = v2 % f0 d = v2 % f1 v3 % f0 = atan2 ( a , c ) v3 % f1 = ( c * b - a * d ) / ( a * a + c * c ) end function atan2HyperDual ! Max functions elemental function max_dd ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 if ( v1 % f0 > v2 % f0 ) then v3 = v1 else v3 = v2 endif end function max_dd elemental function max_ddd ( v1 , v2 , v3 ) result ( v4 ) type ( hyperdual ), intent ( in ) :: v1 , v2 , v3 type ( hyperdual ) :: v4 if ( v1 % f0 > v2 % f0 ) then v4 = v1 else v4 = v2 endif if ( v3 % f0 > v4 % f0 ) v4 = v3 end function max_ddd elemental function max_dr ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 % f0 > v2 ) then v3 = v1 else v3 = v2 endif end function max_dr elemental function max_rd ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 > v2 % f0 ) then v3 = v1 else v3 = v2 endif end function max_rd ! Min functions elemental function min_dd ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 if ( v1 % f0 < v2 % f0 ) then v3 = v1 else v3 = v2 endif end function min_dd elemental function min_dr ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 % f0 < v2 ) then v3 = v1 else v3 = v2 endif end function min_dr elemental function min_rd ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 < v2 % f0 ) then v3 = v1 else v3 = v2 endif end function min_rd end module","tags":"","url":"sourcefile/hyperdual.f90.html"},{"title":"dortmund.f90 – yaeos","text":"Source Code module yaeos__models_ge_group_contribution_dortmund use yaeos__constants , only : pr use yaeos__models_ge_gc_td , only : QuadraticPsi use yaeos__models_ge_group_contribution_groups , only : Groups use yaeos__models_ge_group_contribution_unifac , only : UNIFAC , setup_unifac use yaeos__models_ge_group_contribution_model_parameters , only : GeGCModelParameters use yaeos__models_ge_group_contribution_dortmund_parameters , only : DortmundParameters implicit none contains type ( UNIFAC ) function setup_dortmund ( molecules , parameters ) use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters type ( Groups ), intent ( in ) :: molecules (:) type ( GeGCModelParameters ), optional , intent ( in ) :: parameters type ( GeGCModelParameters ) :: params type ( QuadraticPsi ) :: psi_function real ( pr ), allocatable :: Aij (:, :), Bij (:, :), Cij (:, :) type ( Groups ) :: soup integer :: i , j , ng if ( present ( parameters )) then params = parameters else params = DortmundParameters () end if setup_dortmund = setup_unifac ( molecules , params ) ! ======================================================================== ! Build Aij, Bij and Cij matrix (interaction of the soup's subgroups) ! ------------------------------------------------------------------------ soup = setup_dortmund % groups_stew ng = size ( soup % groups_ids ) allocate ( Aij ( ng , ng ), Bij ( ng , ng ), Cij ( ng , ng )) Aij = 0 Bij = 0 Cij = 0 do i = 1 , size ( soup % groups_ids ) do j = 1 , size ( soup % groups_ids ) Aij ( i , j ) = params % get_subgroups_aij (& soup % groups_ids ( i ), soup % groups_ids ( j ) & ) Bij ( i , j ) = params % get_subgroups_bij (& soup % groups_ids ( i ), soup % groups_ids ( j ) & ) Cij ( i , j ) = params % get_subgroups_cij (& soup % groups_ids ( i ), soup % groups_ids ( j ) & ) end do end do psi_function % Aij = Aij psi_function % Bij = Bij psi_function % Cij = Cij deallocate ( setup_dortmund % psi_function ) setup_dortmund % psi_function = psi_function ! Important, the parameter d (exponent of the r params in Flory-Huggins) setup_dortmund % d = 3.0_pr / 4.0_pr end function end module","tags":"","url":"sourcefile/dortmund.f90.html"},{"title":"flash.f90 – yaeos","text":"Source Code module yaeos__equilibria_flash use yaeos__constants , only : pr use yaeos__models , only : BaseModel , ArModel , GeModel use yaeos__equilibria_equilibrium_state , only : EquilibriumState use yaeos__equilibria_rachford_rice , only : betato01 , betalimits , rachford_rice , solve_rr use yaeos__equilibria_auxiliar , only : k_wilson use yaeos__solvers_pressure_equality , only : pressure_equality_V_beta_xy implicit none contains type ( EquilibriumState ) function flash ( model , z , t , v_spec , p_spec , k0 , iters ) !! Flash algorithm using sucessive substitutions. !! !! Available specifications: !! !! - TP (with T and P_spec variables) !! - TV (with T and V_spec variables) !! !! This algorithm assumes that the specified T and P/V correspond to !! vapor-liquid separation predicted by the provided model (0<beta<1) and !! solves the equilibria and mass-balance equations with a fixed-point !! method. use yaeos__auxiliar , only : optval class ( BaseModel ), intent ( in ) :: model !! Thermodynamic model real ( pr ), intent ( in ) :: z (:) !! Global composition (molar fractions) real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), optional , intent ( in ) :: v_spec !! Specified Volume [L/mol] real ( pr ), optional , intent ( in ) :: p_spec !! Specified Pressure [bar] real ( pr ), optional , intent ( in ) :: k0 (:) !! Initial K factors (y/x) integer , optional , intent ( out ) :: iters !! Number of iterations ! Results from flash calculation real ( pr ), dimension ( size ( z )) :: x ! composition of liquid (molar fractions) real ( pr ), dimension ( size ( z )) :: y ! composition of vapour (molar fractions) real ( pr ) :: beta ! total fraction of vapour (molar base) ! Intermediate variables during calculation process real ( pr ) :: P , V real ( pr ), dimension ( size ( z )) :: lnfug_y , lnfug_x real ( pr ), dimension ( size ( z )) :: K , dK , lnK , dKold , lnKold real ( pr ) :: g0 , g1 ! function g valuated at beta=0 and 1, based on Wilson K factors real ( pr ) :: bmin , bmax , Vy , Vx character ( len = 2 ) :: spec !! Flash specification [PT | VT] ! ======================================================================== ! Starting steps ! ------------------------------------------------------------------------ select type ( model ) class is ( ArModel ) if ( present ( V_spec ) . and . present ( P_spec )) then write ( * , * ) \"ERROR: Can't specify pressure and volume in Flash\" return else if ( present ( p_spec )) then spec = \"TP\" p = p_spec else if ( present ( v_spec )) then spec = \"TV\" v = v_spec end if if ( spec == 'TV' ) then Vx = 0.0 if (. not . present ( k0 )) then ! the EoS one-phase pressure will be used to estimate Wilson K factors call model % pressure ( z , v_spec , t , p = p ) if ( P < 0 ) P = 1.0 end if end if if ( present ( K0 )) then K = K0 else K = k_wilson ( model , t , p ) end if class is ( GeModel ) if ( present ( K0 )) then K = K0 else error stop \"Flash: GeModel requires K0 to initialize\" end if end select ! Get K values that assure that beta is between 0 and 1 call betato01 ( z , K ) ! now we must have  g0>0 and g1<0 and therefore 0<beta<1 (M&M page 252) call betalimits ( z , K , bmin , bmax ) beta = ( bmin + bmax ) / 2 ! first guess for beta lnK = log ( K ) ! ======================================================================== ! Solve with successive substitutions ! ------------------------------------------------------------------------ dK = 1.0 iters = 0 do while ( maxval ( abs ( dK )) > 1.e-6_pr ) iters = iters + 1 call betato01 ( z , K ) call solve_rr ( z , K , beta , bmin , bmax ) y = z * K / ( 1 + beta * ( K - 1._pr )) x = y / K ! Calculate fugacities for each kind of specification select type ( model ) class is ( GeModel ) if ( present ( v_spec ) . or . present ( p_spec )) then error stop \"Flash: GeModel can only spec T\" end if call model % ln_activity_coefficient ( y , T , lngamma = lnfug_y ) call model % ln_activity_coefficient ( x , T , lngamma = lnfug_x ) class is ( ArModel ) select case ( spec ) case ( \"TV\" ) ! find Vy,Vx (vV and vL) from V balance and P equality equations call pressure_equality_V_beta_xy ( model , T , V , beta , x , y , Vx , Vy , P ) call model % lnphi_pt ( y , P , T , V = Vy , root_type = \"stable\" , lnPhi = lnfug_y ) call model % lnphi_pt ( x , P , T , V = Vx , root_type = \"liquid\" , lnPhi = lnfug_x ) case ( \"TP\" ) call model % lnphi_pt ( y , P , T , V = Vy , root_type = \"stable\" , lnPhi = lnfug_y ) call model % lnphi_pt ( x , P , T , V = Vx , root_type = \"liquid\" , lnPhi = lnfug_x ) end select end select dKold = dK lnKold = lnK lnK = lnfug_x - lnfug_y dK = lnK - lnKold K = exp ( lnK ) if ( iters > 10 . and . abs ( sum ( dK + dKold )) < 0.05_pr ) then ! oscilation behavior detected (27/06/15) lnK = ( lnK + lnKold ) / 2 end if ! Assure that beta is between the limits call betalimits ( z , K , bmin , bmax ) ! 26/06/15 if (( beta < bmin ) . or . ( bmax < beta )) then beta = ( bmin + bmax ) / 2 end if ! Step is too big, go back if ( maxval ( abs ( dK )) > 1.10_pr ) then ! 26/11/2014 g0 = sum ( z * K ) - 1._pr g1 = 1._pr - sum ( z / K ) if ( g0 < 0 . or . g1 > 0 ) then ! bring beta back to range, by touching K call betato01 ( z , K ) call betalimits ( z , K , bmin , bmax ) beta = ( bmin + bmax ) / 2 ! new guess for beta end if end if if ( iters > 500 ) then p = - 1 exit end if end do ! ======================================================================== ! Format results ! ------------------------------------------------------------------------ if ( spec == 'TP' ) V = beta * Vy + ( 1 - beta ) * Vx if ( maxval ( K ) < 1.001_pr . and . minval ( K ) > 0.999_pr . or . P < 0 ) then ! trivial solution flash % kind = \"failed\" P = - 1.0 flash % x = x / x flash % y = y / y flash % iters = iters flash % P = P flash % T = T return end if flash % kind = \"split\" flash % iters = iters flash % P = P flash % T = T flash % x = x flash % y = y flash % Vx = Vx flash % Vy = Vy flash % beta = beta end function flash end module yaeos__equilibria_flash","tags":"","url":"sourcefile/flash.f90.html"},{"title":"gemodel_adiff_api.f90 – yaeos","text":"Source Code module yaeos__adiff_hyperdual_ge_api !! Module that contains the automatic differentiation logic for an Ge model. !! !! All that is needed to define an Ge model that uses automatic !! differentiation with hyperdual numbers is to define a new derived type !! that overloads the method to the Ge function that you want to use. use yaeos__constants , only : pr use yaeos__models_ge , only : GeModel use hyperdual_mod implicit none type , abstract , extends ( GeModel ) :: GeModelAdiff contains procedure ( hyperdual_ge ), deferred :: Ge procedure :: excess_gibbs => excess_gibbs end type GeModelAdiff abstract interface type ( hyperdual ) function hyperdual_Ge ( self , n , t ) import hyperdual , GeModelAdiff class ( GeModelAdiff ) :: self type ( hyperdual ), intent ( in ) :: n (:) type ( hyperdual ), intent ( in ) :: t end function hyperdual_Ge end interface contains subroutine excess_gibbs ( self , n , T , Ge , GeT , GeT2 , Gen , GeTn , Gen2 ) class ( GeModelAdiff ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: t real ( pr ), optional , intent ( out ) :: Ge , GeT , GeT2 real ( pr ), optional , dimension ( size ( n )), intent ( out ) :: Gen , GeTn real ( pr ), optional , intent ( out ) :: Gen2 ( size ( n ), size ( n )) type ( hyperdual ) :: d_t , d_n ( size ( n )) type ( hyperdual ) :: d_Ge real ( pr ) :: dGe ( size ( n ) + 1 , size ( n ) + 1 ) integer :: nc logical :: any_deriv any_deriv = . false . nc = size ( n ) if ( present ( GeT ) . or . present ( GeT2 )) then any_deriv = . true . if ( present ( GeT2 )) then call get_dgedt2 end if if (. not . ( present ( GeT2 ) . and . . not . present ( GeTn ))) then call get_dgedt end if end if if ( present ( GeTn )) then any_deriv = . true . call get_dgedtn end if if ( present ( Gen ) . or . present ( Gen2 )) then any_deriv = . true . if ( present ( Gen2 )) then call get_dgedn2 else call get_dgedn end if end if if ( present ( Ge )) then if (. not . any_deriv ) then call reset_vars d_ge = self % Ge ( d_n , d_t ) end if Ge = d_ge % f0 end if contains subroutine get_dgedn () integer :: i , j do i = 2 , size ( n ), 2 call reset_vars d_n ( i - 1 )% f1 = 1 d_n ( i )% f2 = 1 d_Ge = self % Ge ( d_n , d_t ) Gen ( i - 1 ) = d_Ge % f1 Gen ( i ) = d_Ge % f2 end do if ( mod ( size ( n ), 2 ) /= 0 ) then call reset_vars d_n ( size ( n ))% f1 = 1 d_Ge = self % Ge ( d_n , d_t ) Gen ( size ( n )) = d_Ge % f1 end if end subroutine get_dgedn subroutine get_dgedn2 () integer :: i , j do i = 1 , size ( n ) do j = i , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_n ( j )% f2 = 1 d_Ge = self % Ge ( d_n , d_t ) if ( present ( Gen )) Gen ( i ) = d_Ge % f1 Gen2 ( i , j ) = d_Ge % f12 Gen2 ( j , i ) = d_Ge % f12 end do end do end subroutine get_dgedn2 subroutine get_dgedtn () integer :: i do i = 1 , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_t % f2 = 1 d_Ge = self % Ge ( d_n , d_t ) if ( present ( Gen )) Gen ( i ) = d_Ge % f1 if ( present ( GeT )) GeT = d_Ge % f2 GeTn ( i ) = d_Ge % f12 end do end subroutine get_dgedtn subroutine get_dgedt () call reset_vars d_t % f1 = 1 d_Ge = self % Ge ( d_n , d_t ) GeT = d_Ge % f1 end subroutine get_dgedt subroutine get_dgedt2 () call reset_vars d_t % f1 = 1 d_t % f2 = 1 d_Ge = self % Ge ( d_n , d_t ) if ( present ( GeT )) GeT = d_Ge % f1 if ( present ( GeT2 )) GeT2 = d_Ge % f12 end subroutine get_dgedt2 subroutine reset_vars () d_n = n d_t = t end subroutine reset_vars end subroutine excess_gibbs end module yaeos__adiff_hyperdual_ge_api","tags":"","url":"sourcefile/gemodel_adiff_api.f90.html"},{"title":"substance.f90 – yaeos","text":"Source Code module yaeos__substance !! yaeos Subtance module. !! !! Module containing pure components properties and parameters. use yaeos__constants , only : pr type :: Substances !! Set of pure components character ( len = 50 ), allocatable :: names (:) !! Composition names. real ( pr ), allocatable :: tc (:) !! Critical Temperature [K] real ( pr ), allocatable :: pc (:) !! Critical Pressure [bar] real ( pr ), allocatable :: w (:) !! Acentric factor real ( pr ), allocatable :: vc (:) !! Critical Volume [L/mol] end type end module","tags":"","url":"sourcefile/substance.f90.html"},{"title":"groups.f90 – yaeos","text":"Source Code module yaeos__models_ge_group_contribution_groups use yaeos__constants , only : pr implicit none type :: Groups !! # Groups !! Derived type used to represent a molecule and its UNIFAC groups. !! !! # Description !! Derived type used to represent a molecule and its UNIFAC groups. Is !! necessary to specify the subgroups ids and the subgroups on each !! molecule as shown in the example. !! !! # Examples !! !! ```fortran !!  ! Define toluene molecule groups !!  use yaeos, only: Groups !! !!  type(Groups) :: toluene !! !!  ! Toluene [ACH, ACCH3] !!  toluene%groups_ids = [9, 11] ! Subgroups ids !!  toluene%number_of_groups = [5, 1] ! Subgroups occurrences !! ``` !! !! # References !! 1. [Dortmund Data Bank Software & Separation Technology](https://www.ddbst !! .com/published-parameters-unifac.html) integer , allocatable :: groups_ids (:) !! Indexes (ids) of each subgroup in the main group matrix integer , allocatable :: number_of_groups (:) !! Occurrences of each subgroup in the molecule real ( pr ) :: surface_area !! Molecule surface area q real ( pr ) :: volume !! Molecule volume r end type Groups end module yaeos__models_ge_group_contribution_groups","tags":"","url":"sourcefile/groups.f90.html"},{"title":"equilibria_state.f90 – yaeos","text":"Source Code module yaeos__equilibria_equilibrium_state use yaeos__constants , only : pr implicit none type :: EquilibriumState !! Description of a two-phase equilibria state. !! !! Contains the relevant information of an equilibrium point obtained !! from some kind of equilibria calculation. character ( len = 14 ) :: kind !! Kind of point [\"bubble\", \"dew\", \"liquid-liquid\", \"split\"] integer :: iters = 0 !! Iterations needed to reach the state real ( pr ), allocatable :: y (:) !! Light-phase molar fractions real ( pr ), allocatable :: x (:) !! Heavy-phase molar fractions real ( pr ) :: Vx !! Heavy-phase volume [L/mol] real ( pr ) :: Vy !! Light-phase volume [L/mol] real ( pr ) :: T !! Temperature [K] real ( pr ) :: P !! Pressure [bar] real ( pr ) :: beta !! Mole fraction of light-phase contains private procedure , pass :: write => write_EquilibriumState generic , public :: write ( FORMATTED ) => write end type EquilibriumState contains subroutine write_EquilibriumState ( eq , unit , iotype , v_list , iostat , iomsg ) class ( EquilibriumState ), intent ( in ) :: eq integer , intent ( in ) :: unit character ( * ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg character ( * ), parameter :: nl = new_line ( \"G\" ) write ( unit , * ) eq % kind , eq % T , eq % P , eq % beta , eq % x , eq % y end subroutine write_EquilibriumState end module yaeos__equilibria_equilibrium_state","tags":"","url":"sourcefile/equilibria_state.f90.html"},{"title":"quadratic_mixing.f90 – yaeos","text":"Source Code module yaeos__models_ar_cubic_quadratic_mixing !! Quadratic Mixing Rules for Cubic EoS. use yaeos__constants , only : pr , solving_volume use yaeos__substance , only : substances use yaeos__models_ar_genericcubic , only : CubicMixRule use yaeos__models_ar_cubic_mixing_base , only : bmix_qmr implicit none type , extends ( CubicMixRule ) :: QMR !! Quadratic Mixing Rule (QMR) derived type. Classic Van der Waals mixing !! rules. !! !! QMR depends on binary interaction parameters, on a Cubic EoS !! the mixture is obtained by the combination of an attractive and !! repulsive parameter matrices. !! !! By default the attractive parameter matrix is calculated with: !! a_{ij} = \\sqrt{a_i a_j}(1 - k_{ij}) !! generating the a_{ij} matrix, but this procedure can be overriden !! replacing the `aij` pointer procedure. real ( pr ), allocatable :: k (:, :) !! Attractive Binary Interatction parameter matrix real ( pr ), allocatable :: l (:, :) !! Repulsive Binary Interatction parameter matrix contains procedure :: aij => kij_constant !! Default attractive parameter combining rule procedure :: Dmix !! Attractive parameter mixing rule procedure :: Bmix !! Repulsive parameter mixing rule procedure :: D1mix => RKPR_D1mix end type QMR type , extends ( QMR ) :: QMRTD real ( pr ), allocatable :: k0 (:, :) real ( pr ), allocatable :: Tref (:, :) contains procedure :: aij => kij_exp_tdep end type QMRTD abstract interface subroutine get_aij ( self , T , ai , daidt , daidt2 , aij , daijdt , daijdt2 ) !! Combining rule for the attractive parameter. !! !! From previously calculated attractive parameters calculate the !! a_{ij} matrix and it's corresponding derivatives. import pr , QMR class ( QMR ), intent ( in ) :: self real ( pr ), intent ( in ) :: T real ( pr ), intent ( in ) :: ai (:), daidt (:), daidt2 (:) real ( pr ), intent ( out ) :: aij (:, :), daijdt (:, :), daijdt2 (:, :) end subroutine get_aij end interface contains subroutine Dmix ( self , n , T , & ai , daidt , daidt2 , & D , dDdT , dDdT2 , dDi , dDidT , dDij ) !! Attractive parameter mixing rule with quadratic mix. !! !! Takes the all the pure components attractive parameters and their !! derivatives with respect to temperature and mix them with the !! Van der Waals quadratic mixing rule: !! !!  !!   D = \\sum_i \\sum_j n_i n_j a_{ij} = n&#94;2 a_{mix} !!  !! !! Inside the routine the a_{ij} matrix is calculated using the !! procedure contained in the `QMR` object, this procedures defaults !! to the common combining rule: a_{ij} = \\sqrt{a_i a_j} (1 - k_{ij})  !! !! The procedure can be overloaded by a common one that respects the !! interface [[get_aij(interface)]] !! !! ```fortran !! type(QMR) :: my_mixing_rule !! my_mixing_rule%aij => new_aij_procedure !! ``` class ( QMR ), intent ( in ) :: self !! Mixing rule object. real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: n (:) !! Moles vector [mol] real ( pr ), intent ( in ) :: ai (:) !! Pure components attractive parameters a_i real ( pr ), intent ( in ) :: daidt (:) !! \\frac{da_i}{dT} real ( pr ), intent ( in ) :: daidt2 (:) !! \\frac{d&#94;2a_i}{dT&#94;2} real ( pr ), intent ( out ) :: D !! Mixture attractive parameter n&#94;2a_{mix} real ( pr ), intent ( out ) :: dDdT !! \\frac{dD}{dT} real ( pr ), intent ( out ) :: dDdT2 !! \\frac{d&#94;2D}{dT&#94;2} real ( pr ), intent ( out ) :: dDi (:) !! \\frac{dD}{dn_i} real ( pr ), intent ( out ) :: dDidT (:) !! \\frac{d&#94;2D}{dTn_i} real ( pr ), intent ( out ) :: dDij (:, :) !! \\frac{d&#94;2D}{dn_{ij}} integer :: i , j , nc real ( pr ) :: aux , aux2 real ( pr ) :: aij ( size ( ai ), size ( ai )) real ( pr ) :: daijdt ( size ( ai ), size ( ai )) real ( pr ) :: daijdt2 ( size ( ai ), size ( ai )) nc = size ( ai ) call self % aij ( T , ai , daidt , daidt2 , aij , daijdt , daijdt2 ) D = 0 dDdT = 0 dDdT2 = 0 if ( solving_volume ) then D = dot_product ( n , matmul ( n , aij )) else do i = 1 , nc aux = 0 aux2 = 0 dDi ( i ) = 0 dDidT ( i ) = 0 do j = 1 , nc dDi ( i ) = dDi ( i ) + 2 * n ( j ) * aij ( i , j ) dDidT ( i ) = dDidT ( i ) + 2 * n ( j ) * daijdT ( i , j ) aux2 = aux2 + n ( j ) * daijdT2 ( i , j ) dDij ( i , j ) = 2 * aij ( i , j ) aux = aux + n ( j ) * aij ( i , j ) end do D = D + n ( i ) * aux dDdT = dDdT + n ( i ) * dDidT ( i ) * 0.5_pr dDdT2 = dDdT2 + n ( i ) * aux2 end do end if end subroutine Dmix subroutine Bmix ( self , n , bi , B , dBi , dBij ) !! Mixture repulsive parameter. !! !! Calculate the mixture's repulsive parameter and it's derivatives !! with respect to composition: !! !!  !!    nB = \\sum_i \\sum_j n_i n_j \\frac{b_i + b_j}{2} (1 - l_{ij}) !!  !! class ( QMR ), intent ( in ) :: self !! Mixing rule object. real ( pr ), intent ( in ) :: n (:) !! Moles vector. real ( pr ), intent ( in ) :: bi (:) !! Pure components repulsive parameters. real ( pr ), intent ( out ) :: B !! Mixture repulsive parameter. real ( pr ), intent ( out ) :: dBi (:) !! \\frac{dB}{dn_i} real ( pr ), intent ( out ) :: dBij (:, :) !!\\frac{d&#94;2B}{dn_{ij}} call bmix_qmr ( n , bi , self % l , b , dbi , dbij ) end subroutine Bmix subroutine RKPR_D1mix ( self , n , d1i , D1 , dD1i , dD1ij ) use yaeos__models_ar_cubic_mixing_base , only : d1mix_rkpr !! RKPR \\delta_1 parameter mixing rule. !! !! The RKPR EoS doesn't have a constant \\delta_1 value for each !! component, so a proper mixing rule should be provided. A linear !! combination is used. !! !!  !!     \\Delta_1 = \\sum_i&#94;N n_i \\delta_{1i} !!  !! class ( QMR ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: d1i (:) real ( pr ), intent ( out ) :: D1 real ( pr ), intent ( out ) :: dD1i (:) real ( pr ), intent ( out ) :: dD1ij (:, :) call d1mix_rkpr ( n , d1i , d1 , dd1i , dd1ij ) end subroutine RKPR_D1mix subroutine kij_constant (& self , T , a , dadt , dadt2 , & aij , daijdt , daijdt2 & ) !! Combining rule that uses constant k_{ij} values. !! !!  !!  a_{ij} = \\sqrt{a_i a_j} (1 - k_{ij}) !! ] class ( QMR ), intent ( in ) :: self real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: a (:) !! Pure components attractive parameters (\\a_i real ( pr ), intent ( in ) :: dadt (:) !! \\frac{da_i}{dT} real ( pr ), intent ( in ) :: dadt2 (:) !! \\frac{d&#94;2a_i}{dT&#94;2} real ( pr ), intent ( out ) :: aij (:, :) !! a_{ij} Matrix real ( pr ), intent ( out ) :: daijdt (:, :) !! \\frac{da_{ij}{dT} real ( pr ), intent ( out ) :: daijdt2 (:, :) !! \\frac{d&#94;2a_{ij}{dT&#94;2} integer :: i , j real ( pr ) :: sqrt_aii_ajj real ( pr ) :: inner_sum do i = 1 , size ( a ) aij ( i , i ) = a ( i ) daijdt ( i , i ) = dadt ( i ) daijdt2 ( i , i ) = dadt2 ( i ) do j = i + 1 , size ( a ) sqrt_aii_ajj = sqrt ( a ( i ) * a ( j )) aij ( i , j ) = sqrt_aii_ajj * ( 1 - self % k ( i , j )) inner_sum = a ( i ) * dadt ( j ) + a ( j ) * dadt ( i ) daijdt ( i , j ) = 0.5_pr * aij ( i , j ) * ( inner_sum ) / ( a ( i ) * a ( j )) daijdt2 ( i , j ) = & ( 1 - self % k ( i , j )) * ( dadT ( j ) * dadT ( i ) / sqrt ( a ( i ) * a ( j )) & + sqrt ( a ( i ) / a ( j )) * ( dadT2 ( j ) - dadT ( j ) ** 2 / ( 2 * a ( j ))) & + sqrt ( a ( j ) / a ( i )) * ( dadT2 ( i ) - dadT ( i ) ** 2 / ( 2 * a ( i )))) / 2 aij ( j , i ) = aij ( i , j ) daijdt ( j , i ) = daijdt ( i , j ) daijdt2 ( j , i ) = daijdt2 ( i , j ) end do end do end subroutine kij_constant subroutine kij_exp_tdep (& self , T , a , dadt , dadt2 , & aij , daijdt , daijdt2 & ) !! # kij_exp_tdep !! !! Combining rule that uses temperature dependant k_{ij} values. !! With the following expression: !!  !! k_{ij}(T) = k_{ij}&#94;0 + k_{ij}&#94;\\infty \\exp\\left(\\frac{-T}{T&#94;*}\\right) !!   !! !!  !!  a_{ij} = \\sqrt{a_i a_j} (1 - k_{ij}) !! ] use hyperdual_mod class ( QMRTD ), intent ( in ) :: self real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: a (:) !! Pure components attractive parameters (\\a_i real ( pr ), intent ( in ) :: dadt (:) !! \\frac{da_i}{dT} real ( pr ), intent ( in ) :: dadt2 (:) !! \\frac{d&#94;2a_i}{dT&#94;2} real ( pr ), intent ( out ) :: aij (:, :) !! a_{ij} Matrix real ( pr ), intent ( out ) :: daijdt (:, :) !! \\frac{da_{ij}{dT} real ( pr ), intent ( out ) :: daijdt2 (:, :) !! \\frac{d&#94;2a_{ij}{dT&#94;2} real ( pr ) :: k0 ( size ( a ), size ( a )) real ( pr ) :: kinf ( size ( a ), size ( a )) real ( pr ) :: Tstar ( size ( a ), size ( a )) type ( hyperdual ) :: aij_hd ( size ( a ), size ( a )), kij_hd ( size ( a ), size ( a )), T_hd type ( hyperdual ) :: a_hd ( size ( a )) integer :: i , j , nc T_hd = T T_hd % f1 = 1 T_hd % f2 = 1 k0 = self % k0 kinf = self % k Tstar = self % Tref kij_hd = kinf + k0 * exp ( - T_hd / Tstar ) a_hd = a ! Inject the already calculated derivatives a_hd % f1 = dadt a_hd % f2 = dadt a_hd % f12 = dadt2 nc = size ( a ) do i = 1 , size ( a ) aij_hd ( i , i ) = sqrt ( a_hd ( i ) * a_hd ( i )) do j = i + 1 , size ( a ) aij_hd ( i , j ) = sqrt ( a_hd ( i ) * a_hd ( j )) * ( 1._pr - kij_hd ( i , j )) aij_hd ( j , i ) = aij_hd ( i , j ) end do end do aij = aij_hd % f0 daijdt = aij_hd % f1 daijdt2 = aij_hd % f12 end subroutine kij_exp_tdep end module yaeos__models_ar_cubic_quadratic_mixing","tags":"","url":"sourcefile/quadratic_mixing.f90.html"},{"title":"saturation_point.f90 – yaeos","text":"Source Code module yaeos__m_s_sp !! Module to calculate saturation points use yaeos__constants , only : pr use yaeos__models_ar , only : ArModel , size implicit none contains subroutine saturation_F ( model , z , X , ns , S , F , dF , dPdVz , dPdVy ) class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( out ) :: F (:) real ( pr ), optional , intent ( out ) :: dF (:, :) real ( pr ), intent ( out ) :: dPdVz , dPdVy ! Variables real ( pr ) :: T , Vz , Vy real ( pr ) :: z ( size ( model )) ! Main phase variables real ( pr ) :: lnfug_z ( size ( model )), dlnfug_dn_z ( size ( model ), size ( model )) real ( pr ) :: dlnfug_dT_z ( size ( model )), dlnfug_dV_z ( size ( model )) real ( pr ) :: dlnfug_dP_z ( size ( model )) real ( pr ) :: Pz , dPdTz , dPdn_z ( size ( z )) ! incipient phase variables real ( pr ) :: y ( size ( z )) real ( pr ) :: lnfug_y ( size ( model )), dlnfug_dn_y ( size ( model ), size ( model )) real ( pr ) :: dlnfug_dT_y ( size ( model )), dlnfug_dV_y ( size ( model )) real ( pr ) :: dlnfug_dP_y ( size ( model )) real ( pr ) :: Py , dPdTy , dPdn_y ( size ( z )) real ( pr ) :: lnPspec integer :: j , nc nc = size ( z ) y = z * exp ( X (: nc )) Vz = exp ( X ( nc + 1 )) Vy = exp ( X ( nc + 2 )) T = exp ( X ( nc + 3 )) lnPspec = X ( nc + 4 ) if ( present ( df )) then call model % lnfug_vt (& n = z , V = Vz , T = T , P = Pz , dPdT = dPdTz , dPdV = dPdVz , dPdn = dPdn_z , & lnf = lnfug_z , & dlnfdV = dlnfug_dV_z , dlnfdT = dlnfug_dT_z , dlnfdn = dlnfug_dn_z & ) call model % lnfug_vt (& n = y , V = Vy , T = T , P = Py , dPdT = dPdTy , dPdV = dPdVy , dPdn = dPdn_y , & lnf = lnfug_y , & dlnfdV = dlnfug_dV_y , dlnfdT = dlnfug_dT_y , dlnfdn = dlnfug_dn_y & ) else call model % lnfug_vt ( n = z , V = Vz , T = T , P = Pz , lnf = lnfug_z ) call model % lnfug_vt ( n = y , V = Vy , T = T , P = Py , lnf = lnfug_y ) end if F = 0 F (: nc ) = lnfug_y - lnfug_z F ( nc + 1 ) = sum ( y - z ) F ( nc + 2 ) = Py - Pz F ( nc + 3 ) = lnPspec - log ( Py ) F ( nc + 4 ) = X ( ns ) - S if ( present ( dF )) then dF = 0 ! isofugacity do j = 1 , nc df (: nc , j ) = y ( j ) * dlnfug_dn_y (:, j ) end do dF (: nc , nc + 1 ) = - dlnfug_dV_z * Vz dF (: nc , nc + 2 ) = dlnfug_dV_y * Vy dF (: nc , nc + 3 ) = T * ( dlnfug_dT_y - dlnfug_dT_z ) ! mass balance df ( nc + 1 , : nc ) = y ! pressure equality df ( nc + 2 , : nc ) = y * dPdn_y df ( nc + 2 , nc + 1 ) = - dPdVz * Vz df ( nc + 2 , nc + 2 ) = dPdVy * Vy df ( nc + 2 , nc + 3 ) = T * ( dPdTy - dPdTz ) df ( nc + 3 , : nc ) = - y * dPdn_y / Py df ( nc + 3 , nc + 1 ) = 0 df ( nc + 3 , nc + 2 ) = - dPdVy * Vy / Py df ( nc + 3 , nc + 3 ) = - dPdTy * T / Py df ( nc + 3 , nc + 4 ) = 1 df ( nc + 4 , ns ) = 1 end if end subroutine saturation_F subroutine saturation_TP ( model , kind , z , X , ns , S , F , dF , dFdS ) class ( ArModel ), intent ( in ) :: model character ( len =* ), intent ( in ) :: kind real ( pr ), intent ( in ) :: z ( size ( model )) real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( out ) :: F (:) real ( pr ), intent ( out ) :: dF (:, :) real ( pr ), intent ( out ) :: dFdS (:) character ( len = 14 ) :: kind_z , kind_y real ( pr ) :: y ( size ( X ) - 2 ) real ( pr ) :: Vz , Vy real ( pr ) :: lnPhi_z ( size ( X ) - 2 ), lnPhi_y ( size ( X ) - 2 ) real ( pr ) :: dlnphi_dt_z ( size ( X ) - 2 ), dlnphi_dt_y ( size ( X ) - 2 ) real ( pr ) :: dlnphi_dp_z ( size ( X ) - 2 ), dlnphi_dp_y ( size ( X ) - 2 ) real ( pr ) :: dlnphi_dn_z ( size ( X ) - 2 , size ( X ) - 2 ), dlnphi_dn_y ( size ( X ) - 2 , size ( X ) - 2 ) real ( pr ) :: T , P , K ( size ( X ) - 2 ) integer :: i , j , nc nc = size ( X ) - 2 F = 0 dF = 0 K = exp ( X (: nc )) T = exp ( X ( nc + 1 )) P = exp ( X ( nc + 2 )) y = K * z select case ( kind ) case ( \"bubble\" ) kind_z = \"liquid\" kind_y = \"vapor\" case ( \"dew\" ) kind_z = \"vapor\" kind_y = \"liquid\" case ( \"liquid-liquid\" ) kind_z = \"liquid\" kind_y = \"liquid\" case default kind_z = \"stable\" kind_y = \"stable\" end select call model % lnphi_pt (& z , P , T , V = Vz , root_type = kind_z , & lnPhi = lnphi_z , dlnPhidt = dlnphi_dt_z , & dlnPhidp = dlnphi_dp_z , dlnphidn = dlnphi_dn_z & ) call model % lnphi_pt (& y , P , T , V = Vy , root_type = kind_y , & lnPhi = lnphi_y , dlnPhidt = dlnphi_dt_y , & dlnPhidp = dlnphi_dp_y , dlnphidn = dlnphi_dn_y & ) F (: nc ) = X (: nc ) + lnPhi_y - lnPhi_z F ( nc + 1 ) = sum ( y - z ) F ( nc + 2 ) = X ( ns ) - S ! Jacobian Matrix do j = 1 , nc df (: nc , j ) = dlnphi_dn_y (:, j ) * y ( j ) df ( j , j ) = dF ( j , j ) + 1 end do df (: nc , nc + 1 ) = T * ( dlnphi_dt_y - dlnphi_dt_z ) df (: nc , nc + 2 ) = P * ( dlnphi_dp_y - dlnphi_dp_z ) df ( nc + 1 , : nc ) = y df ( nc + 2 , :) = 0 df ( nc + 2 , ns ) = 1 dFdS = 0 dFdS ( nc + 2 ) = - 1 end subroutine saturation_TP subroutine solve_TP ( model , kind , z , X , ns , S , tol , max_iterations , its ) use yaeos__math , only : solve_system class ( ArModel ), intent ( in ) :: model character ( len =* ), intent ( in ) :: kind real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( inout ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( in ) :: tol integer , intent ( in ) :: max_iterations integer , intent ( out ) :: its integer :: nc real ( pr ) :: F ( size ( X )) real ( pr ) :: dF ( size ( X ), size ( X )) real ( pr ) :: dFdS ( size ( X )) real ( pr ) :: dx ( size ( X )) nc = size ( X ) - 2 its = 0 dX = 1 do while ( its < max_iterations ) its = its + 1 call saturation_TP ( model = model , z = z , kind = kind , X = X , ns = ns , S = S , F = F , dF = dF , dFdS = dFdS ) dX = solve_system ( dF , - F ) do while ( abs ( dX ( nc + 1 )) > 0.1 ) dX ( nc + 1 ) = dX ( nc + 1 ) / 2 end do do while ( abs ( dX ( nc + 2 )) > 0.1 ) dX ( nc + 2 ) = dX ( nc + 2 ) / 2 end do X = X + dX if ( all ( abs ( F ) < tol )) exit end do end subroutine solve_TP subroutine solve_VxVyT ( model , z , X , ns , S , tol , max_iterations , its ) use yaeos__math , only : solve_system class ( ArModel ), intent ( in ) :: model real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( inout ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( in ) :: tol integer , intent ( in ) :: max_iterations integer , intent ( out ) :: its real ( pr ) :: dPdVz , dPdVy integer :: nc real ( pr ) :: F ( size ( X )) real ( pr ) :: dF ( size ( X ), size ( X )) real ( pr ) :: dFdS ( size ( X )) real ( pr ) :: Xold ( size ( X )), dx ( size ( X )), dx_old ( size ( x )) nc = size ( X ) - 4 its = 0 do while ( its < max_iterations ) call saturation_F ( model , z , X , ns , S , F , dF , dPdVz , dPdVy ) if ( all ( abs ( F ) < tol )) exit dX = solve_system ( dF , - F ) X = X + dX its = its + 1 end do end subroutine solve_VxVyT end module yaeos__m_s_sp","tags":"","url":"sourcefile/saturation_point.f90.html"},{"title":"parameters_gerg2008.f90 – yaeos","text":"Source Code module yaeos__models_ar_multifluid_parameters_gerg2008 use yaeos__constants , only : pr use yaeos__models_base , only : Substances implicit none integer :: max_residual_terms = 24 , generalized_departure ( 8 , 2 ) integer , parameter :: N = 21 real ( 8 ), dimension ( 21 , 21 , 4 ) :: red_params real ( 8 ), dimension ( 21 , 21 ) :: Bv = 0 , Gv = 0 , Bt = 0 , Gt = 0 real ( 8 ), dimension ( 21 , 24 ) :: noik = 0 , toik = 0 integer , dimension ( 21 , 24 ) :: doik = 0 , coik = 0 integer , dimension ( 21 ) :: Kpol = 0 , Kexp = 0 real ( 8 ), dimension ( 21 , 21 ) :: Fij = 0 real ( 8 ), dimension ( 21 , 21 , 12 ) :: tij = 0 , nij = 0 , ethaij = 0 , epsij = 0 , betaij = 0 , gammaij = 0 integer , dimension ( 21 , 21 , 12 ) :: dij = 0 integer , dimension ( 21 , 21 ) :: Kpolij = 0 , Kexpij = 0 real ( 8 ), dimension ( 21 ) :: T_c = 0 , rho_c = 0 , M = 0 , P_c = 0 , acentric_factor = 0 integer :: tmp1 ( 3 ) = 0 , tmp2 ( 14 ) = 0 ! This variables are used to define indexes for repeated terms real ( 8 ), dimension ( 21 , 7 ) :: n0i = 0 , th0i = 0 real ( 8 ) :: R = 0 , eps = 1 d - 10 type :: Gerg2008Pure integer :: Kpol integer :: Kexp real ( 8 ), allocatable :: n (:) real ( 8 ), allocatable :: d (:) real ( 8 ), allocatable :: t (:) real ( 8 ), allocatable :: c (:) end type Gerg2008Pure type :: Gerg2008Binary integer :: i !! Component i integer :: j !! Component j real ( 8 ) :: Bv !! Binary volume interaction parameters real ( 8 ) :: Gv !! Binary volume interaction parameters real ( 8 ) :: Bt !! Binary temperature interaction parameters real ( 8 ) :: Gt !! Binary temperature interaction parameters integer :: Kpolij integer :: Kexpij real ( 8 ), allocatable :: nij (:) real ( 8 ), allocatable :: dij (:) real ( 8 ), allocatable :: tij (:) real ( 8 ), allocatable :: ethaij (:) real ( 8 ), allocatable :: epsij (:) real ( 8 ), allocatable :: betaij (:) real ( 8 ), allocatable :: gammaij (:) real ( 8 ) :: Fij end type Gerg2008Binary contains subroutine get_original_parameters ( ids , pures , binaries , components ) integer , intent ( in ) :: ids (:) type ( Gerg2008Pure ), intent ( out ) :: pures (:) type ( Gerg2008Binary ), intent ( out ) :: binaries (:, :) type ( Substances ), intent ( out ) :: components integer :: i , j integer :: nc integer :: ikpol , ikexp real ( pr ) :: Tc ( size ( ids )), Pc ( size ( ids )), w ( size ( ids )), Vc ( size ( ids )) nc = size ( ids ) call original_parameters () Tc = [( T_c ( ids ( i )), i = 1 , nc )] Pc = [( P_c ( ids ( i )), i = 1 , nc )] / 1e5 w = [( acentric_factor ( ids ( i )), i = 1 , nc )] Vc = [( 1 / rho_c ( ids ( i )), i = 1 , nc )] components = Substances ( Tc = Tc , Pc = Pc , w = w , Vc = Vc ) do i = 1 , nc pures ( i )% kpol = kpol ( ids ( i )) pures ( i )% kexp = kexp ( ids ( i )) pures ( i )% n = noik ( ids ( i ), :) pures ( i )% d = doik ( ids ( i ), :) pures ( i )% t = toik ( ids ( i ), :) pures ( i )% c = coik ( ids ( i ), kpol ( ids ( i )) + 1 : kexp ( ids ( i )) + kpol ( ids ( i ))) end do do i = 1 , nc do j = 1 , nc binaries ( i , j )% Bt = Bt ( ids ( i ), ids ( j )) binaries ( i , j )% Gt = Gt ( ids ( i ), ids ( j )) binaries ( i , j )% Bv = Bv ( ids ( i ), ids ( j )) binaries ( i , j )% Gv = Gv ( ids ( i ), ids ( j )) ikpol = Kpolij ( ids ( i ), ids ( j )) ikexp = Kexpij ( ids ( i ), ids ( j )) binaries ( i , j )% Kpolij = Kpolij ( ids ( i ), ids ( j )) binaries ( i , j )% Kexpij = Kexpij ( ids ( i ), ids ( j )) binaries ( i , j )% nij = nij ( ids ( i ), ids ( j ), : ikexp + ikpol ) binaries ( i , j )% dij = dij ( ids ( i ), ids ( j ), : ikexp + ikpol ) binaries ( i , j )% tij = tij ( ids ( i ), ids ( j ), : ikexp + ikpol ) binaries ( i , j )% ethaij = ethaij ( ids ( i ), ids ( j ), ikpol + 1 : ikexp + ikpol ) binaries ( i , j )% epsij = epsij ( ids ( i ), ids ( j ), ikpol + 1 : ikexp + ikpol ) binaries ( i , j )% betaij = betaij ( ids ( i ), ids ( j ), ikpol + 1 : ikexp + ikpol ) binaries ( i , j )% gammaij = gammaij ( ids ( i ), ids ( j ), ikpol + 1 : ikexp + ikpol ) binaries ( i , j )% Fij = Fij ( ids ( i ), ids ( j )) end do end do end subroutine get_original_parameters subroutine original_parameters () !! Parameter table of the original GERG 2008 model integer :: i , j , k R = 8.314472d0 P_c ( 1 ) = 4 6.0 * 1 d5 P_c ( 2 ) = 3 3.9 * 1 d5 P_c ( 3 ) = 7 3.8 * 1 d5 P_c ( 4 ) = 4 8.8 * 1 d5 P_c ( 5 ) = 4 2.5 * 1 d5 P_c ( 6 ) = 3 8.0 * 1 d5 P_c ( 7 ) = 3 6.5 * 1 d5 P_c ( 8 ) = 3 3.7 * 1 d5 P_c ( 9 ) = 3 3.9 * 1 d5 P_c ( 10 ) = 3 0.1 * 1 d5 P_c ( 11 ) = 2 7.4 * 1 d5 P_c ( 12 ) = 2 4.9 * 1 d5 P_c ( 13 ) = 228100 0.0d0 P_c ( 14 ) = 210300 0.0d0 P_c ( 15 ) = 129640 0.0d0 P_c ( 16 ) = 504300 0.0d0 P_c ( 17 ) = 349400 0.0d0 P_c ( 18 ) = 2206400 0.0d0 P_c ( 19 ) = 900000 0.0d0 P_c ( 20 ) = 22760 0.0d0 P_c ( 21 ) = 486300 0.0d0 acentric_factor ( 1 ) = 0.011 acentric_factor ( 2 ) = 0.039 acentric_factor ( 3 ) = 0.239 acentric_factor ( 4 ) = 0.099 acentric_factor ( 5 ) = 0.153 acentric_factor ( 6 ) = 0.199 acentric_factor ( 7 ) = 0.183 acentric_factor ( 8 ) = 0.251 acentric_factor ( 9 ) = 0.227 acentric_factor ( 10 ) = 0.299 acentric_factor ( 11 ) = 0.349 acentric_factor ( 12 ) = 0.398 acentric_factor ( 13 ) = 0.4433 acentric_factor ( 14 ) = 0.4884 acentric_factor ( 15 ) = - 0.219 acentric_factor ( 16 ) = 0.0222 acentric_factor ( 17 ) = 0.0497 acentric_factor ( 18 ) = 0.3442920843 acentric_factor ( 19 ) = 0.1005 acentric_factor ( 20 ) = - 0.3836 acentric_factor ( 21 ) = - 0.00219 T_c ( 1 ) = 19 0.564d0 T_c ( 2 ) = 12 6.192d0 T_c ( 3 ) = 30 4.1282d0 T_c ( 4 ) = 30 5.322d0 T_c ( 5 ) = 36 9.825d0 T_c ( 6 ) = 42 5.125d0 T_c ( 7 ) = 40 7.817d0 T_c ( 8 ) = 46 9.7d0 T_c ( 9 ) = 46 0.35d0 T_c ( 10 ) = 50 7.82d0 T_c ( 11 ) = 54 0.13d0 T_c ( 12 ) = 56 9.32d0 T_c ( 13 ) = 59 4.55d0 T_c ( 14 ) = 61 7.7d0 T_c ( 15 ) = 3 3.19d0 T_c ( 16 ) = 15 4.595d0 T_c ( 17 ) = 13 2.86d0 T_c ( 18 ) = 64 7.096d0 T_c ( 19 ) = 37 3.1d0 T_c ( 20 ) = 5.1953d0 T_c ( 21 ) = 15 0.687d0 rho_c ( 1 ) = 1 0.139342719d0 rho_c ( 2 ) = 1 1.1839d0 rho_c ( 3 ) = 1 0.624978698d0 rho_c ( 4 ) = 6.870854540d0 rho_c ( 5 ) = 5.000043088d0 rho_c ( 6 ) = 3.920016792d0 rho_c ( 7 ) = 3.860142940d0 rho_c ( 8 ) = 3.215577588d0 rho_c ( 9 ) = 3.271d0 rho_c ( 10 ) = 2.705877875d0 rho_c ( 11 ) = 2.315324434d0 rho_c ( 12 ) = 2.056404127d0 rho_c ( 13 ) = 1.81d0 rho_c ( 14 ) = 1.64d0 rho_c ( 15 ) = 1 4.94d0 rho_c ( 16 ) = 1 3.63d0 rho_c ( 17 ) = 1 0.85d0 rho_c ( 18 ) = 1 7.873716090d0 rho_c ( 19 ) = 1 0.19d0 rho_c ( 20 ) = 1 7.399d0 rho_c ( 21 ) = 1 3.407429659d0 M ( 1 ) = 1 6.04246d0 M ( 2 ) = 2 8.0134d0 M ( 3 ) = 4 4.0095d0 M ( 4 ) = 3 0.06904d0 M ( 5 ) = 4 4.09562d0 M ( 6 ) = 5 8.1222d0 M ( 7 ) = 5 8.1222d0 M ( 8 ) = 7 2.14878d0 M ( 9 ) = 7 2.14878d0 M ( 10 ) = 8 6.17536d0 M ( 11 ) = 10 0.20194d0 M ( 12 ) = 11 4.22852d0 M ( 13 ) = 12 8.2551d0 M ( 14 ) = 14 2.28168d0 M ( 15 ) = 2.01588d0 M ( 16 ) = 3 1.9988d0 M ( 17 ) = 2 8.0101d0 M ( 18 ) = 1 8.01528d0 M ( 19 ) = 3 4.08088d0 M ( 20 ) = 4.002602d0 M ( 21 ) = 3 9.948d0 Fij ( 1 , 2 ) = 1.0d0 Fij ( 1 , 3 ) = 1.0d0 Fij ( 1 , 4 ) = 1.0d0 Fij ( 1 , 5 ) = 1.0d0 Fij ( 1 , 6 ) = 1.0d0 Fij ( 1 , 7 ) = 0.771035405688d0 Fij ( 1 , 15 ) = 1.0d0 Fij ( 2 , 3 ) = 1.0d0 Fij ( 2 , 4 ) = 1.0d0 Fij ( 4 , 5 ) = 0.130424765150d0 Fij ( 4 , 6 ) = 0.281570073085d0 Fij ( 4 , 7 ) = 0.260632376098d0 Fij ( 5 , 6 ) = 0.312572600489d-1 Fij ( 5 , 7 ) = - 0.551609771024d-1 Fij ( 6 , 7 ) = - 0.551240293009d-1 Fij ( 2 , 1 ) = 1.0d0 Fij ( 3 , 1 ) = 1.0d0 Fij ( 3 , 2 ) = 1.0d0 Fij ( 4 , 1 ) = 1.0d0 Fij ( 4 , 2 ) = 1.0d0 Fij ( 5 , 1 ) = 1.0d0 Fij ( 5 , 4 ) = 0.130424765150d0 Fij ( 6 , 1 ) = 1.0d0 Fij ( 6 , 4 ) = 0.281570073085d0 Fij ( 6 , 5 ) = 0.312572600489d-1 Fij ( 7 , 1 ) = 0.771035405688d0 Fij ( 7 , 4 ) = 0.260632376098d0 Fij ( 7 , 5 ) = - 0.551609771024d-1 Fij ( 7 , 6 ) = - 0.551240293009d-1 Fij ( 15 , 1 ) = 1.0d0 red_params ( 1 , 2 , :) = ( / 0.998721377d0 , 1.013950311d0 , 0.998098830d0 , 0.979273013d0 / ) red_params ( 1 , 3 , :) = ( / 0.999518072d0 , 1.002806594d0 , 1.022624490d0 , 0.975665369d0 / ) red_params ( 1 , 4 , :) = ( / 0.997547866d0 , 1.006617867d0 , 0.996336508d0 , 1.049707697d0 / ) red_params ( 1 , 5 , :) = ( / 1.004827070d0 , 1.038470657d0 , 0.989680305d0 , 1.098655531d0 / ) red_params ( 1 , 6 , :) = ( / 0.979105972d0 , 1.045375122d0 , 0.994174910d0 , 1.171607691d0 / ) red_params ( 1 , 7 , :) = ( / 1.011240388d0 , 1.054319053d0 , 0.980315756d0 , 1.161117729d0 / ) red_params ( 1 , 8 , :) = ( / 0.948330120d0 , 1.124508039d0 , 0.992127525d0 , 1.249173968d0 / ) red_params ( 1 , 9 , :) = ( / 1.0d0 , 1.343685343d0 , 1.0d0 , 1.188899743d0 / ) red_params ( 1 , 10 , :) = ( / 0.958015294d0 , 1.052643846d0 , 0.981844797d0 , 1.330570181d0 / ) red_params ( 1 , 11 , :) = ( / 0.962050831d0 , 1.156655935d0 , 0.977431529d0 , 1.379850328d0 / ) red_params ( 1 , 12 , :) = ( / 0.994740603d0 , 1.116549372d0 , 0.957473785d0 , 1.449245409d0 / ) red_params ( 1 , 13 , :) = ( / 1.002852287d0 , 1.141895355d0 , 0.947716769d0 , 1.528532478d0 / ) red_params ( 1 , 14 , :) = ( / 1.033086292d0 , 1.146089637d0 , 0.937777823d0 , 1.568231489d0 / ) red_params ( 1 , 15 , :) = ( / 1.0d0 , 1.018702573d0 , 1.0d0 , 1.352643115d0 / ) red_params ( 1 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 0.950000000d0 / ) red_params ( 1 , 17 , :) = ( / 0.997340772d0 , 1.006102927d0 , 0.987411732d0 , 0.987473033d0 / ) red_params ( 1 , 18 , :) = ( / 1.012783169d0 , 1.585018334d0 , 1.063333913d0 , 0.775810513d0 / ) red_params ( 1 , 19 , :) = ( / 1.012599087d0 , 1.040161207d0 , 1.011090031d0 , 0.961155729d0 / ) red_params ( 1 , 20 , :) = ( / 1.0d0 , 0.881405683d0 , 1.0d0 , 3.159776855d0 / ) red_params ( 1 , 21 , :) = ( / 1.034630259d0 , 1.014678542d0 , 0.990954281d0 , 0.989843388d0 / ) red_params ( 2 , 3 , :) = ( / 0.977794634d0 , 1.047578256d0 , 1.005894529d0 , 1.107654104d0 / ) red_params ( 2 , 4 , :) = ( / 0.978880168d0 , 1.042352891d0 , 1.007671428d0 , 1.098650964d0 / ) red_params ( 2 , 5 , :) = ( / 0.974424681d0 , 1.081025408d0 , 1.002677329d0 , 1.201264026d0 / ) red_params ( 2 , 6 , :) = ( / 0.996082610d0 , 1.146949309d0 , 0.994515234d0 , 1.304886838d0 / ) red_params ( 2 , 7 , :) = ( / 0.986415830d0 , 1.100576129d0 , 0.992868130d0 , 1.284462634d0 / ) red_params ( 2 , 8 , :) = ( / 1.0d0 , 1.078877166d0 , 1.0d0 , 1.419029041d0 / ) red_params ( 2 , 9 , :) = ( / 1.0d0 , 1.154135439d0 , 1.0d0 , 1.381770770d0 / ) red_params ( 2 , 10 , :) = ( / 1.0d0 , 1.195952177d0 , 1.0d0 , 1.472607971d0 / ) red_params ( 2 , 11 , :) = ( / 1.0d0 , 1.404554090d0 , 1.0d0 , 1.520975334d0 / ) red_params ( 2 , 12 , :) = ( / 1.0d0 , 1.186067025d0 , 1.0d0 , 1.733280051d0 / ) red_params ( 2 , 13 , :) = ( / 1.0d0 , 1.100405929d0 , 0.956379450d0 , 1.749119996d0 / ) red_params ( 2 , 14 , :) = ( / 1.0d0 , 1.0d0 , 0.957934447d0 , 1.822157123d0 / ) red_params ( 2 , 15 , :) = ( / 0.972532065d0 , 0.970115357d0 , 0.946134337d0 , 1.175696583d0 / ) red_params ( 2 , 17 , :) = ( / 1.0d0 , 1.008690943d0 , 1.0d0 , 0.993425388d0 / ) red_params ( 2 , 18 , :) = ( / 1.0d0 , 1.094749685d0 , 1.0d0 , 0.968808467d0 / ) red_params ( 2 , 16 , :) = ( / 0.999521770d0 , 0.997082328d0 , 0.997190589d0 , 0.995157044d0 / ) red_params ( 2 , 19 , :) = ( / 0.910394249d0 , 1.256844157d0 , 1.004692366d0 , 0.960174200d0 / ) red_params ( 2 , 20 , :) = ( / 0.969501055d0 , 0.932629867d0 , 0.692868765d0 , 1.471831580d0 / ) red_params ( 2 , 21 , :) = ( / 1.004166412d0 , 1.002212182d0 , 0.999069843d0 , 0.990034831d0 / ) red_params ( 3 , 4 , :) = ( / 1.002525718d0 , 1.032876701d0 , 1.013871147d0 , 0.900949530d0 / ) red_params ( 3 , 5 , :) = ( / 0.996898004d0 , 1.047596298d0 , 1.033620538d0 , 0.908772477d0 / ) red_params ( 3 , 6 , :) = ( / 1.174760923d0 , 1.222437324d0 , 1.018171004d0 , 0.911498231d0 / ) red_params ( 3 , 7 , :) = ( / 1.076551882d0 , 1.081909003d0 , 1.023339824d0 , 0.929982936d0 / ) red_params ( 3 , 8 , :) = ( / 1.024311498d0 , 1.068406078d0 , 1.027000795d0 , 0.979217302d0 / ) red_params ( 3 , 9 , :) = ( / 1.060793104d0 , 1.116793198d0 , 1.019180957d0 , 0.961218039d0 / ) red_params ( 3 , 10 , :) = ( / 1.0d0 , 0.851343711d0 , 1.0d0 , 1.038675574d0 / ) red_params ( 3 , 11 , :) = ( / 1.205469976d0 , 1.164585914d0 , 1.011806317d0 , 1.046169823d0 / ) red_params ( 3 , 12 , :) = ( / 1.026169373d0 , 1.104043935d0 , 1.029690780d0 , 1.074455386d0 / ) red_params ( 3 , 13 , :) = ( / 1.0d0 , 0.973386152d0 , 1.007688620d0 , 1.140671202d0 / ) red_params ( 3 , 14 , :) = ( / 1.000151132d0 , 1.183394668d0 , 1.020028790d0 , 1.145512213d0 / ) red_params ( 3 , 15 , :) = ( / 0.904142159d0 , 1.152792550d0 , 0.942320195d0 , 1.782924792d0 / ) red_params ( 3 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 3 , 17 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 3 , 18 , :) = ( / 0.949055959d0 , 1.542328793d0 , 0.997372205d0 , 0.775453996d0 / ) red_params ( 3 , 19 , :) = ( / 0.906630564d0 , 1.024085837d0 , 1.016034583d0 , 0.926018880d0 / ) red_params ( 3 , 20 , :) = ( / 0.846647561d0 , 0.864141549d0 , 0.768377630d0 , 3.207456948d0 / ) red_params ( 3 , 21 , :) = ( / 1.008392428d0 , 1.029205465d0 , 0.996512863d0 , 1.050971635d0 / ) red_params ( 4 , 5 , :) = ( / 0.997607277d0 , 1.003034720d0 , 0.996199694d0 , 1.014730190d0 / ) red_params ( 4 , 6 , :) = ( / 0.999157205d0 , 1.006179146d0 , 0.999130554d0 , 1.034832749d0 / ) red_params ( 4 , 7 , :) = ( / 1.0d0 , 1.006616886d0 , 1.0d0 , 1.033283811d0 / ) red_params ( 4 , 8 , :) = ( / 0.993851009d0 , 1.026085655d0 , 0.998688946d0 , 1.066665676d0 / ) red_params ( 4 , 9 , :) = ( / 1.0d0 , 1.045439935d0 , 1.0d0 , 1.021150247d0 / ) red_params ( 4 , 10 , :) = ( / 1.0d0 , 1.169701102d0 , 1.0d0 , 1.092177796d0 / ) red_params ( 4 , 11 , :) = ( / 1.0d0 , 1.057666085d0 , 1.0d0 , 1.134532014d0 / ) red_params ( 4 , 12 , :) = ( / 1.007469726d0 , 1.071917985d0 , 0.984068272d0 , 1.168636194d0 / ) red_params ( 4 , 13 , :) = ( / 1.0d0 , 1.143534730d0 , 1.0d0 , 1.056033030d0 / ) red_params ( 4 , 14 , :) = ( / 0.995676258d0 , 1.098361281d0 , 0.970918061d0 , 1.237191558d0 / ) red_params ( 4 , 15 , :) = ( / 0.925367171d0 , 1.106072040d0 , 0.932969831d0 , 1.902008495d0 / ) red_params ( 4 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 4 , 17 , :) = ( / 1.0d0 , 1.201417898d0 , 1.0d0 , 1.069224728d0 / ) red_params ( 4 , 18 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 4 , 19 , :) = ( / 1.010817909d0 , 1.030988277d0 , 0.990197354d0 , 0.902736660d0 / ) red_params ( 4 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 4 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 5 , 6 , :) = ( / 0.999795868d0 , 1.003264179d0 , 1.000310289d0 , 1.007392782d0 / ) red_params ( 5 , 7 , :) = ( / 0.999243146d0 , 1.001156119d0 , 0.998012298d0 , 1.005250774d0 / ) red_params ( 5 , 8 , :) = ( / 1.044919431d0 , 1.019921513d0 , 0.996484021d0 , 1.008344412d0 / ) red_params ( 5 , 9 , :) = ( / 1.040459289d0 , 0.999432118d0 , 0.994364425d0 , 1.003269500d0 / ) red_params ( 5 , 10 , :) = ( / 1.0d0 , 1.057872566d0 , 1.0d0 , 1.025657518d0 / ) red_params ( 5 , 11 , :) = ( / 1.0d0 , 1.079648053d0 , 1.0d0 , 1.050044169d0 / ) red_params ( 5 , 12 , :) = ( / 1.0d0 , 1.102764612d0 , 1.0d0 , 1.063694129d0 / ) red_params ( 5 , 13 , :) = ( / 1.0d0 , 1.199769134d0 , 1.0d0 , 1.109973833d0 / ) red_params ( 5 , 14 , :) = ( / 0.984104227d0 , 1.053040574d0 , 0.985331233d0 , 1.140905252d0 / ) red_params ( 5 , 15 , :) = ( / 1.0d0 , 1.074006110d0 , 1.0d0 , 2.308215191d0 / ) red_params ( 5 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 5 , 17 , :) = ( / 1.0d0 , 1.108143673d0 , 1.0d0 , 1.197564208d0 / ) red_params ( 5 , 18 , :) = ( / 1.0d0 , 1.011759763d0 , 1.0d0 , 0.600340961d0 / ) red_params ( 5 , 19 , :) = ( / 0.936811219d0 , 1.010593999d0 , 0.992573556d0 , 0.905829247d0 / ) red_params ( 5 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 5 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 6 , 7 , :) = ( / 1.000880464d0 , 1.000414440d0 , 1.000077547d0 , 1.001432824d0 / ) red_params ( 6 , 8 , :) = ( / 1.0d0 , 1.018159650d0 , 1.0d0 , 1.002143640d0 / ) red_params ( 6 , 9 , :) = ( / 1.0d0 , 1.002728434d0 , 1.0d0 , 1.000792201d0 / ) red_params ( 6 , 10 , :) = ( / 1.0d0 , 1.034995284d0 , 1.0d0 , 1.009157060d0 / ) red_params ( 6 , 11 , :) = ( / 1.0d0 , 1.019174227d0 , 1.0d0 , 1.021283378d0 / ) red_params ( 6 , 12 , :) = ( / 1.0d0 , 1.046905515d0 , 1.0d0 , 1.033180106d0 / ) red_params ( 6 , 13 , :) = ( / 1.0d0 , 1.049219137d0 , 1.0d0 , 1.014096448d0 / ) red_params ( 6 , 14 , :) = ( / 0.976951968d0 , 1.027845529d0 , 0.993688386d0 , 1.076466918d0 / ) red_params ( 6 , 15 , :) = ( / 1.0d0 , 1.232939523d0 , 1.0d0 , 2.509259945d0 / ) red_params ( 6 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 6 , 17 , :) = ( / 1.0d0 , 1.084740904d0 , 1.0d0 , 1.173916162d0 / ) red_params ( 6 , 18 , :) = ( / 1.0d0 , 1.223638763d0 , 1.0d0 , 0.615512682d0 / ) red_params ( 6 , 19 , :) = ( / 0.908113163d0 , 1.033366041d0 , 0.985962886d0 , 0.926156602d0 / ) red_params ( 6 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 6 , 21 , :) = ( / 1.0d0 , 1.214638734d0 , 1.0d0 , 1.245039498d0 / ) red_params ( 7 , 8 , :) = ( / 1.0d0 , 1.002779804d0 , 1.0d0 , 1.002495889d0 / ) red_params ( 7 , 9 , :) = ( / 1.0d0 , 1.002284353d0 , 1.0d0 , 1.001835788d0 / ) red_params ( 7 , 10 , :) = ( / 1.0d0 , 1.010493989d0 , 1.0d0 , 1.006018054d0 / ) red_params ( 7 , 11 , :) = ( / 1.0d0 , 1.021668316d0 , 1.0d0 , 1.009885760d0 / ) red_params ( 7 , 12 , :) = ( / 1.0d0 , 1.032807063d0 , 1.0d0 , 1.013945424d0 / ) red_params ( 7 , 13 , :) = ( / 1.0d0 , 1.047298475d0 , 1.0d0 , 1.017817492d0 / ) red_params ( 7 , 14 , :) = ( / 1.0d0 , 1.060243344d0 , 1.0d0 , 1.021624748d0 / ) red_params ( 7 , 15 , :) = ( / 1.0d0 , 1.147595688d0 , 1.0d0 , 1.895305393d0 / ) red_params ( 7 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 7 , 17 , :) = ( / 1.0d0 , 1.087272232d0 , 1.0d0 , 1.161390082d0 / ) red_params ( 7 , 18 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 7 , 19 , :) = ( / 1.012994431d0 , 0.988591117d0 , 0.974550548d0 , 0.937130844d0 / ) red_params ( 7 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 7 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 8 , 9 , :) = ( / 1.0d0 , 1.000024335d0 , 1.0d0 , 1.000050537d0 / ) red_params ( 8 , 10 , :) = ( / 1.0d0 , 1.002480637d0 , 1.0d0 , 1.000761237d0 / ) red_params ( 8 , 11 , :) = ( / 1.0d0 , 1.008972412d0 , 1.0d0 , 1.002441051d0 / ) red_params ( 8 , 12 , :) = ( / 1.0d0 , 1.069223964d0 , 1.0d0 , 1.016422347d0 / ) red_params ( 8 , 13 , :) = ( / 1.0d0 , 1.034910633d0 , 1.0d0 , 1.103421755d0 / ) red_params ( 8 , 14 , :) = ( / 1.0d0 , 1.016370338d0 , 1.0d0 , 1.049035838d0 / ) red_params ( 8 , 15 , :) = ( / 1.0d0 , 1.188334783d0 , 1.0d0 , 2.013859174d0 / ) red_params ( 8 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 8 , 17 , :) = ( / 1.0d0 , 1.119954454d0 , 1.0d0 , 1.206043295d0 / ) red_params ( 8 , 18 , :) = ( / 1.0d0 , 0.956677310d0 , 1.0d0 , 0.447666011d0 / ) red_params ( 8 , 19 , :) = ( / 0.984613203d0 , 1.076539234d0 , 0.962006651d0 , 0.959065662d0 / ) red_params ( 8 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 8 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 9 , 10 , :) = ( / 1.0d0 , 1.002995876d0 , 1.0d0 , 1.001204174d0 / ) red_params ( 9 , 11 , :) = ( / 1.0d0 , 1.009928206d0 , 1.0d0 , 1.003194615d0 / ) red_params ( 9 , 12 , :) = ( / 1.0d0 , 1.017880545d0 , 1.0d0 , 1.005647480d0 / ) red_params ( 9 , 13 , :) = ( / 1.0d0 , 1.028994325d0 , 1.0d0 , 1.008191499d0 / ) red_params ( 9 , 14 , :) = ( / 1.0d0 , 1.039372957d0 , 1.0d0 , 1.010825138d0 / ) red_params ( 9 , 15 , :) = ( / 1.0d0 , 1.184340443d0 , 1.0d0 , 1.996386669d0 / ) red_params ( 9 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 9 , 17 , :) = ( / 1.0d0 , 1.116694577d0 , 1.0d0 , 1.199326059d0 / ) red_params ( 9 , 18 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 9 , 19 , :) = ( / 1.0d0 , 0.835763343d0 , 1.0d0 , 0.982651529d0 / ) red_params ( 9 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 9 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 10 , 11 , :) = ( / 1.0d0 , 1.001508227d0 , 1.0d0 , 0.999762786d0 / ) red_params ( 10 , 12 , :) = ( / 1.0d0 , 1.006268954d0 , 1.0d0 , 1.001633952d0 / ) red_params ( 10 , 13 , :) = ( / 1.0d0 , 1.020761680d0 , 1.0d0 , 1.055369591d0 / ) red_params ( 10 , 14 , :) = ( / 1.001516371d0 , 1.013511439d0 , 0.997641010d0 , 1.028939539d0 / ) red_params ( 10 , 15 , :) = ( / 1.0d0 , 1.243461678d0 , 1.0d0 , 3.021197546d0 / ) red_params ( 10 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 10 , 17 , :) = ( / 1.0d0 , 1.155145836d0 , 1.0d0 , 1.233272781d0 / ) red_params ( 10 , 18 , :) = ( / 1.0d0 , 1.170217596d0 , 1.0d0 , 0.569681333d0 / ) red_params ( 10 , 19 , :) = ( / 0.754473958d0 , 1.339283552d0 , 0.985891113d0 , 0.956075596d0 / ) red_params ( 10 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 10 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 11 , 12 , :) = ( / 1.0d0 , 1.006767176d0 , 1.0d0 , 0.998793111d0 / ) red_params ( 11 , 13 , :) = ( / 1.0d0 , 1.001370076d0 , 1.0d0 , 1.001150096d0 / ) red_params ( 11 , 14 , :) = ( / 1.0d0 , 1.002972346d0 , 1.0d0 , 1.002229938d0 / ) red_params ( 11 , 15 , :) = ( / 1.0d0 , 1.159131722d0 , 1.0d0 , 3.169143057d0 / ) red_params ( 11 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 11 , 17 , :) = ( / 1.0d0 , 1.190354273d0 , 1.0d0 , 1.256123503d0 / ) red_params ( 11 , 18 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 11 , 19 , :) = ( / 0.828967164d0 , 1.087956749d0 , 0.988937417d0 , 1.013453092d0 / ) red_params ( 11 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 11 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 12 , 13 , :) = ( / 1.0d0 , 1.001357085d0 , 1.0d0 , 1.000235044d0 / ) red_params ( 12 , 14 , :) = ( / 1.0d0 , 1.002553544d0 , 1.0d0 , 1.007186267d0 / ) red_params ( 12 , 15 , :) = ( / 1.0d0 , 1.305249405d0 , 1.0d0 , 2.191555216d0 / ) red_params ( 12 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 12 , 17 , :) = ( / 1.0d0 , 1.219206702d0 , 1.0d0 , 1.276565536d0 / ) red_params ( 12 , 18 , :) = ( / 1.0d0 , 0.599484191d0 , 1.0d0 , 0.662072469d0 / ) red_params ( 12 , 19 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 12 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 12 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 13 , 14 , :) = ( / 1.0d0 , 1.000810520d0 , 1.0d0 , 1.000182392d0 / ) red_params ( 13 , 15 , :) = ( / 1.0d0 , 1.342647661d0 , 1.0d0 , 2.234354040d0 / ) red_params ( 13 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 13 , 17 , :) = ( / 1.0d0 , 1.252151449d0 , 1.0d0 , 1.294070556d0 / ) red_params ( 13 , 18 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 13 , 19 , :) = ( / 1.0d0 , 1.082905109d0 , 1.0d0 , 1.086557826d0 / ) red_params ( 13 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 13 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 14 , 15 , :) = ( / 1.695358382d0 , 1.120233729d0 , 1.064818089d0 , 3.786003724d0 / ) red_params ( 14 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 14 , 17 , :) = ( / 1.0d0 , 0.870184960d0 , 1.049594632d0 , 1.803567587d0 / ) red_params ( 14 , 18 , :) = ( / 1.0d0 , 0.551405318d0 , 0.897162268d0 , 0.740416402d0 / ) red_params ( 14 , 19 , :) = ( / 0.975187766d0 , 1.171714677d0 , 0.973091413d0 , 1.103693489d0 / ) red_params ( 14 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 14 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 15 , 16 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 15 , 17 , :) = ( / 1.0d0 , 1.121416201d0 , 1.0d0 , 1.377504607d0 / ) red_params ( 15 , 18 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 15 , 19 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 15 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 15 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 16 , 17 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 16 , 18 , :) = ( / 1.0d0 , 1.143174289d0 , 1.0d0 , 0.964767932d0 / ) red_params ( 16 , 19 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 16 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 16 , 21 , :) = ( / 0.999746847d0 , 0.993907223d0 , 1.000023103d0 , 0.990430423d0 / ) red_params ( 17 , 18 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 17 , 19 , :) = ( / 0.795660392d0 , 1.101731308d0 , 1.025536736d0 , 1.022749748d0 / ) red_params ( 17 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 17 , 21 , :) = ( / 1.0d0 , 1.159720623d0 , 1.0d0 , 0.954215746d0 / ) red_params ( 18 , 19 , :) = ( / 1.0d0 , 1.014832832d0 , 1.0d0 , 0.940587083d0 / ) red_params ( 18 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 18 , 21 , :) = ( / 1.0d0 , 1.038993495d0 , 1.0d0 , 1.070941866d0 / ) red_params ( 19 , 20 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 19 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) red_params ( 20 , 21 , :) = ( / 1.0d0 , 1.0d0 , 1.0d0 , 1.0d0 / ) do i = 1 , N - 1 do j = i + 1 , N Bv ( i , j ) = red_params ( i , j , 1 ) Gv ( i , j ) = red_params ( i , j , 2 ) Bt ( i , j ) = red_params ( i , j , 3 ) Gt ( i , j ) = red_params ( i , j , 4 ) Bv ( j , i ) = 1.d0 / Bv ( i , j ) Gv ( j , i ) = Gv ( i , j ) Bt ( j , i ) = 1.d0 / Bt ( i , j ) Gt ( j , i ) = Gt ( i , j ) end do end do noik ( 1 , 1 ) = 0.57335704239162d0 noik ( 1 , 2 ) = - 0.16760687523730d1 noik ( 1 , 3 ) = 0.23405291834916d0 noik ( 1 , 4 ) = - 0.21947376343441d0 noik ( 1 , 5 ) = 0.16369201404128d-1 noik ( 1 , 6 ) = 0.15004406389280d-1 noik ( 1 , 7 ) = 0.98990489492918d-1 noik ( 1 , 8 ) = 0.58382770929055d0 noik ( 1 , 9 ) = - 0.74786867560390d0 noik ( 1 , 10 ) = 0.30033302857974d0 noik ( 1 , 11 ) = 0.20985543806568d0 noik ( 1 , 12 ) = - 0.18590151133061d-1 noik ( 1 , 13 ) = - 0.15782558339049d0 noik ( 1 , 14 ) = 0.12716735220791d0 noik ( 1 , 15 ) = - 0.32019743894346d-1 noik ( 1 , 16 ) = - 0.68049729364536d-1 noik ( 1 , 17 ) = 0.24291412853736d-1 noik ( 1 , 18 ) = 0.51440451639444d-2 noik ( 1 , 19 ) = - 0.19084949733532d-1 noik ( 1 , 20 ) = 0.55229677241291d-2 noik ( 1 , 21 ) = - 0.44197392976085d-2 noik ( 1 , 22 ) = 0.40061416708429d-1 noik ( 1 , 23 ) = - 0.33752085907575d-1 noik ( 1 , 24 ) = - 0.25127658213357d-2 noik ( 2 , 1 ) = 0.59889711801201d0 noik ( 2 , 2 ) = - 0.16941557480731d1 noik ( 2 , 3 ) = 0.24579736191718d0 noik ( 2 , 4 ) = - 0.23722456755175d0 noik ( 2 , 5 ) = 0.17954918715141d-1 noik ( 2 , 6 ) = 0.14592875720215d-1 noik ( 2 , 7 ) = 0.10008065936206d0 noik ( 2 , 8 ) = 0.73157115385532d0 noik ( 2 , 9 ) = - 0.88372272336366d0 noik ( 2 , 10 ) = 0.31887660246708d0 noik ( 2 , 11 ) = 0.20766491728799d0 noik ( 2 , 12 ) = - 0.19379315454158d-1 noik ( 2 , 13 ) = - 0.16936641554983d0 noik ( 2 , 14 ) = 0.13546846041701d0 noik ( 2 , 15 ) = - 0.33066712095307d-1 noik ( 2 , 16 ) = - 0.60690817018557d-1 noik ( 2 , 17 ) = 0.12797548292871d-1 noik ( 2 , 18 ) = 0.58743664107299d-2 noik ( 2 , 19 ) = - 0.18451951971969d-1 noik ( 2 , 20 ) = 0.47226622042472d-2 noik ( 2 , 21 ) = - 0.52024079680599d-2 noik ( 2 , 22 ) = 0.43563505956635d-1 noik ( 2 , 23 ) = - 0.36251690750939d-1 noik ( 2 , 24 ) = - 0.28974026866543d-2 noik ( 3 , 1 ) = 0.52646564804653d0 noik ( 3 , 2 ) = - 0.14995725042592d1 noik ( 3 , 3 ) = 0.27329786733782d0 noik ( 3 , 4 ) = 0.12949500022786d0 noik ( 3 , 5 ) = 0.15404088341841d0 noik ( 3 , 6 ) = - 0.58186950946814d0 noik ( 3 , 7 ) = - 0.18022494838296d0 noik ( 3 , 8 ) = - 0.95389904072812d-1 noik ( 3 , 9 ) = - 0.80486819317679d-2 noik ( 3 , 10 ) = - 0.35547751273090d-1 noik ( 3 , 11 ) = - 0.28079014882405d0 noik ( 3 , 12 ) = - 0.82435890081677d-1 noik ( 3 , 13 ) = 0.10832427979006d-1 noik ( 3 , 14 ) = - 0.67073993161097d-2 noik ( 3 , 15 ) = - 0.46827907600524d-2 noik ( 3 , 16 ) = - 0.28359911832177d-1 noik ( 3 , 17 ) = 0.19500174744098d-1 noik ( 3 , 18 ) = - 0.21609137507166d0 noik ( 3 , 19 ) = 0.43772794926972d0 noik ( 3 , 20 ) = - 0.22130790113593d0 noik ( 3 , 21 ) = 0.15190189957331d-1 noik ( 3 , 22 ) = - 0.15380948953300d-1 noik ( 4 , 1 ) = 0.63596780450714d0 noik ( 4 , 2 ) = - 0.17377981785459d1 noik ( 4 , 3 ) = 0.28914060926272d0 noik ( 4 , 4 ) = - 0.33714276845694d0 noik ( 4 , 5 ) = 0.22405964699561d-1 noik ( 4 , 6 ) = 0.15715424886913d-1 noik ( 4 , 7 ) = 0.11450634253745 noik ( 4 , 8 ) = 0.10612049379745d1 noik ( 4 , 9 ) = - 0.12855224439423d1 noik ( 4 , 10 ) = 0.39414630777652d0 noik ( 4 , 11 ) = 0.31390924682041d0 noik ( 4 , 12 ) = - 0.21592277117247d-1 noik ( 4 , 13 ) = - 0.21723666564905d0 noik ( 4 , 14 ) = - 0.28999574439489d0 noik ( 4 , 15 ) = 0.42321173025732d0 noik ( 4 , 16 ) = 0.46434100259260d-1 noik ( 4 , 17 ) = - 0.13138398329741d0 noik ( 4 , 18 ) = 0.11492850364368d-1 noik ( 4 , 19 ) = - 0.33387688429909d-1 noik ( 4 , 20 ) = 0.15183171583644d-1 noik ( 4 , 21 ) = - 0.47610805647657d-2 noik ( 4 , 22 ) = 0.46917166277885d-1 noik ( 4 , 23 ) = - 0.39401755804649d-1 noik ( 4 , 24 ) = - 0.32569956247611d-2 noik ( 5 , 1 ) = 0.10403973107358d1 noik ( 5 , 2 ) = - 0.28318404081403d1 noik ( 5 , 3 ) = 0.84393809606294d0 noik ( 5 , 4 ) = - 0.76559591850023d-1 noik ( 5 , 5 ) = 0.94697373057280d-1 noik ( 5 , 6 ) = 0.24796475497006d-3 noik ( 5 , 7 ) = 0.27743760422870d0 noik ( 5 , 8 ) = - 0.43846000648377d-1 noik ( 5 , 9 ) = - 0.26991064784350d0 noik ( 5 , 10 ) = - 0.69313413089860d-1 noik ( 5 , 11 ) = - 0.29632145981653d-1 noik ( 5 , 12 ) = 0.14040126751380d-1 noik ( 6 , 1 ) = 0.10626277411455d1 noik ( 6 , 2 ) = - 0.28620951828350d1 noik ( 6 , 3 ) = 0.88738233403777d0 noik ( 6 , 4 ) = - 0.12570581155345d0 noik ( 6 , 5 ) = 0.10286308708106d0 noik ( 6 , 6 ) = 0.25358040602654d-3 noik ( 6 , 7 ) = 0.32325200233982d0 noik ( 6 , 8 ) = - 0.37950761057432d-1 noik ( 6 , 9 ) = - 0.32534802014452d0 noik ( 6 , 10 ) = - 0.79050969051011d-1 noik ( 6 , 11 ) = - 0.20636720547775d-1 noik ( 6 , 12 ) = 0.57053809334750d-2 noik ( 7 , 1 ) = 0.10429331589100d1 noik ( 7 , 2 ) = - 0.28184272548892d1 noik ( 7 , 3 ) = 0.86176232397850d0 noik ( 7 , 4 ) = - 0.10613619452487d0 noik ( 7 , 5 ) = 0.98615749302134d-1 noik ( 7 , 6 ) = 0.23948208682322d-3 noik ( 7 , 7 ) = 0.30330004856950d0 noik ( 7 , 8 ) = - 0.41598156135099d-1 noik ( 7 , 9 ) = - 0.29991937470058d0 noik ( 7 , 10 ) = - 0.80369342764109d-1 noik ( 7 , 11 ) = - 0.29761373251151d-1 noik ( 7 , 12 ) = 0.13059630303140d-1 noik ( 8 , 1 ) = 0.10968643098001d1 noik ( 8 , 2 ) = - 0.29988888298061d1 noik ( 8 , 3 ) = 0.99516886799212d0 noik ( 8 , 4 ) = - 0.16170708558539d0 noik ( 8 , 5 ) = 0.11334460072775d0 noik ( 8 , 6 ) = 0.26760595150748d-3 noik ( 8 , 7 ) = 0.40979881986931d0 noik ( 8 , 8 ) = - 0.40876423083075d-1 noik ( 8 , 9 ) = - 0.38169482469447d0 noik ( 8 , 10 ) = - 0.10931956843993d0 noik ( 8 , 11 ) = - 0.32073223327990d-1 noik ( 8 , 12 ) = 0.16877016216975d-1 noik ( 9 , 1 ) = 0.10963d1 noik ( 9 , 2 ) = - 0.30402d1 noik ( 9 , 3 ) = 0.10317d1 noik ( 9 , 4 ) = - 0.15410d0 noik ( 9 , 5 ) = 0.11535d0 noik ( 9 , 6 ) = 0.29809d-3 noik ( 9 , 7 ) = 0.39571d0 noik ( 9 , 8 ) = - 0.45881d-1 noik ( 9 , 9 ) = - 0.35804d0 noik ( 9 , 10 ) = - 0.10107d0 noik ( 9 , 11 ) = - 0.35484d-1 noik ( 9 , 12 ) = 0.18156d-1 noik ( 10 , 1 ) = 0.10553238013661d1 noik ( 10 , 2 ) = - 0.26120615890629d1 noik ( 10 , 3 ) = 0.76613882967260d0 noik ( 10 , 4 ) = - 0.29770320622459d0 noik ( 10 , 5 ) = 0.11879907733358d0 noik ( 10 , 6 ) = 0.27922861062617d-3 noik ( 10 , 7 ) = 0.46347589844105d0 noik ( 10 , 8 ) = 0.11433196980297d-1 noik ( 10 , 9 ) = - 0.48256968738131d0 noik ( 10 , 10 ) = - 0.93750558924659d-1 noik ( 10 , 11 ) = - 0.67273247155994d-2 noik ( 10 , 12 ) = - 0.51141583585428d-2 noik ( 11 , 1 ) = 0.10543747645262d1 noik ( 11 , 2 ) = - 0.26500681506144d1 noik ( 11 , 3 ) = 0.81730047827543d0 noik ( 11 , 4 ) = - 0.30451391253428d0 noik ( 11 , 5 ) = 0.12253868710800d0 noik ( 11 , 6 ) = 0.27266472743928d-3 noik ( 11 , 7 ) = 0.49865825681670d0 noik ( 11 , 8 ) = - 0.71432815084176d-3 noik ( 11 , 9 ) = - 0.54236895525450d0 noik ( 11 , 10 ) = - 0.13801821610756d0 noik ( 11 , 11 ) = - 0.61595287380011d-2 noik ( 11 , 12 ) = 0.48602510393022d-3 noik ( 12 , 1 ) = 0.10722544875633d1 noik ( 12 , 2 ) = - 0.24632951172003d1 noik ( 12 , 3 ) = 0.65386674054928d0 noik ( 12 , 4 ) = - 0.36324974085628d0 noik ( 12 , 5 ) = 0.12713269626764d0 noik ( 12 , 6 ) = 0.30713572777930d-3 noik ( 12 , 7 ) = 0.52656856987540d0 noik ( 12 , 8 ) = 0.19362862857653d-1 noik ( 12 , 9 ) = - 0.58939426849155d0 noik ( 12 , 10 ) = - 0.14069963991934d0 noik ( 12 , 11 ) = - 0.78966330500036d-2 noik ( 12 , 12 ) = 0.33036597968109d-2 noik ( 13 , 1 ) = 0.11151d1 noik ( 13 , 2 ) = - 0.27020d1 noik ( 13 , 3 ) = 0.83416d0 noik ( 13 , 4 ) = - 0.38828d0 noik ( 13 , 5 ) = 0.13760d0 noik ( 13 , 6 ) = 0.28185d-3 noik ( 13 , 7 ) = 0.62037d0 noik ( 13 , 8 ) = 0.15847d-1 noik ( 13 , 9 ) = - 0.61726d0 noik ( 13 , 10 ) = - 0.15043d0 noik ( 13 , 11 ) = - 0.12982d-1 noik ( 13 , 12 ) = 0.44325d-2 noik ( 14 , 1 ) = 0.10461d1 noik ( 14 , 2 ) = - 0.24807d1 noik ( 14 , 3 ) = 0.74372d0 noik ( 14 , 4 ) = - 0.52579d0 noik ( 14 , 5 ) = 0.15315d0 noik ( 14 , 6 ) = 0.32865d-3 noik ( 14 , 7 ) = 0.84178d0 noik ( 14 , 8 ) = 0.55424d-1 noik ( 14 , 9 ) = - 0.73555d0 noik ( 14 , 10 ) = - 0.18507d0 noik ( 14 , 11 ) = - 0.20775d-1 noik ( 14 , 12 ) = 0.12335d-1 noik ( 15 , 1 ) = 0.53579928451252d1 noik ( 15 , 2 ) = - 0.62050252530595d1 noik ( 15 , 3 ) = 0.13830241327086d0 noik ( 15 , 4 ) = - 0.71397954896129d-1 noik ( 15 , 5 ) = 0.15474053959733d-1 noik ( 15 , 6 ) = - 0.14976806405771d0 noik ( 15 , 7 ) = - 0.26368723988451d-1 noik ( 15 , 8 ) = 0.56681303156066d-1 noik ( 15 , 9 ) = - 0.60063958030436d-1 noik ( 15 , 10 ) = - 0.45043942027132d0 noik ( 15 , 11 ) = 0.42478840244500d0 noik ( 15 , 12 ) = - 0.21997640827139d-1 noik ( 15 , 13 ) = - 0.10499521374530d-1 noik ( 15 , 14 ) = - 0.28955902866816d-2 noik ( 16 , 1 ) = 0.88878286369701d0 noik ( 16 , 2 ) = - 0.24879433312148d1 noik ( 16 , 3 ) = 0.59750190775886d0 noik ( 16 , 4 ) = 0.96501817061881d-2 noik ( 16 , 5 ) = 0.71970428712770d-1 noik ( 16 , 6 ) = 0.22337443000195d-3 noik ( 16 , 7 ) = 0.18558686391474d0 noik ( 16 , 8 ) = - 0.38129368035760d-1 noik ( 16 , 9 ) = - 0.15352245383006d0 noik ( 16 , 10 ) = - 0.26726814910919d-1 noik ( 16 , 11 ) = - 0.25675298677127d-1 noik ( 16 , 12 ) = 0.95714302123668d-2 noik ( 17 , 1 ) = 0.90554d0 noik ( 17 , 2 ) = - 0.24515d1 noik ( 17 , 3 ) = 0.53149d0 noik ( 17 , 4 ) = 0.24173d-1 noik ( 17 , 5 ) = 0.72156d-1 noik ( 17 , 6 ) = 0.18818d-3 noik ( 17 , 7 ) = 0.19405d0 noik ( 17 , 8 ) = - 0.43268d-1 noik ( 17 , 9 ) = - 0.12778d0 noik ( 17 , 10 ) = - 0.27896d-1 noik ( 17 , 11 ) = - 0.34154d-1 noik ( 17 , 12 ) = 0.16329d-1 noik ( 18 , 1 ) = 0.82728408749586d0 noik ( 18 , 2 ) = - 0.18602220416584d1 noik ( 18 , 3 ) = - 0.11199009613744d1 noik ( 18 , 4 ) = 0.15635753976056d0 noik ( 18 , 5 ) = 0.87375844859025d0 noik ( 18 , 6 ) = - 0.36674403715731d0 noik ( 18 , 7 ) = 0.53987893432436d-1 noik ( 18 , 8 ) = 0.10957690214499d1 noik ( 18 , 9 ) = 0.53213037828563d-1 noik ( 18 , 10 ) = 0.13050533930825d-1 noik ( 18 , 11 ) = - 0.41079520434476d0 noik ( 18 , 12 ) = 0.14637443344120d0 noik ( 18 , 13 ) = - 0.55726838623719d-1 noik ( 18 , 14 ) = - 0.11201774143800d-1 noik ( 18 , 15 ) = - 0.66062758068099d-2 noik ( 18 , 16 ) = 0.46918522004538d-2 noik ( 19 , 1 ) = 0.87641d0 noik ( 19 , 2 ) = - 0.20367d1 noik ( 19 , 3 ) = 0.21634d0 noik ( 19 , 4 ) = - 0.50199d-1 noik ( 19 , 5 ) = 0.66994d-1 noik ( 19 , 6 ) = 0.19076d-3 noik ( 19 , 7 ) = 0.20227d0 noik ( 19 , 8 ) = - 0.45348d-2 noik ( 19 , 9 ) = - 0.22230d0 noik ( 19 , 10 ) = - 0.34714d-1 noik ( 19 , 11 ) = - 0.14885d-1 noik ( 19 , 12 ) = 0.74154d-2 noik ( 20 , 1 ) = - 0.45579024006737d0 noik ( 20 , 2 ) = 0.12516390754925d1 noik ( 20 , 3 ) = - 0.15438231650621d1 noik ( 20 , 4 ) = 0.20467489707221d-1 noik ( 20 , 5 ) = - 0.34476212380781d0 noik ( 20 , 6 ) = - 0.20858459512787d-1 noik ( 20 , 7 ) = 0.16227414711778d-1 noik ( 20 , 8 ) = - 0.57471818200892d-1 noik ( 20 , 9 ) = 0.19462416430715d-1 noik ( 20 , 10 ) = - 0.33295680123020d-1 noik ( 20 , 11 ) = - 0.10863577372367d-1 noik ( 20 , 12 ) = - 0.22173365245954d-1 noik ( 21 , 1 ) = 0.85095714803969d0 noik ( 21 , 2 ) = - 0.24003222943480d1 noik ( 21 , 3 ) = 0.54127841476466d0 noik ( 21 , 4 ) = 0.16919770692538d-1 noik ( 21 , 5 ) = 0.68825965019035d-1 noik ( 21 , 6 ) = 0.21428032815338d-3 noik ( 21 , 7 ) = 0.17429895321992d0 noik ( 21 , 8 ) = - 0.33654495604194d-1 noik ( 21 , 9 ) = - 0.13526799857691d0 noik ( 21 , 10 ) = - 0.16387350791552d-1 noik ( 21 , 11 ) = - 0.24987666851475d-1 noik ( 21 , 12 ) = 0.88769204815709d-2 coik ( 3 , 5 ) = 1 coik ( 3 , 6 ) = 1 coik ( 3 , 7 ) = 1 coik ( 3 , 8 ) = 1 coik ( 3 , 9 ) = 1 coik ( 3 , 10 ) = 1 coik ( 3 , 11 ) = 2 coik ( 3 , 12 ) = 2 coik ( 3 , 13 ) = 3 coik ( 3 , 14 ) = 3 coik ( 3 , 15 ) = 3 coik ( 3 , 16 ) = 3 coik ( 3 , 17 ) = 3 coik ( 3 , 18 ) = 5 coik ( 3 , 19 ) = 5 coik ( 3 , 20 ) = 5 coik ( 3 , 21 ) = 6 coik ( 3 , 22 ) = 6 coik ( 15 , 6 ) = 1 coik ( 15 , 7 ) = 1 coik ( 15 , 8 ) = 1 coik ( 15 , 9 ) = 1 coik ( 15 , 10 ) = 2 coik ( 15 , 11 ) = 2 coik ( 15 , 12 ) = 3 coik ( 15 , 13 ) = 3 coik ( 15 , 14 ) = 5 coik ( 18 , 8 ) = 1 coik ( 18 , 9 ) = 1 coik ( 18 , 10 ) = 1 coik ( 18 , 11 ) = 2 coik ( 18 , 12 ) = 2 coik ( 18 , 13 ) = 2 coik ( 18 , 14 ) = 3 coik ( 18 , 15 ) = 5 coik ( 18 , 16 ) = 5 coik ( 20 , 5 ) = 1 coik ( 20 , 6 ) = 1 coik ( 20 , 7 ) = 1 coik ( 20 , 8 ) = 1 coik ( 20 , 9 ) = 1 coik ( 20 , 10 ) = 2 coik ( 20 , 11 ) = 3 coik ( 20 , 12 ) = 3 tmp1 = ( / 1 , 2 , 4 / ) do i = 1 , size ( tmp1 ) k = tmp1 ( i ) doik ( k , 1 ) = 1 doik ( k , 2 ) = 1 doik ( k , 3 ) = 2 doik ( k , 4 ) = 2 doik ( k , 5 ) = 4 doik ( k , 6 ) = 4 doik ( k , 7 ) = 1 doik ( k , 8 ) = 1 doik ( k , 9 ) = 1 doik ( k , 10 ) = 2 doik ( k , 11 ) = 3 doik ( k , 12 ) = 6 doik ( k , 13 ) = 2 doik ( k , 14 ) = 3 doik ( k , 15 ) = 3 doik ( k , 16 ) = 4 doik ( k , 17 ) = 4 doik ( k , 18 ) = 2 doik ( k , 19 ) = 3 doik ( k , 20 ) = 4 doik ( k , 21 ) = 5 doik ( k , 22 ) = 6 doik ( k , 23 ) = 6 doik ( k , 24 ) = 7 toik ( k , 1 ) = 0.125d0 toik ( k , 2 ) = 1.125d0 toik ( k , 3 ) = 0.375d0 toik ( k , 4 ) = 1.125d0 toik ( k , 5 ) = 0.625d0 toik ( k , 6 ) = 1.500d0 toik ( k , 7 ) = 0.625d0 toik ( k , 8 ) = 2.625d0 toik ( k , 9 ) = 2.750d0 toik ( k , 10 ) = 2.125d0 toik ( k , 11 ) = 2.000d0 toik ( k , 12 ) = 1.750d0 toik ( k , 13 ) = 4.500d0 toik ( k , 14 ) = 4.750d0 toik ( k , 15 ) = 5.000d0 toik ( k , 16 ) = 4.000d0 toik ( k , 17 ) = 4.500d0 toik ( k , 18 ) = 7.500d0 toik ( k , 19 ) = 1 4.000d0 toik ( k , 20 ) = 1 1.500d0 toik ( k , 21 ) = 2 6.000d0 toik ( k , 22 ) = 2 8.000d0 toik ( k , 23 ) = 3 0.000d0 toik ( k , 24 ) = 1 6.000d0 coik ( k , 7 ) = 1 coik ( k , 8 ) = 1 coik ( k , 9 ) = 1 coik ( k , 10 ) = 1 coik ( k , 11 ) = 1 coik ( k , 12 ) = 1 coik ( k , 13 ) = 2 coik ( k , 14 ) = 2 coik ( k , 15 ) = 2 coik ( k , 16 ) = 2 coik ( k , 17 ) = 2 coik ( k , 18 ) = 3 coik ( k , 19 ) = 3 coik ( k , 20 ) = 3 coik ( k , 21 ) = 6 coik ( k , 22 ) = 6 coik ( k , 23 ) = 6 coik ( k , 24 ) = 6 Kpol ( k ) = 6 Kexp ( k ) = 18 end do tmp2 = ( / 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 16 , 17 , 19 , 21 / ) do i = 1 , size ( tmp2 ) k = tmp2 ( i ) coik ( k , 7 ) = 1 coik ( k , 8 ) = 1 coik ( k , 9 ) = 2 coik ( k , 10 ) = 2 coik ( k , 11 ) = 3 coik ( k , 12 ) = 3 doik ( k , 1 ) = 1 doik ( k , 2 ) = 1 doik ( k , 3 ) = 1 doik ( k , 4 ) = 2 doik ( k , 5 ) = 3 doik ( k , 6 ) = 7 doik ( k , 7 ) = 2 doik ( k , 8 ) = 5 doik ( k , 9 ) = 1 doik ( k , 10 ) = 4 doik ( k , 11 ) = 3 doik ( k , 12 ) = 4 toik ( k , 1 ) = 0.250d0 toik ( k , 2 ) = 1.125d0 toik ( k , 3 ) = 1.500d0 toik ( k , 4 ) = 1.375d0 toik ( k , 5 ) = 0.250d0 toik ( k , 6 ) = 0.875d0 toik ( k , 7 ) = 0.625d0 toik ( k , 8 ) = 1.750d0 toik ( k , 9 ) = 3.625d0 toik ( k , 10 ) = 3.625d0 toik ( k , 11 ) = 1 4.500d0 toik ( k , 12 ) = 1 2.000d0 Kpol ( k ) = 6 Kexp ( k ) = 6 end do Kpol ( 3 ) = 4 Kexp ( 3 ) = 18 Kpol ( 15 ) = 5 Kexp ( 15 ) = 9 Kpol ( 18 ) = 7 Kexp ( 18 ) = 9 Kpol ( 20 ) = 4 Kexp ( 20 ) = 8 doik ( 20 , 1 ) = 1 doik ( 20 , 2 ) = 1 doik ( 20 , 3 ) = 1 doik ( 20 , 4 ) = 4 doik ( 20 , 5 ) = 1 doik ( 20 , 6 ) = 3 doik ( 20 , 7 ) = 5 doik ( 20 , 8 ) = 5 doik ( 20 , 9 ) = 5 doik ( 20 , 10 ) = 2 doik ( 20 , 11 ) = 1 doik ( 20 , 12 ) = 2 toik ( 20 , 1 ) = 0.000d0 toik ( 20 , 2 ) = 0.125d0 toik ( 20 , 3 ) = 0.750d0 toik ( 20 , 4 ) = 1.000d0 toik ( 20 , 5 ) = 0.750d0 toik ( 20 , 6 ) = 2.625d0 toik ( 20 , 7 ) = 0.125d0 toik ( 20 , 8 ) = 1.250d0 toik ( 20 , 9 ) = 2.000d0 toik ( 20 , 10 ) = 1.000d0 toik ( 20 , 11 ) = 4.500d0 toik ( 20 , 12 ) = 5.000d0 doik ( 18 , 1 ) = 1 doik ( 18 , 2 ) = 1 doik ( 18 , 3 ) = 1 doik ( 18 , 4 ) = 2 doik ( 18 , 5 ) = 2 doik ( 18 , 6 ) = 3 doik ( 18 , 7 ) = 4 doik ( 18 , 8 ) = 1 doik ( 18 , 9 ) = 5 doik ( 18 , 10 ) = 5 doik ( 18 , 11 ) = 1 doik ( 18 , 12 ) = 2 doik ( 18 , 13 ) = 4 doik ( 18 , 14 ) = 4 doik ( 18 , 15 ) = 1 doik ( 18 , 16 ) = 1 toik ( 18 , 1 ) = 0.500d0 toik ( 18 , 2 ) = 1.250d0 toik ( 18 , 3 ) = 1.875d0 toik ( 18 , 4 ) = 0.125d0 toik ( 18 , 5 ) = 1.500d0 toik ( 18 , 6 ) = 1.000d0 toik ( 18 , 7 ) = 0.750d0 toik ( 18 , 8 ) = 1.500d0 toik ( 18 , 9 ) = 0.625d0 toik ( 18 , 10 ) = 2.625d0 toik ( 18 , 11 ) = 5.000d0 toik ( 18 , 12 ) = 4.000d0 toik ( 18 , 13 ) = 4.500d0 toik ( 18 , 14 ) = 3.000d0 toik ( 18 , 15 ) = 4.000d0 toik ( 18 , 16 ) = 6.000d0 doik ( 15 , 1 ) = 1 doik ( 15 , 2 ) = 1 doik ( 15 , 3 ) = 2 doik ( 15 , 4 ) = 2 doik ( 15 , 5 ) = 4 doik ( 15 , 6 ) = 1 doik ( 15 , 7 ) = 5 doik ( 15 , 8 ) = 5 doik ( 15 , 9 ) = 5 doik ( 15 , 10 ) = 1 doik ( 15 , 11 ) = 1 doik ( 15 , 12 ) = 2 doik ( 15 , 13 ) = 5 doik ( 15 , 14 ) = 1 toik ( 15 , 1 ) = 0.500d0 toik ( 15 , 2 ) = 0.625d0 toik ( 15 , 3 ) = 0.375d0 toik ( 15 , 4 ) = 0.625d0 toik ( 15 , 5 ) = 1.125d0 toik ( 15 , 6 ) = 2.625d0 toik ( 15 , 7 ) = 0.000d0 toik ( 15 , 8 ) = 0.250d0 toik ( 15 , 9 ) = 1.375d0 toik ( 15 , 10 ) = 4.000d0 toik ( 15 , 11 ) = 4.250d0 toik ( 15 , 12 ) = 5.000d0 toik ( 15 , 13 ) = 8.000d0 toik ( 15 , 14 ) = 8.000d0 doik ( 3 , 1 ) = 1 doik ( 3 , 2 ) = 1 doik ( 3 , 3 ) = 2 doik ( 3 , 4 ) = 3 doik ( 3 , 5 ) = 3 doik ( 3 , 6 ) = 3 doik ( 3 , 7 ) = 4 doik ( 3 , 8 ) = 5 doik ( 3 , 9 ) = 6 doik ( 3 , 10 ) = 6 doik ( 3 , 11 ) = 1 doik ( 3 , 12 ) = 4 doik ( 3 , 13 ) = 1 doik ( 3 , 14 ) = 1 doik ( 3 , 15 ) = 3 doik ( 3 , 16 ) = 3 doik ( 3 , 17 ) = 4 doik ( 3 , 18 ) = 5 doik ( 3 , 19 ) = 5 doik ( 3 , 20 ) = 5 doik ( 3 , 21 ) = 5 doik ( 3 , 22 ) = 5 toik ( 3 , 1 ) = 0.000d0 toik ( 3 , 2 ) = 1.250d0 toik ( 3 , 3 ) = 1.625d0 toik ( 3 , 4 ) = 0.375d0 toik ( 3 , 5 ) = 0.375d0 toik ( 3 , 6 ) = 1.375d0 toik ( 3 , 7 ) = 1.125d0 toik ( 3 , 8 ) = 1.375d0 toik ( 3 , 9 ) = 0.125d0 toik ( 3 , 10 ) = 1.625d0 toik ( 3 , 11 ) = 3.750d0 toik ( 3 , 12 ) = 3.500d0 toik ( 3 , 13 ) = 7.500d0 toik ( 3 , 14 ) = 8.000d0 toik ( 3 , 15 ) = 6.000d0 toik ( 3 , 16 ) = 1 6.000d0 toik ( 3 , 17 ) = 1 1.000d0 toik ( 3 , 18 ) = 2 4.000d0 toik ( 3 , 19 ) = 2 6.000d0 toik ( 3 , 20 ) = 2 8.000d0 toik ( 3 , 21 ) = 2 4.000d0 toik ( 3 , 22 ) = 2 6.000d0 ! Departure function parameters dij ( 1 , 2 , 1 ) = 1 dij ( 1 , 2 , 2 ) = 4 dij ( 1 , 2 , 3 ) = 1 dij ( 1 , 2 , 4 ) = 2 dij ( 1 , 2 , 5 ) = 2 dij ( 1 , 2 , 6 ) = 2 dij ( 1 , 2 , 7 ) = 2 dij ( 1 , 2 , 8 ) = 2 dij ( 1 , 2 , 9 ) = 3 tij ( 1 , 2 , 1 ) = 0.000d0 tij ( 1 , 2 , 2 ) = 1.850d0 tij ( 1 , 2 , 3 ) = 7.850d0 tij ( 1 , 2 , 4 ) = 5.400d0 tij ( 1 , 2 , 5 ) = 0.000d0 tij ( 1 , 2 , 6 ) = 0.750d0 tij ( 1 , 2 , 7 ) = 2.800d0 tij ( 1 , 2 , 8 ) = 4.450d0 tij ( 1 , 2 , 9 ) = 4.250d0 nij ( 1 , 2 , 1 ) = - 0.98038985517335d-2 nij ( 1 , 2 , 2 ) = 0.42487270143005d-3 nij ( 1 , 2 , 3 ) = - 0.34800214576142d-1 nij ( 1 , 2 , 4 ) = - 0.13333813013896d0 nij ( 1 , 2 , 5 ) = - 0.11993694974627d-1 nij ( 1 , 2 , 6 ) = 0.69243379775168d-1 nij ( 1 , 2 , 7 ) = - 0.31022508148249d0 nij ( 1 , 2 , 8 ) = 0.24495491753226d0 nij ( 1 , 2 , 9 ) = 0.22369816716981d0 ethaij ( 1 , 2 , 3 ) = 1.000d0 ethaij ( 1 , 2 , 4 ) = 1.000d0 ethaij ( 1 , 2 , 5 ) = 0.250d0 ethaij ( 1 , 2 , 6 ) = 0.000d0 ethaij ( 1 , 2 , 7 ) = 0.000d0 ethaij ( 1 , 2 , 8 ) = 0.000d0 ethaij ( 1 , 2 , 9 ) = 0.000d0 epsij ( 1 , 2 , 3 ) = 0.5d0 epsij ( 1 , 2 , 4 ) = 0.5d0 epsij ( 1 , 2 , 5 ) = 0.5d0 epsij ( 1 , 2 , 6 ) = 0.5d0 epsij ( 1 , 2 , 7 ) = 0.5d0 epsij ( 1 , 2 , 8 ) = 0.5d0 epsij ( 1 , 2 , 9 ) = 0.5d0 betaij ( 1 , 2 , 3 ) = 1.000d0 betaij ( 1 , 2 , 4 ) = 1.000d0 betaij ( 1 , 2 , 5 ) = 2.500d0 betaij ( 1 , 2 , 6 ) = 3.000d0 betaij ( 1 , 2 , 7 ) = 3.000d0 betaij ( 1 , 2 , 8 ) = 3.000d0 betaij ( 1 , 2 , 9 ) = 3.000d0 gammaij ( 1 , 2 , 3 ) = 0.5d0 gammaij ( 1 , 2 , 4 ) = 0.5d0 gammaij ( 1 , 2 , 5 ) = 0.5d0 gammaij ( 1 , 2 , 6 ) = 0.5d0 gammaij ( 1 , 2 , 7 ) = 0.5d0 gammaij ( 1 , 2 , 8 ) = 0.5d0 gammaij ( 1 , 2 , 9 ) = 0.5d0 dij ( 1 , 3 , 1 ) = 1 dij ( 1 , 3 , 2 ) = 2 dij ( 1 , 3 , 3 ) = 3 dij ( 1 , 3 , 4 ) = 1 dij ( 1 , 3 , 5 ) = 2 dij ( 1 , 3 , 6 ) = 3 tij ( 1 , 3 , 1 ) = 2.600d0 tij ( 1 , 3 , 2 ) = 1.950d0 tij ( 1 , 3 , 3 ) = 0.000d0 tij ( 1 , 3 , 4 ) = 3.950d0 tij ( 1 , 3 , 5 ) = 7.950d0 tij ( 1 , 3 , 6 ) = 8.000d0 nij ( 1 , 3 , 1 ) = - 0.10859387354942d0 nij ( 1 , 3 , 2 ) = 0.80228576727389d-1 nij ( 1 , 3 , 3 ) = - 0.93303985115717d-2 nij ( 1 , 3 , 4 ) = 0.40989274005848d-1 nij ( 1 , 3 , 5 ) = - 0.24338019772494d0 nij ( 1 , 3 , 6 ) = 0.23855347281124d0 ethaij ( 1 , 3 , 4 ) = 1.000d0 ethaij ( 1 , 3 , 5 ) = 0.500d0 ethaij ( 1 , 3 , 6 ) = 0.000d0 epsij ( 1 , 3 , 4 ) = 0.5d0 epsij ( 1 , 3 , 5 ) = 0.5d0 epsij ( 1 , 3 , 6 ) = 0.5d0 betaij ( 1 , 3 , 4 ) = 1.000d0 betaij ( 1 , 3 , 5 ) = 2.000d0 betaij ( 1 , 3 , 6 ) = 3.000d0 gammaij ( 1 , 3 , 4 ) = 0.5d0 gammaij ( 1 , 3 , 5 ) = 0.5d0 gammaij ( 1 , 3 , 6 ) = 0.5d0 dij ( 1 , 4 , 1 ) = 3 dij ( 1 , 4 , 2 ) = 4 dij ( 1 , 4 , 3 ) = 1 dij ( 1 , 4 , 4 ) = 2 dij ( 1 , 4 , 5 ) = 2 dij ( 1 , 4 , 6 ) = 2 dij ( 1 , 4 , 7 ) = 2 dij ( 1 , 4 , 8 ) = 2 dij ( 1 , 4 , 9 ) = 2 dij ( 1 , 4 , 10 ) = 3 dij ( 1 , 4 , 11 ) = 3 dij ( 1 , 4 , 12 ) = 3 tij ( 1 , 4 , 1 ) = 0.650d0 tij ( 1 , 4 , 2 ) = 1.550d0 tij ( 1 , 4 , 3 ) = 3.100d0 tij ( 1 , 4 , 4 ) = 5.900d0 tij ( 1 , 4 , 5 ) = 7.050d0 tij ( 1 , 4 , 6 ) = 3.350d0 tij ( 1 , 4 , 7 ) = 1.200d0 tij ( 1 , 4 , 8 ) = 5.800d0 tij ( 1 , 4 , 9 ) = 2.700d0 tij ( 1 , 4 , 10 ) = 0.450d0 tij ( 1 , 4 , 11 ) = 0.550d0 tij ( 1 , 4 , 12 ) = 1.950d0 nij ( 1 , 4 , 1 ) = - 0.80926050298746d-3 nij ( 1 , 4 , 2 ) = - 0.75381925080059d-3 nij ( 1 , 4 , 3 ) = - 0.41618768891219d-1 nij ( 1 , 4 , 4 ) = - 0.23452173681569d0 nij ( 1 , 4 , 5 ) = 0.14003840584586d0 nij ( 1 , 4 , 6 ) = 0.63281744807738d-1 nij ( 1 , 4 , 7 ) = - 0.34660425848809d-1 nij ( 1 , 4 , 8 ) = - 0.23918747334251d0 nij ( 1 , 4 , 9 ) = 0.19855255066891d-2 nij ( 1 , 4 , 10 ) = 0.61777746171555d1 nij ( 1 , 4 , 11 ) = - 0.69575358271105d1 nij ( 1 , 4 , 12 ) = 0.10630185306388d1 ethaij ( 1 , 4 , 3 ) = 1.000d0 ethaij ( 1 , 4 , 4 ) = 1.000d0 ethaij ( 1 , 4 , 5 ) = 1.000d0 ethaij ( 1 , 4 , 6 ) = 0.875d0 ethaij ( 1 , 4 , 7 ) = 0.750d0 ethaij ( 1 , 4 , 8 ) = 0.500d0 ethaij ( 1 , 4 , 9 ) = 0.000d0 ethaij ( 1 , 4 , 10 ) = 0.000d0 ethaij ( 1 , 4 , 11 ) = 0.000d0 ethaij ( 1 , 4 , 12 ) = 0.000d0 epsij ( 1 , 4 , 3 ) = 0.5d0 epsij ( 1 , 4 , 4 ) = 0.5d0 epsij ( 1 , 4 , 5 ) = 0.5d0 epsij ( 1 , 4 , 6 ) = 0.5d0 epsij ( 1 , 4 , 7 ) = 0.5d0 epsij ( 1 , 4 , 8 ) = 0.5d0 epsij ( 1 , 4 , 9 ) = 0.5d0 epsij ( 1 , 4 , 10 ) = 0.5d0 epsij ( 1 , 4 , 11 ) = 0.5d0 epsij ( 1 , 4 , 12 ) = 0.5d0 betaij ( 1 , 4 , 3 ) = 1.000d0 betaij ( 1 , 4 , 4 ) = 1.000d0 betaij ( 1 , 4 , 5 ) = 1.000d0 betaij ( 1 , 4 , 6 ) = 1.250d0 betaij ( 1 , 4 , 7 ) = 1.500d0 betaij ( 1 , 4 , 8 ) = 2.000d0 betaij ( 1 , 4 , 9 ) = 3.000d0 betaij ( 1 , 4 , 10 ) = 3.000d0 betaij ( 1 , 4 , 11 ) = 3.000d0 betaij ( 1 , 4 , 12 ) = 3.000d0 gammaij ( 1 , 4 , 3 ) = 0.5d0 gammaij ( 1 , 4 , 4 ) = 0.5d0 gammaij ( 1 , 4 , 5 ) = 0.5d0 gammaij ( 1 , 4 , 6 ) = 0.5d0 gammaij ( 1 , 4 , 7 ) = 0.5d0 gammaij ( 1 , 4 , 8 ) = 0.5d0 gammaij ( 1 , 4 , 9 ) = 0.5d0 gammaij ( 1 , 4 , 10 ) = 0.5d0 gammaij ( 1 , 4 , 11 ) = 0.5d0 gammaij ( 1 , 4 , 12 ) = 0.5d0 dij ( 1 , 5 , 1 ) = 3 dij ( 1 , 5 , 2 ) = 3 dij ( 1 , 5 , 3 ) = 4 dij ( 1 , 5 , 4 ) = 4 dij ( 1 , 5 , 5 ) = 4 dij ( 1 , 5 , 6 ) = 1 dij ( 1 , 5 , 7 ) = 1 dij ( 1 , 5 , 8 ) = 1 dij ( 1 , 5 , 9 ) = 2 tij ( 1 , 5 , 1 ) = 1.850d0 tij ( 1 , 5 , 2 ) = 3.950d0 tij ( 1 , 5 , 3 ) = 0.000d0 tij ( 1 , 5 , 4 ) = 1.850d0 tij ( 1 , 5 , 5 ) = 3.850d0 tij ( 1 , 5 , 6 ) = 5.250d0 tij ( 1 , 5 , 7 ) = 3.850d0 tij ( 1 , 5 , 8 ) = 0.200d0 tij ( 1 , 5 , 9 ) = 6.500d0 nij ( 1 , 5 , 1 ) = 0.13746429958576d-1 nij ( 1 , 5 , 2 ) = - 0.74425012129552d-2 nij ( 1 , 5 , 3 ) = - 0.45516600213685d-2 nij ( 1 , 5 , 4 ) = - 0.54546603350237d-2 nij ( 1 , 5 , 5 ) = 0.23682016824471d-2 nij ( 1 , 5 , 6 ) = 0.18007763721438d0 nij ( 1 , 5 , 7 ) = - 0.44773942932486d0 nij ( 1 , 5 , 8 ) = 0.19327374888200d-1 nij ( 1 , 5 , 9 ) = - 0.30632197804624d0 ethaij ( 1 , 5 , 6 ) = 0.250d0 ethaij ( 1 , 5 , 7 ) = 0.250d0 ethaij ( 1 , 5 , 8 ) = 0.000d0 ethaij ( 1 , 5 , 9 ) = 0.000d0 epsij ( 1 , 5 , 6 ) = 0.5d0 epsij ( 1 , 5 , 7 ) = 0.5d0 epsij ( 1 , 5 , 8 ) = 0.5d0 epsij ( 1 , 5 , 9 ) = 0.5d0 betaij ( 1 , 5 , 6 ) = 0.750d0 betaij ( 1 , 5 , 7 ) = 1.000d0 betaij ( 1 , 5 , 8 ) = 2.000d0 betaij ( 1 , 5 , 9 ) = 3.000d0 gammaij ( 1 , 5 , 6 ) = 0.5d0 gammaij ( 1 , 5 , 7 ) = 0.5d0 gammaij ( 1 , 5 , 8 ) = 0.5d0 gammaij ( 1 , 5 , 9 ) = 0.5d0 dij ( 2 , 3 , 1 ) = 2 dij ( 2 , 3 , 2 ) = 3 dij ( 2 , 3 , 3 ) = 1 dij ( 2 , 3 , 4 ) = 1 dij ( 2 , 3 , 5 ) = 1 dij ( 2 , 3 , 6 ) = 2 tij ( 2 , 3 , 1 ) = 1.850d0 tij ( 2 , 3 , 2 ) = 1.400d0 tij ( 2 , 3 , 3 ) = 3.200d0 tij ( 2 , 3 , 4 ) = 2.500d0 tij ( 2 , 3 , 5 ) = 8.000d0 tij ( 2 , 3 , 6 ) = 3.750d0 nij ( 2 , 3 , 1 ) = 0.28661625028399d0 nij ( 2 , 3 , 2 ) = - 0.10919833861247d0 nij ( 2 , 3 , 3 ) = - 0.11374032082270d1 nij ( 2 , 3 , 4 ) = 0.76580544237358d0 nij ( 2 , 3 , 5 ) = 0.42638000926819d-2 nij ( 2 , 3 , 6 ) = 0.17673538204534d0 ethaij ( 2 , 3 , 3 ) = 0.250d0 ethaij ( 2 , 3 , 4 ) = 0.250d0 ethaij ( 2 , 3 , 5 ) = 0.000d0 ethaij ( 2 , 3 , 6 ) = 0.000d0 epsij ( 2 , 3 , 3 ) = 0.5d0 epsij ( 2 , 3 , 4 ) = 0.5d0 epsij ( 2 , 3 , 5 ) = 0.5d0 epsij ( 2 , 3 , 6 ) = 0.5d0 betaij ( 2 , 3 , 3 ) = 0.750d0 betaij ( 2 , 3 , 4 ) = 1.000d0 betaij ( 2 , 3 , 5 ) = 2.000d0 betaij ( 2 , 3 , 6 ) = 3.000d0 gammaij ( 2 , 3 , 3 ) = 0.5d0 gammaij ( 2 , 3 , 4 ) = 0.5d0 gammaij ( 2 , 3 , 5 ) = 0.5d0 gammaij ( 2 , 3 , 6 ) = 0.5d0 dij ( 2 , 4 , 1 ) = 2 dij ( 2 , 4 , 2 ) = 2 dij ( 2 , 4 , 3 ) = 3 dij ( 2 , 4 , 4 ) = 1 dij ( 2 , 4 , 5 ) = 2 dij ( 2 , 4 , 6 ) = 2 tij ( 2 , 4 , 1 ) = 0.000d0 tij ( 2 , 4 , 2 ) = 0.050d0 tij ( 2 , 4 , 3 ) = 0.000d0 tij ( 2 , 4 , 4 ) = 3.650d0 tij ( 2 , 4 , 5 ) = 4.900d0 tij ( 2 , 4 , 6 ) = 4.450d0 nij ( 2 , 4 , 1 ) = - 0.47376518126608d0 nij ( 2 , 4 , 2 ) = 0.48961193461001d0 nij ( 2 , 4 , 3 ) = - 0.57011062090535d-2 nij ( 2 , 4 , 4 ) = - 0.19966820041320d0 nij ( 2 , 4 , 5 ) = - 0.69411103101723d0 nij ( 2 , 4 , 6 ) = 0.69226192739021d0 ethaij ( 2 , 4 , 4 ) = 1.000d0 ethaij ( 2 , 4 , 5 ) = 1.000d0 ethaij ( 2 , 4 , 6 ) = 0.875d0 epsij ( 2 , 4 , 4 ) = 0.5d0 epsij ( 2 , 4 , 5 ) = 0.5d0 epsij ( 2 , 4 , 6 ) = 0.5d0 betaij ( 2 , 4 , 4 ) = 1.000d0 betaij ( 2 , 4 , 5 ) = 1.000d0 betaij ( 2 , 4 , 6 ) = 1.250d0 gammaij ( 2 , 4 , 4 ) = 0.5d0 gammaij ( 2 , 4 , 5 ) = 0.5d0 gammaij ( 2 , 4 , 6 ) = 0.5d0 dij ( 1 , 15 , 1 ) = 1 dij ( 1 , 15 , 2 ) = 3 dij ( 1 , 15 , 3 ) = 3 dij ( 1 , 15 , 4 ) = 4 tij ( 1 , 15 , 1 ) = 2.000d0 tij ( 1 , 15 , 2 ) = - 1.000d0 tij ( 1 , 15 , 3 ) = 1.750d0 tij ( 1 , 15 , 4 ) = 1.400d0 nij ( 1 , 15 , 1 ) = - 0.25157134971934d0 nij ( 1 , 15 , 2 ) = - 0.62203841111983d-2 nij ( 1 , 15 , 3 ) = 0.88850315184396d-1 nij ( 1 , 15 , 4 ) = - 0.35592212573239d-1 generalized_departure ( 1 , :) = ( / 1 , 6 / ) generalized_departure ( 2 , :) = ( / 1 , 7 / ) generalized_departure ( 3 , :) = ( / 4 , 5 / ) generalized_departure ( 4 , :) = ( / 4 , 6 / ) generalized_departure ( 5 , :) = ( / 4 , 7 / ) generalized_departure ( 6 , :) = ( / 5 , 6 / ) generalized_departure ( 7 , :) = ( / 5 , 7 / ) generalized_departure ( 8 , :) = ( / 6 , 7 / ) do k = 1 , 8 i = generalized_departure ( k , 1 ) j = generalized_departure ( k , 2 ) dij ( i , j , 1 ) = 1 dij ( i , j , 2 ) = 1 dij ( i , j , 3 ) = 1 dij ( i , j , 4 ) = 2 dij ( i , j , 5 ) = 2 dij ( i , j , 6 ) = 3 dij ( i , j , 7 ) = 3 dij ( i , j , 8 ) = 4 dij ( i , j , 9 ) = 4 dij ( i , j , 10 ) = 4 tij ( i , j , 1 ) = 1.000d0 tij ( i , j , 2 ) = 1.550d0 tij ( i , j , 3 ) = 1.700d0 tij ( i , j , 4 ) = 0.250d0 tij ( i , j , 5 ) = 1.350d0 tij ( i , j , 6 ) = 0.000d0 tij ( i , j , 7 ) = 1.250d0 tij ( i , j , 8 ) = 0.000d0 tij ( i , j , 9 ) = 0.700d0 tij ( i , j , 10 ) = 5.400d0 nij ( i , j , 1 ) = 0.25574776844118d1 nij ( i , j , 2 ) = - 0.79846357136353d1 nij ( i , j , 3 ) = 0.47859131465806d1 nij ( i , j , 4 ) = - 0.73265392369587 nij ( i , j , 5 ) = 0.13805471345312d1 nij ( i , j , 6 ) = 0.28349603476365d0 nij ( i , j , 7 ) = - 0.49087385940425d0 nij ( i , j , 8 ) = - 0.10291888921447d0 nij ( i , j , 9 ) = 0.11836314681968d0 nij ( i , j , 10 ) = 0.55527385721943d-4 Kpolij ( i , j ) = 10 Kexpij ( i , j ) = 0 end do KPolij ( 1 , 2 ) = 2 KExpij ( 1 , 2 ) = 7 KPolij ( 1 , 3 ) = 3 KExpij ( 1 , 3 ) = 3 KPolij ( 1 , 4 ) = 2 KExpij ( 1 , 4 ) = 10 KPolij ( 1 , 5 ) = 5 KExpij ( 1 , 5 ) = 4 KPolij ( 2 , 3 ) = 2 KExpij ( 2 , 3 ) = 4 KPolij ( 2 , 4 ) = 3 KExpij ( 2 , 4 ) = 3 KPolij ( 1 , 15 ) = 4 KExpij ( 1 , 15 ) = 0 n0i ( 1 , 1 ) = 1 9.597508817d0 n0i ( 1 , 2 ) = - 8 3.959667892d0 n0i ( 1 , 3 ) = 3.00088d0 n0i ( 1 , 4 ) = 0.76315d0 n0i ( 1 , 5 ) = 0.00460d0 n0i ( 1 , 6 ) = 8.74432d0 n0i ( 1 , 7 ) = - 4.46921d0 n0i ( 2 , 1 ) = 1 1.083407489d0 n0i ( 2 , 2 ) = - 2 2.202102428d0 n0i ( 2 , 3 ) = 2.50031d0 n0i ( 2 , 4 ) = 0.13732d0 n0i ( 2 , 5 ) = - 0.14660d0 n0i ( 2 , 6 ) = 0.90066d0 n0i ( 2 , 7 ) = 0.0d0 n0i ( 3 , 1 ) = 1 1.925152758d0 n0i ( 3 , 2 ) = - 1 6.118762264d0 n0i ( 3 , 3 ) = 2.50002d0 n0i ( 3 , 4 ) = 2.04452d0 n0i ( 3 , 5 ) = - 1.06044d0 n0i ( 3 , 6 ) = 2.03366d0 n0i ( 3 , 7 ) = 0.01393d0 n0i ( 4 , 1 ) = 2 4.675437527d0 n0i ( 4 , 2 ) = - 7 7.425313760d0 n0i ( 4 , 3 ) = 3.00263d0 n0i ( 4 , 4 ) = 4.33939d0 n0i ( 4 , 5 ) = 1.23722d0 n0i ( 4 , 6 ) = 1 3.19740d0 n0i ( 4 , 7 ) = - 6.01989d0 n0i ( 5 , 1 ) = 3 1.602908195d0 n0i ( 5 , 2 ) = - 8 4.463284382d0 n0i ( 5 , 3 ) = 3.02939d0 n0i ( 5 , 4 ) = 6.60569d0 n0i ( 5 , 5 ) = 3.19700d0 n0i ( 5 , 6 ) = 1 9.19210d0 n0i ( 5 , 7 ) = - 8.37267d0 n0i ( 6 , 1 ) = 2 0.884143364d0 n0i ( 6 , 2 ) = - 9 1.638478026d0 n0i ( 6 , 3 ) = 3.33944d0 n0i ( 6 , 4 ) = 9.44893d0 n0i ( 6 , 5 ) = 6.89406d0 n0i ( 6 , 6 ) = 2 4.46180d0 n0i ( 6 , 7 ) = 1 4.78240d0 n0i ( 7 , 1 ) = 2 0.413726078d0 n0i ( 7 , 2 ) = - 9 4.467620036d0 n0i ( 7 , 3 ) = 3.06714d0 n0i ( 7 , 4 ) = 8.97575d0 n0i ( 7 , 5 ) = 5.25156d0 n0i ( 7 , 6 ) = 2 5.14230d0 n0i ( 7 , 7 ) = 1 6.13880d0 n0i ( 8 , 1 ) = 1 4.536611217d0 n0i ( 8 , 2 ) = - 8 9.919548319d0 n0i ( 8 , 3 ) = 3.00000d0 n0i ( 8 , 4 ) = 8.95043d0 n0i ( 8 , 5 ) = 2 1.83600d0 n0i ( 8 , 6 ) = 3 3.40320d0 n0i ( 8 , 7 ) = 0.0d0 n0i ( 9 , 1 ) = 1 5.449907693d0 n0i ( 9 , 2 ) = - 10 1.298172792d0 n0i ( 9 , 3 ) = 3.00000d0 n0i ( 9 , 4 ) = 1 1.76180d0 n0i ( 9 , 5 ) = 2 0.11010d0 n0i ( 9 , 6 ) = 3 3.16880d0 n0i ( 9 , 7 ) = 0.0d0 n0i ( 10 , 1 ) = 1 4.345969349d0 n0i ( 10 , 2 ) = - 9 6.165722367d0 n0i ( 10 , 3 ) = 3.00000d0 n0i ( 10 , 4 ) = 1 1.69770d0 n0i ( 10 , 5 ) = 2 6.81420d0 n0i ( 10 , 6 ) = 3 8.61640d0 n0i ( 10 , 7 ) = 0.0d0 n0i ( 11 , 1 ) = 1 5.063786601d0 n0i ( 11 , 2 ) = - 9 7.345252349d0 n0i ( 11 , 3 ) = 3.00000d0 n0i ( 11 , 4 ) = 1 3.72660d0 n0i ( 11 , 5 ) = 3 0.47070d0 n0i ( 11 , 6 ) = 4 3.55610d0 n0i ( 11 , 7 ) = 0.0d0 n0i ( 12 , 1 ) = 1 5.864687161d0 n0i ( 12 , 2 ) = - 9 7.370667555d0 n0i ( 12 , 3 ) = 3.00000d0 n0i ( 12 , 4 ) = 1 5.68650d0 n0i ( 12 , 5 ) = 3 3.80290d0 n0i ( 12 , 6 ) = 4 8.17310d0 n0i ( 12 , 7 ) = 0.0d0 n0i ( 13 , 1 ) = 1 6.313913248d0 n0i ( 13 , 2 ) = - 10 2.160247463d0 n0i ( 13 , 3 ) = 3.00000d0 n0i ( 13 , 4 ) = 1 8.02410d0 n0i ( 13 , 5 ) = 3 8.12350d0 n0i ( 13 , 6 ) = 5 3.34150d0 n0i ( 13 , 7 ) = 0.0d0 n0i ( 14 , 1 ) = 1 5.870791919d0 n0i ( 14 , 2 ) = - 10 8.858547525d0 n0i ( 14 , 3 ) = 3.00000d0 n0i ( 14 , 4 ) = 2 1.00690d0 n0i ( 14 , 5 ) = 4 3.49310d0 n0i ( 14 , 6 ) = 5 8.36570d0 n0i ( 14 , 7 ) = 0.0d0 n0i ( 15 , 1 ) = 1 3.796443393d0 n0i ( 15 , 2 ) = - 17 5.864487294d0 n0i ( 15 , 3 ) = 1.47906d0 n0i ( 15 , 4 ) = 0.95806d0 n0i ( 15 , 5 ) = 0.45444d0 n0i ( 15 , 6 ) = 1.56039d0 n0i ( 15 , 7 ) = 1.37560d0 n0i ( 16 , 1 ) = 1 0.001843586d0 n0i ( 16 , 2 ) = - 1 4.996095135d0 n0i ( 16 , 3 ) = 2.50146d0 n0i ( 16 , 4 ) = 1.07558d0 n0i ( 16 , 5 ) = 1.01334d0 n0i ( 16 , 6 ) = 0.0d0 n0i ( 16 , 7 ) = 0.0d0 n0i ( 17 , 1 ) = 1 0.813340744d0 n0i ( 17 , 2 ) = - 1 9.834733959d0 n0i ( 17 , 3 ) = 2.50055d0 n0i ( 17 , 4 ) = 1.02865d0 n0i ( 17 , 5 ) = 0.00493d0 n0i ( 17 , 6 ) = 0.0d0 n0i ( 17 , 7 ) = 0.0d0 n0i ( 18 , 1 ) = 8.203520690d0 n0i ( 18 , 2 ) = - 1 1.996306443d0 n0i ( 18 , 3 ) = 3.00392d0 n0i ( 18 , 4 ) = 0.01059d0 n0i ( 18 , 5 ) = 0.98763d0 n0i ( 18 , 6 ) = 3.06904d0 n0i ( 18 , 7 ) = 0.0d0 n0i ( 19 , 1 ) = 9.336197742d0 n0i ( 19 , 2 ) = - 1 6.266508995d0 n0i ( 19 , 3 ) = 3.00000d0 n0i ( 19 , 4 ) = 3.11942d0 n0i ( 19 , 5 ) = 1.00243d0 n0i ( 19 , 6 ) = 0.0d0 n0i ( 19 , 7 ) = 0.0d0 n0i ( 20 , 1 ) = 1 3.628409737d0 n0i ( 20 , 2 ) = - 14 3.470759602d0 n0i ( 20 , 3 ) = 1.50000d0 n0i ( 20 , 4 ) = 0.0d0 n0i ( 20 , 5 ) = 0.0d0 n0i ( 20 , 6 ) = 0.0d0 n0i ( 20 , 7 ) = 0.0d0 n0i ( 21 , 1 ) = 8.316631500d0 n0i ( 21 , 2 ) = - 4.946502600d0 n0i ( 21 , 3 ) = 1.50000d0 n0i ( 21 , 4 ) = 0.0d0 n0i ( 21 , 5 ) = 0.0d0 n0i ( 21 , 6 ) = 0.0d0 n0i ( 21 , 7 ) = 0.0d0 th0i ( 1 , 4 ) = 4.306474465d0 th0i ( 1 , 5 ) = 0.936220902d0 th0i ( 1 , 6 ) = 5.577233895d0 th0i ( 1 , 7 ) = 5.722644361d0 th0i ( 2 , 4 ) = 5.251822620d0 th0i ( 2 , 5 ) = - 5.393067706d0 th0i ( 2 , 6 ) = 1 3.788988208d0 th0i ( 2 , 7 ) = 0.0d0 th0i ( 3 , 4 ) = 3.022758166d0 th0i ( 3 , 5 ) = - 2.844425476d0 th0i ( 3 , 6 ) = 1.589964364d0 th0i ( 3 , 7 ) = 1.121596090d0 th0i ( 4 , 4 ) = 1.831882406d0 th0i ( 4 , 5 ) = 0.731306621d0 th0i ( 4 , 6 ) = 3.378007481d0 th0i ( 4 , 7 ) = 3.508721939d0 th0i ( 5 , 4 ) = 1.297521801d0 th0i ( 5 , 5 ) = 0.543210978d0 th0i ( 5 , 6 ) = 2.583146083d0 th0i ( 5 , 7 ) = 2.777773271d0 th0i ( 6 , 4 ) = 1.101487798d0 th0i ( 6 , 5 ) = 0.431957660d0 th0i ( 6 , 6 ) = 4.502440459d0 th0i ( 6 , 7 ) = 2.124516319d0 th0i ( 7 , 4 ) = 1.074673199d0 th0i ( 7 , 5 ) = 0.485556021d0 th0i ( 7 , 6 ) = 4.671261865d0 th0i ( 7 , 7 ) = 2.191583480d0 th0i ( 8 , 4 ) = 0.380391739d0 th0i ( 8 , 5 ) = 1.789520971d0 th0i ( 8 , 6 ) = 3.777411113d0 th0i ( 8 , 7 ) = 0.0d0 th0i ( 9 , 4 ) = 0.635392636d0 th0i ( 9 , 5 ) = 1.977271641d0 th0i ( 9 , 6 ) = 4.169371131d0 th0i ( 9 , 7 ) = 0.0d0 th0i ( 10 , 4 ) = 0.359036667d0 th0i ( 10 , 5 ) = 1.691951873d0 th0i ( 10 , 6 ) = 3.596924107d0 th0i ( 10 , 7 ) = 0.0d0 th0i ( 11 , 4 ) = 0.314348398d0 th0i ( 11 , 5 ) = 1.548136560d0 th0i ( 11 , 6 ) = 3.259326458d0 th0i ( 11 , 7 ) = 0.0d0 th0i ( 12 , 4 ) = 0.279143540d0 th0i ( 12 , 5 ) = 1.431644769d0 th0i ( 12 , 6 ) = 2.973845992d0 th0i ( 12 , 7 ) = 0.0d0 th0i ( 13 , 4 ) = 0.263819696d0 th0i ( 13 , 5 ) = 1.370586158d0 th0i ( 13 , 6 ) = 2.848860483d0 th0i ( 13 , 7 ) = 0.0d0 th0i ( 14 , 4 ) = 0.267034159d0 th0i ( 14 , 5 ) = 1.353835195d0 th0i ( 14 , 6 ) = 2.833479035d0 th0i ( 14 , 7 ) = 0.0d0 th0i ( 15 , 4 ) = 6.891654113d0 th0i ( 15 , 5 ) = 9.847634830d0 th0i ( 15 , 6 ) = 4 9.765290750d0 th0i ( 15 , 7 ) = 5 0.367279301d0 th0i ( 16 , 4 ) = 1 4.461722565d0 th0i ( 16 , 5 ) = 7.223325463d0 th0i ( 16 , 6 ) = 0.0d0 th0i ( 16 , 7 ) = 0.0d0 th0i ( 17 , 4 ) = 1 1.669802800d0 th0i ( 17 , 5 ) = 5.302762306d0 th0i ( 17 , 6 ) = 0.0d0 th0i ( 17 , 7 ) = 0.0d0 th0i ( 18 , 4 ) = 0.415386589d0 th0i ( 18 , 5 ) = 1.763895929d0 th0i ( 18 , 6 ) = 3.874803739d0 th0i ( 18 , 7 ) = 0.0d0 th0i ( 19 , 4 ) = 4.914580541d0 th0i ( 19 , 5 ) = 2.270653980d0 th0i ( 19 , 6 ) = 0.0d0 th0i ( 19 , 7 ) = 0.0d0 th0i ( 20 , 4 ) = 0.0d0 th0i ( 20 , 5 ) = 0.0d0 th0i ( 20 , 6 ) = 0.0d0 th0i ( 20 , 7 ) = 0.0d0 th0i ( 21 , 4 ) = 0.0d0 th0i ( 21 , 5 ) = 0.0d0 th0i ( 21 , 6 ) = 0.0d0 th0i ( 21 , 7 ) = 0.0d0 end subroutine original_parameters end module yaeos__models_ar_multifluid_parameters_gerg2008","tags":"","url":"sourcefile/parameters_gerg2008.f90.html"},{"title":"huron_vidal.f90 – yaeos","text":"Source Code module yaeos__models_cubic_mixing_rules_huron_vidal !! # Huron-Vidal (like) mixing rules module !! This module contains the mixing rules that are based/similar to the !! mixing rules defined by Huron-Vidal !! !! # Description !! Huron-Vidal presented a way to link a G&#94;E model with a Cubic EoS !! mixing rule. This makes it possible to make good predictions on !! polar compounds containing mixtures. !! !! # Examples !! !! ```fortran !!  A basic code example !! ``` !! !! # References !! use yaeos__constants , only : pr , R , solving_volume use yaeos__models_ar_genericcubic , only : CubicMixRule use yaeos__models_ar_cubic_mixing_base , only : bmix_qmr use yaeos__models_ge , only : GeModel implicit none private public :: HV public :: MHV public :: DmixMHV type , extends ( CubicMixRule ) :: HV class ( GeModel ), allocatable :: ge real ( pr ), allocatable :: del1 (:) real ( pr ), allocatable :: bi (:) contains procedure :: Bmix => BmixHV procedure :: D1Mix => D1MixHV procedure :: Dmix => DmixHV end type HV type , extends ( CubicMixRule ) :: MHV !! # Michelsen's modified Huron-Vidal mixing rule !! Mixing rule at zero-pressure which allows for the inclusion of an !! excess-gibbs model. !! !! # Description !! This mixing rule is based on the aproximate zero-pressure limit !!  of a cubic equation of state. At the aproximate zero-pressure limit the !! attractive parameter can be expressed as: !! !!  !! \\frac{D}{RTB}(n, T) = \\sum_i n_i \\frac{a_i(T)}{b_i} + \\frac{1}{q} !!  \\left(\\frac{G&#94;E(n, T)}{RT} + \\sum_i n_i \\ln \\frac{B}{nb_i} \\right) !!  !! Where q is a weak function of temperature. In the case of `MHV` !! and simplicity it is considered that depends on the model used. !! !! # Examples !! To use the modified Huron-Vidal mixing rule it is necessary to define !! a `CubicEoS` and replace its original mixing rule with the one generated !! by the user. !! ```fortran !! type(MHV) :: mixrule !! type(NRTL) :: ge_model !! type(CubicEoS) :: model !! !! ! Define the Ge model to be used and the CubicEoS !! ge_model = NRTL(a, b, c) !! model = SoaveRedlichKwong(tc, pc, w) !! !! ! Use the initialization function to setup !! mixrule = MHV(ge=ge_model, q=-0.593_pr, bi=model%b) !! !! ! Replace the original mixrule on the previously defined model !! model%mixrule = mixrule !! !! ! Ready to do calculations !! call pressure(model, n, v, T) !! ``` !! !! # References !! real ( pr ), allocatable :: l (:, :) real ( pr ), private , allocatable :: bi (:) real ( pr ), private , allocatable :: B , dBi (:), dBij (:, :) class ( GeModel ), allocatable :: ge real ( pr ) :: q contains procedure :: Bmix => BmixMHV procedure :: D1Mix => D1MixMHV procedure :: Dmix => DmixMHV end type MHV interface MHV module procedure :: init_mhv end interface MHV contains ! =========================================================================== ! Huron-Vidal Mixing rule ! --------------------------------------------------------------------------- subroutine BmixHV ( self , n , bi , B , dBi , dBij ) !! # Repulsive parameter B mixing rule !! Quadratinc mixing rule for the repulsive parameter. !! !! # Description !! B = \\sum_i n_i b_i use yaeos__models_ar_cubic_mixing_base , only : bmix_linear class ( HV ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: bi (:) real ( pr ), intent ( out ) :: B , dBi (:), dBij (:, :) call bmix_linear ( n , bi , b , dbi , dbij ) end subroutine BmixHV subroutine D1MixHV ( self , n , d1i , D1 , dD1i , dD1ij ) use yaeos__models_ar_cubic_mixing_base , only : d1mix_rkpr class ( HV ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: d1i (:) real ( pr ), intent ( out ) :: D1 real ( pr ), intent ( out ) :: dD1i (:) real ( pr ), intent ( out ) :: dD1ij (:, :) call d1mix_rkpr ( n , d1i , D1 , dD1i , dD1ij ) end subroutine D1MixHV subroutine DmixHV ( self , n , T , & ai , daidt , daidt2 , & D , dDdT , dDdT2 , dDi , dDidT , dDij & ) use yaeos__models_ar_cubic_mixing_base , only : lamdba_hv class ( HV ), intent ( in ) :: self real ( pr ), intent ( in ) :: T , n (:) real ( pr ), intent ( in ) :: ai (:), daidt (:), daidt2 (:) real ( pr ), intent ( out ) :: D , dDdT , dDdT2 , dDi (:), dDidT (:), dDij (:, :) real ( pr ) :: f , fdt , fdt2 , fdi ( size ( n )), fdit ( size ( n )), fdij ( size ( n ), size ( n )) real ( pr ) :: b , bi ( size ( n )), dbi ( size ( n )), dbij ( size ( n ), size ( n )) real ( pr ) :: del1 ( size ( n )), del2 ( size ( n )) real ( pr ) :: d1 , d1i ( size ( n )), dd1i ( size ( n )), dd1ij ( size ( n ), size ( n )) real ( pr ) :: Ge , GeT , GeT2 , Gen ( size ( n )), GeTn ( size ( n )), Gen2 ( size ( n ), size ( n )) real ( pr ) :: totn !! Total number of moles integer :: i , j , nc real ( pr ) :: L , dL ( size ( n )), dL2 ( size ( n ), size ( n )) nc = size ( n ) totn = sum ( n ) del1 = self % del1 bi = self % bi call self % Bmix ( n , bi , B , dBi , dBij ) call self % D1Mix ( n , del1 , D1 , dD1i , dD1ij ) call lamdba_hv ( D1 , dD1i , dD1ij , L , dL , dL2 ) call self % ge % excess_gibbs ( & n , T , Ge = Ge , GeT = GeT , GeT2 = GeT2 , Gen = Gen , GeTn = GeTn , Gen2 = Gen2 & ) f = sum ( n * ai / bi ) - Ge / L fdt = sum ( n * daidt / bi ) - GeT / L fdt2 = sum ( n * daidt2 / bi ) - GeT2 / L fdi = ai / bi - ( Gen / L - dL * Ge / L ** 2 ) fdiT = daidt / bi - ( GeTn / L - dL * GeT / L ** 2 ) do concurrent ( i = 1 : nc , j = 1 : nc ) fdij ( i , j ) = & Ge * dL2 ( i , j ) / L ** 2 & - 2 * Ge * dL ( i ) * dL ( j ) / L ** 3 & - Gen2 ( i , j ) / L & + Gen ( i ) * dL ( j ) / L ** 2 & + Gen ( j ) * dL ( i ) / L ** 2 !   Gen2(i, j)/L & ! - dL(j) * Gen(i)/L**2 & ! - (dL2(i,j) * Gen2(i,j)/L**2 & ! + dL(i)*(Gen2(i,j)/L**2-Gen(i)/L * dL(j)/2)) end do dDi = B * fdi + f * dBi dDidT = B * fdiT + fdT * dBi D = f * B dDdT = fdT * B dDdT2 = fdT2 * B dDij = fdij do i = 1 , nc do j = 1 , nc dDij ( i , j ) = dBi ( j ) * fdi ( i ) + B * fdij ( j , i ) + f * dBij ( i , j ) + fdi ( j ) * dBi ( i ) end do end do end subroutine DmixHV ! =========================================================================== ! Michelsen's Modified Huron-Vidal 1 ! --------------------------------------------------------------------------- type ( MHV ) function init_mhv ( ge , b , q , lij ) result ( mixrule ) class ( GeModel ), intent ( in ) :: Ge real ( pr ), intent ( in ) :: b (:) real ( pr ), intent ( in ) :: q real ( pr ), optional , intent ( in ) :: lij (:, :) integer :: i , nc nc = size ( b ) mixrule % q = q mixrule % bi = b mixrule % Ge = ge if ( present ( lij )) then mixrule % l = lij else mixrule % l = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) end if end function init_mhv subroutine BmixMHV ( self , n , bi , B , dBi , dBij ) !! # Repulsive parameter B mixing rule !! Quadratinc mixing rule for the repulsive parameter, using !!  b_{ij} = \\frac{b_i + b_j}{2} (1 - l_{ij})  as a combining rule. !! !! # Description !! Michelsen's modified Huron-Vidal mixing rule assumes a linear mix of !! the repulsive parameter. !! !! B = \\sum_i n_i b_i !! !! In this implementation the most known crossed combining rule is used: !! nB = \\sum_i \\sum_j \\frac{b_i + b_j}{2} (1 - l_{ij}) !! to provide versatility to the used model. !! !! @warning !! This mixing rule is intended to use only with a linear combining !! rule, using l_{ij} could negatively affect the thermodynamic !! consistency of the model. !! @endwarning !! !! # Examples !! !! ```fortran !!  A basic code example !! ``` !! !! # References !! use yaeos__models_ar_cubic_mixing_base , only : bmix_linear class ( MHV ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: bi (:) real ( pr ), intent ( out ) :: B , dBi (:), dBij (:, :) call bmix_qmr ( n , bi , self % l , b , dbi , dbij ) ! call bmix_linear(n, bi, b, dbi, dbij) end subroutine BmixMHV subroutine DmixMHV ( self , n , T , & ai , daidt , daidt2 , & D , dDdT , dDdT2 , dDi , dDidT , dDij & ) !! # Michelsen Modified Huron-Vidal mixing rule. !! Mixing rule at infinite pressure as defined in the book of Michelsen and !! Møllerup. !! !! # Description !! At the infinite pressure limit of a cubic equation of state it is possible to !! relate teh mixing rule for the attractive term with a excess Gibbs energy !! model like NRTL with the expression: !! !!  !! \\frac{D}{RTB}(n, T) = \\sum_i n_i \\frac{a_i(T)}{b_i} + \\frac{1}{q} !!  \\left(\\frac{G&#94;E(n, T)}{RT} + \\sum_i n_i \\ln \\frac{B}{nb_i} \\right) !!  !! !! # Examples !! !! ```fortran !!  type(CubicEoS) !! ``` !! !! # References !! class ( MHV ), intent ( in ) :: self real ( pr ), intent ( in ) :: T , n (:) real ( pr ), intent ( in ) :: ai (:), daidt (:), daidt2 (:) real ( pr ), intent ( out ) :: D , dDdT , dDdT2 , dDi (:), dDidT (:), dDij (:, :) real ( pr ) :: f , fdt , fdt2 , fdi ( size ( n )), fdit ( size ( n )), fdij ( size ( n ), size ( n )) real ( pr ) :: b , bi ( size ( n )), dbi ( size ( n )), dbij ( size ( n ), size ( n )) real ( pr ) :: Ge , GeT , GeT2 , Gen ( size ( n )), GeTn ( size ( n )), Gen2 ( size ( n ), size ( n )) real ( pr ) :: totn !! Total number of moles real ( pr ) :: dot_n_logB_nbi real ( pr ) :: logB_nbi ( size ( n )) !! \\ln \\frac{B}{n b_i} real ( pr ) :: dlogBi_nbi ( size ( n )) real ( pr ) :: d2logBi_nbi ( size ( n ), size ( n )) integer :: i , j , l , nc real ( pr ) :: q nc = size ( n ) totn = sum ( n ) q = self % q bi = self % bi if (. not . solving_volume ) then call self % ge % excess_gibbs ( & n , T , Ge = Ge , GeT = GeT , GeT2 = GeT2 , Gen = Gen , GeTn = GeTn , Gen2 = Gen2 & ) else call self % ge % excess_gibbs ( & n , T , Ge = Ge & ) end if call self % Bmix ( n , bi , B , dBi , dBij ) logb_nbi = log ( B / ( totn * bi )) dot_n_logB_nbi = dot_product ( n , logB_nbi ) do i = 1 , nc dlogBi_nbi ( i ) = logB_nbi ( i ) + sum ( n * dBi ( i )) / B - 1 end do if (. not . solving_volume ) then do i = 1 , nc do j = 1 , nc !TODO: Need to figure out this derivative d2logBi_nbi ( i , j ) = dlogBi_nbi ( j ) & + ( sum ( n * dBij ( i , j )) + dBi ( i )) / B & - totn * dBi ( i ) * dBi ( j ) / B ** 2 end do end do autodiff : block !! Autodiff injection until we can decipher this derivative use hyperdual_mod type ( hyperdual ) :: hB type ( hyperdual ) :: hdot_ln_B_nbi type ( hyperdual ) :: hn ( nc ) integer :: ii , jj hn = n do i = 1 , nc do j = i , nc hn = n hn ( i )% f1 = 1 hn ( j )% f2 = 1 hB = 0._pr do ii = 1 , nc do jj = 1 , nc hB = hB & + ( hn ( ii ) * hn ( jj )) & * 0.5_pr * ( bi ( ii ) + bi ( jj )) * ( 1._pr - self % l ( ii , jj )) end do end do hB = hB / sum ( hn ) hdot_ln_B_nbi = sum ( hn * log ( hB / ( sum ( hn ) * bi ))) d2logBi_nbi ( i , j ) = hdot_ln_B_nbi % f12 d2logBi_nbi ( j , i ) = hdot_ln_B_nbi % f12 end do end do end block autodiff end if f = sum ( n * ai / bi ) + ( Ge + R * T * dot_n_logB_nbi ) / q fdt = sum ( n * daidt / bi ) + ( GeT + R * dot_n_logB_nbi ) / q fdt2 = sum ( n * daidt2 / bi ) + ( GeT2 ) / q fdi = ai / bi + ( 1._pr / q ) * ( GeN + R * T * ( dlogBi_nbi )) fdit = daidt / bi + ( 1._pr / q ) * ( GeTn + R * ( dlogBi_nbi )) do i = 1 , nc do j = 1 , nc fdij ( i , j ) = R * T * ( d2logBi_nbi ( i , j )) fdij ( i , j ) = 1 / q * ( fdij ( i , j ) + GeN2 ( i , j )) fdij ( i , j ) = & dBi ( j ) * fdi ( i ) + B * fdij ( i , j ) + fdi ( j ) * dBi ( i ) + f * dBij ( i , j ) end do end do dDi = B * fdi + f * dBi dDidT = B * fdiT + fdT * dBi D = f * B dDdT = fdT * B dDdT2 = fdT2 * B dDij = fdij end subroutine DmixMHV subroutine D1MixMHV ( self , n , d1i , D1 , dD1i , dD1ij ) use yaeos__models_ar_cubic_mixing_base , only : d1mix_rkpr class ( MHV ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: d1i (:) real ( pr ), intent ( out ) :: D1 real ( pr ), intent ( out ) :: dD1i (:) real ( pr ), intent ( out ) :: dD1ij (:, :) call d1mix_rkpr ( n , d1i , D1 , dD1i , dD1ij ) end subroutine D1MixMHV end module yaeos__models_cubic_mixing_rules_huron_vidal","tags":"","url":"sourcefile/huron_vidal.f90.html"},{"title":"auxiliar.f90 – yaeos","text":"Source Code module yaeos__equilibria_boundaries_auxiliar !! Equilibria boundaries auxiliar module !! This module contains the auxiliar functions and subroutines !! used in the phase-boundaries calculations. use yaeos__constants , only : R , pr implicit none contains subroutine get_z ( alpha , z_0 , z_inj , z , dzda ) !! Calculate the fluid composition based on an amount of addition !! of second fluid. !! !! The injection can be considered as two kinds of injection: !! - Displacement:  z = \\alpha z_i + (1-\\alpha) z_0  !! - Addition:   z = \\frac{\\alpha z_i + (1-\\alpha) z_0}{\\sum_{i=1}&#94;N \\alpha z_i + (1-\\alpha) z_0}  real ( pr ), intent ( in ) :: alpha !! Addition percentaje  \\alpha  real ( pr ), intent ( in ) :: z_inj (:) real ( pr ), intent ( in ) :: z_0 (:) real ( pr ), intent ( out ) :: z ( size ( z_0 )) !! New composition real ( pr ), optional , intent ( out ) :: dzda ( size ( z_0 )) !! Derivative wrt \\alpha z = z_inj * alpha + ( 1.0_pr - alpha ) * z_0 if ( present ( dzda )) dzda = z_inj - z_0 end subroutine get_z end module yaeos__equilibria_boundaries_auxiliar","tags":"","url":"sourcefile/auxiliar.f90~2.html"},{"title":"legacy.f90 – yaeos","text":"Source Code module legacy_ar_models !! Legacy Thermodynamic routines !! Module for a cubic eos system, made with the intention to keep !! compatiblity with legacy codes but with a better structure. !! this should be later adapted into a simple oop system where an eos object !! stores the relevant parameters (or some functional oriented approach) use yaeos__constants , only : pr , R use ar_interface , only : ar_fun , vinit implicit none ! Model settings integer :: thermo_model !! Which thermodynamic model to use integer :: tdep !! Temperature dependance of kij integer :: mixing_rule !! What mixing rule to use integer :: nc !! Number of components ! Mole fractions real ( pr ), allocatable :: z (:) !! Mole fractions vector ! ========================================================================== !  Cubic EoS Possible parameters ! -------------------------------------------------------------------------- ! Critical constants real ( pr ), allocatable :: tc (:) !! Critical temperature [K] real ( pr ), allocatable :: pc (:) !! Critical pressure [bar] real ( pr ), allocatable :: dc (:) !! Critical density [mol/L] real ( pr ), allocatable :: w (:) !! Acentric factor ! Model parameters real ( pr ), allocatable :: ac (:) !! Critical attractive parameter [bar (L/mol)&#94;2] real ( pr ), allocatable :: b (:) !! repulsive parameter [L] real ( pr ), allocatable :: del1 (:) !! \\delta_1 parameter real ( pr ), allocatable :: k (:) !! Attractive parameter constant ! Classic VdW mixing rules parameters real ( pr ), allocatable :: kij (:, :) !! Attractive BIP real ( pr ), allocatable :: lij (:, :) !! Repulsive BIP real ( pr ), allocatable :: bij (:, :) ! T dependant mixing rule parameters real ( pr ), allocatable :: kij0 (:, :), kinf (:, :), tstar (:, :) ! ========================================================================== contains ! ========================================================================== !  Initializer routines ! -------------------------------------------------------------------------- subroutine setup ( n , nmodel , ntdep , ncomb ) !! Setup the basics variables that describe the model. ! TODO: With a more integrated legacy code maybe this can be !       avoided or at least better set up integer , intent ( in ) :: n !! Number of components integer , intent ( in ) :: nmodel !! Number of model integer , intent ( in ) :: ntdep !! Kij dependant of temperature integer , intent ( in ) :: ncomb !! Combining rule thermo_model = nmodel tdep = ntdep mixing_rule = ncomb nc = n if ( allocated ( tc )) deallocate ( tc ) if ( allocated ( pc )) deallocate ( pc ) if ( allocated ( dc )) deallocate ( dc ) if ( allocated ( w )) deallocate ( w ) if ( allocated ( ac )) deallocate ( ac ) if ( allocated ( b )) deallocate ( b ) if ( allocated ( del1 )) deallocate ( del1 ) if ( allocated ( k )) deallocate ( k ) if ( allocated ( kij )) deallocate ( kij ) if ( allocated ( lij )) deallocate ( lij ) if ( allocated ( kinf )) deallocate ( kinf ) if ( allocated ( tstar )) deallocate ( tstar ) if ( allocated ( bij )) deallocate ( bij ) allocate ( tc ( n )) allocate ( pc ( n )) allocate ( dc ( n )) allocate ( w ( n )) allocate ( ac ( n )) allocate ( b ( n )) allocate ( del1 ( n )) allocate ( k ( n )) allocate ( kij ( n , n )) allocate ( lij ( n , n )) allocate ( kinf ( n , n )) allocate ( tstar ( n , n )) allocate ( bij ( n , n )) end subroutine setup subroutine PR78_factory ( moles_in , ac_in , b_in , tc_in , pc_in , w_in , k_in ) !! PengRobinson 78 factory !! !! Takes either the critical parameters or the fitted model parameters !! and gets ones in base of the others real ( pr ), intent ( in ) :: moles_in ( nc ) real ( pr ), optional , intent ( in ) :: ac_in ( nc ) real ( pr ), optional , intent ( in ) :: b_in ( nc ) real ( pr ), optional , intent ( in ) :: tc_in ( nc ) real ( pr ), optional , intent ( in ) :: pc_in ( nc ) real ( pr ), optional , intent ( in ) :: w_in ( nc ) real ( pr ), optional , intent ( in ) :: k_in ( nc ) integer :: i logical :: params_spec , critical_spec real ( pr ) :: zc ( nc ), oma ( nc ), omb ( nc ) real ( pr ) :: vceos ( nc ), al , be , ga ( nc ) real ( pr ) :: RTc ( nc ) ar_fun => ar_srkpr vinit => cubic_v0 del1 = 1 + sqrt ( 2.0_pr ) z = moles_in params_spec = ( present ( ac_in ) . and . present ( b_in ) . and . present ( k_in )) critical_spec = ( present ( tc_in ) . and . present ( pc_in ) . and . present ( w_in )) if ( params_spec ) then ac = ac_in b = b_in k = k_in call get_Zc_OMa_OMb ( del1 , zc , oma , omb ) Tc = OMb * ac / ( OMa * R * b ) RTc = R * Tc Pc = OMb * RTc / b Vceos = Zc * RTc / Pc al = - 0.26992 be = 1.54226 ga = 0.37464 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al else if ( critical_spec ) then tc = tc_in pc = pc_in w = w_in RTc = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RTc ** 2 / Pc b = OMb * RTc / Pc Vceos = Zc * RTc / Pc ! k (or m) constant to calculate attractive parameter depending on temperature do i = 1 , nc if ( w ( i ) <= 0.491 ) then ! m from PR k ( i ) = 0.37464 + 1.54226 * w ( i ) - 0.26992 * w ( i ) ** 2 else ! PR78 k ( i ) = 0.379642 + 1.48503 * w ( i ) - 0.164423 * w ( i ) ** 2 + 0.016666 * w ( i ) ** 3 end if end do end if end subroutine subroutine PR76_factory ( moles_in , ac_in , b_in , tc_in , pc_in , w_in , k_in ) !! PengRobinson 76 factory !! !! Takes either the critical parameters or the fitted model parameters !! and gets ones in base of the others real ( pr ), intent ( in ) :: moles_in ( nc ) real ( pr ), optional , intent ( in ) :: ac_in ( nc ) real ( pr ), optional , intent ( in ) :: b_in ( nc ) real ( pr ), optional , intent ( in ) :: tc_in ( nc ) real ( pr ), optional , intent ( in ) :: pc_in ( nc ) real ( pr ), optional , intent ( in ) :: w_in ( nc ) real ( pr ), optional , intent ( in ) :: k_in ( nc ) integer :: i logical :: params_spec , critical_spec real ( pr ) :: zc ( nc ), oma ( nc ), omb ( nc ) real ( pr ) :: vceos ( nc ), al , be , ga ( nc ) real ( pr ) :: RTc ( nc ) ar_fun => ar_srkpr vinit => cubic_v0 del1 = 1 + sqrt ( 2.0_pr ) z = moles_in params_spec = ( present ( ac_in ) . and . present ( b_in ) . and . present ( k_in )) critical_spec = ( present ( tc_in ) . and . present ( pc_in ) . and . present ( w_in )) if ( params_spec ) then ac = ac_in b = b_in k = k_in call get_Zc_OMa_OMb ( del1 , zc , oma , omb ) Tc = OMb * ac / ( OMa * R * b ) RTc = R * Tc Pc = OMb * RTc / b Vceos = Zc * RTc / Pc al = - 0.26992 be = 1.54226 ga = 0.37464 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al else if ( critical_spec ) then tc = tc_in pc = pc_in w = w_in RTc = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RTc ** 2 / Pc b = OMb * RTc / Pc Vceos = Zc * RTc / Pc ! k (or m) constant to calculate attractive parameter depending on temperature do i = 1 , nc k ( i ) = 0.37464 + 1.54226 * w ( i ) - 0.26992 * w ( i ) ** 2 end do end if ! ac = 0.45723553_pr * R**2 * tc**2 / pc ! b = 0.07779607_pr * R * tc/pc ! k = 0.37464_pr + 1.54226_pr * w - 0.26993_pr * w**2 end subroutine subroutine SRK_factory ( moles_in , ac_in , b_in , tc_in , pc_in , w_in , k_in ) !! SoaveRedlichKwong factory !! !! Takes either the critical parameters or the fitted model parameters !! and gets ones in base of the others real ( pr ), intent ( in ) :: moles_in ( nc ) real ( pr ), optional , intent ( in ) :: ac_in ( nc ) real ( pr ), optional , intent ( in ) :: b_in ( nc ) real ( pr ), optional , intent ( in ) :: tc_in ( nc ) real ( pr ), optional , intent ( in ) :: pc_in ( nc ) real ( pr ), optional , intent ( in ) :: w_in ( nc ) real ( pr ), optional , intent ( in ) :: k_in ( nc ) logical :: params_spec , critical_spec real ( pr ) :: zc ( nc ), oma ( nc ), omb ( nc ) real ( pr ) :: vceos ( nc ), al , be , ga ( nc ) real ( pr ) :: RTc ( nc ) integer :: i , j ar_fun => ar_srkpr vinit => cubic_v0 del1 = 1 z = moles_in params_spec = ( present ( ac_in ) . and . present ( b_in ) . and . present ( k_in )) critical_spec = ( present ( tc_in ) . and . present ( pc_in ) . and . present ( w_in )) if ( params_spec ) then ac = ac_in b = b_in k = k_in call get_Zc_OMa_OMb ( del1 , zc , oma , omb ) Tc = OMb * ac / ( OMa * R * b ) RTc = R * Tc Pc = OMb * RTc / b Vceos = Zc * RTc / Pc dc = 1 / vceos al = - 0.26992 be = 1.54226 ga = 0.37464 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al else if ( critical_spec ) then tc = tc_in pc = pc_in w = w_in RTc = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RTc ** 2 / Pc b = OMb * RTc / Pc Vceos = Zc * RTc / Pc k = 0.48 + 1.574 * w - 0.175 * w ** 2 end if end subroutine subroutine get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) !! Calculate Zc, OMa and OMb from the delta_1 parameter. real ( pr ), intent ( in ) :: del1 (:) !! delta_1 parameter real ( pr ), intent ( out ) :: Zc (:) !! Critical compressibility factor real ( pr ), intent ( out ) :: OMa (:) !! OMa real ( pr ), intent ( out ) :: OMb (:) !! OMb real ( pr ) :: d1 ( size ( del1 )), y ( size ( del1 )) d1 = ( 1._pr + del1 ** 2._pr ) / ( 1._pr + del1 ) y = 1._pr + ( 2._pr * ( 1._pr + del1 )) ** ( 1.0_pr / 3._pr ) + ( 4._pr / ( 1._pr + del1 )) ** ( 1.0_pr / 3 ) OMa = ( 3._pr * y * y + 3._pr * y * d1 + d1 ** 2._pr + d1 - 1.0_pr ) / ( 3._pr * y + d1 - 1.0_pr ) ** 2._pr OMb = 1._pr / ( 3._pr * y + d1 - 1.0_pr ) Zc = y / ( 3._pr * y + d1 - 1.0_pr ) end subroutine get_Zc_OMa_OMb ! ========================================================================== ! ========================================================================== !  Ar Functions ! -------------------------------------------------------------------------- subroutine ar_srkpr ( z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) !! Wrapper subroutine to the SRK/PR Residula Helmholtz function to !! use the general interface real ( pr ), intent ( in ) :: z (:) !! Number of moles real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( out ) :: ar !! Residual Helmholtz real ( pr ), intent ( out ) :: arv !! dAr/dV real ( pr ), intent ( out ) :: artv !! dAr2/dTV real ( pr ), intent ( out ) :: arv2 !! dAr2/dV2 real ( pr ), intent ( out ) :: Arn ( size ( z )) !! dAr/dn real ( pr ), intent ( out ) :: ArVn ( size ( z )) !! dAr2/dVn real ( pr ), intent ( out ) :: ArTn ( size ( z )) !! dAr2/dTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) !! dAr2/dn2 integer :: nd !! Compositional derivatives integer :: nt !! Temperature derivatives nd = 2 nt = 1 call HelmSRKPR ( size ( z ), nd , nt , z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) end subroutine subroutine ar_rkpr ( z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) real ( pr ), intent ( in ) :: z (:) !! Number of moles real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( out ) :: ar !! Residual Helmholtz real ( pr ), intent ( out ) :: arv !! dAr/dV real ( pr ), intent ( out ) :: artv !! dAr2/dTV real ( pr ), intent ( out ) :: arv2 !! dAr2/dV2 real ( pr ), intent ( out ) :: Arn ( size ( z )) !! dAr/dn real ( pr ), intent ( out ) :: ArVn ( size ( z )) !! dAr2/dVn real ( pr ), intent ( out ) :: ArTn ( size ( z )) !! dAr2/dTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) !! dAr2/dn2 integer :: nd !! Compositional derivatives integer :: nt !! Temperature derivatives nd = 2 nt = 1 call HelmRKPR ( size ( z ), nd , nt , z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) end subroutine subroutine HelmSRKPR ( nc , ND , NT , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) integer , intent ( in ) :: nc !! Number of components integer , intent ( in ) :: nd !! Compositional derivatives integer , intent ( in ) :: nt !! Temperature derivatives real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( in ) :: rn ( nc ) !! Number of moles real ( pr ), intent ( out ) :: ar !! Residual Helmholtz real ( pr ), intent ( out ) :: arv !! dAr/dV real ( pr ), intent ( out ) :: artv !! dAr2/dTV real ( pr ), intent ( out ) :: arv2 !! dAr2/dV2 real ( pr ), intent ( out ) :: Arn ( nc ) !! dAr/dn real ( pr ), intent ( out ) :: ArVn ( nc ) !! dAr2/dVn real ( pr ), intent ( out ) :: ArTn ( nc ) !! dAr2/dTn real ( pr ), intent ( out ) :: Arn2 ( nc , nc ) !! dAr2/dn2 real ( pr ) :: ArT , ArTT real ( pr ) :: Bmix , dBi ( nc ), dBij ( nc , nc ) real ( pr ) :: D , dDi ( nc ), dDij ( nc , nc ), dDiT ( nc ), dDdT , dDdT2 real ( pr ) :: totn , d1 , d2 real ( pr ) :: f , g , fv , fB , gv , fv2 , gv2 , AUX , FFB , FFBV , FFBB integer :: i , j real ( pr ) :: b_v , a TOTN = sum ( rn ) D1 = del1 ( 1 ) D2 = ( 1._pr - D1 ) / ( 1._pr + D1 ) if ( mixing_rule . lt . 2 ) then call Bnder ( nc , rn , Bmix , dBi , dBij ) call DandTnder ( NT , nc , T , rn , D , dDi , dDiT , dDij , dDdT , dDdT2 ) end if ! The f's and g's used here are for Ar, not F (reduced Ar) ! This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = R * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) fB = - ( f + V * fv ) / Bmix gv = R * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = R * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) ! Reduced Helmholtz Energy and derivatives Ar = - TOTN * g * T - D * f ArV = - TOTN * gv * T - D * fv ArV2 = - TOTN * gv2 * T - D * fv2 AUX = R * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 do i = 1 , nc Arn ( i ) = - g * T + FFB * dBi ( i ) - f * dDi ( i ) ArVn ( i ) = - gv * T + FFBV * dBi ( i ) - fv * dDi ( i ) if ( ND . eq . 2 ) then do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end if end do ! TEMPERATURE DERIVATIVES if ( NT . eq . 1 ) then ArT = - TOTN * g - dDdT * f ArTV = - TOTN * gv - dDdT * fV ArTT = - dDdT2 * f do i = 1 , nc ArTn ( i ) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi ( i ) - f * dDiT ( i ) end do end if end subroutine HelmSRKPR subroutine HelmRKPR ( nco , NDE , NTD , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) !! Calculate the reduced residual Helmholtz Energy and it's derivatives with the RKPR EOS integer , intent ( in ) :: nco integer , intent ( in ) :: NDE integer , intent ( in ) :: NTD real ( pr ), intent ( in ) :: rn ( nco ) real ( pr ), intent ( in ) :: V real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: Ar , ArV , ArTV , ArV2 real ( pr ), intent ( out ) :: Arn ( nco ), ArVn ( nco ), ArTn ( nco ), Arn2 ( nco , nco ) real ( pr ) :: totn real ( pr ) :: Bmix , dBi ( nco ), dBij ( nco , nco ), dD1i ( nco ), dD1ij ( nco , nco ) real ( pr ) :: D , dDi ( nco ), dDij ( nco , nco ), dDiT ( nco ), dDdT , dDdT2 real ( pr ) :: D1 , D2 ! Auxiliar functions for Ar real ( pr ) :: f , g , fv , fB , gv , fv2 , gv2 , AUX , FFB , FFBV , FFBB ! Extra auxiliar functions for RKPR real ( pr ) :: auxD2 , fD1 , fBD1 , fVD1 , fD1D1 real ( pr ) :: ArT , ArTT integer :: i , j nc = nco TOTN = sum ( rn ) call DELTAnder ( nc , rn , D1 , dD1i , dD1ij ) D2 = ( 1 - D1 ) / ( 1 + D1 ) if ( mixing_rule . lt . 2 ) then call Bnder ( nc , rn , Bmix , dBi , dBij ) call DandTnder ( NTD , nc , T , rn , D , dDi , dDiT , dDij , dDdT , dDdT2 ) else ! call Bcubicnder(nc,rn,Bmix,dBi,dBij) ! call DCubicandTnder(NTD,nc,T,rn,D,dDi,dDiT,dDij,dDdT,dDdT2) end if !  The f's and g's used here are for Ar, not F (reduced Ar) !  This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = R * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) fB = - ( f + V * fv ) / Bmix gv = R * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = R * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) ! DERIVATIVES OF f WITH RESPECT TO DELTA1 auxD2 = ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1 = ( 1 / ( V + D1 * Bmix ) + 2 / ( V + D2 * Bmix ) / ( 1 + D1 ) ** 2 ) - f * auxD2 fD1 = fD1 / ( D1 - D2 ) fBD1 = - ( fB * auxD2 + D1 / ( V + D1 * Bmix ) ** 2 + 2 * D2 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 2 ) fBD1 = fBD1 / ( D1 - D2 ) fVD1 = - ( fV * auxD2 + 1 / ( V + D1 * Bmix ) ** 2 + 2 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 2 ) / ( D1 - D2 ) fD1D1 = 4 * ( f - 1 / ( V + D2 * Bmix )) / ( 1 + D1 ) ** 3 + Bmix * ( - 1 / ( V + D1 * Bmix ) ** 2 & + 4 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 4 ) - 2 * fD1 * ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1D1 = fD1D1 / ( D1 - D2 ) ! Reduced Helmholtz Energy and derivatives Ar = - TOTN * g * T - D * f ArV = - TOTN * gv * T - D * fv ArV2 = - TOTN * gv2 * T - D * fv2 AUX = R * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 do i = 1 , nc Arn ( i ) = - g * T + FFB * dBi ( i ) - f * dDi ( i ) - D * fD1 * dD1i ( i ) ArVn ( i ) = - gv * T + FFBV * dBi ( i ) - fv * dDi ( i ) - D * fVD1 * dD1i ( i ) if ( NDE . eq . 2 ) then do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( i , j ) = Arn2 ( i , j ) - D * fBD1 * ( dBi ( i ) * dD1i ( j ) + dBi ( j ) * dD1i ( i )) & - fD1 * ( dDi ( i ) * dD1i ( j ) + dDi ( j ) * dD1i ( i )) & - D * fD1 * dD1ij ( i , j ) - D * fD1D1 * dD1i ( i ) * dD1i ( j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end if end do ! TEMPERATURE DERIVATIVES if ( NTD . eq . 1 ) then ArT = - TOTN * g - dDdT * f ArTV = - TOTN * gv - dDdT * fV ArTT = - dDdT2 * f do i = 1 , nc ArTn ( i ) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi ( i ) - f * dDiT ( i ) - dDdT * fD1 * dD1i ( i ) end do end if end subroutine HelmRKPR subroutine ArVnder ( nc , NDER , NTEMP , z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) integer , intent ( in ) :: nc integer , intent ( in ) :: nder ! Get compositional derivatives integer , intent ( in ) :: ntemp ! Get temperature derivatives real ( pr ), intent ( in ) :: z ( nc ) real ( pr ), intent ( in ) :: V real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: ar , arv , artv , arv2 real ( pr ), dimension ( size ( z )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) vinit => cubic_v0 call ar_fun ( z , v , t , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) end subroutine ArVnder ! ========================================================================== ! ========================================================================== !  Attractive parameter routines ! -------------------------------------------------------------------------- subroutine aTder ( ac , Tc , k , T , a , dadT , dadT2 ) ! Given ac,Tc and the k parameter of the RKPR correlation, as well as the actual T, ! this subroutine calculates a(T) and its first and second derivatives with T. real ( pr ), intent ( in ) :: ac real ( pr ), intent ( in ) :: Tc real ( pr ), intent ( in ) :: k real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: a real ( pr ), intent ( out ) :: dadT real ( pr ), intent ( out ) :: dadT2 real ( pr ) :: Tr Tr = T / Tc if ( thermo_model . le . 3 ) then a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc dadT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5D0 ) else if ( thermo_model == 4 ) then a = ac * ( 3 / ( 2 + Tr )) ** k dadT = - k * a / Tc / ( 2 + Tr ) dadT2 = - ( k + 1 ) * dadT / Tc / ( 2 + Tr ) end if end subroutine aTder subroutine aijTder ( NTD , nc , T , aij , daijdT , daijdT2 ) integer , intent ( in ) :: ntd integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: aij ( nc , nc ), daijdT ( nc , nc ), daijdT2 ( nc , nc ) real ( pr ) :: ai ( nc ), daidT ( nc ), daidT2 ( nc ) real ( pr ) :: aux ( nc , nc ), ratK ( nc , nc ) integer :: i , j if ( tdep . ge . 1 ) then Kij = 0.0D0 do i = 1 , nc Kij (: i - 1 , i ) = Kinf (: i - 1 , i ) + Kij0 (: i - 1 , i ) * exp ( - T / Tstar (: i - 1 , i )) end do end if do i = 1 , nc call aTder ( ac ( i ), Tc ( i ), k ( i ), T , ai ( i ), daidT ( i ), daidT2 ( i )) aij ( i , i ) = ai ( i ) daijdT ( i , i ) = daidT ( i ) daijdT2 ( i , i ) = daidT2 ( i ) if ( i . gt . 1 ) then do j = 1 , i - 1 aij ( j , i ) = sqrt ( ai ( i ) * ai ( j )) * ( 1 - Kij ( j , i )) aij ( i , j ) = aij ( j , i ) if ( NTD . eq . 1 ) then daijdT ( j , i ) = ( 1 - Kij ( j , i )) * ( sqrt ( ai ( i ) / ai ( j )) * daidT ( j ) & + sqrt ( ai ( j ) / ai ( i )) * daidT ( i )) / 2 daijdT2 ( j , i ) = ( 1 - Kij ( j , i )) * ( daidT ( j ) * daidT ( i ) / sqrt ( ai ( i ) * ai ( j )) & + sqrt ( ai ( i ) / ai ( j )) * ( daidT2 ( j ) - daidT ( j ) ** 2 / ( 2 * ai ( j ))) & + sqrt ( ai ( j ) / ai ( i )) * ( daidT2 ( i ) - daidT ( i ) ** 2 / ( 2 * ai ( i )))) / 2 daijdT ( i , j ) = daijdT ( j , i ) daijdT2 ( i , j ) = daijdT2 ( j , i ) end if end do end if end do end subroutine aijTder subroutine DandTnder ( NTD , nc , T , rn , D , dDi , dDiT , dDij , dDdT , dDdT2 ) integer , intent ( in ) :: ntd integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: T real ( pr ), intent ( in ) :: rn ( nc ) real ( pr ), intent ( out ) :: D real ( pr ), intent ( out ) :: dDiT ( nc ) real ( pr ), intent ( out ) :: dDdT real ( pr ), intent ( out ) :: dDdT2 real ( pr ), intent ( out ) :: dDi ( nc ) real ( pr ), intent ( out ) :: dDij ( nc , nc ) real ( pr ) :: aij ( nc , nc ), daijdT ( nc , nc ), daijdT2 ( nc , nc ) real ( pr ) :: aux , aux2 integer :: i , j call aijTder ( NTD , nc , T , aij , daijdT , daijdT2 ) D = 0 dDdT = 0 dDdT2 = 0 do i = 1 , nc aux = 0 aux2 = 0 dDi ( i ) = 0 dDiT ( i ) = 0 do j = 1 , nc dDi ( i ) = dDi ( i ) + 2 * rn ( j ) * aij ( i , j ) if ( NTD . eq . 1 ) then dDiT ( i ) = dDiT ( i ) + 2 * rn ( j ) * daijdT ( i , j ) aux2 = aux2 + rn ( j ) * daijdT2 ( i , j ) end if dDij ( i , j ) = 2 * aij ( i , j ) aux = aux + rn ( j ) * aij ( i , j ) end do D = D + rn ( i ) * aux if ( NTD . eq . 1 ) then dDdT = dDdT + rn ( i ) * dDiT ( i ) / 2 dDdT2 = dDdT2 + rn ( i ) * aux2 end if end do end subroutine DandTnder ! ========================================================================== subroutine DELTAnder ( nc , rn , D1m , dD1i , dD1ij ) integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: rn ( nc ) real ( pr ), intent ( out ) :: D1m , dD1i ( nc ), dD1ij ( nc , nc ) real ( pr ) :: totn integer :: i , j D1m = 0.0_pr do i = 1 , nc D1m = D1m + rn ( i ) * del1 ( i ) end do TOTN = sum ( rn ) D1m = D1m / totn do i = 1 , nc dD1i ( i ) = ( del1 ( i ) - D1m ) / totn do j = 1 , nc dD1ij ( i , j ) = ( 2.0_pr * D1m - del1 ( i ) - del1 ( j )) / totn ** 2 end do end do end subroutine DELTAnder ! ========================================================================== !  Repulsive parameter routines ! -------------------------------------------------------------------------- subroutine Bnder ( nc , rn , Bmix , dBi , dBij ) integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: rn ( nc ) real ( pr ), intent ( out ) :: Bmix , dBi ( nc ), dBij ( nc , nc ) real ( pr ) :: totn , aux ( nc ) integer :: i , j TOTN = sum ( rn ) Bmix = 0.0_pr aux = 0.0_pr do i = 1 , nc do j = 1 , nc bij ( i , j ) = ( b ( i ) + b ( j )) * 0.5_pr * ( 1.0_pr - lij ( i , j )) aux ( i ) = aux ( i ) + rn ( j ) * bij ( i , j ) end do Bmix = Bmix + rn ( i ) * aux ( i ) end do Bmix = Bmix / totn do i = 1 , nc dBi ( i ) = ( 2 * aux ( i ) - Bmix ) / totn do j = 1 , i dBij ( i , j ) = ( 2 * bij ( i , j ) - dBi ( i ) - dBi ( j )) / totn dBij ( j , i ) = dBij ( i , j ) end do end do end subroutine Bnder ! ========================================================================== ! ========================================================================== !  Properties ! -------------------------------------------------------------------------- function cubic_v0 ( z , p , t ) real ( pr ) :: z (:) real ( pr ) :: p real ( pr ) :: t real ( pr ) :: cubic_v0 real ( pr ) :: dbi ( nc ), dbij ( nc , nc ) call bnder ( nc , z , cubic_v0 , dBi , dBij ) end function end module module legacy_thermo_properties use yaeos__constants , only : R , pr use legacy_ar_models , only : ArVnder , vinit implicit none contains subroutine TERMO ( nc , MTYP , INDIC , T , P , rn , V , PHILOG , DLPHIP , DLPHIT , FUGN ) !  MTYP      TYPE OF ROOT DESIRED (-1 vapor, 1 liquid, 0 lower Gibbs energy phase) !  rn        mixture mole numbers                        (input) !  t         temperature (k)                             (input)x, y !  p         pressure    (bar)                          (input) !  v         volume      (L)                            (output) !  PHILOG    vector of ln(phi(i)*P)                     (output)   INDIC < 5 !  DLPHIT    t-derivative of ln(phi(i)) (const P, n)    (output)   INDIC = 2 or 4 !  DLPHIP    P-derivative of ln(phi(i)) (const T, n)    (output)   INDIC < 5 !  FUGN      comp-derivative of ln(phi(i)) (const t & P)(output)   INDIC > 2 !  ------------------------------------------------------------------------- integer , intent ( in ) :: nc !! Number of components integer , intent ( in ) :: indic !! Desired element, this should be setted with optionals integer , intent ( in ) :: mtyp !! Type of root desired (-1 vapor, 1 liquid, 0 lower Gr) real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( in ) :: p !! Pressure [bar] real ( pr ), intent ( in ) :: rn ( nc ) !! Mixture mole numbers real ( pr ), intent ( out ) :: v !! Volume [L] real ( pr ), intent ( out ) :: PHILOG ( nc ) !! ln(phi*p) vector real ( pr ), optional , intent ( out ) :: DLPHIT ( nc ) !! ln(phi) Temp derivative real ( pr ), optional , intent ( out ) :: DLPHIP ( nc ) !! ln(phi) Presssure derivative real ( pr ), optional , intent ( out ) :: FUGN ( nc , nc ) !! ln(phi) compositional derivative real ( pr ) :: ar , arv , artv , arv2 real ( pr ) :: RT , Z , dpv , dpdt real ( pr ) :: Arn ( nc ) real ( pr ) :: ArVn ( nc ) real ( pr ) :: ArTn ( nc ) real ( pr ) :: Arn2 ( nc , nc ) real ( pr ) :: DPDN ( nc ) real ( pr ) :: totn integer :: ntemp , igz , nder , i , k !  The output PHILOG is actually the vector ln(phi(i)*P) NTEMP = 0 IGZ = 0 NDER = 1 if ( INDIC . gt . 2 ) NDER = 2 if ( INDIC . eq . 2 . or . INDIC . eq . 4 ) NTEMP = 1 TOTN = sum ( rn ) ! if (P .le. 0.0d0) MTYP = 1 call VCALC ( MTYP , NC , NTEMP , rn , T , P , V ) RT = R * T Z = V / ( TOTN * RT ) ! this is Z/P call ArVnder ( nc , NDER , NTEMP , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) DPV = - ArV2 - RT * TOTN / V ** 2 DPDT = - ArTV + TOTN * R / V do I = 1 , NC PHILOG ( I ) = - log ( Z ) + Arn ( I ) / RT DPDN ( I ) = RT / V - ArVn ( I ) if ( present ( dlphip )) DLPHIP ( I ) = - DPDN ( I ) / DPV / RT - 1.D0 / P if ( NTEMP . ne . 0 ) then if ( present ( dlphit )) then DLPHIT ( I ) = ( ArTn ( I ) - Arn ( I ) / T ) / RT + DPDN ( I ) * DPDT / DPV / RT + 1.D0 / T end if end if end do if ( present ( fugn )) then do I = 1 , NC do K = I , NC FUGN ( I , K ) = 1.D0 / TOTN + ( Arn2 ( I , K ) + DPDN ( I ) * DPDN ( K ) / DPV ) / RT FUGN ( K , I ) = FUGN ( I , K ) end do end do end if end subroutine TERMO subroutine zTVTERMO ( nc , INDIC , T , rn , V , P , DPV , PHILOG , DLPHIP , DLPHIT , FUGN ) !! Calculation of lnphi*P and derivatives !!  rn        mixture mole numbers                       (input) !!  t         temperature (k)                            (input) !!  v         volume      (L)                            (input) !!  p         pressure    (bar)                          (output) !!  PHILOG    vector of ln(phi(i)*P)                     (output)  0 < INDIC < 5 !!  DLPHIT    t-derivative of ln(phi(i)) (const P, n)    (output)  0 < INDIC = 2 or 4 !!  DLPHIP    P-derivative of ln(phi(i)) (const T, n)    (output)  0 < INDIC < 5 !!  FUGN      comp-derivative of ln(phi(i)) (const t & P)(output)  2 < INDIC !!  ------------------------------------------------------------------------- implicit none integer , intent ( in ) :: nc , indic real ( pr ), intent ( in ) :: t , rn ( nc ), v real ( pr ), intent ( out ) :: p , dpv real ( pr ), intent ( out ) :: PHILOG ( nc ), DLPHIT ( nc ), DLPHIP ( nc ) real ( pr ), intent ( out ) :: FUGN ( nc , nc ) real ( pr ) :: Arn ( nc ), ArVn ( nc ), ArTn ( nc ), Arn2 ( nc , nc ), DPDN ( nc ), totn real ( pr ) :: ar , arv , artv , arv2 , RT , Z , dpdt integer :: ntemp , igz , nder , i , k NTEMP = 0 IGZ = 0 NDER = 1 if ( INDIC . gt . 2 ) NDER = 2 if ( INDIC . eq . 2 . or . INDIC . eq . 4 ) NTEMP = 1 TOTN = sum ( rn ) RT = R * T Z = V / ( TOTN * RT ) ! this is Z/P call ArVnder ( nc , NDER , NTEMP , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) P = TOTN * RT / V - ArV DPV = - ArV2 - RT * TOTN / V ** 2 DPDT = - ArTV + TOTN * R / V if ( INDIC > 0 ) then do I = 1 , NC PHILOG ( I ) = - log ( Z ) + Arn ( I ) / RT DPDN ( I ) = RT / V - ArVn ( I ) DLPHIP ( I ) = - DPDN ( I ) / DPV / RT - 1.D0 / P if ( NTEMP . ne . 0 ) then DLPHIT ( I ) = ( ArTn ( I ) - Arn ( I ) / T ) / RT + DPDN ( I ) * DPDT / DPV / RT + 1.D0 / T end if end do end if if ( NDER . ge . 2 ) then do I = 1 , NC do K = I , NC FUGN ( I , K ) = 1.D0 / TOTN + ( Arn2 ( I , K ) + DPDN ( I ) * DPDN ( K ) / DPV ) / RT FUGN ( K , I ) = FUGN ( I , K ) end do end do end if end subroutine zTVTERMO subroutine PUREFUG_CALC ( nc , icomp , T , P , V , phi ) !! Fugacity of a pure component integer , intent ( in ) :: nc integer , intent ( in ) :: icomp real ( pr ), intent ( in ) :: T , P , V real ( pr ), intent ( out ) :: phi real ( pr ) :: rn ( nc ), Ar , Arv , ArTV , ArV2 , Arn ( nc ), ArVn ( nc ), ArTn ( nc ), Arn2 ( nc , nc ) real ( pr ) :: RT , Z , philog rn = 0.0 rn ( icomp ) = 1.0 RT = R * T Z = P * V / RT call ArVnder ( nc , 0 , 0 , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) PHILOG = - log ( Z ) + Arn ( icomp ) / RT phi = exp ( PHILOG ) end subroutine purefug_calc recursive subroutine VCALC ( ITYP , nc , NTEMP , rn , T , P , V ) !! ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE integer , intent ( in ) :: ITYP !! TYPE OF ROOT DESIRED (-1 vapor, 1 liquid, 0 lower Gibbs energy phase) integer , intent ( in ) :: nc !! NO. OF COMPONENTS integer , intent ( in ) :: ntemp !! 1 if T-derivatives are required real ( pr ), intent ( in ) :: rn ( nc ) !! FEED MOELS real ( pr ), intent ( in ) :: T !! TEMPERATURE real ( pr ), intent ( in ) :: P !! PRESURE real ( pr ), intent ( out ) :: V !! VOLUME real ( pr ) :: Ar , ArV , ArTV , ArV2 , Arn ( nc ), ArVn ( nc ), ArTn ( nc ), Arn2 ( nc , nc ) logical :: FIRST_RUN integer :: nder real ( pr ) :: totn real ( pr ) :: B , CPV , S3R real ( pr ) :: ZETMIN , ZETA , ZETMAX real ( pr ) :: del , pcalc , der , AT , AVAP , VVAP integer :: iter NDER = 0 FIRST_RUN = . true . TOTN = sum ( rn ) CPV = vinit ( rn , p , t ) B = CPV S3R = 1.D0 / CPV ITER = 0 ZETMIN = 0.D0 !ZETMAX = 1.D0-0.01*T/5000        !.99D0  This is flexible for low T (V very close to B) ZETMAX = 1.D0 - 0.01 * T / ( 10000 * B ) ! improvement for cases with heavy components if ( ITYP . gt . 0 ) then ZETA = . 5 D0 else ! IDEAL GAS ESTIMATE ZETA = min (. 5 D0 , CPV * P / ( TOTN * R * T )) end if 100 continue DEL = 1 pcalc = 2 * p do while ( abs ( DEL ) > 1 d - 10 . and . iter < 100 ) V = CPV / ZETA ITER = ITER + 1 call ArVnder (& nc , NDER , NTEMP , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 & ) PCALC = TOTN * R * T / V - ArV if ( PCALC . gt . P ) then ZETMAX = ZETA else ZETMIN = ZETA end if AT = ( Ar + V * P ) / ( T * R ) - TOTN * log ( V ) ! AT is something close to Gr(P,T) DER = ( ArV2 * V ** 2 + TOTN * R * T ) * S3R ! this is dPdrho/B DEL = - ( PCALC - P ) / DER ZETA = ZETA + max ( min ( DEL , 0.1D0 ), - . 1 D0 ) if ( ZETA . gt . ZETMAX . or . ZETA . lt . ZETMIN ) & ZETA = . 5 D0 * ( ZETMAX + ZETMIN ) end do if ( ITYP . eq . 0 ) then ! FIRST RUN WAS VAPOUR; RERUN FOR LIQUID if ( FIRST_RUN ) then VVAP = V AVAP = AT FIRST_RUN = . false . ZETA = 0.5D0 ZETMAX = 1.D0 - 0.01 * T / 500 goto 100 else if ( AT . gt . AVAP ) V = VVAP end if end if end subroutine vcalc ! ========================================================================== end module","tags":"","url":"sourcefile/legacy.f90.html"},{"title":"psrk.f90 – yaeos","text":"Source Code module yaeos__models_ge_group_contribution_psrk use yaeos__constants , only : pr use yaeos__models_ge_gc_td , only : QuadraticPsi use yaeos__models_ge_group_contribution_groups , only : Groups use yaeos__models_ge_group_contribution_unifac , only : UNIFAC , setup_unifac use yaeos__models_ge_group_contribution_psrk_parameters , only : PSRKParameters , GeGCModelParameters implicit none contains type ( UNIFAC ) function setup_psrk ( molecules , parameters ) use yaeos__models_ge_group_contribution_unifac_parameters , only : UNIFACParameters type ( Groups ), intent ( in ) :: molecules (:) type ( GeGCModelParameters ), optional , intent ( in ) :: parameters type ( GeGCModelParameters ) :: params type ( QuadraticPsi ) :: psi_function real ( pr ), allocatable :: Aij (:, :), Bij (:, :), Cij (:, :) type ( Groups ) :: soup integer :: i , j , ng if ( present ( parameters )) then params = parameters else params = PSRKParameters () end if setup_psrk = setup_unifac ( molecules , params ) ! ======================================================================== ! Build Aij, Bij and Cij matrix (interaction of the soup's subgroups) ! ------------------------------------------------------------------------ soup = setup_psrk % groups_stew ng = size ( soup % groups_ids ) allocate ( Aij ( ng , ng ), Bij ( ng , ng ), Cij ( ng , ng )) Aij = 0 Bij = 0 Cij = 0 do i = 1 , size ( soup % groups_ids ) do j = 1 , size ( soup % groups_ids ) Aij ( i , j ) = params % get_subgroups_aij (& soup % groups_ids ( i ), soup % groups_ids ( j ) & ) Bij ( i , j ) = params % get_subgroups_bij (& soup % groups_ids ( i ), soup % groups_ids ( j ) & ) Cij ( i , j ) = params % get_subgroups_cij (& soup % groups_ids ( i ), soup % groups_ids ( j ) & ) end do end do psi_function % Aij = Aij psi_function % Bij = Bij psi_function % Cij = Cij deallocate ( setup_psrk % psi_function ) setup_psrk % psi_function = psi_function end function end module","tags":"","url":"sourcefile/psrk.f90.html"},{"title":"armodel_adiff_api.f90 – yaeos","text":"Source Code module yaeos__adiff_hyperdual_ar_api !! Module that contains the automatic differentiation logic for an Ar model. !! !! All that is needed to define an Ar model that uses automatic !! differentiation with hyperdual numbers is to define a new derived type !! that overloads the method to the Ar function that you want to use. !! A minimal example follows: !! !! ```fortran !! module newmodel !! use yaeos__adiff_hyperdual_ar_api, only: ArModelAdiff !! !! type, extends(ArModelAdiff) :: YourNewModel !!       type(Substances) :: composition !!       real(8) :: parameters(:) !!     contains !!       procedure :: Ar => arfun !!       procedure :: get_v0 => v0 !! end type !! contains !! subroutine arfun(self, n, v, t, Ar) !!    class(YourNewModel), intent(in) :: self !!    type(hyperdual), intent(in) :: n(:) ! Number of moles !!    type(hyperdual), intent(in) :: v ! Volume [L] !!    type(hyperdual), intent(in) :: t ! Temperature [K] !!    type(hyperdual), intent(out) :: ar_value ! Residual Helmholtz Energy !! !!    ! A very complicated residual helmholtz function of a mixture !!    Ar = sum(n) * v * t !! end subroutine !! !! function v0(self, n, p, t) !!    class(YourNewModel), intent(in) :: self !!    real(pr), intent(in) :: n(:) ! Number of moles !!    real(pr), intent(in) :: p ! Pressure [bar] !!    real(pr), intent(in) :: t ! Temperature [K] !!    real(pr) :: v0 !! !!    v0 = self%parameters(3) !! end function !! ``` !! !! A complete implementation of the PR76 Equation of State can me found in !! `example/adiff/adiff_pr76.f90` !! use yaeos__constants , only : pr use yaeos__models_ar , only : ArModel use hyperdual_mod implicit none type , abstract , extends ( ArModel ) :: ArModelAdiff contains procedure ( hyperdual_ar ), deferred :: Ar procedure :: residual_helmholtz => residual_helmholtz end type abstract interface type ( hyperdual ) function hyperdual_Ar ( self , n , v , t ) import hyperdual , ArModelAdiff class ( ArModelAdiff ) :: self type ( hyperdual ), intent ( in ) :: n (:) type ( hyperdual ), intent ( in ) :: v type ( hyperdual ), intent ( in ) :: t end function end interface contains subroutine residual_helmholtz (& self , n , v , t , Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) class ( ArModelAdiff ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: v , t real ( pr ), optional , intent ( out ) :: Ar , ArV , ArT , ArT2 , ArTV , ArV2 real ( pr ), optional , dimension ( size ( n )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) type ( hyperdual ) :: d_v , d_t , d_n ( size ( n )) type ( hyperdual ) :: d_Ar logical :: any_deriv any_deriv = . false . if ( present ( ArV )) then any_deriv = . true . if ( present ( ArV2 )) call get_dardv2 if ( present ( ArVn )) call get_dardvn if ( present ( ArTV )) call get_dardvt if (. not . ( present ( ArV2 ) . and . present ( ArVn ) . and . present ( ArTV ))) & call get_dardv end if if ( present ( ArT )) then any_deriv = . true . if ( present ( ArT2 )) call get_dardt2 if (. not . ( present ( ArT2 ) . and . present ( ArTn ))) call get_dardt end if if ( present ( ArTn )) then any_deriv = . true . call get_dardtn end if if ( present ( Arn )) then any_deriv = . true . if ( present ( Arn2 )) then call get_dardn2 else call get_dardn end if end if if ( present ( Ar )) then if (. not . any_deriv ) then call reset_vars d_ar = self % Ar ( d_n , d_v , d_t ) end if Ar = d_Ar % f0 end if contains subroutine get_dardn () integer :: i , j do i = 2 , size ( n ), 2 call reset_vars d_n ( i - 1 )% f1 = 1 d_n ( i )% f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i - 1 ) = d_Ar % f1 Arn ( i ) = d_Ar % f2 end do if ( mod ( size ( n ), 2 ) /= 0 ) then call reset_vars d_n ( size ( n ))% f1 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( size ( n )) = d_Ar % f1 end if end subroutine subroutine get_dardn2 () integer :: i , j do i = 1 , size ( n ) do j = i , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_n ( j )% f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i ) = d_Ar % f1 Arn2 ( i , j ) = d_Ar % f12 Arn2 ( j , i ) = d_Ar % f12 end do end do end subroutine subroutine get_dardvn () integer :: i do i = 1 , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_v % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i ) = d_Ar % f1 ArV = d_Ar % f2 ArVn ( i ) = d_Ar % f12 end do end subroutine subroutine get_dardtn () integer :: i do i = 1 , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_t % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i ) = d_Ar % f1 if ( present ( ArT )) ArT = d_Ar % f2 ArTn ( i ) = d_Ar % f12 end do end subroutine subroutine get_dardv () call reset_vars d_v % f1 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArV = d_Ar % f1 end subroutine subroutine get_dardt () call reset_vars d_t % f1 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArT = d_Ar % f1 end subroutine subroutine get_dardt2 () call reset_vars d_t % f1 = 1 d_t % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArT = d_Ar % f1 ArT2 = d_Ar % f12 end subroutine subroutine get_dardv2 () call reset_vars d_v % f1 = 1 d_v % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArV = d_Ar % f1 ArV2 = d_Ar % f12 end subroutine subroutine get_dardvt () call reset_vars d_v % f1 = 1 d_t % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArV = d_Ar % f1 ArTV = d_Ar % f12 end subroutine subroutine reset_vars () d_n = n d_v = v d_t = t end subroutine end subroutine end module","tags":"","url":"sourcefile/armodel_adiff_api.f90.html"},{"title":"auxiliar.f90 – yaeos","text":"Source Code module yaeos__auxiliar use yaeos__constants , only : pr implicit none interface optval module procedure optval_integer , optval_real , optval_character end interface optval contains integer function optval_integer ( val , default ) !! Set a value to a default if it is not defined integer , optional , intent ( in ) :: val integer , intent ( in ) :: default if ( present ( val )) then optval_integer = val else optval_integer = default end if end function optval_integer real ( pr ) function optval_real ( val , default ) !! Set a value to a default if it is not defined real ( pr ), optional , intent ( in ) :: val real ( pr ), intent ( in ) :: default if ( present ( val )) then optval_real = val else optval_real = default end if end function optval_real function optval_character ( val , default ) !! Set a value to a default if it is not defined character ( len =* ), optional , intent ( in ) :: val character ( len =* ), intent ( in ) :: default character ( len = :), allocatable :: optval_character if ( present ( val )) then optval_character = val else optval_character = default end if end function optval_character subroutine sort ( array , idx ) use stdlib_sorting , only : std => sort !! Sort an array and return the indexes real ( pr ), intent ( in out ) :: array (:) integer , optional , intent ( out ) :: idx (:) call std ( array ) end subroutine sort end module yaeos__auxiliar","tags":"","url":"sourcefile/auxiliar.f90~3.html"},{"title":"User documentation – yaeos","text":"Welcome to yaeos user documentation yaeos is a Fortran library that handles thermodynamic Equations of\nState-based calculations, mostly phase-equilibria related ones and properties\nestimation ones. This is a work-in-progress library (and documentation) so don’t hesisate to\nreport any problem/requirement as an issue in our GitHub\npage . Basic usage The base object that represents most of yaeos functionality is the ArModel object, which holds the basic interface of how a model behaves. Since all the properties that yaeos calculates are based on residual\nHelmholtz energy, once the object is set-up all the library functionality is\navailable. use yaeos class ( ArModel ), allocatable :: model ! Variable that holds the model ! A setup function that returns a setted model model = setup_model ( < the properties that define a model > ) ! Once the model is set up, the user has access to the properties call model % pressure ( n , V , T , P , dPdn = dPdn )","tags":"","url":"page/index.html"},{"title":"Using yaeos – yaeos","text":"Getting started Fortran Getting yaeos Setting up a model Calculating thermodynamic properties Units Getting started Fortran Maybe you’ve heard of Fortran as that old and cryptic language that everyone is\nafraid of. Well, not anymore! Fortran is really easy to understand and has been\nupdated a lot in the recent decades. There is a fairly direct guide on the fortran-lang site Getting yaeos yaeos is a Fortran library intended to be used as a fpm package (fpm: Fortran Package Manager), fpm can\nbe easily easily obtained with the Python package manager pip with a simple: pip install --user fpm With fpm installed you can create a new Fortran project by running: fpm new your_project_name A new directory with the name of your project will be created. You can include yaeos in your fpm project by adding it as a dependency on\nyour fpm.toml file by adding this: [dependencies] stdlib = \"*\" yaeos = { git = \"https://github.com/ipqa-research/yaeos\" } Or maybe you want a specific version: [dependencies] stdlib = \"*\" yaeos = { git = \"https://github.com/ipqa-research/yaeos\" , tag = \"2.0.0\" } Setting up a model On yaeos there is a series of models implemented, right now we include\nResidual Helmholtz energy models (like Cubic Equations of State), but plan on\nextening to a broader variety. Moreover, yaeos implements excess Gibbs energy\nmodels like NRTL, UNIQUAC, liquid-vapor UNIFAC, and more. In this example we’ll show how a model in yaeos can be used. We’ll take the Peng-Robinson equation of state as an example, but all the implemented models\ncan be seen at yaeos__models . Inside your app/main.f90 file use program main use yaeos ! Set the variable `model` as a generic `ArModel` class ( ArModel ), allocatable :: model ! Set the variables that we're going to use as variable length arrays real ( pr ), allocatable :: n (:), tc (:), pc (:), w (:) n = [ 0.3 , 0.7 ] ! Number of moles of each component [mol] tc = [ 190 , 310 ] ! Critical temperatures [K] pc = [ 14 , 30 ] ! Critical pressures [bar] w = [ 0.001 , 0.03 ] ! Acentric factors [-] ! Now we set our model as the PengRobinson76 equation of state. model = PengRobinson76 ( tc , pc , w ) end program And then it’s all set, now we’ve set the model variable to use in our\ncalculations. The parameter pr is the precision used by yaeos , with real64 as its value. Calculating thermodynamic properties Some thermodynamic properties can be calculated with yaeos models, and we’re\nadding more! In this example we’ll calculate a PV isotherm from our previously\ndefined model. For the sake of simplicity all the next code blocks are assumed\nto be extensions of the previous one, before the end program sentence. pv_isotherm : block real ( pr ) :: v , t , p ! Thermodynamic variables real ( pr ) :: v0 , vf , dv ! End and start volumes integer :: i , n_points ! iteration variable and how many points to calc t = 30 0.0_pr ! Set temperature to 300 K n_points = 10 ! Set the number of points to calculate ! Set initial and final volume points v0 = 0.1 vf = 10 dv = ( vf - v0 ) / ( n_points + 1 ) ! Build isotherm print * , \"Volume [L], Pressure [bar]\" do i = 0 , n_points + 1 ! Set new volume point v = v0 + i * dv ! Calculate pressure call model % pressure ( n , v , t , p ) ! <- Pressure is stored in `p` ! Print results as a CSV table print * , v , \",\" , p end do end block pv_isotherm You will obtain a table with the data: Volume [L] Pressure [bar] 0.100 456.048 1.000 18.936 1.900 11.310 2.800 8.044 3.700 6.238 4.600 5.093 5.500 4.303 6.400 3.725 7.300 3.284 8.200 2.936 9.100 2.655 10.000 2.423 Also some useful derivatives are available when calculating each property, they\ncan be easily accessed as optional arguments of the routine. For example, to\nobtain the derivative of pressure with respect to volume the line that\ncalculates pressure should be changed to: call model % pressure ( n , v , t , p , dPdV = dPdV ) ! Calculate pressure and dPdV In the next sections of this documentation are listed all the available\nproperties and derivatives that can be calculated with yaeos models. Also,\nin further sections we’ll show how to calculate phase equilibriums and how to\ncreate new models. Units If you were paying attention to the previous examples, you may have noticed\nthat the units of yaeos are defined according to the ideal gas constant R with\nunits: Because of that, pressure must be specified as bar, volume as liters,\ntemperature as Kelvin and number of moles as moles. The returns of the\nproperties will be in the same units as the inputs. Energetic properties as\nenthalpy, entropy, etc will have unit of , which equals to\ncentijoules .","tags":"","url":"page/usage/index.html"},{"title":"Equations of State – yaeos","text":"Equations of State Thermodynamic properties Pressure: P(n, V, T) Volume: V(n, P, T) Fugacity coefficients (V,T): \\ln \\phi_i (V,T) Fugacity coefficients (P,T): \\ln \\phi_i (P,T) Fugacity (V,T): \\ln f_i (V,T) Residual entropy (V,T): S&#94;r(n,V,T) Residual enthalpy (V,T): H&#94;r(n,V,T) Residual Gibbs free energy (V,T): G&#94;r(n,V,T) Residual internal energy (V,T): U&#94;r(n,V,T) Residual constant volume heat capacity (V,T): C_V&#94;r(n,V,T) Residual constant pressure heat capacity (V,T): C_P&#94;r(n,V,T) References Equations of State yaeos is a library based on Equation-of-State calculations. An Equation of\nState (EOS) is a mathematical model that describes the relationship between\nthermodynamic properties of a system, typically pressure (P), volume (V), and\ntemperature (T). These equations are fundamental in physics, chemistry, and\nengineering, especially in thermodynamics and fluid mechanics. EOS models are used to predict phase behavior, thermodynamic properties, and\nequilibrium conditions of gases, liquids, solids, and mixtures. They are widely\napplied in areas such as chemical engineering, petroleum engineering, and\nmaterial science. From the ideal gas law, to cubic equations of state and SAFT,\nto more complex models, EOS are essential tools for the study and design of\nprocesses. The classic way of defining an EOS is though a mathematical equation that\nexpress the pressure as a function of the volume and temperature. For example,\nthe Van der Waals EOS is defined as: Where is the pressure, is the molar volume, is the\ntemperature, is the gas constant, and and are parameters that\ndepend on the substance. For mixtures, the and parameters are\ncalculated from the pure components parameters using a mixing rule. The modern way of defining an EOS is through a mathematical model that express\nthe residual Helmholtz free energy as a function of the mole number, volume and\ntemperature. This approach is more general and allows for a more flexible\ndefinition of the EOS in the context of implementing it in code. All\nthermodynamic properties can be calculated from the residual Helmholtz free\nenergy and its derivatives. yaeos is based on this approach. This section of the documentation will guide you through the thermodynamic\nproperties that can be calculated with yaeos using Helmholtz free energy\nmodels. Additionally, this page serves as a summary of how all these properties\ncan be derived from the Helmholtz free energy and its derivatives. First of all, you might be used to the classic way of defining an\nEOS. This is normal since it is the most common way of explaining them in\nundergraduate thermodynamics courses. So, a very reasonable question is: “how\ncan I obtain the expression for the residual Helmholtz free energy from the expression?”. The answer is the following: We are ready to go now. We leave an example of how to instantiate a\nPeng-Robinson EOS model in the next code block if you want to start evaluating\nproperties right away. program main use yaeos ! We will instantiate a Peng-Robinson EOS model with two components ! Set the variable `model` as a generic `ArModel` class ( ArModel ), allocatable :: model ! Set the variables that we're going to use as variable length arrays real ( pr ), allocatable :: n (:), tc (:), pc (:), w (:) n = [ 0.3 , 0.7 ] ! Number of moles of each component [mol] tc = [ 190 , 310 ] ! Critical temperatures [K] pc = [ 14 , 30 ] ! Critical pressures [bar] w = [ 0.001 , 0.03 ] ! Acentric factors [-] ! Now we set our model as the PengRobinson76 equation of state. model = PengRobinson76 ( tc , pc , w ) end program main The examples provided for each property must be treated as a continuation of\nthe previous code block (before the end program statement). Thermodynamic properties Pressure: Pressure can be calculated from the residual Helmholtz free energy as follows: pressure : block real ( pr ) :: T , V , P , dPdV , dPdT , dPdn ( 2 ) T = 30 0.0_pr ! Set temperature to 300 K V = 0.1_pr ! Set volume to 0.1 L ! Calculate pressure and its derivatives call model % pressure ( n , V , T , P = P , dPdV = dPdV , dPdT = dPdT , dPdn = dPdn ) print * , \"Pressure: \" , P print * , \"dPdV: \" , dPdV print * , \"dPdT: \" , dPdT print * , \"dPdn: \" , dPdn end block pressure Volume: As you must know, given a temperature and pressure, the volume has not a unique\nsolution. In the case of a cubic EOS, there are three possible solutions for\nthe volume. For this reason, the volume is calculated iteratively. Provided , , and we fix and and iterate over the volume until the pressure is the same as the\ninput pressure. To learm how the initial guess for is obtained, please refer to the book\n“Thermodynamic Models: Fundamentals and Computational Aspects” by Michael L.\nMichelsen and Jørgen M. Mollerup. Also, you will find how to calculate derivatives in terms of and derivatives. volume : block real ( pr ) :: T , P , V T = 30 0.0_pr ! Set temperature to 300 K P = 1.0_pr ! Set pressure to 1 bar ! Calculate different volume roots call model % volume ( n , P , T , V = V , root = \"liquid\" ) print * , \"Liquid volume: \" , V call model % volume ( n , P , T , V = V , root = \"vapor\" ) print * , \"Vapor volume: \" , V call model % volume ( n , P , T , V = V , root = \"stable\" ) print * , \"Stable volume root: \" , V end block volume Fugacity coefficients (V,T): Natural logarithm of fugacity coefficients specifing and are\ncalculated as follows: Remember that the compressibility factor is calculated as: Next, the derivatives: With: lnphi_vt : block real ( pr ) :: T , V , lnPhi ( 2 ), dlnPhidP ( 2 ), dlnPhidT ( 2 ), dlnPhidn ( 2 , 2 ) T = 30 0.0_pr ! Set temperature to 300 K V = 1.0_pr ! Set volume to 1 liter call eos % lnphi_vt (& n , V , T , lnPhi = lnPhi , & dlnPhidP = dlnPhidP , dlnPhidT = dlnPhidT , dlnPhidn = dlnPhidn & ) end block lnphi_vt The subroutine lnphi_vt also allows to obtain the value of pressure and its\nderivatives at the specified volume and temperature. Since those values are\nneeded to calculate the fugacity coefficients, you can take advantage of this\nfeature to avoid calculating them twice. lnphi_vt_p : block real ( pr ) :: T , V , lnPhi ( 2 ), P , dPdV , dPdT , dPdn ( 2 ) T = 30 0.0_pr ! Set temperature to 300 K V = 1.0_pr ! Set volume to 1 liter call eos % lnphi_vt (& n , V , T , lnPhi = lnPhi , P = P , dPdV = dPdV , dPdT = dPdT , dPdn = dPdn & ) end block lnphi_vt_p Fugacity coefficients (P,T): There is no need for a direct way of calculating natural logarithm the fugacity\ncoefficients specifing and since we can solve volume from those\nspecifications and then calculate the fugacity coefficients using the method. For that reason you can choose the root of the volume\nthat you want to use to calculate the fugacity coefficients in the same way as\nthe volume method. lnphi_pt : block real ( pr ) :: T , P , lnPhi ( 2 ), dlnPhidP ( 2 ), dlnPhidT ( 2 ), dlnPhidn ( 2 , 2 ) T = 30 0.0_pr ! Set temperature to 300 K P = 1.0_pr ! Set volume to 1 bar call eos % lnphi_pt (& n , P , T , root_type = \"liquid\" , lnPhi = lnPhi , & dlnPhidP = dlnPhidP , dlnPhidT = dlnPhidT , dlnPhidn = dlnPhidn & ) call eos % lnphi_pt (& n , P , T , root_type = \"vapor\" , lnPhi = lnPhi , & dlnPhidP = dlnPhidP , dlnPhidT = dlnPhidT , dlnPhidn = dlnPhidn & ) call eos % lnphi_pt (& n , P , T , root_type = \"stable\" , lnPhi = lnPhi , & dlnPhidP = dlnPhidP , dlnPhidT = dlnPhidT , dlnPhidn = dlnPhidn & ) end block lnphi_pt As in the method you can take advantage and the retrieve\nthe value of the calculated volume and the pressure derivatives. lnphi_pt_v : block real ( pr ) :: T , P , V , lnPhi ( 2 ), dPdV , dPdT , dPdn ( 2 ) T = 30 0.0_pr ! Set temperature to 300 K P = 1.0_pr ! Set volume to 1 bar call eos % lnphi_pt (& n , P , T , V = V , root_type = \"stable\" , lnPhi = lnPhi , & dPdV = dPdV , dPdT = dPdT , dPdn = dPdn & ) end block lnphi_pt_v Fugacity (V,T): Alternative way of calculating fugacity directly from the residual Helmholtz\nfree energy: fugacity_vt : block real ( pr ) :: T , V , lnf ( 2 ), dlnfdV ( 2 ), dlnfdT ( 2 ), dlnfdn ( 2 , 2 ) T = 30 0.0_pr ! Set temperature to 300 K V = 1.0_pr ! Set volume to 1 liter call eos % lnfug_vt (& n , V , T , lnf , & dlnfdV , dlnfdT , dlnfdn , & ) end block fugacity_vt Residual entropy (V,T): We start explaining the residual entropy because it is the easiest property to\ncalculate. Also, helps us to understand how to calculate the next properties. The residual entropy is calculated as follows: And its derivatives: residual_entropy : block real ( pr ) :: T , V , S , dSdV , dSdT , dSdn ( 2 ) T = 30 0.0_pr ! Set temperature to 300 K V = 1.0_pr ! Set volume to 1 liter ! Calculate residual entropy and its derivatives call eos % residual_entropy ( n , V , T , Sr = Sr , SrT = SrT , SrV = SrV , Srn = Srn ) print * , \"Residual entropy: \" , Sr print * , \"SrV: \" , SrV print * , \"SrT: \" , SrT print * , \"Srn: \" , Srn end block residual_entropy Residual enthalpy (V,T): The residual enthalpy is calculated as follows: We know that pressure can be calculated as: Then, we can obtain: And we also know how to calculate residual entropy as: Then, we can obtain the residual enthalpy as: And its derivatives: residual_enthalpy : block real ( pr ) :: T , V , Hr , HrV , HrT , Hrn ( 2 ) T = 30 0.0_pr ! Set temperature to 300 K V = 1.0_pr ! Set volume to 1 liter ! Calculate residual enthalpy and its derivatives call eos % residual_enthalpy ( n , V , T , Hr = Hr , HrV = HrV , HrT = HrT , Hrn = Hrn ) print * , \"Residual enthalpy: \" , Hr print * , \"HrV: \" , HrV print * , \"HrT: \" , HrT print * , \"Hrn: \" , Hrn end block residual_enthalpy Residual Gibbs free energy (V,T): The residual Gibbs free energy is calculated as follows: As with residual enthalpy we can easily deduce: And its derivatives: residual_gibbs : block real ( pr ) :: T , V , Gr , GrV , GrT , Grn ( 2 ) T = 30 0.0_pr ! Set temperature to 300 K V = 1.0_pr ! Set volume to 1 liter ! Calculate residual Gibbs free energy and its derivatives call eos % residual_gibbs ( n , V , T , Gr = Gr , GrV = GrV , GrT = GrT , Grn = Grn ) print * , \"Residual Gibbs free energy: \" , Gr print * , \"GrV: \" , GrV print * , \"GrT: \" , GrT print * , \"Grn: \" , Grn end block residual_gibbs Residual internal energy (V,T): The residual internal energy is calculated as follows: Therefore: And its derivatives: residual_internal_energy : block real ( pr ) :: T , V , Ur , UrV , UrT , Urn ( 2 ) T = 30 0.0_pr ! Set temperature to 300 K V = 1.0_pr ! Set volume to 1 liter ! Calculate residual internal energy and its derivatives call eos % internal_energyresidual ( n , V , T , Ur = Ur , UrV = UrV , UrT = UrT , Urn = Urn ) print * , \"Residual internal energy: \" , Ur print * , \"UrV: \" , UrV print * , \"UrT: \" , UrT print * , \"Urn: \" , Urn end block residual_internal_energy Residual constant volume heat capacity (V,T): The residual constant volume heat capacity is calculated as follows: residual_cv : block real ( pr ) :: T , V , Cv T = 30 0.0_pr ! Set temperature to 300 K V = 1.0_pr ! Set volume to 1 liter ! Calculate residual constant volume heat capacity call eos % residual_cv ( n , V , T , Cv = Cv ) print * , \"Residual constant volume heat capacity: \" , Cv end block residual_cv Residual constant pressure heat capacity (V,T): The residual constant pressure heat capacity is calculated as follows: residual_cp : block real ( pr ) :: T , V , Cp T = 30 0.0_pr ! Set temperature to 300 K V = 1.0_pr ! Set volume to 1 liter ! Calculate residual constant pressure heat capacity call eos % residual_cp ( n , V , T , Cp = Cp ) print * , \"Residual constant pressure heat capacity: \" , Cp end block residual_cp References [1] 1. Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models:\nFundamentals & computational aspects (2. ed). Tie-Line Publications.","tags":"","url":"page/usage/eos/index.html"},{"title":"Cubics – yaeos","text":"SoaveRedlichKwong PengRobinson76 PengRobinson78 RKPR PSRK References Our Cubic Equations of State are implemented based on the generic Cubic\nEquation [1]: Cubic equation of state allows to include the and matrices. \nUsing by default Classic Van der Waals mixing rules.\nFor more information about mixing rules look at Mixing Rules .\nMoreover, cubic equations of state allows to modify their default function, look at Alpha functions . SoaveRedlichKwong Fortran definition: SoaveRedlichKwong . The SoaveRedlichKwong EoS uses the\nfollowing function and its respective correlation for . PengRobinson76 Fortran definition: PengRobinson76 . The Peng-Robinson EoS uses\nthe following function and correlation for k. PengRobinson78 Fortran definition: PengRobinson78 . The Peng-Robinson 78 EoS is an\nimproved version of the original PengRobinson equation for heavier components. \nThis equation ensures a monotonically increasing as the values of increasises.\nIt uses the following function and correlation for k. RKPR RKPR The RKPR EoS [2] extends the classical formulation of Cubic Equations of State by\nfreeing the parameter and setting [1]. This extra degree provides extra ways of\nimplementing the equation in comparison of other Cubic EoS (like PR and SRK)\nwhich are limited to definition of their critical constants. Besides that extra parameter, the RKRR includes another function: These two extra parameters can be provided as arguments. But, if they are\nnot provided they will be calculated by the following correlations: In this implementation, the constants (if not provided) will also \nbe readjusted to assure that at . It is also possible to include the parameters as optional arguments. PSRK PSRK The PSRK EoS [3,4] (Predictive Soave-Redlich-Kwong) is a Soave-Redlich-Kwong\ncubic equation of state that uses the MHV mixrule and the AlphaMathiasCopeman function. With the MHV mixrule, a Gibbs\nexcess energy model is required, in the case of PSRK, the PSRK-UNIFAC model is\nused. References [1] Michelsen, M. L., & Mollerup, J. M. (2007). Thermodynamic models:\nFundamentals & computational aspects (2. ed). Tie-Line Publications. [2] M. Cismondi, J. Mollerup, Development and application of a three-parameter \nRK–PR equation of state, Fluid Phase Equilibria 232 (2005) 74–89.\nhttps://doi.org/10.1016/j.fluid.2005.03.020. [3] Holderbaum, T., & Gmehling, J. (1991). PSRK: A Group Contribution Equation\nof State Based on UNIFAC. Fluid Phase Equilibria, 70(2-3), 251-265.\nhttps://doi.org/10.1016/0378-3812(91)85038-V [4] Horstmann, S., Jabłoniec, A., Krafczyk, J., Fischer, K., & Gmehling, J.\n(2005). PSRK group contribution equation of state: Comprehensive revision and\nextension IV, including critical constants and α-function parameters for 1000\ncomponents. Fluid Phase Equilibria, 227(2), 157-164.\nhttps://doi.org/10.1016/j.fluid.2004.11.002","tags":"","url":"page/usage/eos/cubics/index.html"},{"title":"Alpha functions – yaeos","text":"","tags":"","url":"page/usage/eos/cubics/alpha.html"},{"title":"Mixing Rules – yaeos","text":"Cubic Mixing Rules All CubicEoS in yaeos include a CubicMixRule derived type, which \nhandles how the and parameters in the CubicEoS are calculated. Quadratic Mixing Rules (QMR) Quadratic mixing rules are the ussually most used mixing rules for cubic \nequations of state. QMR are handled by the QMR derived type. Which can be used like: use yaeos , only : pr , QMR type ( QMR ) :: mixrule real ( pr ) :: kij ( 2 , 2 ), lij ( 2 , 2 ) kij ( 1 , :) = [ 0.0 , 0.1 ] kij ( 2 , :) = [ 0.1 , 0.0 ] lij ( 1 , :) = [ 0.0 , 0.01 ] lij ( 2 , :) = [ 0.01 , 0.0 ] mixrule = QMR ( k = kij , l = lij ) By default the matrix will be calculated with a constant value (as shown below). But this functionality can be modified by replacing\nthe get_aij procedure use yaeos , only : pr , QMR type ( QMR ) :: mixrule real ( pr ) :: kij ( 2 , 2 ), lij ( 2 , 2 ) kij ( 1 , :) = [ 0.0 , 0.1 ] kij ( 2 , :) = [ 0.1 , 0.0 ] lij ( 1 , :) = [ 0.0 , 0.01 ] lij ( 2 , :) = [ 0.01 , 0.0 ] mixrule = QMR ( k = kij , l = lij ) mixrule % get_aij => my_aij_implementation subroutine my_aij_implementation ( self , ai , daidt , daidt2 , aij , daijdt , daijdt2 ) class ( QMR ) :: self real ( pr ), intent ( in ) :: ai (:), daidt (:), daidt2 (:) real ( pr ), intent ( out ) :: aij (:, :), daijdt (:, .), daijdt2 (:, :) ! Implementation here end subroutine Models Mixing Rules It is possible to mix the attractive parameter of Cubic Equations with an \nexcess Gibbs-based model.\nThis can be useful for cases of polar molecules and/or systems that have been \nfitted to models. Michelsen’s Modified Huron-Vidal Mixing Rules This mixing rule is based on the aproximate zero-pressure limit \nof a cubic equation of state. At the aproximate zero-pressure limit the\nattractive parameter can be expressed as: Where is a weak function of temperature. In the case of MHV and simplicity it is considered that depends on the model used.","tags":"","url":"page/usage/eos/cubics/mixing.html"},{"title":"Gibbs Excess Models – yaeos","text":"Gibbs Excess Models Routines and Methods \\ln \\gamma_i \\ln \\gamma_i  derivatives Example Excess enthalpy  (H&#94;E) Example Excess entropy  (S&#94;E) Example References Gibbs Excess Models Excess properties are properties of mixtures which quantify the non-ideal\nbehavior of real mixtures. They are defined as the difference between the value\nof the property in a real mixture and the value that would exist in an ideal\nsolution under the same conditions. Gibbs excess models are defined in terms of a mathematical expression that\ndescribes the excess Gibbs energy of a mixture as a function of the composition\nof the components in the mixture and temperature. Then, the other excess\nproperties can be derived from the excess Gibbs energy derivatives. Routines and Methods Activity coefficients are calculated from the excess Gibbs energy using the\nfollowing expression: derivatives The derivatives of the activity coefficients with respect to the mole numbers: The temperature derivative of the activity coefficients: You may notice that yaeos calculates the derivatives of the .\nIf for some reason you need the derivatives of the activity coefficients, you\nmay find useful the following expressions: Example program main use yaeos , only : pr use yaeos , only : Groups , setup_unifac , UNIFAC type ( UNIFAC ) :: model integer , parameter :: nc = 3 type ( Groups ) :: molecules ( nc ) real ( pr ) :: n ( nc ), T , ln_gamma ( nc ), dln_gamma_dT ( nc ) real ( pr ) :: dln_gamma_dn ( nc , nc ) T = 29 8.15_pr n = [ 2 0.0_pr , 7 0.0_pr , 1 0.0_pr ] ! ! Ethane [CH3] molecules ( 1 )% groups_ids = [ 1 ] molecules ( 1 )% number_of_groups = [ 2 ] ! ! Ethanol [CH3, CH2, OH] molecules ( 2 )% groups_ids = [ 1 , 2 , 14 ] molecules ( 2 )% number_of_groups = [ 1 , 1 , 1 ] ! ! Methylamine [CH3-NH2] molecules ( 3 )% groups_ids = [ 28 ] molecules ( 3 )% number_of_groups = [ 1 ] ! setup UNIFAC model model = setup_unifac ( molecules ) ! Calculate ln_gamma and its derivatives call model % ln_gamma ( n , T , ln_gamma , dln_gamma_dT , dln_gamma_dn ) print * , \"ln_gamma = \" , ln_gamma print * , \"dln_gamma_dT = \" , dln_gamma_dT print * , \"dln_gamma_dn = \" , dln_gamma_dn end program main Excess enthalpy From the Gibbs-Helmholtz equation [1]: We can calculate the excess enthalpy from the excess Gibbs energy as: The derivatives of the excess enthalpy can be calculated as: Example To simplify the example, we will use the same code as the previous example,\nommited here for brevity. The following code calculates the excess enthalpy and\nits derivatives. real ( pr ) :: H_E , dH_E_dT , dH_E_dn ( nc ) ! Calculate excess enthalpy and its derivatives call model % excess_enthalpy ( n , T , HE , dHE_dT , dHE_dn ) print * , \"HE = \" , HE print * , \"dHE_dT = \" , dHE_dT print * , \"dHE_dn = \" , dHE_dn Excess entropy Finally, excess entropy can be calculated from the excess Gibbs energy and\nexcess enthalpy as: Replacing : The derivatives of the excess entropy can be calculated as: Example To simplify the example, we will use the same code as the previous example,\nommited here for brevity. The following code calculates the excess entropy and\nits derivatives. real ( pr ) :: SE , dSE_dT , dSE_dn ( nc ) ! Calculate excess entropy and its derivatives call model % excess_entropy ( n , T , SE , dSE_dT , dSE_dn ) print * , \"S_E = \" , SE print * , \"dSE_dT = \" , dSE_dT print * , \"dSE_dn = \" , dSE_dn References [1] https://en.wikipedia.org/wiki/Gibbs%E2%80%93Helmholtz_equation","tags":"","url":"page/usage/excessmodels/index.html"},{"title":"NRTL – yaeos","text":"NRTL The Non-Random-Two-Liquid model presented by Renon and Prausnitz.\nThis model uses local compositions to represent the excess Gibbs energy. with: Where are fittable parameters. H. Renon and J. M. Prausnitz, “Local compositions in thermodynamic excess\nfunctions for liquid mixtures,” AIChE Journal, vol. 14, no. 1, pp. 135–144,\n1968, doi:","tags":"","url":"page/usage/excessmodels/nrtl.html"},{"title":"UNIFAC-LV – yaeos","text":"UNIFAC Combinatorial term derivatives Flory-Huggins Staverman-Guggenheim Fredenslund et al. (UNIFAC) Residual terms derivatives The compositional derivatives: The temperature derivatives: Temperature-compositional cross derivative: Examples Calculating activity coefficients References UNIFAC UNIFAC (UNIQUAC Functional-group Activity Coefficients) is an Excess Gibbs\nfree energy model used to estimate activity coefficients in non-ideal mixtures.\nIt is particularly useful for predicting the phase behavior of chemical\nmixtures, including liquid-liquid equilibrium (LLE) and vapor-liquid\nequilibrium (VLE). In this model the Excess Gibbs free energy is calculated\nfrom the contribution of a combinatorial term and a residual term. Being: Combinatorial: Accounts for the size and shape of the molecules. Residual: Accounts for the energy interactions between different functional groups. Each substance of a mixture modeled with UNIFAC must be represented by a\nlist a functional groups and other list with the ocurrence of each functional\ngroup on the substance. The list of the functional groups culd be accesed on\nthe DDBST web page: https://www.ddbst.com/published-parameters-unifac.html Combinatorial term derivatives Combinatorial term has two parameters and that could be modified.\nThe parameter is always set to 10, and the parameter is set to 1\nfor the Classic Liquid-Vapor UNIFAC model and the PSRK-UNIFAC model, and 3/4\nfor the Dortmund-UNIFAC model. Both could be changed (they are attributes of\nthe UNIFAC objects). Calculate the UNIFAC combinatorial term of reduced Gibbs excess energy.\nThe subroutine uses the Flory-Huggins and Staverman-Guggenheim\ncombinatory terms as follows: Flory-Huggins Staverman-Guggenheim Fredenslund et al. (UNIFAC) Residual terms derivatives Evaluate the UNIFAC residual term. The residual Gibbs excess energy\nand its derivatives are evaluated as: With: In the UNIFAC model, the values are calculated assuming\nthat the molecule “i” is pure, hence only the subgroups of the molecule\n“i” must be considered for the calculation. On the other hand, for the values, all the system’s subgroups are considered. The compositional derivatives: With: The temperature derivatives: With: Temperature-compositional cross derivative: With: Examples Calculating activity coefficients We can instantiate a UNIFAC model with a mixture ethanol-water and evaluate\nthe logarithm of activity coefficients of the model for a 0.5 mole fraction of\neach, and a temperature of 298.0 K. use yaeos__constants , only : pr use yaeos__models_ge_group_contribution_unifac , only : Groups , UNIFAC , setup_unifac ! Variables declarations type ( UNIFAC ) :: model type ( Groups ) :: molecules ( 2 ) real ( pr ) :: ln_gammas ( 2 ) ! Variables instances ! Ethanol definition [CH3, CH2, OH] molecules ( 1 )% groups_ids = [ 1 , 2 , 14 ] ! Subgroups ids molecules ( 1 )% number_of_groups = [ 1 , 1 , 1 ] ! Subgroups occurrences ! Water definition [H2O] molecules ( 2 )% groups_ids = [ 16 ] molecules ( 2 )% number_of_groups = [ 1 ] ! Model setup model = setup_unifac ( molecules ) ! Calculate ln_gammas call model % ln_activity_coefficient ([ 0.5_pr , 0.5_pr ], 29 8.0_pr , ln_gammas ) print * , ln_gammas You will obtain: >>> 0.18534142000449058    0.40331395945417559 References Dortmund Data Bank Software & Separation Technology Fredenslund, A., Jones, R. L., & Prausnitz, J. M. (1975). Group‐contribution\nestimation of activity coefficients in nonideal liquid mixtures. AIChE Journal,\n21(6), 1086–1099. https://doi.org/10.1002/aic.690210607 Skjold-Jorgensen, S., Kolbe, B., Gmehling, J., & Rasmussen, P. (1979).\nVapor-Liquid Equilibria by UNIFAC Group Contribution. Revision and Extension.\nIndustrial & Engineering Chemistry Process Design and Development, 18(4),\n714–722. https://doi.org/10.1021/i260072a024 Gmehling, J., Rasmussen, P., & Fredenslund, A. (1982). Vapor-liquid\nequilibriums by UNIFAC group contribution. Revision and extension. 2.\nIndustrial & Engineering Chemistry Process Design and Development, 21(1),\n118–127. https://doi.org/10.1021/i200016a021 Macedo, E. A., Weidlich, U., Gmehling, J., & Rasmussen, P. (1983).\nVapor-liquid equilibriums by UNIFAC group contribution. Revision and extension. Industrial & Engineering Chemistry Process Design and Development, 22(4),\n676–678. https://doi.org/10.1021/i200023a023 Tiegs, D., Rasmussen, P., Gmehling, J., & Fredenslund, A. (1987).\nVapor-liquid equilibria by UNIFAC group contribution. 4. Revision and\nextension. Industrial & Engineering Chemistry Research, 26(1), 159–161. https://doi.org/10.1021/ie00061a030 Hansen, H. K., Rasmussen, P., Fredenslund, A., Schiller, M., & Gmehling, J.\n(1991). Vapor-liquid equilibria by UNIFAC group contribution. 5. Revision and\nextension. Industrial & Engineering Chemistry Research, 30 (10), 2352–2355. https://doi.org/10.1021/ie00058a017 Wittig, R., Lohmann, J., & Gmehling, J. (2003). Vapor−Liquid Equilibria by\nUNIFAC Group Contribution. 6. Revision and Extension. Industrial & Engineering\nChemistry Research, 42(1), 183–188. https://doi.org/10.1021/ie020506l SINTEF - Thermopack","tags":"","url":"page/usage/excessmodels/unifaclv.html"},{"title":"UNIQUAC – yaeos","text":"UNIQUAC Temperature derivatives Cross temperature-compositional derivative Compositional derivatives Examples References UNIQUAC UNIQUAC ( uni versal qua si c hemical) Excess Gibbs free energy model. With: Some of the model’s terms can be simplified to reduce the complexity of the\nderivatives. Also, allows the model to be evaluated in mole vector n where\nsome of the composition are equal to zero. Being the total number of moles in the system. The expression for the\nExcess Gibbs free energy can be rewritten as: Temperature derivatives : Cross temperature-compositional derivative Compositional derivatives : derivatives are not really needed, but we also provide them. : : Differentiating each term of the first compositional derivative respect to we get: Examples Example from: Gmehling et al. (2012) [2] An example of having a mixture of Water-Ethanol-Bezene at 298.15 K with \nconstant [K]: Water Ethanol Benzene 0 526.02 309.64 −318.06 0 −91.532 1325.1 302.57 0 use yaeos , only : pr , setup_uniquac , UNIQUAC integer , parameter :: nc = 3 real ( pr ) :: rs ( nc ), qs ( nc ) real ( pr ) :: b ( nc , nc ) real ( pr ) :: n ( nc ) real ( pr ) :: ln_gammas ( nc ), T type ( UNIQUAC ) :: model rs = [ 0.92_pr , 2.1055_pr , 3.1878_pr ] qs = [ 1.4_pr , 1.972_pr , 2.4_pr ] T = 29 8.15_pr ! Calculate bij from DUij. We need -DU/R to get bij b ( 1 ,:) = [ 0.0_pr , - 52 6.02_pr , - 30 9.64_pr ] b ( 2 ,:) = [ 31 8.06_pr , 0.0_pr , 9 1.532_pr ] b ( 3 ,:) = [ - 132 5.1_pr , - 30 2.57_pr , 0.0_pr ] model = setup_uniquac ( qs , rs , bij = b ) n = [ 2.0_pr , 2.0_pr , 8.0_pr ] call model % ln_activity_coefficient ( n , T , ln_gammas ) print * , exp ( ln_gammas ) ! [8.856, 0.860, 1.425] References Maurer, G., & Prausnitz, J. M. (1978). On the derivation and extension of\n   the UNIQUAC equation. Fluid Phase Equilibria, 2(2), 91-99. Gmehling, Jurgen, Barbel Kolbe, Michael Kleiber, and Jurgen Rarey. Chemical\n   Thermodynamics for Process Simulation. 1st edition. Weinheim: Wiley-VCH,\n   2012. Caleb Bell and Contributors (2016-2024). Thermo: Chemical properties\n   component of Chemical Engineering Design Library (ChEDL)\n   https://github.com/CalebBell/thermo.","tags":"","url":"page/usage/excessmodels/uniquac.html"},{"title":"Phase Equilibrium – yaeos","text":"Phase Equilibria calculations are fundamental for the majority of EoS based\nmodelling either for processes or when studying phase-behaviour. In yaeos most of phase-equilibria procedures return the EquilibriumState type EquilibriumState , which holds all the relevant information of an\nequilibria point. The implemented methods, and their usage are: Flash calculations Saturation points Phase envelopes Isopleths Flash calculations Flash calcuations are one of the most used phase-equilibria calculations during\nmodelling of processes. In yaeos it is possible to make Flash calculations either specifying: type ( EquilibriaState ) :: result ! zPT flash result = flash ( model , z , p_spec = P , T = T ) ! zVT flash result = flash ( model , z , v_spec = P , T = T ) ! It is possible to provide initialization compositions in terms of the ! K-factors. Where k0=y/x result = flash ( model , z , v_spec = P , T = T , k0 = k0 ) It is also possible to make flash calculations with models. In that\ncase, it is important to ignore the v_spec and p_spec arguments, and provide\nan initial guess for -values. A good way of estimating initial \nvalues is by using the mintpd subroutine. For example: integer , parameter :: nc = 3 type ( UNIFAC ) :: model type ( Groups ) :: molecules ( nc ) real ( pr ) :: n ( nc ), w ( nc ), T type ( EquilibriumState ) :: fr real ( pr ) :: mintpd integer :: i ! Define the groups of the three molecules molecules ( 1 )% groups_ids = [ 1 , 42 ] molecules ( 1 )% number_of_groups = [ 1 , 1 ] molecules ( 2 )% groups_ids = [ 1 , 2 ] molecules ( 2 )% number_of_groups = [ 2 , 4 ] molecules ( 3 )% groups_ids = [ 16 ] molecules ( 3 )% number_of_groups = [ 1 ] ! Temperature T = 250 ! Moles n = [ 0.2 , 0.7 , 0.1 ] ! setup UNIFAC model model = setup_unifac ( molecules ) ! Find the composition that provides the mininum tpd call min_tpd ( model , n , P = 1._pr , T = T , mintpd = mintpd , w = w ) ! Calculate the phase-split flash fr = flash ( model , n , T , k0 = w / n , iters = i ) Saturation points Single saturation point calculations are included with the procedures saturation_pressure and saturation_temperature . Both procedures solve\nthe equation With a newton procedure with respect to the desired variable (either or , and updating the values of at each point with type ( EquilibriaState ) :: sat_point sat = saturation_pressure ( model , z , T = T , kind = \"bubble\" ) sat = saturation_pressure ( model , z , T = T , kind = \"dew\" ) sat = saturation_temperature ( model , z , P = P , kind = \"bubble\" ) sat = saturation_temperature ( model , z , P = P , kind = \"dew\" ) Phase envelopes Phase envelopes are the conection of all the saturation points of a system.\nWhen the interest is in calculating a whole phase diagram instead of a single\npoint, or the point is hard to converge. It is better to use a robust\nmathematical algorithm that eases the calcuation providing an easy-to-converge\npoint and using its information to initialize a next one and continue along the\nwhole phase-boundary. In yaeos all kind of phase envelopes are calculated using the numerical \ncontinuation method. This method is extremely useful to calculate lines that\ncan be defined as a undertemined system , which has one degree\nof freedom left. This degree of freedom can be used to define an extra equation Where ns is the index of some specified variable from , and is some specified value. Now the system has no degree\nof freedom left and can be solved by traditional methods like Newton-Raphson. When one point is solved, it is possible to determine how the vector of\nvariables change with respect to the specified variable by solving the following\nsystem of equations: Knowing the sensitivities vector, we\ncan select the next variable to specify by selecting the one that has the\nhighest absolute value of . And a good \nextrapolation to calculate the next point can be obtained with Isopleths type ( PTEnvel2 ) :: env sat = saturation_pressure ( model , z , T = 15 0._pr , kind = \"bubble\" ) env = pt_envelope_2ph ( model , z , sat )","tags":"","url":"page/usage/phase_equilibrium/index.html"},{"title":"Phase envelopes – yaeos","text":"Two-phase envelopes Two-phase envelopes show all the saturation points of a mixture, they can\nbe seen as the boundary line of transition between monophasic regions to \ntwo-phase equilibria regions. In yaeos it is possible to calculate two-phase of different kinds. Isoplets Isoplets Isoplets are the phase boundaries at constant composition \n(the global composition) of the system. Here is a simple example with\ncommentaries on how a phase boundary can be calculated: program phase_diagram !! Program for calculation of phase diagrams. use forsus , only : Substance , forsus_dir , forsus_default_dir use yaeos , only : pr , & SoaveRedlichKwong , PengRobinson76 , PengRobinson78 , RKPR , & EquilibriaState , ArModel , PTEnvel2 , & pt_envelope_2ph , saturation_pressure , saturation_temperature use yaeos__phase_equilibria_auxiliar , only : k_wilson implicit none ! =========================================================================== ! Variables definition ! --------------------------------------------------------------------------- integer , parameter :: nc = 2 class ( ArModel ), allocatable :: model ! Thermodynamic model to be used type ( EquilibriaState ) :: sat_point ! Init type ( PTEnvel2 ) :: envelope ! PT Phase envelope real ( pr ) :: tc ( nc ), pc ( nc ), w ( nc ) ! Component's critical constants real ( pr ) :: n ( nc ) ! Termodynamic variables type ( Substance ) :: sus ( nc ) ! Substances to use ! =========================================================================== ! forsus database directory forsus_dir = \"build/dependencies/forsus/\" // forsus_default_dir ! Find the selected substances on the database and extract their ! critical constants sus ( 1 ) = Substance ( \"methane\" ) sus ( 2 ) = Substance ( \"n-hexane\" ) call get_critical_constants ( sus , tc , pc , w ) ! Model definition model = PengRobinson76 ( tc , pc , w ) ! Composition vector n = [ 0.9_pr , 0.1_pr ] ! Calculate a dew point at low pressure to later ! initialize the phase envelope sat_point = saturation_temperature ( model , n , P = 1._pr , kind = \"dew\" , t0 = 15 0._pr ) ! Calculate phase envelope envelope = pt_envelope_2ph ( model , n , sat_point ) ! Write the phase envelope to screen write ( * , * ) envelope contains subroutine get_critical_constants ( subs , tc_in , pc_in , w_in ) type ( Substance ) :: subs (:) real ( pr ), intent ( out ) :: tc_in (:), pc_in (:), w_in (:) tc_in = subs % critical % critical_temperature % value pc_in = subs % critical % critical_pressure % value / 1e5 w_in = subs % critical % acentric_factor % value end subroutine end program phase_diagram The output of the write command will be pre-formatted. Showing in tabular\ndata with this # PTEnvel2\n\n# kind of sat point\nkind T P [liquid-phase composition vector] [gas-phase composition vector]\n\n# other kind of sat point\nkind T P [liquid-phase composition vector] [gas-phase composition vector]\n\n# Critical\nT P Which when plotted with gnuplot with: plot \"outfile\" \\ index \"dew\" u 2 : 3 w l title \"Dew\" , \\ \"\" index \"bubble\" u 2 : 3 w l t \"Bubble\" , \\ \"\" index \"Critical\" u 1 : 2 w p pt 7 lc rgb \"black\" t \"CP\" Gives the following plot:","tags":"","url":"page/usage/phase_equilibrium/envelopes.html"},{"title":"Flash calculations – yaeos","text":"","tags":"","url":"page/usage/phase_equilibrium/flash.html"},{"title":"Saturation Points – yaeos","text":"","tags":"","url":"page/usage/phase_equilibrium/saturation_points.html"},{"title":"Adding your own models – yaeos","text":"Most of thermodynamic properties calculated in yaeos heavily depend on\ndifferent kind of models and their respective derivatives. Since obtaining the\nderivatives of complex models can be a tedious and error-prone task. We provide\ntwo different ways of getting them automatically (in some cases with some\nperformance-cost), but there is also the possibility of using analytical\nobtained expressions instead. The calculation of thermodynamic properties heavily depends on On yaeos there are three different ways of adding your own model:W Residual Helmholtz models Residual Helmholtz models Residual Helmholtz models are the basis to obtain the residual properties. The main basis in yaeos to define a new object that extends the abstract\ntype called` ArModel . Which enforces the expected functionality of this\nkind of models. use yaeos , only : ArModel type , extends ( ArModel ) :: MyNewModel end type The definition of an ArModel expects that two procedures are defined: abs_residual_helmholtz : Procedure to calculate residual\n      Helmholtz energy and it’s derivatives abs_volume_initializer : Volume initializer to find a liquid\n      root, given a pressure and temperature. use yaeos , only : ArModel type , extends ( ArModel ) :: MyNewModel contains procedure :: residual_helmholtz => an_Ar_implementation procedure :: volume_initializer => an_v0_implementation end type Satisfying those requirements, our model will be ready to make calculations! use yaeos , only : pressure use my_model , only : MyNewModel type ( MyNewModel ) :: model ! Assuming model parameters are set-up call pressure ( model , n , V , T , P )","tags":"","url":"page/usage/newmodels/index.html"},{"title":"Analytical derivatives – yaeos","text":"","tags":"","url":"page/usage/newmodels/analtical.html"},{"title":"Automatic differentiation – yaeos","text":"Autodiff The implementation of new models and all their required derivatives can be\nan endeavours and error-prone task. A tool that helps with this, at a small\nperformance cost, can be automatic differentiation. Automatic differentiation can be implemented in two ways: Forward Differentiation Backward Differentiation With can be combined to obtain higher order derivatives. In yaeos it is possible to add new models via two different kind of\nimplementations. Operator overloading with hyperdual numbers and\nsource-to-source automatic differentiation with tapenade . @warn\nRemember to use the R constant from yaeos__constants , and all models\nshould have a type(Substances) attribute!\n@endwarn Hyperdual autodiff ArModel Automatic differentiation with hyperdual numbers can be done with the ArModelAdiff derived type. This implementation requires just to extend\nthat derived type with your own implementation and a volume initializer. module hyperdual_pr76 use yaeos__adiff_hyperdual_ar_api , only : ArModelAdiff use yaeos__constants , only : pr , R use yaeos__substance , only : Substances implicit none type , extends ( ArModelAdiff ) :: PR76 !! PengRobinson 76 EoS ! Mixing rule Parameters real ( pr ), allocatable :: kij (:, :), lij (:, :) ! EoS parameters real ( pr ), allocatable :: ac (:), b (:), k (:) real ( pr ), allocatable :: tc (:), pc (:), w (:) contains procedure :: Ar => arfun procedure :: get_v0 => v0 procedure :: volume => volume end type PR76 real ( pr ), parameter :: del1 = 1._pr + sqrt ( 2._pr ) real ( pr ), parameter :: del2 = 1._pr - sqrt ( 2._pr ) contains type ( PR76 ) function setup ( tc , pc , w , kij , lij ) result ( self ) !! Function to obtain a defined PR76 model with setted up parameters !! as function of Tc, Pc, and w real ( pr ) :: tc (:) real ( pr ) :: pc (:) real ( pr ) :: w (:) real ( pr ) :: kij (:, :) real ( pr ) :: lij (:, :) self % composition % tc = tc self % composition % pc = pc self % composition % w = w self % ac = 0.45723553_pr * R ** 2 * tc ** 2 / pc self % b = 0.07779607_pr * R * tc_in / pc_in self % k = 0.37464_pr + 1.54226_pr * w - 0.26993_pr * w ** 2 self % kij = kij self % lij = lij end function function arfun ( self , n , v , t ) result ( ar ) !! Residual Helmholtz calculation for a generic cubic with !! quadratic mixing rules. class ( PR76 ) :: self type ( hyperdual ), intent ( in ) :: n (:), v , t type ( hyperdual ) :: ar type ( hyperdual ) :: amix , a ( size ( n )), ai ( size ( n )), n2 ( size ( n )) type ( hyperdual ) :: bmix type ( hyperdual ) :: b_v , nij integer :: i , j ! Associate allows us to keep the later expressions simple. associate (& pc => self % composition % pc , ac => self % ac , b => self % b , k => self % k ,& kij => self % kij , lij => self % lij , tc => self % compostion % tc & ) ! Soave alpha function a = 1.0_pr + k * ( 1.0_pr - sqrt ( t / tc )) a = ac * a ** 2 ai = sqrt ( a ) ! Quadratic Mixing Rule amix = 0.0_pr bmix = 0.0_pr do i = 1 , size ( n ) - 1 do j = i + 1 , size ( n ) nij = n ( i ) * n ( j ) amix = amix + 2 * nij * ( ai ( i ) * ai ( j )) * ( 1 - kij ( i , j )) bmix = bmix + nij * ( b ( i ) + b ( j )) * ( 1 - lij ( i , j )) end do end do end do amix = amix + sum ( n ** 2 * a ) bmix = bmix + sum ( n ** 2 * b ) bmix = bmix / sum ( n ) b_v = bmix / v ! Generic Cubic Ar function ar = (& - sum ( n ) * log ( 1.0_pr - b_v ) & - amix / ( R * T * bmix ) * 1.0_pr / ( del1 - del2 ) & * log (( 1.0_pr + del1 * b_v ) / ( 1.0_pr + del2 * b_v )) & ) * ( R * T ) end associate end function arfun function v0 ( self , n , p , t ) !! Initialization of liquid volume solving with covolume. This also !! helps the Michelsen volume solver class ( PR76 ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: p real ( pr ), intent ( in ) :: t real ( pr ) :: v0 v0 = sum ( n * self % b ) / sum ( n ) end function v0 subroutine volume ( eos , n , P , T , V , root_type ) !! In the case of models that have a \"covolume\" value, using the solver !! of Michelsen is a better option that the default. use yaeos__models_solvers , only : volume_michelsen class ( PR76 ), intent ( in ) :: eos real ( pr ), intent ( in ) :: n (:), P , T real ( pr ), intent ( out ) :: V character ( len =* ), intent ( in ) :: root_type call volume_michelsen ( eos , n , P , T , V , root_type ) end subroutine end module hyperdual_pr76 Tapenade Adiff And alternative to hyperdual that takes a bit more work, but can end in a more\nperformant model, is doing tapenade source-to-source differentiation. For\nthis tapenade must be installed and accessible from a terminal donwload link . tapenade diff Tapenade is an automatic differentiation tool developed by researchers at INRIA (the French National\nInstitute for Research in Computer Science and Automation). Tapenade is designed to automatically generate derivative code for numerical\nsimulation programs written in Fortran or C. It enables the computation of\ngradients, Hessians, and other derivatives efficiently, which is particularly\nuseful in fields such as optimization, sensitivity analysis, and scientific\ncomputing. By analyzing the source code of the original program, Tapenade generates code\nthat computes the derivatives of the program’s outputs with respect to its\ninputs. This capability is crucial in many scientific and engineering\napplications where the ability to efficiently compute derivatives is essential. Overall, Tapenade simplifies the process of incorporating automatic\ndifferentiation into existing numerical simulation codes, making it a valuable\ntool for researchers and developers working in computational science and\nengineering. How we use it In yaeos we developed a wrapper object that receives a set of routines from\na differentiated module and uses and internal logic to get the desired $A_r$ \nderivatives. Obtain a tapenade differentiated EoS Getting a usable $A_r$ equation of state with tapenade is fairly easy. Install tapenade and assure that you have the tapenade executable in\n   your PATH . Setup your new model following the template file .\n   a full implementation of the PengRobinson EoS can be seen at pr.f90 as an example. Run the script gen_tapemodel.sh , providing your file as an argument: bash\n   bash gen_tapemodel.sh <your_model_file.f90> This will generate a new folder tapeout , with your differentiated model\n   inside. Some little post-process must be done due to some details in the tapenade implementation. These are described in the base template but can also\n   be checked on the differentiated PR76 result after fixing the last details To add your new tapenade model just include the file in your src folder and\nuse it with use yaeos , only : ArModel , pressure use your_module_name , only : setup_model class ( ArModel ), allocatable :: model model = setup_model ( < your parameters > ) call pressure ( model , n , v , t )","tags":"","url":"page/usage/newmodels/autodiff.html"},{"title":"Contributing – yaeos","text":"Contributing to yaeos First off, thanks for your interesnt and taking the time to contribute! All types of contributions are encouraged and valued. \nSee the Table of Contents for different ways to help and\ndetails about how this project handles them. Please make sure to read the\nrelevant section before making your contribution. It will make it a lot easier\nfor us maintainers and smooth out the experience for all involved. The\ncommunity looks forward to your contributions. 🎉 And if you like the project, but just don’t have time to contribute, that’s\nfine. There are other easy ways to support the project and show your\nappreciation, which we would also be very happy about:\n- Star the project\n- Tweet about it\n- Refer this project in your project’s readme\n- Mention the project at local meetups and tell your friends/colleagues Table of Contents I Have a Question I Want To Contribute Reporting Bugs Suggesting Enhancements Your First Code Contribution Improving The Documentation Styleguides Commit Messages Join The Project Team I Have a Question If you want to ask a question, we assume that you have read the available Documentation . Before you ask a question, it is best to search for existing Issues that might help you. In\ncase you have found a suitable issue and still need clarification, you can\nwrite your question in this issue. It is also advisable to search the internet\nfor answers first. If you then still feel the need to ask a question and need clarification, we\nrecommend the following: Open an Issue . Provide as much context as you can about what you’re running into. Provide project and platform versions, depending on what seems relevant. We will then take care of the issue as soon as possible. I Want To Contribute Legal Notice When contributing to this project, you must agree that you have authored 100%\nof the content, that you have the necessary rights to the content and that\nthe content you contribute may be provided under the project license. Reporting Bugs Before Submitting a Bug Report A good bug report shouldn’t leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible. Make sure that you are using the latest version. Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the documentation . If you are looking for support, you might want to check this section ). To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the bug tracker . Also make sure to search the internet (including Stack Overflow) to see if users outside of the GitHub community have discussed the issue. Collect information about the bug: Stack trace (Traceback) OS, Platform and Version (Windows, Linux, macOS, x86, ARM) Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant. Possibly your input and the output Can you reliably reproduce the issue? And can you also reproduce it with older versions? How Do I Submit a Good Bug Report? You must never report security related issues, vulnerabilities or bugs including sensitive information to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by email to <>. We use GitHub issues to track bugs and errors. If you run into an issue with the project: Open an Issue . (Since we can’t be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.) Explain the behavior you would expect and the actual behavior. Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case. Provide the information you collected in the previous section. Once it’s filed: The project team will label the issue accordingly. A team member will try to reproduce the issue with your provided steps. If there are no reproduction steps or no obvious way to reproduce the issue, the team will ask you for those steps and mark the issue as needs-repro . Bugs with the needs-repro tag will not be addressed until they are reproduced. If the team is able to reproduce the issue, it will be marked needs-fix , as well as possibly other tags (such as critical ), and the issue will be left to be implemented by someone . Suggesting Enhancements This section guides you through submitting an enhancement suggestion for yaeos, including completely new features and minor improvements to existing\nfunctionality . Following these guidelines will help maintainers and the\ncommunity to understand your suggestion and find related suggestions. Before Submitting an Enhancement Make sure that you are using the latest version. Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration. Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one. Find out whether your idea fits with the scope and aims of the project. It’s up to you to make a strong case to convince the project’s developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you’re just targeting a minority of users, consider writing an add-on/plugin library. How Do I Submit a Good Enhancement Suggestion? Enhancement suggestions are tracked as GitHub issues . Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Describe the current behavior and explain which behavior you expected to see instead and why. At this point you can also tell which alternatives do not work for you. You may want to include screenshots and animated GIFs which help you demonstrate the steps or point out the part which the suggestion is related to. You can use this tool to record GIFs on macOS and Windows, and this tool or this tool on Linux. Explain why this enhancement would be useful to most yaeos users. You may also want to point out the other projects that solved it better and which could serve as inspiration. Your First Code Contribution Improving The Documentation Styleguides Our code style can be read at Style Guide Commit Messages We encourage the use of commitizen styling on commit\nmessages. Join The Project Team mail me","tags":"","url":"page/contributing/index.html"},{"title":"Style guide – yaeos","text":"yaeos Style Guide Adopting a consistent style can improve code legibility through the choice of good naming conventions.\nIn addition, style checks will be run during CI to flag any severe non-conformance.\nThis allows code review discussions to focus on semantics and substance rather than pedantry.\nConsistent whitespace usage, and not polluting line endings with trailing white space makes git diff s considerably more legible.\nThis style guide is a living document and proposed changes may be adopted after discussing them and coming to a consensus. Use (modern) standard Fortran Do not use obsolescent or deleted language features\n  E.g., common , pause , entry , arithmetic if and computed goto Do not use vendor extensions in the form of non-standard syntax and vendor supplied intrinsic procedures\n  E.g., real*8 or etime() , use real(pr) Naming of variables and constructs Variable and procedure names, as well as Fortran keywords, should be written in lowercase All constants (like the R gas constant) should be upper case All variables should be in lowercase unless they are represented in uppercase in the bibliography.\n  for example, the molar volume would be v and the total volume would be V . In the case of derivatives, for general properties they should be written as dXdy for first derivatives and dXdyz or dXdy2 for second order derivatives. The only exception is with energetic properties, like Ar , where derivatives are written like ArV , ArVn , etc. All thermodynamic variables that are input of a subroutine/function should\n  have the order: n, V, T n, P, T Variable and procedure names should be made up of one or more full words separated by an underscore,\n  for example has_failed is preferred over hasfailed Where conventional and appropriate shortening of a word is used then the underscore may be omitted,\n  for example linspace is preferred over lin_space For derived types use CamelCase, like ArModel File naming conventions Source files should contain at most one program , module , or submodule The filename should match the program or module name and have the file extension .f90 or .F90 if preprocessing is required module names should include it’s subdirectory, using yaeos__ for the parent src directory. For example the module in src/phase_equilibria/flash.f90 should be named yaeos__phase_equilibria_flash . If the interface and implementation is split using submodules the implementation submodule file should have the same name as the\n  interface (parent) module but end in _implementation E.g., string_class.f90 and string_class_implementation.f90 Tests should be added in the test subdirectory and have the same name as the module they are testing with the test_ prefix\n  added E.g., string_class.f90 and test/test_string_class.f90 Indentation & whitespace By setting and following a convention for indentation and whitespace, code\nreviews and git-diffs can focus on the semantics of the proposed changes rather\nthan style and formatting. We recommend ~~enforce~~ the use of findent to format your files. The body of every Fortran construct should be indented by three (3) spaces Line length should be limited to 80 characters and must not exceed 132 Do not use Tab characters for indentation Remove trailing white space before committing code Attributes Always specify intent for dummy arguments. Don’t use dimension attribute to declare arrays because it is more verbose.\n  Use this: real, allocatable :: a(:), b(:,:) instead of: real, dimension(:), allocatable :: a real, dimension(:,:), allocatable :: b When defining many arrays of the same dimension, dimension can be used as an exception if it makes the code less verbose. If the optional attribute is used to declare a dummy argument, it should follow the intent attribute. End block closing statements Fortran allows certain block constructs or scopes to include the name of the program unit in the end statement.\nThe convention adopted herein is to include procedure names, module names and program names in the end statement,\nunless the closing statement can reasonably be expected to be on the same screen or page, within about 25 lines. Document public API code with FORD Documentation strings should be provided for all public and protected entities and their arguments or parameters.\nThis is currently accomplished using the FORD tool .\nFor help writing FORD style documentation please see the FORD wiki .\nThe following two sections are most relevant for contributing new code: Writing Documentation Documentation Meta Data Limitations To write the “spec” (specification) for a new proposal, please place it in the FORD “pages” directory at doc/specs/ .\nTo get help please see the “Writing Pages” and “Writing Documentation” pages\non the FORD wiki .","tags":"","url":"page/contributing/styleguide.html"},{"title":"Python-API – yaeos","text":"Python API documentation. Dummy file to make sure the Python API documentation\nindex.html is generated, then is replaces with the index.html from the Python\ndocumentation generated with Sphinx.","tags":"","url":"page/python-api/index.html"}]}