var tipuesearch = {"pages":[{"title":" Yaeos ","text":"Yaeos [ ](https://opensource.org/licenses/MPL-2.0) YA_EoS There are multiple open source equation of state libraries, like: Clapeyron julia FeOs rust with Python bindings teqp C++ with Python bindings thermo python thermopack Fortran with Python bindings CoolProp C++ with Python bindings Here we are presenting yet another (still in development) one, that tackles the\nsame problem just, in another way. Mostly exploiting readability and\nextensiblity of Modern Fortran for scientists to have an easy way to implement\nnew thermodynamic models without dealing with lower level languages but still\ngetting decent performance. \nAnd also this framework provides the possiblility of using analitically obtained\nderivatives so both options are easy available. This is an experimental work in progress and we recommend the before\nmentioned libraries if you are intending to use some of this in real work.\nBig part of the code comes from a refactoring process of older codes so\nnot all parts are easily readable, yet. We focus mainly in that the addition of a new thermodynamic model is as easy as\npossible. Also providing our own models too! For now we only include residual helmholtz model (like Cubic or Saft Equations\nof State). But we’ll be adding other models like $G&#94;E$ (UNIFAC for example). Including new models with Automatic Differentiation. We are using the hyperdual module developed by Philipp Rehner and Gernot Bauer The automatic differentiation API isn’t fully optimized yet so performance is\nmuch slower than it should be. type , extends ( ArModelAdiff ) :: YourNewModel type ( Substances ) :: composition real ( 8 ) :: parameters (:) contains procedure :: Ar => arfun procedure :: get_v0 => v0 end type subroutine arfun ( self , n , v , t , Ar ) class ( YourNewModel ), intent ( in ) :: self type ( hyperdual ), intent ( in ) :: n (:) ! Number of moles type ( hyperdual ), intent ( in ) :: v ! Volume [L] type ( hyperdual ), intent ( in ) :: t ! Temperature [K] type ( hyperdual ), intent ( out ) :: ar_value ! Residual Helmholtz Energy ! A very complicated residual helmholtz function of a mixture Ar = sum ( n ) * v * t end subroutine function v0 ( self , n , p , t ) class ( YourNewModel ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) ! Number of moles real ( pr ), intent ( in ) :: p ! Pressure [bar] real ( pr ), intent ( in ) :: t ! Temperature [K] real ( pr ) :: v0 v0 = self % parameters ( 3 ) end function A complete implementation of the PR76 Equation of State can me found in example/adiff/adiff_pr76.f90 . All the thermodynamic properties can be found in yaeos_thermoprops and called\nlike: use yaeos_thermoprops , only : fugacity_vt use my_new_model , only : YourNewModel ... type ( YourNewModel ) :: eos eos % parameters = [ 1 , 2 , 3 ] call fugacity_vt ( eos , n , v , t , lnfug = lnfug , dlnphidn = dlnphidn ) Documentation The latest API documentation for the main branch can be found here . This was generated from the source\ncode using FORD . We’re\nworking in extending it more. Developer Info Federico Benelli PhD student with focus on reservoir PVT simulation.","tags":"home","loc":"index.html"},{"title":"hyperdual – Yaeos ","text":"type, public, bind(c) :: hyperdual Derived type for hyperdual numbers Hyperdual numbers are represented by the tuple \\f$\\mathbf{f} =\n [f_0, f_1, f_2, f_{12}] = f_0 + f_1 \\varepsilon_1\n + f_2 \\varepsilon_2 + f_{12} \\varepsilon_1 \\varepsilon_2 \\f$.\n Calculations specificaions are defined in module hyperdual_mod.\nsequence Contents Variables f0 f1 f12 f2 Components Type Visibility Attributes Name Initial real(kind=pr), public :: f0 = 0 real part of the hyperdual number real(kind=pr), public :: f1 = 0 \\f$\\varepsilon_1\\f$-part of  the hyperdual number real(kind=pr), public :: f12 = 0 \\f$\\varepsilon_1\\varepsilon_2\\f$-part of the real(kind=pr), public :: f2 = 0 \\f$\\varepsilon_2\\f$-part of  the hyperdual number","tags":"","loc":"type/hyperdual.html"},{"title":"ArModelAdiff – Yaeos ","text":"type, public, abstract, extends( ArModel ) :: ArModelAdiff Inherits type~~armodeladiff~~InheritsGraph type~armodeladiff ArModelAdiff type~armodel ArModel type~armodeladiff->type~armodel Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables id name Type-Bound Procedures Ar get_v0 residual_helmholtz Components Type Visibility Attributes Name Initial integer, public :: id character(len=:), public, allocatable :: name Type-Bound Procedures procedure( hyperdual_Ar ), public, deferred :: Ar function hyperdual_Ar(self, n, v, t) Prototype Arguments Type Intent Optional Attributes Name class( ArModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual ) procedure( abs_volume_initializer ), public, deferred :: get_v0 function abs_volume_initializer(self, n, p, t) Prototype Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) procedure, public :: residual_helmholtz public subroutine residual_helmholtz (self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional dimension(size(n)) :: Arn real(kind=pr), intent(out), optional dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"type/armodeladiff.html"},{"title":"Substances – Yaeos ","text":"type, public :: Substances Inherited by type~~substances~~InheritedByGraph type~substances Substances type~cubiceos CubicEoS type~cubiceos->type~substances components Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables pc tc w Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: pc (:) real(kind=pr), public, allocatable :: tc (:) real(kind=pr), public, allocatable :: w (:)","tags":"","loc":"type/substances.html"},{"title":"ArModel – Yaeos ","text":"type, public, abstract :: ArModel Inherited by type~~armodel~~InheritedByGraph type~armodel ArModel type~armodeladiff ArModelAdiff type~armodeladiff->type~armodel type~cubiceos CubicEoS type~cubiceos->type~armodel Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables id name Type-Bound Procedures get_v0 residual_helmholtz Components Type Visibility Attributes Name Initial integer, public :: id character(len=:), public, allocatable :: name Type-Bound Procedures procedure( abs_volume_initializer ), public, deferred :: get_v0 function abs_volume_initializer(self, n, p, t) Prototype Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) procedure( abs_residual_helmholtz ), public, deferred :: residual_helmholtz subroutine abs_residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Prototype Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional dimension(size(n)) :: Arn real(kind=pr), intent(out), optional dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"type/armodel.html"},{"title":"AlphaFunction – Yaeos ","text":"type, public, abstract :: AlphaFunction Inherited by type~~alphafunction~~InheritedByGraph type~alphafunction AlphaFunction type~cubiceos CubicEoS type~cubiceos->type~alphafunction alpha type~alphasoave AlphaSoave type~alphasoave->type~alphafunction Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures alpha Type-Bound Procedures procedure( abs_alpha ), public, deferred :: alpha subroutine abs_alpha(self, Tr, a, dadt, dadt2) Prototype Arguments Type Intent Optional Attributes Name class( AlphaFunction ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","loc":"type/alphafunction.html"},{"title":"CubicEoS – Yaeos ","text":"type, public, extends( ArModel ) :: CubicEoS Inherits type~~cubiceos~~InheritsGraph type~cubiceos CubicEoS type~substances Substances type~cubiceos->type~substances components type~armodel ArModel type~cubiceos->type~armodel type~cubicmixrule CubicMixRule type~cubiceos->type~cubicmixrule mixrule type~alphafunction AlphaFunction type~cubiceos->type~alphafunction alpha Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables ac alpha b components del1 del2 id mixrule name Type-Bound Procedures get_v0 residual_helmholtz Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: ac (:) class( AlphaFunction ), public, allocatable :: alpha real(kind=pr), public, allocatable :: b (:) class( Substances ), public, allocatable :: components real(kind=pr), public, allocatable :: del1 (:) real(kind=pr), public, allocatable :: del2 (:) integer, public :: id class( CubicMixRule ), public, allocatable :: mixrule character(len=:), public, allocatable :: name Type-Bound Procedures procedure, public :: get_v0 => v0 public function v0 (self, n, p, t) Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) procedure, public :: residual_helmholtz => GenericCubic_Ar public subroutine GenericCubic_Ar (self, n, v, t, ar, arv, ArT, artv, arv2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: ar real(kind=pr), intent(out), optional :: arv real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: artv real(kind=pr), intent(out), optional :: arv2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"type/cubiceos.html"},{"title":"CubicMixRule – Yaeos ","text":"type, public, abstract :: CubicMixRule Inherited by type~~cubicmixrule~~InheritedByGraph type~cubicmixrule CubicMixRule type~cubiceos CubicEoS type~cubiceos->type~cubicmixrule mixrule type~qmr QMR type~qmr->type~cubicmixrule Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures Bmix Dmix Type-Bound Procedures procedure( abs_Bmix ), public, deferred :: Bmix subroutine abs_Bmix(self, n, bi, B, dBi, dBij) Prototype Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) procedure( abs_Dmix ), public, deferred :: Dmix subroutine abs_Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Prototype Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:)","tags":"","loc":"type/cubicmixrule.html"},{"title":"QMR – Yaeos ","text":"type, public, extends( CubicMixRule ) :: QMR Inherits type~~qmr~~InheritsGraph type~qmr QMR type~cubicmixrule CubicMixRule type~qmr->type~cubicmixrule Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables aij k l Type-Bound Procedures Bmix Dmix Components Type Visibility Attributes Name Initial procedure( get_aij ), public, pointer :: aij => kij_constant real(kind=pr), public, allocatable :: k (:,:) real(kind=pr), public, allocatable :: l (:,:) Type-Bound Procedures procedure, public :: Bmix public subroutine Bmix (self, n, bi, B, dBi, dBij) Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) procedure, public :: Dmix public subroutine Dmix (self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:)","tags":"","loc":"type/qmr.html"},{"title":"AlphaSoave – Yaeos ","text":"type, public, extends( AlphaFunction ) :: AlphaSoave Inherits type~~alphasoave~~InheritsGraph type~alphasoave AlphaSoave type~alphafunction AlphaFunction type~alphasoave->type~alphafunction Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables k Type-Bound Procedures alpha Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: k (:) Type-Bound Procedures procedure, public :: alpha public subroutine alpha (self, Tr, a, dadt, dadt2) Arguments Type Intent Optional Attributes Name class( AlphaSoave ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","loc":"type/alphasoave.html"},{"title":"tapenade_ar – Yaeos","text":"abstract interface private subroutine tapenade_ar(n, v, t, arval) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: arval","tags":"","loc":"interface/tapenade_ar.html"},{"title":"tapenade_ar_b – Yaeos","text":"abstract interface private subroutine tapenade_ar_b(n, nb, v, vb, t, tb, arval, arvalb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: arval real(kind=pr) :: arvalb","tags":"","loc":"interface/tapenade_ar_b.html"},{"title":"tapenade_ar_d – Yaeos","text":"abstract interface private subroutine tapenade_ar_d(n, nd, v, vd, t, td, arval, arvald) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald","tags":"","loc":"interface/tapenade_ar_d.html"},{"title":"tapenade_ar_d_b – Yaeos","text":"abstract interface private subroutine tapenade_ar_d_b(n, nb, v, vb, t, tb, arval, arvalb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: arval real(kind=pr) :: arvalb","tags":"","loc":"interface/tapenade_ar_d_b.html"},{"title":"tapenade_ar_d_d – Yaeos","text":"abstract interface private subroutine tapenade_ar_d_d(n, nd, v, vd0, vd, t, td0, td, arval, arvald0, arvald, arvaldd) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd0 real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald0 real(kind=pr), intent(out) :: arvald real(kind=pr), intent(out) :: arvaldd","tags":"","loc":"interface/tapenade_ar_d_d.html"},{"title":"hyperdual_Ar – Yaeos","text":"abstract interface public function hyperdual_Ar(self, n, v, t) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual )","tags":"","loc":"interface/hyperdual_ar.html"},{"title":"Ares – Yaeos","text":"abstract interface public subroutine Ares(z, v, t, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) Description Residual Helmholtz model interface","tags":"","loc":"interface/ares.html"},{"title":"initial_volume – Yaeos","text":"abstract interface public function initial_volume(z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr)","tags":"","loc":"interface/initial_volume.html"},{"title":"abs_residual_helmholtz – Yaeos","text":"abstract interface public subroutine abs_residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional dimension(size(n)) :: Arn real(kind=pr), intent(out), optional dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"interface/abs_residual_helmholtz.html"},{"title":"abs_volume_initializer – Yaeos","text":"abstract interface public function abs_volume_initializer(self, n, p, t) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr)","tags":"","loc":"interface/abs_volume_initializer.html"},{"title":"abs_Bmix – Yaeos","text":"abstract interface public subroutine abs_Bmix(self, n, bi, B, dBi, dBij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:)","tags":"","loc":"interface/abs_bmix.html"},{"title":"abs_Dmix – Yaeos","text":"abstract interface public subroutine abs_Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:)","tags":"","loc":"interface/abs_dmix.html"},{"title":"abs_alpha – Yaeos","text":"abstract interface public subroutine abs_alpha(self, Tr, a, dadt, dadt2) Arguments Type Intent Optional Attributes Name class( AlphaFunction ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","loc":"interface/abs_alpha.html"},{"title":"get_aij – Yaeos","text":"abstract interface public subroutine get_aij(self, ai, daidt, daidt2, aij, daijdt, daijdt2) Arguments Type Intent Optional Attributes Name class( QMR ) :: self real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: aij (:,:) real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:)","tags":"","loc":"interface/get_aij.html"},{"title":"PUREFUG_CALC – Yaeos","text":"public subroutine PUREFUG_CALC(self, nc, icomp, T, P, V, fug) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self integer, intent(in) :: nc integer, intent(in) :: icomp real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: V real(kind=pr), intent(out) :: fug Contents Variables Ar Arn RT Z lnfug n Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ar real(kind=pr), public :: Arn (nc) real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: lnfug real(kind=pr), public :: n (nc)","tags":"","loc":"proc/purefug_calc.html"},{"title":"VCALC – Yaeos","text":"public recursive subroutine VCALC(self, ITYP, nc, rn, T, P, V, max_iters) Uses iso_fortran_env stdlib_optval proc~~vcalc~~UsesGraph proc~vcalc VCALC iso_fortran_env iso_fortran_env proc~vcalc->iso_fortran_env stdlib_optval stdlib_optval proc~vcalc->stdlib_optval Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self integer, intent(in) :: ITYP integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(out) :: V integer, intent(in), optional :: max_iters Calls proc~~vcalc~~CallsGraph proc~vcalc VCALC optval optval proc~vcalc->optval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~vcalc~~CalledByGraph proc~vcalc VCALC proc~fugacity_tp fugacity_tp proc~fugacity_tp->proc~vcalc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables AT AVAP Ar ArV ArV2 B CPV FIRST_RUN S3R VVAP ZETA ZETMAX ZETMIN del der iter maximum_iterations pcalc totn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AT real(kind=pr), public :: AVAP real(kind=pr), public :: Ar real(kind=pr), public :: ArV real(kind=pr), public :: ArV2 real(kind=pr), public :: B real(kind=pr), public :: CPV logical, public :: FIRST_RUN real(kind=pr), public :: S3R real(kind=pr), public :: VVAP real(kind=pr), public :: ZETA real(kind=pr), public :: ZETMAX real(kind=pr), public :: ZETMIN real(kind=pr), public :: del real(kind=pr), public :: der integer, public :: iter integer, public :: maximum_iterations real(kind=pr), public :: pcalc real(kind=pr), public :: totn","tags":"","loc":"proc/vcalc.html"},{"title":"fugacity_tp – Yaeos","text":"public subroutine fugacity_tp(self, n, t, p, v, root_type, lnfug, dlnphidp, dlnphidt, dlnphidn) Uses iso_fortran_env proc~~fugacity_tp~~UsesGraph proc~fugacity_tp fugacity_tp iso_fortran_env iso_fortran_env proc~fugacity_tp->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: p real(kind=pr), intent(out), optional :: v integer, intent(in) :: root_type real(kind=pr), intent(out) :: lnfug (size(n)) real(kind=pr), intent(out), optional :: dlnphidp (size(n)) real(kind=pr), intent(out), optional :: dlnphidt (size(n)) real(kind=pr), intent(out), optional :: dlnphidn (size(n),size(n)) Calls proc~~fugacity_tp~~CallsGraph proc~fugacity_tp fugacity_tp proc~vcalc VCALC proc~fugacity_tp->proc~vcalc proc~fugacity_vt fugacity_vt proc~fugacity_tp->proc~fugacity_vt optval optval proc~vcalc->optval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables p_in v_in Variables Type Visibility Attributes Name Initial real(kind=pr), public :: p_in real(kind=pr), public :: v_in","tags":"","loc":"proc/fugacity_tp.html"},{"title":"fugacity_vt – Yaeos","text":"public subroutine fugacity_vt(self, n, v, t, p, lnfug, dlnphidp, dlnphidt, dlnphidn) Arguments Type Intent Optional Attributes Name class( ArModel ) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: p real(kind=pr), intent(out), optional :: lnfug (size(n)) real(kind=pr), intent(out), optional :: dlnphidp (size(n)) real(kind=pr), intent(out), optional :: dlnphidt (size(n)) real(kind=pr), intent(out), optional :: dlnphidn (size(n),size(n)) Called by proc~~fugacity_vt~~CalledByGraph proc~fugacity_vt fugacity_vt proc~fugacity_tp fugacity_tp proc~fugacity_tp->proc~fugacity_vt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Ar ArTV ArTn ArV ArV2 ArVn Arn Arn2 RT Z dPdN dPdT dPdV i j nc totn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ar real(kind=pr), public :: ArTV real(kind=pr), public, dimension(size(n)) :: ArTn real(kind=pr), public :: ArV real(kind=pr), public :: ArV2 real(kind=pr), public, dimension(size(n)) :: ArVn real(kind=pr), public, dimension(size(n)) :: Arn real(kind=pr), public :: Arn2 (size(n),size(n)) real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: dPdN (size(n)) real(kind=pr), public :: dPdT real(kind=pr), public :: dPdV integer, public :: i integer, public :: j integer, public :: nc real(kind=pr), public :: totn","tags":"","loc":"proc/fugacity_vt.html"},{"title":"AddHyperDualHyperDual – Yaeos","text":"public elemental function AddHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~addhyperdualhyperdual~~CalledByGraph proc~addhyperdualhyperdual AddHyperDualHyperDual interface~operator (+)~2 operator (+) interface~operator (+)~2->proc~addhyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/addhyperdualhyperdual.html"},{"title":"AddHyperDualReal – Yaeos","text":"public elemental function AddHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~addhyperdualreal~~CalledByGraph proc~addhyperdualreal AddHyperDualReal interface~operator (+)~2 operator (+) interface~operator (+)~2->proc~addhyperdualreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/addhyperdualreal.html"},{"title":"AddRealHyperDual – Yaeos","text":"public elemental function AddRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~addrealhyperdual~~CalledByGraph proc~addrealhyperdual AddRealHyperDual interface~operator (+)~2 operator (+) interface~operator (+)~2->proc~addrealhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/addrealhyperdual.html"},{"title":"DivideHyperDualHyperDual – Yaeos","text":"public elemental function DivideHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~dividehyperdualhyperdual~~CalledByGraph proc~dividehyperdualhyperdual DivideHyperDualHyperDual interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~dividehyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dividehyperdualhyperdual.html"},{"title":"DivideHyperDualReal – Yaeos","text":"public elemental function DivideHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~dividehyperdualreal~~CalledByGraph proc~dividehyperdualreal DivideHyperDualReal interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~dividehyperdualreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables invV2 Variables Type Visibility Attributes Name Initial real(kind=pr), public :: invV2","tags":"","loc":"proc/dividehyperdualreal.html"},{"title":"DivideRealHyperDual – Yaeos","text":"public elemental function DivideRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~dividerealhyperdual~~CalledByGraph proc~dividerealhyperdual DivideRealHyperDual interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~dividerealhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables invV2 Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: invV2","tags":"","loc":"proc/dividerealhyperdual.html"},{"title":"MinusHyperDualHyperDual – Yaeos","text":"public elemental function MinusHyperDualHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~minushyperdualhyperdual~~CalledByGraph proc~minushyperdualhyperdual MinusHyperDualHyperDual interface~operator (-) operator (-) interface~operator (-)->proc~minushyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/minushyperdualhyperdual.html"},{"title":"MultiplyHyperDualHyperDual – Yaeos","text":"public elemental function MultiplyHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~multiplyhyperdualhyperdual~~CalledByGraph proc~multiplyhyperdualhyperdual MultiplyHyperDualHyperDual interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~multiplyhyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/multiplyhyperdualhyperdual.html"},{"title":"MultiplyHyperDualInt – Yaeos","text":"public elemental function MultiplyHyperDualInt(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~multiplyhyperdualint~~CalledByGraph proc~multiplyhyperdualint MultiplyHyperDualInt interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~multiplyhyperdualint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/multiplyhyperdualint.html"},{"title":"MultiplyHyperDualReal – Yaeos","text":"public elemental function MultiplyHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~multiplyhyperdualreal~~CalledByGraph proc~multiplyhyperdualreal MultiplyHyperDualReal interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~multiplyhyperdualreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/multiplyhyperdualreal.html"},{"title":"MultiplyIntHyperDual – Yaeos","text":"public elemental function MultiplyIntHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~multiplyinthyperdual~~CalledByGraph proc~multiplyinthyperdual MultiplyIntHyperDual interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~multiplyinthyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/multiplyinthyperdual.html"},{"title":"MultiplyRealHyperDual – Yaeos","text":"public elemental function MultiplyRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~multiplyrealhyperdual~~CalledByGraph proc~multiplyrealhyperdual MultiplyRealHyperDual interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~multiplyrealhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/multiplyrealhyperdual.html"},{"title":"PlusHyperDualHyperDual – Yaeos","text":"public elemental function PlusHyperDualHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~plushyperdualhyperdual~~CalledByGraph proc~plushyperdualhyperdual PlusHyperDualHyperDual interface~operator (+) operator (+) interface~operator (+)->proc~plushyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/plushyperdualhyperdual.html"},{"title":"PowerHyperDualHyperDual – Yaeos","text":"public elemental function PowerHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Calls proc~~powerhyperdualhyperdual~~CallsGraph proc~powerhyperdualhyperdual PowerHyperDualHyperDual proc~loghyperdual logHyperDual proc~powerhyperdualhyperdual->proc~loghyperdual proc~exphyperdual expHyperDual proc~powerhyperdualhyperdual->proc~exphyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~powerhyperdualhyperdual~~CalledByGraph proc~powerhyperdualhyperdual PowerHyperDualHyperDual interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~powerhyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables v4 Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: v4","tags":"","loc":"proc/powerhyperdualhyperdual.html"},{"title":"PowerHyperDualInt – Yaeos","text":"public elemental function PowerHyperDualInt(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~powerhyperdualint~~CalledByGraph proc~powerhyperdualint PowerHyperDualInt interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~powerhyperdualint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i vv2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: vv2","tags":"","loc":"proc/powerhyperdualint.html"},{"title":"PowerHyperDualReal – Yaeos","text":"public elemental function PowerHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~powerhyperdualreal~~CalledByGraph proc~powerhyperdualreal PowerHyperDualReal interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~powerhyperdualreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables deriv tol xval Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public, parameter :: tol = 1.0e-15_pr real(kind=pr), public :: xval","tags":"","loc":"proc/powerhyperdualreal.html"},{"title":"SubtractHyperDualHyperDual – Yaeos","text":"public elemental function SubtractHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~subtracthyperdualhyperdual~~CalledByGraph proc~subtracthyperdualhyperdual SubtractHyperDualHyperDual interface~operator (-)~2 operator (-) interface~operator (-)~2->proc~subtracthyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subtracthyperdualhyperdual.html"},{"title":"SubtractHyperDualReal – Yaeos","text":"public elemental function SubtractHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~subtracthyperdualreal~~CalledByGraph proc~subtracthyperdualreal SubtractHyperDualReal interface~operator (-)~2 operator (-) interface~operator (-)~2->proc~subtracthyperdualreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subtracthyperdualreal.html"},{"title":"SubtractRealHyperDual – Yaeos","text":"public elemental function SubtractRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~subtractrealhyperdual~~CalledByGraph proc~subtractrealhyperdual SubtractRealHyperDual interface~operator (-)~2 operator (-) interface~operator (-)~2->proc~subtractrealhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subtractrealhyperdual.html"},{"title":"SumHyperDual – Yaeos","text":"public pure function SumHyperDual(v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) Called by proc~~sumhyperdual~~CalledByGraph proc~sumhyperdual SumHyperDual interface~sum sum interface~sum->proc~sumhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/sumhyperdual.html"},{"title":"SumHyperDual2 – Yaeos","text":"public pure function SumHyperDual2(v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ),allocatable,(:) Called by proc~~sumhyperdual2~~CalledByGraph proc~sumhyperdual2 SumHyperDual2 interface~sum sum interface~sum->proc~sumhyperdual2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/sumhyperdual2.html"},{"title":"absHyperDual – Yaeos","text":"public elemental function absHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~abshyperdual~~CalledByGraph proc~abshyperdual absHyperDual interface~abs abs interface~abs->proc~abshyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/abshyperdual.html"},{"title":"acosHyperDual – Yaeos","text":"public elemental function acosHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~acoshyperdual~~CalledByGraph proc~acoshyperdual acosHyperDual interface~acos acos interface~acos->proc~acoshyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables deriv deriv1 Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public :: deriv1","tags":"","loc":"proc/acoshyperdual.html"},{"title":"asinHyperDual – Yaeos","text":"public elemental function asinHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~asinhyperdual~~CalledByGraph proc~asinhyperdual asinHyperDual interface~asin asin interface~asin->proc~asinhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables deriv deriv1 Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public :: deriv1","tags":"","loc":"proc/asinhyperdual.html"},{"title":"atan2HyperDual – Yaeos","text":"public elemental function atan2HyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~atan2hyperdual~~CalledByGraph proc~atan2hyperdual atan2HyperDual interface~atan2 atan2 interface~atan2->proc~atan2hyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables a b c d Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a real(kind=pr), public :: b real(kind=pr), public :: c real(kind=pr), public :: d","tags":"","loc":"proc/atan2hyperdual.html"},{"title":"atanHyperDual – Yaeos","text":"public elemental function atanHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~atanhyperdual~~CalledByGraph proc~atanhyperdual atanHyperDual interface~atan atan interface~atan->proc~atanhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables deriv deriv1 Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public :: deriv1","tags":"","loc":"proc/atanhyperdual.html"},{"title":"cosHyperDual – Yaeos","text":"public elemental function cosHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~coshyperdual~~CalledByGraph proc~coshyperdual cosHyperDual interface~cos cos interface~cos->proc~coshyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables dx f Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx real(kind=pr), public :: f","tags":"","loc":"proc/coshyperdual.html"},{"title":"coshHyperDual – Yaeos","text":"public elemental function coshHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~coshhyperdual~~CalledByGraph proc~coshhyperdual coshHyperDual interface~cosh cosh interface~cosh->proc~coshhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables t1 t2 Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: t1 type( hyperdual ), public :: t2","tags":"","loc":"proc/coshhyperdual.html"},{"title":"eq_dd – Yaeos","text":"public function eq_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~eq_dd~~CalledByGraph proc~eq_dd eq_dd interface~operator (.eq.) operator (.eq.) interface~operator (.eq.)->proc~eq_dd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eq_dd.html"},{"title":"eq_di – Yaeos","text":"public function eq_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~eq_di~~CalledByGraph proc~eq_di eq_di interface~operator (.eq.) operator (.eq.) interface~operator (.eq.)->proc~eq_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eq_di.html"},{"title":"eq_dr – Yaeos","text":"public elemental function eq_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~eq_dr~~CalledByGraph proc~eq_dr eq_dr interface~operator (.eq.) operator (.eq.) interface~operator (.eq.)->proc~eq_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eq_dr.html"},{"title":"eq_id – Yaeos","text":"public function eq_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~eq_id~~CalledByGraph proc~eq_id eq_id interface~operator (.eq.) operator (.eq.) interface~operator (.eq.)->proc~eq_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eq_id.html"},{"title":"eq_rd – Yaeos","text":"public elemental function eq_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~eq_rd~~CalledByGraph proc~eq_rd eq_rd interface~operator (.eq.) operator (.eq.) interface~operator (.eq.)->proc~eq_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eq_rd.html"},{"title":"expHyperDual – Yaeos","text":"public elemental function expHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~exphyperdual~~CalledByGraph proc~exphyperdual expHyperDual proc~powerhyperdualhyperdual PowerHyperDualHyperDual proc~powerhyperdualhyperdual->proc~exphyperdual interface~exp exp interface~exp->proc~exphyperdual interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~powerhyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables dx Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx","tags":"","loc":"proc/exphyperdual.html"},{"title":"ge_dd – Yaeos","text":"public function ge_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ge_dd~~CalledByGraph proc~ge_dd ge_dd interface~operator (.ge.) operator (.ge.) interface~operator (.ge.)->proc~ge_dd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ge_dd.html"},{"title":"ge_di – Yaeos","text":"public function ge_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~ge_di~~CalledByGraph proc~ge_di ge_di interface~operator (.ge.) operator (.ge.) interface~operator (.ge.)->proc~ge_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ge_di.html"},{"title":"ge_dr – Yaeos","text":"public function ge_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~ge_dr~~CalledByGraph proc~ge_dr ge_dr interface~operator (.ge.) operator (.ge.) interface~operator (.ge.)->proc~ge_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ge_dr.html"},{"title":"ge_id – Yaeos","text":"public function ge_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ge_id~~CalledByGraph proc~ge_id ge_id interface~operator (.ge.) operator (.ge.) interface~operator (.ge.)->proc~ge_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ge_id.html"},{"title":"ge_rd – Yaeos","text":"public function ge_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ge_rd~~CalledByGraph proc~ge_rd ge_rd interface~operator (.ge.) operator (.ge.) interface~operator (.ge.)->proc~ge_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ge_rd.html"},{"title":"gt_dd – Yaeos","text":"public function gt_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~gt_dd~~CalledByGraph proc~gt_dd gt_dd interface~operator (.gt.) operator (.gt.) interface~operator (.gt.)->proc~gt_dd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gt_dd.html"},{"title":"gt_di – Yaeos","text":"public function gt_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~gt_di~~CalledByGraph proc~gt_di gt_di interface~operator (.gt.) operator (.gt.) interface~operator (.gt.)->proc~gt_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gt_di.html"},{"title":"gt_dr – Yaeos","text":"public function gt_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~gt_dr~~CalledByGraph proc~gt_dr gt_dr interface~operator (.gt.) operator (.gt.) interface~operator (.gt.)->proc~gt_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gt_dr.html"},{"title":"gt_id – Yaeos","text":"public function gt_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~gt_id~~CalledByGraph proc~gt_id gt_id interface~operator (.gt.) operator (.gt.) interface~operator (.gt.)->proc~gt_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gt_id.html"},{"title":"gt_rd – Yaeos","text":"public function gt_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~gt_rd~~CalledByGraph proc~gt_rd gt_rd interface~operator (.gt.) operator (.gt.) interface~operator (.gt.)->proc~gt_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gt_rd.html"},{"title":"intHyperDual – Yaeos","text":"public elemental function intHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer Called by proc~~inthyperdual~~CalledByGraph proc~inthyperdual intHyperDual interface~int int interface~int->proc~inthyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inthyperdual.html"},{"title":"le_dd – Yaeos","text":"public function le_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~le_dd~~CalledByGraph proc~le_dd le_dd interface~operator (.le.) operator (.le.) interface~operator (.le.)->proc~le_dd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/le_dd.html"},{"title":"le_di – Yaeos","text":"public function le_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~le_di~~CalledByGraph proc~le_di le_di interface~operator (.le.) operator (.le.) interface~operator (.le.)->proc~le_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/le_di.html"},{"title":"le_dr – Yaeos","text":"public function le_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~le_dr~~CalledByGraph proc~le_dr le_dr interface~operator (.le.) operator (.le.) interface~operator (.le.)->proc~le_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/le_dr.html"},{"title":"le_id – Yaeos","text":"public function le_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~le_id~~CalledByGraph proc~le_id le_id interface~operator (.le.) operator (.le.) interface~operator (.le.)->proc~le_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/le_id.html"},{"title":"le_rd – Yaeos","text":"public function le_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~le_rd~~CalledByGraph proc~le_rd le_rd interface~operator (.le.) operator (.le.) interface~operator (.le.)->proc~le_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/le_rd.html"},{"title":"log10HyperDual – Yaeos","text":"public elemental function log10HyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~log10hyperdual~~CalledByGraph proc~log10hyperdual log10HyperDual interface~log10 log10 interface~log10->proc~log10hyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/log10hyperdual.html"},{"title":"logHyperDual – Yaeos","text":"public elemental function logHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~loghyperdual~~CalledByGraph proc~loghyperdual logHyperDual proc~powerhyperdualhyperdual PowerHyperDualHyperDual proc~powerhyperdualhyperdual->proc~loghyperdual interface~log log interface~log->proc~loghyperdual interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~powerhyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables dx1 dx2 Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx1 real(kind=pr), public :: dx2","tags":"","loc":"proc/loghyperdual.html"},{"title":"lt_dd – Yaeos","text":"public function lt_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~lt_dd~~CalledByGraph proc~lt_dd lt_dd interface~operator (.lt.) operator (.lt.) interface~operator (.lt.)->proc~lt_dd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lt_dd.html"},{"title":"lt_di – Yaeos","text":"public function lt_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~lt_di~~CalledByGraph proc~lt_di lt_di interface~operator (.lt.) operator (.lt.) interface~operator (.lt.)->proc~lt_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lt_di.html"},{"title":"lt_dr – Yaeos","text":"public function lt_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~lt_dr~~CalledByGraph proc~lt_dr lt_dr interface~operator (.lt.) operator (.lt.) interface~operator (.lt.)->proc~lt_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lt_dr.html"},{"title":"lt_id – Yaeos","text":"public function lt_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~lt_id~~CalledByGraph proc~lt_id lt_id interface~operator (.lt.) operator (.lt.) interface~operator (.lt.)->proc~lt_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lt_id.html"},{"title":"lt_rd – Yaeos","text":"public function lt_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~lt_rd~~CalledByGraph proc~lt_rd lt_rd interface~operator (.lt.) operator (.lt.) interface~operator (.lt.)->proc~lt_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lt_rd.html"},{"title":"max_dd – Yaeos","text":"public elemental function max_dd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~max_dd~~CalledByGraph proc~max_dd max_dd interface~max max interface~max->proc~max_dd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/max_dd.html"},{"title":"max_ddd – Yaeos","text":"public elemental function max_ddd(v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual ) Called by proc~~max_ddd~~CalledByGraph proc~max_ddd max_ddd interface~max max interface~max->proc~max_ddd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/max_ddd.html"},{"title":"max_dr – Yaeos","text":"public elemental function max_dr(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~max_dr~~CalledByGraph proc~max_dr max_dr interface~max max interface~max->proc~max_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/max_dr.html"},{"title":"max_rd – Yaeos","text":"public elemental function max_rd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~max_rd~~CalledByGraph proc~max_rd max_rd interface~max max interface~max->proc~max_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/max_rd.html"},{"title":"min_dd – Yaeos","text":"public elemental function min_dd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~min_dd~~CalledByGraph proc~min_dd min_dd interface~min min interface~min->proc~min_dd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/min_dd.html"},{"title":"min_dr – Yaeos","text":"public elemental function min_dr(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~min_dr~~CalledByGraph proc~min_dr min_dr interface~min min interface~min->proc~min_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/min_dr.html"},{"title":"min_rd – Yaeos","text":"public elemental function min_rd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~min_rd~~CalledByGraph proc~min_rd min_rd interface~min min interface~min->proc~min_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/min_rd.html"},{"title":"ne_dd – Yaeos","text":"public function ne_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ne_dd~~CalledByGraph proc~ne_dd ne_dd interface~operator (.ne.) operator (.ne.) interface~operator (.ne.)->proc~ne_dd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ne_dd.html"},{"title":"ne_di – Yaeos","text":"public function ne_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~ne_di~~CalledByGraph proc~ne_di ne_di interface~operator (.ne.) operator (.ne.) interface~operator (.ne.)->proc~ne_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ne_di.html"},{"title":"ne_dr – Yaeos","text":"public function ne_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~ne_dr~~CalledByGraph proc~ne_dr ne_dr interface~operator (.ne.) operator (.ne.) interface~operator (.ne.)->proc~ne_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ne_dr.html"},{"title":"ne_id – Yaeos","text":"public function ne_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ne_id~~CalledByGraph proc~ne_id ne_id interface~operator (.ne.) operator (.ne.) interface~operator (.ne.)->proc~ne_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ne_id.html"},{"title":"ne_rd – Yaeos","text":"public function ne_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ne_rd~~CalledByGraph proc~ne_rd ne_rd interface~operator (.ne.) operator (.ne.) interface~operator (.ne.)->proc~ne_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ne_rd.html"},{"title":"nintHyperDual – Yaeos","text":"public elemental function nintHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer Called by proc~~ninthyperdual~~CalledByGraph proc~ninthyperdual nintHyperDual interface~nint nint interface~nint->proc~ninthyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ninthyperdual.html"},{"title":"realHyperDual – Yaeos","text":"public elemental function realHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr) Called by proc~~realhyperdual~~CalledByGraph proc~realhyperdual realHyperDual interface~real real interface~real->proc~realhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/realhyperdual.html"},{"title":"sign_dd – Yaeos","text":"public elemental function sign_dd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~sign_dd~~CalledByGraph proc~sign_dd sign_dd interface~sign sign interface~sign->proc~sign_dd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ssign Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ssign","tags":"","loc":"proc/sign_dd.html"},{"title":"sign_dr – Yaeos","text":"public elemental function sign_dr(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~sign_dr~~CalledByGraph proc~sign_dr sign_dr interface~sign sign interface~sign->proc~sign_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ssign Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ssign","tags":"","loc":"proc/sign_dr.html"},{"title":"sign_rd – Yaeos","text":"public elemental function sign_rd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~sign_rd~~CalledByGraph proc~sign_rd sign_rd interface~sign sign interface~sign->proc~sign_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ssign Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ssign","tags":"","loc":"proc/sign_rd.html"},{"title":"sinHyperDual – Yaeos","text":"public elemental function sinHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~sinhyperdual~~CalledByGraph proc~sinhyperdual sinHyperDual interface~sin sin interface~sin->proc~sinhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables dx f Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx real(kind=pr), public :: f","tags":"","loc":"proc/sinhyperdual.html"},{"title":"sinhHyperDual – Yaeos","text":"public elemental function sinhHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~sinhhyperdual~~CalledByGraph proc~sinhhyperdual sinhHyperDual interface~sinh sinh interface~sinh->proc~sinhhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables t1 t2 Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: t1 type( hyperdual ), public :: t2","tags":"","loc":"proc/sinhhyperdual.html"},{"title":"sqrtHyperDual – Yaeos","text":"public elemental function sqrtHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~sqrthyperdual~~CalledByGraph proc~sqrthyperdual sqrtHyperDual interface~sqrt sqrt interface~sqrt->proc~sqrthyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables expo square Variables Type Visibility Attributes Name Initial real(kind=pr), public, parameter :: expo = 3.0_pr/2.0_pr real(kind=pr), public :: square","tags":"","loc":"proc/sqrthyperdual.html"},{"title":"tanHyperDual – Yaeos","text":"public elemental function tanHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~tanhyperdual~~CalledByGraph proc~tanhyperdual tanHyperDual interface~tan tan interface~tan->proc~tanhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables dx f Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx real(kind=pr), public :: f","tags":"","loc":"proc/tanhyperdual.html"},{"title":"tanhHyperDual – Yaeos","text":"public elemental function tanhHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~tanhhyperdual~~CalledByGraph proc~tanhhyperdual tanhHyperDual interface~tanh tanh interface~tanh->proc~tanhhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables t1 t2 Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: t1 type( hyperdual ), public :: t2","tags":"","loc":"proc/tanhhyperdual.html"},{"title":"EqualHyperDualHyperDual – Yaeos","text":"public elemental subroutine EqualHyperDualHyperDual(res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp Called by proc~~equalhyperdualhyperdual~~CalledByGraph proc~equalhyperdualhyperdual EqualHyperDualHyperDual interface~assignment (=) assignment (=) interface~assignment (=)->proc~equalhyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/equalhyperdualhyperdual.html"},{"title":"EqualHyperDualReal – Yaeos","text":"public elemental subroutine EqualHyperDualReal(res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp Called by proc~~equalhyperdualreal~~CalledByGraph proc~equalhyperdualreal EqualHyperDualReal interface~assignment (=) assignment (=) interface~assignment (=)->proc~equalhyperdualreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/equalhyperdualreal.html"},{"title":"abs – Yaeos","text":"public interface abs Calls interface~~abs~~CallsGraph interface~abs abs proc~abshyperdual absHyperDual interface~abs->proc~abshyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures absHyperDual Module Procedures public elemental function absHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/abs.html"},{"title":"acos – Yaeos","text":"public interface acos Calls interface~~acos~~CallsGraph interface~acos acos proc~acoshyperdual acosHyperDual interface~acos->proc~acoshyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures acosHyperDual Module Procedures public elemental function acosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/acos.html"},{"title":"asin – Yaeos","text":"public interface asin Calls interface~~asin~~CallsGraph interface~asin asin proc~asinhyperdual asinHyperDual interface~asin->proc~asinhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures asinHyperDual Module Procedures public elemental function asinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/asin.html"},{"title":"assignment (=) – Yaeos","text":"public interface assignment (=) Calls interface~~assignment (=)~~CallsGraph interface~assignment (=) assignment (=) proc~equalhyperdualhyperdual EqualHyperDualHyperDual interface~assignment (=)->proc~equalhyperdualhyperdual proc~equalhyperdualreal EqualHyperDualReal interface~assignment (=)->proc~equalhyperdualreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures EqualHyperDualHyperDual EqualHyperDualReal Module Procedures public elemental subroutine EqualHyperDualHyperDual (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp public elemental subroutine EqualHyperDualReal (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp","tags":"","loc":"interface/assignment (=).html"},{"title":"atan – Yaeos","text":"public interface atan Calls interface~~atan~~CallsGraph interface~atan atan proc~atanhyperdual atanHyperDual interface~atan->proc~atanhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures atanHyperDual Module Procedures public elemental function atanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/atan.html"},{"title":"atan2 – Yaeos","text":"public interface atan2 Calls interface~~atan2~~CallsGraph interface~atan2 atan2 proc~atan2hyperdual atan2HyperDual interface~atan2->proc~atan2hyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures atan2HyperDual Module Procedures public elemental function atan2HyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/atan2.html"},{"title":"cos – Yaeos","text":"public interface cos Calls interface~~cos~~CallsGraph interface~cos cos proc~coshyperdual cosHyperDual interface~cos->proc~coshyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures cosHyperDual Module Procedures public elemental function cosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/cos.html"},{"title":"cosh – Yaeos","text":"public interface cosh Calls interface~~cosh~~CallsGraph interface~cosh cosh proc~coshhyperdual coshHyperDual interface~cosh->proc~coshhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures coshHyperDual Module Procedures public elemental function coshHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/cosh.html"},{"title":"exp – Yaeos","text":"public interface exp Calls interface~~exp~~CallsGraph interface~exp exp proc~exphyperdual expHyperDual interface~exp->proc~exphyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures expHyperDual Module Procedures public elemental function expHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/exp.html"},{"title":"int – Yaeos","text":"public interface int Calls interface~~int~~CallsGraph interface~int int proc~inthyperdual intHyperDual interface~int->proc~inthyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures intHyperDual Module Procedures public elemental function intHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer","tags":"","loc":"interface/int.html"},{"title":"log – Yaeos","text":"public interface log Calls interface~~log~~CallsGraph interface~log log proc~loghyperdual logHyperDual interface~log->proc~loghyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures logHyperDual Module Procedures public elemental function logHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/log.html"},{"title":"log10 – Yaeos","text":"public interface log10 Calls interface~~log10~~CallsGraph interface~log10 log10 proc~log10hyperdual log10HyperDual interface~log10->proc~log10hyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures log10HyperDual Module Procedures public elemental function log10HyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/log10.html"},{"title":"max – Yaeos","text":"public interface max Calls interface~~max~~CallsGraph interface~max max proc~max_dd max_dd interface~max->proc~max_dd proc~max_dr max_dr interface~max->proc~max_dr proc~max_rd max_rd interface~max->proc~max_rd proc~max_ddd max_ddd interface~max->proc~max_ddd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures max_dd max_ddd max_dr max_rd Module Procedures public elemental function max_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_ddd (v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual ) public elemental function max_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/max.html"},{"title":"min – Yaeos","text":"public interface min Calls interface~~min~~CallsGraph interface~min min proc~min_dd min_dd interface~min->proc~min_dd proc~min_dr min_dr interface~min->proc~min_dr proc~min_rd min_rd interface~min->proc~min_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures min_dd min_dr min_rd Module Procedures public elemental function min_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/min.html"},{"title":"nint – Yaeos","text":"public interface nint Calls interface~~nint~~CallsGraph interface~nint nint proc~ninthyperdual nintHyperDual interface~nint->proc~ninthyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures nintHyperDual Module Procedures public elemental function nintHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer","tags":"","loc":"interface/nint.html"},{"title":"operator (*) – Yaeos","text":"public interface operator (*) Calls interface~~operator (ASTERISK)~~CallsGraph interface~operator (ASTERISK) operator (*) proc~multiplyhyperdualhyperdual MultiplyHyperDualHyperDual interface~operator (ASTERISK)->proc~multiplyhyperdualhyperdual proc~multiplyrealhyperdual MultiplyRealHyperDual interface~operator (ASTERISK)->proc~multiplyrealhyperdual proc~multiplyhyperdualreal MultiplyHyperDualReal interface~operator (ASTERISK)->proc~multiplyhyperdualreal proc~multiplyhyperdualint MultiplyHyperDualInt interface~operator (ASTERISK)->proc~multiplyhyperdualint proc~multiplyinthyperdual MultiplyIntHyperDual interface~operator (ASTERISK)->proc~multiplyinthyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures MultiplyHyperDualHyperDual MultiplyHyperDualReal MultiplyRealHyperDual MultiplyHyperDualInt MultiplyIntHyperDual Module Procedures public elemental function MultiplyHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyIntHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/operator (ASTERISK).html"},{"title":"operator (**) – Yaeos","text":"public interface operator (**) Calls interface~~operator (ASTERISKASTERISK)~~CallsGraph interface~operator (ASTERISKASTERISK) operator (**) proc~powerhyperdualint PowerHyperDualInt interface~operator (ASTERISKASTERISK)->proc~powerhyperdualint proc~powerhyperdualreal PowerHyperDualReal interface~operator (ASTERISKASTERISK)->proc~powerhyperdualreal proc~powerhyperdualhyperdual PowerHyperDualHyperDual interface~operator (ASTERISKASTERISK)->proc~powerhyperdualhyperdual proc~loghyperdual logHyperDual proc~powerhyperdualhyperdual->proc~loghyperdual proc~exphyperdual expHyperDual proc~powerhyperdualhyperdual->proc~exphyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures PowerHyperDualInt PowerHyperDualHyperDual PowerHyperDualReal Module Procedures public elemental function PowerHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/operator (ASTERISKASTERISK).html"},{"title":"operator (+) – Yaeos","text":"public interface operator (+) Calls interface~~operator (+)~~CallsGraph interface~operator (+) operator (+) proc~plushyperdualhyperdual PlusHyperDualHyperDual interface~operator (+)->proc~plushyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures PlusHyperDualHyperDual Module Procedures public elemental function PlusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/operator (+).html"},{"title":"operator (+) – Yaeos","text":"public interface operator (+) Calls interface~~operator (+)~2~~CallsGraph interface~operator (+)~2 operator (+) proc~addhyperdualhyperdual AddHyperDualHyperDual interface~operator (+)~2->proc~addhyperdualhyperdual proc~addhyperdualreal AddHyperDualReal interface~operator (+)~2->proc~addhyperdualreal proc~addrealhyperdual AddRealHyperDual interface~operator (+)~2->proc~addrealhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures AddHyperDualHyperDual AddHyperDualReal AddRealHyperDual Module Procedures public elemental function AddHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/operator (+)~2.html"},{"title":"operator (-) – Yaeos","text":"public interface operator (-) Calls interface~~operator (-)~~CallsGraph interface~operator (-) operator (-) proc~minushyperdualhyperdual MinusHyperDualHyperDual interface~operator (-)->proc~minushyperdualhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures MinusHyperDualHyperDual Module Procedures public elemental function MinusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/operator (-).html"},{"title":"operator (-) – Yaeos","text":"public interface operator (-) Calls interface~~operator (-)~2~~CallsGraph interface~operator (-)~2 operator (-) proc~subtracthyperdualhyperdual SubtractHyperDualHyperDual interface~operator (-)~2->proc~subtracthyperdualhyperdual proc~subtracthyperdualreal SubtractHyperDualReal interface~operator (-)~2->proc~subtracthyperdualreal proc~subtractrealhyperdual SubtractRealHyperDual interface~operator (-)~2->proc~subtractrealhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures SubtractHyperDualHyperDual SubtractHyperDualReal SubtractRealHyperDual Module Procedures public elemental function SubtractHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/operator (-)~2.html"},{"title":"operator (.eq.) – Yaeos","text":"public interface operator (.eq.) Calls interface~~operator (.eq.)~~CallsGraph interface~operator (.eq.) operator (.eq.) proc~eq_id eq_id interface~operator (.eq.)->proc~eq_id proc~eq_di eq_di interface~operator (.eq.)->proc~eq_di proc~eq_rd eq_rd interface~operator (.eq.)->proc~eq_rd proc~eq_dd eq_dd interface~operator (.eq.)->proc~eq_dd proc~eq_dr eq_dr interface~operator (.eq.)->proc~eq_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures eq_dd eq_dr eq_rd eq_di eq_id Module Procedures public function eq_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function eq_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public elemental function eq_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function eq_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function eq_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.eq.).html"},{"title":"operator (.ge.) – Yaeos","text":"public interface operator (.ge.) Calls interface~~operator (.ge.)~~CallsGraph interface~operator (.ge.) operator (.ge.) proc~ge_dd ge_dd interface~operator (.ge.)->proc~ge_dd proc~ge_rd ge_rd interface~operator (.ge.)->proc~ge_rd proc~ge_dr ge_dr interface~operator (.ge.)->proc~ge_dr proc~ge_id ge_id interface~operator (.ge.)->proc~ge_id proc~ge_di ge_di interface~operator (.ge.)->proc~ge_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures ge_dd ge_dr ge_rd ge_di ge_id Module Procedures public function ge_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ge_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function ge_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ge_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function ge_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.ge.).html"},{"title":"operator (.gt.) – Yaeos","text":"public interface operator (.gt.) Calls interface~~operator (.gt.)~~CallsGraph interface~operator (.gt.) operator (.gt.) proc~gt_id gt_id interface~operator (.gt.)->proc~gt_id proc~gt_di gt_di interface~operator (.gt.)->proc~gt_di proc~gt_rd gt_rd interface~operator (.gt.)->proc~gt_rd proc~gt_dd gt_dd interface~operator (.gt.)->proc~gt_dd proc~gt_dr gt_dr interface~operator (.gt.)->proc~gt_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures gt_dd gt_dr gt_rd gt_di gt_id Module Procedures public function gt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function gt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function gt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function gt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function gt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.gt.).html"},{"title":"operator (.le.) – Yaeos","text":"public interface operator (.le.) Calls interface~~operator (.le.)~~CallsGraph interface~operator (.le.) operator (.le.) proc~le_id le_id interface~operator (.le.)->proc~le_id proc~le_di le_di interface~operator (.le.)->proc~le_di proc~le_rd le_rd interface~operator (.le.)->proc~le_rd proc~le_dd le_dd interface~operator (.le.)->proc~le_dd proc~le_dr le_dr interface~operator (.le.)->proc~le_dr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures le_dd le_dr le_rd le_di le_id Module Procedures public function le_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function le_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function le_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function le_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function le_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.le.).html"},{"title":"operator (.lt.) – Yaeos","text":"public interface operator (.lt.) Calls interface~~operator (.lt.)~~CallsGraph interface~operator (.lt.) operator (.lt.) proc~lt_id lt_id interface~operator (.lt.)->proc~lt_id proc~lt_di lt_di interface~operator (.lt.)->proc~lt_di proc~lt_dr lt_dr interface~operator (.lt.)->proc~lt_dr proc~lt_rd lt_rd interface~operator (.lt.)->proc~lt_rd proc~lt_dd lt_dd interface~operator (.lt.)->proc~lt_dd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures lt_dd lt_dr lt_rd lt_di lt_id Module Procedures public function lt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function lt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function lt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function lt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function lt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.lt.).html"},{"title":"operator (.ne.) – Yaeos","text":"public interface operator (.ne.) Calls interface~~operator (.ne.)~~CallsGraph interface~operator (.ne.) operator (.ne.) proc~ne_di ne_di interface~operator (.ne.)->proc~ne_di proc~ne_id ne_id interface~operator (.ne.)->proc~ne_id proc~ne_dd ne_dd interface~operator (.ne.)->proc~ne_dd proc~ne_dr ne_dr interface~operator (.ne.)->proc~ne_dr proc~ne_rd ne_rd interface~operator (.ne.)->proc~ne_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures ne_dd ne_dr ne_rd ne_di ne_id Module Procedures public function ne_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ne_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function ne_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ne_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function ne_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.ne.).html"},{"title":"operator (/) – Yaeos","text":"public interface operator (/) Calls interface~~operator (SLASH)~~CallsGraph interface~operator (SLASH) operator (/) proc~dividehyperdualhyperdual DivideHyperDualHyperDual interface~operator (SLASH)->proc~dividehyperdualhyperdual proc~dividerealhyperdual DivideRealHyperDual interface~operator (SLASH)->proc~dividerealhyperdual proc~dividehyperdualreal DivideHyperDualReal interface~operator (SLASH)->proc~dividehyperdualreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures DivideHyperDualHyperDual DivideHyperDualReal DivideRealHyperDual Module Procedures public elemental function DivideHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/operator (SLASH).html"},{"title":"real – Yaeos","text":"public interface real Calls interface~~real~~CallsGraph interface~real real proc~realhyperdual realHyperDual interface~real->proc~realhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures realHyperDual Module Procedures public elemental function realHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr)","tags":"","loc":"interface/real.html"},{"title":"sign – Yaeos","text":"public interface sign Calls interface~~sign~~CallsGraph interface~sign sign proc~sign_dd sign_dd interface~sign->proc~sign_dd proc~sign_dr sign_dr interface~sign->proc~sign_dr proc~sign_rd sign_rd interface~sign->proc~sign_rd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sign_dd sign_dr sign_rd Module Procedures public elemental function sign_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/sign.html"},{"title":"sin – Yaeos","text":"public interface sin Calls interface~~sin~~CallsGraph interface~sin sin proc~sinhyperdual sinHyperDual interface~sin->proc~sinhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sinHyperDual Module Procedures public elemental function sinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/sin.html"},{"title":"sinh – Yaeos","text":"public interface sinh Calls interface~~sinh~~CallsGraph interface~sinh sinh proc~sinhhyperdual sinhHyperDual interface~sinh->proc~sinhhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sinhHyperDual Module Procedures public elemental function sinhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/sinh.html"},{"title":"sqrt – Yaeos","text":"public interface sqrt Calls interface~~sqrt~~CallsGraph interface~sqrt sqrt proc~sqrthyperdual sqrtHyperDual interface~sqrt->proc~sqrthyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sqrtHyperDual Module Procedures public elemental function sqrtHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/sqrt.html"},{"title":"sum – Yaeos","text":"public interface sum Calls interface~~sum~~CallsGraph interface~sum sum proc~sumhyperdual SumHyperDual interface~sum->proc~sumhyperdual proc~sumhyperdual2 SumHyperDual2 interface~sum->proc~sumhyperdual2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures SumHyperDual SumHyperDual2 Module Procedures public pure function SumHyperDual (v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) public pure function SumHyperDual2 (v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ),allocatable, (:)","tags":"","loc":"interface/sum.html"},{"title":"tan – Yaeos","text":"public interface tan Calls interface~~tan~~CallsGraph interface~tan tan proc~tanhyperdual tanHyperDual interface~tan->proc~tanhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures tanHyperDual Module Procedures public elemental function tanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/tan.html"},{"title":"tanh – Yaeos","text":"public interface tanh Calls interface~~tanh~~CallsGraph interface~tanh tanh proc~tanhhyperdual tanhHyperDual interface~tanh->proc~tanhhyperdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures tanhHyperDual Module Procedures public elemental function tanhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/tanh.html"},{"title":"residual_helmholtz – Yaeos","text":"private subroutine residual_helmholtz(n, v, t, ar, dardn, dardv, dardt, dardn2, darnv, dardnt, dardvt, dardv2, dardt2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: ar real(kind=pr), intent(out), optional :: dardn (size(n)) real(kind=pr), intent(out), optional :: dardv real(kind=pr), intent(out), optional :: dardt real(kind=pr), intent(out), optional :: dardn2 (size(n),size(n)) real(kind=pr), intent(out), optional :: darnv (size(n)) real(kind=pr), intent(out), optional :: dardnt (size(n)) real(kind=pr), intent(out), optional :: dardvt real(kind=pr), intent(out), optional :: dardv2 real(kind=pr), intent(out), optional :: dardt2 Contents None","tags":"","loc":"proc/residual_helmholtz.html"},{"title":"residual_helmholtz – Yaeos","text":"public subroutine residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional dimension(size(n)) :: Arn real(kind=pr), intent(out), optional dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Calls proc~~residual_helmholtz~2~~CallsGraph proc~residual_helmholtz~2 residual_helmholtz none~get_dardv2 get_dardv2 proc~residual_helmholtz~2->none~get_dardv2 none~get_dardv get_dardv proc~residual_helmholtz~2->none~get_dardv none~get_dardn get_dardn proc~residual_helmholtz~2->none~get_dardn none~get_dardtn get_dardtn proc~residual_helmholtz~2->none~get_dardtn none~get_dardvn get_dardvn proc~residual_helmholtz~2->none~get_dardvn none~get_dardt2 get_dardt2 proc~residual_helmholtz~2->none~get_dardt2 none~get_dardvt get_dardvt proc~residual_helmholtz~2->none~get_dardvt none~get_dardt get_dardt proc~residual_helmholtz~2->none~get_dardt none~get_dardn2 get_dardn2 proc~residual_helmholtz~2->none~get_dardn2 none~reset_vars reset_vars none~get_dardv2->none~reset_vars none~get_dardv->none~reset_vars none~get_dardn->none~reset_vars arn arn none~get_dardn->arn none~get_dardtn->none~reset_vars none~get_dardtn->arn artn artn none~get_dardtn->artn none~get_dardvn->none~reset_vars none~get_dardvn->arn arvn arvn none~get_dardvn->arvn none~get_dardt2->none~reset_vars none~get_dardvt->none~reset_vars none~get_dardt->none~reset_vars none~get_dardn2->none~reset_vars none~get_dardn2->arn arn2 arn2 none~get_dardn2->arn2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables d_Ar d_n d_t d_v Subroutines get_dardn get_dardn2 get_dardt get_dardt2 get_dardtn get_dardv get_dardv2 get_dardvn get_dardvt reset_vars Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: d_Ar type( hyperdual ), public :: d_n (size(n)) type( hyperdual ), public :: d_t type( hyperdual ), public :: d_v Subroutines subroutine get_dardn() Arguments None subroutine get_dardn2() Arguments None subroutine get_dardt() Arguments None subroutine get_dardt2() Arguments None subroutine get_dardtn() Arguments None subroutine get_dardv() Arguments None subroutine get_dardv2() Arguments None subroutine get_dardvn() Arguments None subroutine get_dardvt() Arguments None subroutine reset_vars() Arguments None","tags":"","loc":"proc/residual_helmholtz~2.html"},{"title":"cubic_v0 – Yaeos","text":"public function cubic_v0(z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr) Calls proc~~cubic_v0~~CallsGraph proc~cubic_v0 cubic_v0 proc~bnder Bnder proc~cubic_v0->proc~bnder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables dbi dbij Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dbi (nc) real(kind=pr), public :: dbij (nc,nc)","tags":"","loc":"proc/cubic_v0.html"},{"title":"ArVnder – Yaeos","text":"public subroutine ArVnder(nc, nder, ntemp, z, V, T, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: nder integer, intent(in) :: ntemp real(kind=pr), intent(in) :: z (nc) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) Called by proc~~arvnder~~CalledByGraph proc~arvnder ArVnder proc~purefug_calc~2 PUREFUG_CALC proc~purefug_calc~2->proc~arvnder proc~vcalc~2 VCALC proc~vcalc~2->proc~arvnder proc~termo TERMO proc~termo->proc~arvnder proc~termo->proc~vcalc~2 proc~ztvtermo zTVTERMO proc~ztvtermo->proc~arvnder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/arvnder.html"},{"title":"Bnder – Yaeos","text":"public subroutine Bnder(nc, rn, Bmix, dBi, dBij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: Bmix real(kind=pr), intent(out) :: dBi (nc) real(kind=pr), intent(out) :: dBij (nc,nc) Called by proc~~bnder~~CalledByGraph proc~bnder Bnder proc~cubic_v0 cubic_v0 proc~cubic_v0->proc~bnder proc~helmrkpr HelmRKPR proc~helmrkpr->proc~bnder proc~helmsrkpr HelmSRKPR proc~helmsrkpr->proc~bnder proc~ar_rkpr ar_rkpr proc~ar_rkpr->proc~helmrkpr proc~ar_srkpr ar_srkpr proc~ar_srkpr->proc~helmsrkpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables aux i j totn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aux (nc) integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","loc":"proc/bnder.html"},{"title":"DELTAnder – Yaeos","text":"public subroutine DELTAnder(nc, rn, D1m, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D1m real(kind=pr), intent(out) :: dD1i (nc) real(kind=pr), intent(out) :: dD1ij (nc,nc) Called by proc~~deltander~~CalledByGraph proc~deltander DELTAnder proc~helmrkpr HelmRKPR proc~helmrkpr->proc~deltander proc~ar_rkpr ar_rkpr proc~ar_rkpr->proc~helmrkpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j totn Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","loc":"proc/deltander.html"},{"title":"DandTnder – Yaeos","text":"public subroutine DandTnder(ntd, nc, T, rn, D, dDi, dDiT, dDij, dDdT, dDdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDi (nc) real(kind=pr), intent(out) :: dDiT (nc) real(kind=pr), intent(out) :: dDij (nc,nc) real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 Calls proc~~dandtnder~~CallsGraph proc~dandtnder DandTnder proc~aijtder aijTder proc~dandtnder->proc~aijtder proc~atder aTder proc~aijtder->proc~atder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dandtnder~~CalledByGraph proc~dandtnder DandTnder proc~helmrkpr HelmRKPR proc~helmrkpr->proc~dandtnder proc~helmsrkpr HelmSRKPR proc~helmsrkpr->proc~dandtnder proc~ar_rkpr ar_rkpr proc~ar_rkpr->proc~helmrkpr proc~ar_srkpr ar_srkpr proc~ar_srkpr->proc~helmsrkpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables aij aux aux2 daijdT daijdT2 i j Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aij (nc,nc) real(kind=pr), public :: aux real(kind=pr), public :: aux2 real(kind=pr), public :: daijdT (nc,nc) real(kind=pr), public :: daijdT2 (nc,nc) integer, public :: i integer, public :: j","tags":"","loc":"proc/dandtnder.html"},{"title":"HelmRKPR – Yaeos","text":"public subroutine HelmRKPR(nco, NDE, NTD, rn, V, T, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nco integer, intent(in) :: NDE integer, intent(in) :: NTD real(kind=pr), intent(in) :: rn (nco) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out) :: Arn (nco) real(kind=pr), intent(out) :: ArVn (nco) real(kind=pr), intent(out) :: ArTn (nco) real(kind=pr), intent(out) :: Arn2 (nco,nco) Calls proc~~helmrkpr~~CallsGraph proc~helmrkpr HelmRKPR proc~deltander DELTAnder proc~helmrkpr->proc~deltander proc~dandtnder DandTnder proc~helmrkpr->proc~dandtnder proc~bnder Bnder proc~helmrkpr->proc~bnder proc~aijtder aijTder proc~dandtnder->proc~aijtder proc~atder aTder proc~aijtder->proc~atder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helmrkpr~~CalledByGraph proc~helmrkpr HelmRKPR proc~ar_rkpr ar_rkpr proc~ar_rkpr->proc~helmrkpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables AUX ArT ArTT Bmix D D1 D2 FFB FFBB FFBV auxD2 dBi dBij dD1i dD1ij dDdT dDdT2 dDi dDiT dDij f fB fBD1 fD1 fD1D1 fVD1 fv fv2 g gv gv2 i j totn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AUX real(kind=pr), public :: ArT real(kind=pr), public :: ArTT real(kind=pr), public :: Bmix real(kind=pr), public :: D real(kind=pr), public :: D1 real(kind=pr), public :: D2 real(kind=pr), public :: FFB real(kind=pr), public :: FFBB real(kind=pr), public :: FFBV real(kind=pr), public :: auxD2 real(kind=pr), public :: dBi (nco) real(kind=pr), public :: dBij (nco,nco) real(kind=pr), public :: dD1i (nco) real(kind=pr), public :: dD1ij (nco,nco) real(kind=pr), public :: dDdT real(kind=pr), public :: dDdT2 real(kind=pr), public :: dDi (nco) real(kind=pr), public :: dDiT (nco) real(kind=pr), public :: dDij (nco,nco) real(kind=pr), public :: f real(kind=pr), public :: fB real(kind=pr), public :: fBD1 real(kind=pr), public :: fD1 real(kind=pr), public :: fD1D1 real(kind=pr), public :: fVD1 real(kind=pr), public :: fv real(kind=pr), public :: fv2 real(kind=pr), public :: g real(kind=pr), public :: gv real(kind=pr), public :: gv2 integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","loc":"proc/helmrkpr.html"},{"title":"HelmSRKPR – Yaeos","text":"public subroutine HelmSRKPR(nc, nd, nt, rn, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: nd integer, intent(in) :: nt real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out) :: Arn (nc) real(kind=pr), intent(out) :: ArVn (nc) real(kind=pr), intent(out) :: ArTn (nc) real(kind=pr), intent(out) :: Arn2 (nc,nc) Calls proc~~helmsrkpr~~CallsGraph proc~helmsrkpr HelmSRKPR proc~bnder Bnder proc~helmsrkpr->proc~bnder proc~dandtnder DandTnder proc~helmsrkpr->proc~dandtnder proc~aijtder aijTder proc~dandtnder->proc~aijtder proc~atder aTder proc~aijtder->proc~atder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helmsrkpr~~CalledByGraph proc~helmsrkpr HelmSRKPR proc~ar_srkpr ar_srkpr proc~ar_srkpr->proc~helmsrkpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables AUX ArT ArTT Bmix D FFB FFBB FFBV a b_v d1 d2 dBi dBij dDdT dDdT2 dDi dDiT dDij f fB fv fv2 g gv gv2 i j totn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AUX real(kind=pr), public :: ArT real(kind=pr), public :: ArTT real(kind=pr), public :: Bmix real(kind=pr), public :: D real(kind=pr), public :: FFB real(kind=pr), public :: FFBB real(kind=pr), public :: FFBV real(kind=pr), public :: a real(kind=pr), public :: b_v real(kind=pr), public :: d1 real(kind=pr), public :: d2 real(kind=pr), public :: dBi (nc) real(kind=pr), public :: dBij (nc,nc) real(kind=pr), public :: dDdT real(kind=pr), public :: dDdT2 real(kind=pr), public :: dDi (nc) real(kind=pr), public :: dDiT (nc) real(kind=pr), public :: dDij (nc,nc) real(kind=pr), public :: f real(kind=pr), public :: fB real(kind=pr), public :: fv real(kind=pr), public :: fv2 real(kind=pr), public :: g real(kind=pr), public :: gv real(kind=pr), public :: gv2 integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","loc":"proc/helmsrkpr.html"},{"title":"PR76_factory – Yaeos","text":"public subroutine PR76_factory(moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) Calls proc~~pr76_factory~~CallsGraph proc~pr76_factory PR76_factory proc~get_zc_oma_omb get_Zc_OMa_OMb proc~pr76_factory->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables RTc al be critical_spec ga i oma omb params_spec vceos zc Variables Type Visibility Attributes Name Initial real(kind=pr), public :: RTc (nc) real(kind=pr), public :: al real(kind=pr), public :: be logical, public :: critical_spec real(kind=pr), public :: ga (nc) integer, public :: i real(kind=pr), public :: oma (nc) real(kind=pr), public :: omb (nc) logical, public :: params_spec real(kind=pr), public :: vceos (nc) real(kind=pr), public :: zc (nc)","tags":"","loc":"proc/pr76_factory.html"},{"title":"PR78_factory – Yaeos","text":"public subroutine PR78_factory(moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) Calls proc~~pr78_factory~~CallsGraph proc~pr78_factory PR78_factory proc~get_zc_oma_omb get_Zc_OMa_OMb proc~pr78_factory->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables RTc al be critical_spec ga i oma omb params_spec vceos zc Variables Type Visibility Attributes Name Initial real(kind=pr), public :: RTc (nc) real(kind=pr), public :: al real(kind=pr), public :: be logical, public :: critical_spec real(kind=pr), public :: ga (nc) integer, public :: i real(kind=pr), public :: oma (nc) real(kind=pr), public :: omb (nc) logical, public :: params_spec real(kind=pr), public :: vceos (nc) real(kind=pr), public :: zc (nc)","tags":"","loc":"proc/pr78_factory.html"},{"title":"SRK_factory – Yaeos","text":"public subroutine SRK_factory(moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) Calls proc~~srk_factory~~CallsGraph proc~srk_factory SRK_factory proc~get_zc_oma_omb get_Zc_OMa_OMb proc~srk_factory->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables RTc al be critical_spec ga i j oma omb params_spec vceos zc Variables Type Visibility Attributes Name Initial real(kind=pr), public :: RTc (nc) real(kind=pr), public :: al real(kind=pr), public :: be logical, public :: critical_spec real(kind=pr), public :: ga (nc) integer, public :: i integer, public :: j real(kind=pr), public :: oma (nc) real(kind=pr), public :: omb (nc) logical, public :: params_spec real(kind=pr), public :: vceos (nc) real(kind=pr), public :: zc (nc)","tags":"","loc":"proc/srk_factory.html"},{"title":"aTder – Yaeos","text":"public subroutine aTder(ac, Tc, k, T, a, dadT, dadT2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: ac real(kind=pr), intent(in) :: Tc real(kind=pr), intent(in) :: k real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: a real(kind=pr), intent(out) :: dadT real(kind=pr), intent(out) :: dadT2 Called by proc~~atder~~CalledByGraph proc~atder aTder proc~aijtder aijTder proc~aijtder->proc~atder proc~dandtnder DandTnder proc~dandtnder->proc~aijtder proc~helmrkpr HelmRKPR proc~helmrkpr->proc~dandtnder proc~helmsrkpr HelmSRKPR proc~helmsrkpr->proc~dandtnder proc~ar_rkpr ar_rkpr proc~ar_rkpr->proc~helmrkpr proc~ar_srkpr ar_srkpr proc~ar_srkpr->proc~helmsrkpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Tr Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Tr","tags":"","loc":"proc/atder.html"},{"title":"aijTder – Yaeos","text":"public subroutine aijTder(ntd, nc, T, aij, daijdT, daijdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: aij (nc,nc) real(kind=pr), intent(out) :: daijdT (nc,nc) real(kind=pr), intent(out) :: daijdT2 (nc,nc) Calls proc~~aijtder~~CallsGraph proc~aijtder aijTder proc~atder aTder proc~aijtder->proc~atder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aijtder~~CalledByGraph proc~aijtder aijTder proc~dandtnder DandTnder proc~dandtnder->proc~aijtder proc~helmrkpr HelmRKPR proc~helmrkpr->proc~dandtnder proc~helmsrkpr HelmSRKPR proc~helmsrkpr->proc~dandtnder proc~ar_rkpr ar_rkpr proc~ar_rkpr->proc~helmrkpr proc~ar_srkpr ar_srkpr proc~ar_srkpr->proc~helmsrkpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ai aux daidT daidT2 i j ratK Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ai (nc) real(kind=pr), public :: aux (nc,nc) real(kind=pr), public :: daidT (nc) real(kind=pr), public :: daidT2 (nc) integer, public :: i integer, public :: j real(kind=pr), public :: ratK (nc,nc)","tags":"","loc":"proc/aijtder.html"},{"title":"ar_rkpr – Yaeos","text":"public subroutine ar_rkpr(z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out) :: Arn (size(z)) real(kind=pr), intent(out) :: ArVn (size(z)) real(kind=pr), intent(out) :: ArTn (size(z)) real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) Calls proc~~ar_rkpr~~CallsGraph proc~ar_rkpr ar_rkpr proc~helmrkpr HelmRKPR proc~ar_rkpr->proc~helmrkpr proc~deltander DELTAnder proc~helmrkpr->proc~deltander proc~dandtnder DandTnder proc~helmrkpr->proc~dandtnder proc~bnder Bnder proc~helmrkpr->proc~bnder proc~aijtder aijTder proc~dandtnder->proc~aijtder proc~atder aTder proc~aijtder->proc~atder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables nd nt Variables Type Visibility Attributes Name Initial integer, public :: nd integer, public :: nt","tags":"","loc":"proc/ar_rkpr.html"},{"title":"ar_srkpr – Yaeos","text":"public subroutine ar_srkpr(z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out) :: Arn (size(z)) real(kind=pr), intent(out) :: ArVn (size(z)) real(kind=pr), intent(out) :: ArTn (size(z)) real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) Calls proc~~ar_srkpr~~CallsGraph proc~ar_srkpr ar_srkpr proc~helmsrkpr HelmSRKPR proc~ar_srkpr->proc~helmsrkpr proc~bnder Bnder proc~helmsrkpr->proc~bnder proc~dandtnder DandTnder proc~helmsrkpr->proc~dandtnder proc~aijtder aijTder proc~dandtnder->proc~aijtder proc~atder aTder proc~aijtder->proc~atder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables nd nt Variables Type Visibility Attributes Name Initial integer, public :: nd integer, public :: nt","tags":"","loc":"proc/ar_srkpr.html"},{"title":"get_Zc_OMa_OMb – Yaeos","text":"public subroutine get_Zc_OMa_OMb(del1, Zc, OMa, OMb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: del1 (:) real(kind=pr), intent(out) :: Zc (:) real(kind=pr), intent(out) :: OMa (:) real(kind=pr), intent(out) :: OMb (:) Called by proc~~get_zc_oma_omb~~CalledByGraph proc~get_zc_oma_omb get_Zc_OMa_OMb proc~pr76_factory PR76_factory proc~pr76_factory->proc~get_zc_oma_omb proc~pr78_factory PR78_factory proc~pr78_factory->proc~get_zc_oma_omb proc~srk_factory SRK_factory proc~srk_factory->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables d1 y Variables Type Visibility Attributes Name Initial real(kind=pr), public :: d1 (size(del1)) real(kind=pr), public :: y (size(del1))","tags":"","loc":"proc/get_zc_oma_omb.html"},{"title":"setup – Yaeos","text":"public subroutine setup(n, nmodel, ntdep, ncomb) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: nmodel integer, intent(in) :: ntdep integer, intent(in) :: ncomb Contents None","tags":"","loc":"proc/setup.html"},{"title":"PUREFUG_CALC – Yaeos","text":"public subroutine PUREFUG_CALC(nc, icomp, T, P, V, phi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: icomp real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: V real(kind=pr), intent(out) :: phi Calls proc~~purefug_calc~2~~CallsGraph proc~purefug_calc~2 PUREFUG_CALC proc~arvnder ArVnder proc~purefug_calc~2->proc~arvnder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Ar ArTV ArTn ArV2 ArVn Arn Arn2 Arv RT Z philog rn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ar real(kind=pr), public :: ArTV real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArV2 real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: Arv real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: philog real(kind=pr), public :: rn (nc)","tags":"","loc":"proc/purefug_calc~2.html"},{"title":"TERMO – Yaeos","text":"public subroutine TERMO(nc, mtyp, indic, t, p, rn, v, PHILOG, DLPHIP, DLPHIT, FUGN) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: mtyp integer, intent(in) :: indic real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: v real(kind=pr), intent(out) :: PHILOG (nc) real(kind=pr), intent(out), optional :: DLPHIP (nc) real(kind=pr), intent(out), optional :: DLPHIT (nc) real(kind=pr), intent(out), optional :: FUGN (nc,nc) Calls proc~~termo~~CallsGraph proc~termo TERMO proc~vcalc~2 VCALC proc~termo->proc~vcalc~2 proc~arvnder ArVnder proc~termo->proc~arvnder proc~vcalc~2->proc~arvnder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ArTn ArVn Arn Arn2 DPDN RT Z ar artv arv arv2 dpdt dpv i igz k nder ntemp totn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: DPDN (nc) real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: ar real(kind=pr), public :: artv real(kind=pr), public :: arv real(kind=pr), public :: arv2 real(kind=pr), public :: dpdt real(kind=pr), public :: dpv integer, public :: i integer, public :: igz integer, public :: k integer, public :: nder integer, public :: ntemp real(kind=pr), public :: totn","tags":"","loc":"proc/termo.html"},{"title":"VCALC – Yaeos","text":"public recursive subroutine VCALC(ITYP, nc, ntemp, rn, T, P, V) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP integer, intent(in) :: nc integer, intent(in) :: ntemp real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(out) :: V Calls proc~~vcalc~2~~CallsGraph proc~vcalc~2 VCALC proc~arvnder ArVnder proc~vcalc~2->proc~arvnder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~vcalc~2~~CalledByGraph proc~vcalc~2 VCALC proc~termo TERMO proc~termo->proc~vcalc~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables AT AVAP Ar ArTV ArTn ArV ArV2 ArVn Arn Arn2 B CPV FIRST_RUN S3R VVAP ZETA ZETMAX ZETMIN del der iter nder pcalc totn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AT real(kind=pr), public :: AVAP real(kind=pr), public :: Ar real(kind=pr), public :: ArTV real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArV real(kind=pr), public :: ArV2 real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: B real(kind=pr), public :: CPV logical, public :: FIRST_RUN real(kind=pr), public :: S3R real(kind=pr), public :: VVAP real(kind=pr), public :: ZETA real(kind=pr), public :: ZETMAX real(kind=pr), public :: ZETMIN real(kind=pr), public :: del real(kind=pr), public :: der integer, public :: iter integer, public :: nder real(kind=pr), public :: pcalc real(kind=pr), public :: totn","tags":"","loc":"proc/vcalc~2.html"},{"title":"zTVTERMO – Yaeos","text":"public subroutine zTVTERMO(nc, indic, t, rn, v, p, dpv, PHILOG, DLPHIP, DLPHIT, FUGN) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: indic real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: v real(kind=pr), intent(out) :: p real(kind=pr), intent(out) :: dpv real(kind=pr), intent(out) :: PHILOG (nc) real(kind=pr), intent(out) :: DLPHIP (nc) real(kind=pr), intent(out) :: DLPHIT (nc) real(kind=pr), intent(out) :: FUGN (nc,nc) Calls proc~~ztvtermo~~CallsGraph proc~ztvtermo zTVTERMO proc~arvnder ArVnder proc~ztvtermo->proc~arvnder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ArTn ArVn Arn Arn2 DPDN RT Z ar artv arv arv2 dpdt i igz k nder ntemp totn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: DPDN (nc) real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: ar real(kind=pr), public :: artv real(kind=pr), public :: arv real(kind=pr), public :: arv2 real(kind=pr), public :: dpdt integer, public :: i integer, public :: igz integer, public :: k integer, public :: nder integer, public :: ntemp real(kind=pr), public :: totn","tags":"","loc":"proc/ztvtermo.html"},{"title":"ADMM_REBASE – Yaeos","text":"public interface ADMM_REBASE Contents Subroutines ADMM_REBASE Subroutines public subroutine ADMM_REBASE(base) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: base","tags":"","loc":"interface/admm_rebase.html"},{"title":"ADMM_REBASESHADOWED – Yaeos","text":"public interface ADMM_REBASESHADOWED Contents Subroutines ADMM_REBASESHADOWED Subroutines public subroutine ADMM_REBASESHADOWED(base, baseb) bind(c, name=     \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: base type(C_PTR) :: baseb","tags":"","loc":"interface/admm_rebaseshadowed.html"},{"title":"ADMM_REGISTER – Yaeos","text":"public interface ADMM_REGISTER Contents Subroutines ADMM_REGISTER Subroutines public subroutine ADMM_REGISTER(base, obase, size, nbelem) bind(c, name=     \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size integer, VALUE :: nbelem","tags":"","loc":"interface/admm_register.html"},{"title":"ADMM_REGISTERSHADOWED – Yaeos","text":"public interface ADMM_REGISTERSHADOWED Contents Subroutines ADMM_REGISTERSHADOWED Subroutines public subroutine ADMM_REGISTERSHADOWED(base, obase, size, baseb, obaseb, sizeb, nbelem) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size type(C_PTR), VALUE :: baseb type(C_PTR), VALUE :: obaseb integer, VALUE :: sizeb integer, VALUE :: nbelem","tags":"","loc":"interface/admm_registershadowed.html"},{"title":"ADMM_UNREGISTER – Yaeos","text":"public interface ADMM_UNREGISTER Contents Subroutines ADMM_UNREGISTER Subroutines public subroutine ADMM_UNREGISTER(base, nbelem) bind(c, name=     \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base integer :: nbelem","tags":"","loc":"interface/admm_unregister.html"},{"title":"ADMM_UNREGISTERSHADOWED – Yaeos","text":"public interface ADMM_UNREGISTERSHADOWED Contents Subroutines ADMM_UNREGISTERSHADOWED Subroutines public subroutine ADMM_UNREGISTERSHADOWED(base, baseb, nbelem) bind(c,      name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: baseb integer :: nbelem","tags":"","loc":"interface/admm_unregistershadowed.html"},{"title":"POPPOINTER8 – Yaeos","text":"public interface POPPOINTER8 Contents Subroutines POPPOINTER8 Subroutines public subroutine POPPOINTER8(pp) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: pp","tags":"","loc":"interface/poppointer8.html"},{"title":"PUSHPOINTER8 – Yaeos","text":"public interface PUSHPOINTER8 Contents Subroutines PUSHPOINTER8 Subroutines public subroutine PUSHPOINTER8(pp) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: pp","tags":"","loc":"interface/pushpointer8.html"},{"title":"v0 – Yaeos","text":"public function v0(self, n, p, t) Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) Contents Variables dbi dbij Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dbi (size(n)) real(kind=pr), public :: dbij (size(n),size(n))","tags":"","loc":"proc/v0.html"},{"title":"GenericCubic_Ar – Yaeos","text":"public subroutine GenericCubic_Ar(self, n, v, t, ar, arv, ArT, artv, arv2, ArT2, Arn, ArVn, ArTn, Arn2) Uses yaeos_constants proc~~genericcubic_ar~~UsesGraph proc~genericcubic_ar GenericCubic_Ar module~yaeos_constants yaeos_constants proc~genericcubic_ar->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: ar real(kind=pr), intent(out), optional :: arv real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: artv real(kind=pr), intent(out), optional :: arv2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Contents Variables AUX Bmix D FFB FFBB FFBV Tr a d1 d2 dBi dBij dDdT dDdT2 dDi dDidT dDij dadt dadt2 f fB fv fv2 g gv gv2 i j nc totn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AUX real(kind=pr), public :: Bmix real(kind=pr), public :: D real(kind=pr), public :: FFB real(kind=pr), public :: FFBB real(kind=pr), public :: FFBV real(kind=pr), public :: Tr (size(n)) real(kind=pr), public :: a (size(n)) real(kind=pr), public :: d1 real(kind=pr), public :: d2 real(kind=pr), public :: dBi (size(n)) real(kind=pr), public :: dBij (size(n),size(n)) real(kind=pr), public :: dDdT real(kind=pr), public :: dDdT2 real(kind=pr), public :: dDi (size(n)) real(kind=pr), public :: dDidT (size(n)) real(kind=pr), public :: dDij (size(n),size(n)) real(kind=pr), public :: dadt (size(n)) real(kind=pr), public :: dadt2 (size(n)) real(kind=pr), public :: f real(kind=pr), public :: fB real(kind=pr), public :: fv real(kind=pr), public :: fv2 real(kind=pr), public :: g real(kind=pr), public :: gv real(kind=pr), public :: gv2 integer, public :: i integer, public :: j integer, public :: nc real(kind=pr), public :: totn","tags":"","loc":"proc/genericcubic_ar.html"},{"title":"PengRobinson76 – Yaeos","text":"public function PengRobinson76(tc, pc, w, kij, lij) result(model) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) real(kind=pr), intent(in) :: pc (:) real(kind=pr), intent(in) :: w (:) real(kind=pr), intent(in), optional :: kij (:,:) real(kind=pr), intent(in), optional :: lij (:,:) Return Value type( CubicEoS ) Contents Variables alpha composition i mixrule nc Variables Type Visibility Attributes Name Initial type( AlphaSoave ), private :: alpha type( Substances ), private :: composition integer, private :: i type( QMR ), private :: mixrule integer, private :: nc","tags":"","loc":"proc/pengrobinson76.html"},{"title":"SoaveRedlichKwong – Yaeos","text":"public function SoaveRedlichKwong(tc, pc, w, kij, lij) result(model) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) real(kind=pr), intent(in) :: pc (:) real(kind=pr), intent(in) :: w (:) real(kind=pr), intent(in), optional :: kij (:,:) real(kind=pr), intent(in), optional :: lij (:,:) Return Value type( CubicEoS ) Contents Variables alpha composition i mixrule nc Variables Type Visibility Attributes Name Initial type( AlphaSoave ), private :: alpha type( Substances ), private :: composition integer, private :: i type( QMR ), private :: mixrule integer, private :: nc","tags":"","loc":"proc/soaveredlichkwong.html"},{"title":"PengRobinson78 – Yaeos","text":"public function PengRobinson78(tc, pc, w, kij, lij) result(model) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) real(kind=pr), intent(in) :: pc (:) real(kind=pr), intent(in) :: w (:) real(kind=pr), intent(in), optional :: kij (:,:) real(kind=pr), intent(in), optional :: lij (:,:) Return Value type( CubicEoS ) Contents Variables alpha composition i mixrule nc Variables Type Visibility Attributes Name Initial type( AlphaSoave ), private :: alpha type( Substances ), private :: composition integer, private :: i type( QMR ), private :: mixrule integer, private :: nc","tags":"","loc":"proc/pengrobinson78.html"},{"title":"Bmix – Yaeos","text":"public subroutine Bmix(self, n, bi, B, dBi, dBij) Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) Contents Variables aux bij i j nc totn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aux (size(n)) real(kind=pr), public :: bij (size(n),size(n)) integer, public :: i integer, public :: j integer, public :: nc real(kind=pr), public :: totn","tags":"","loc":"proc/bmix.html"},{"title":"Dmix – Yaeos","text":"public subroutine Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) Contents Variables aij aux aux2 daijdt daijdt2 i j nc Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aij (size(ai),size(ai)) real(kind=pr), public :: aux real(kind=pr), public :: aux2 real(kind=pr), public :: daijdt (size(ai),size(ai)) real(kind=pr), public :: daijdt2 (size(ai),size(ai)) integer, public :: i integer, public :: j integer, public :: nc","tags":"","loc":"proc/dmix.html"},{"title":"kij_constant – Yaeos","text":"public subroutine kij_constant(self, a, dadt, dadt2, aij, daijdt, daijdt2) Arguments Type Intent Optional Attributes Name class( QMR ) :: self real(kind=pr), intent(in) :: a (:) real(kind=pr), intent(in) :: dadt (:) real(kind=pr), intent(in) :: dadt2 (:) real(kind=pr), intent(out) :: aij (:,:) real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:) Contents Variables ai2 aij_daidt i inner_sum inner_sum_2 j sqrt_aii_ajj Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ai2 (size(a)) real(kind=pr), public :: aij_daidt integer, public :: i real(kind=pr), public :: inner_sum real(kind=pr), public :: inner_sum_2 integer, public :: j real(kind=pr), public :: sqrt_aii_ajj","tags":"","loc":"proc/kij_constant.html"},{"title":"alpha – Yaeos","text":"public subroutine alpha(self, Tr, a, dadt, dadt2) Arguments Type Intent Optional Attributes Name class( AlphaSoave ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:) Contents None","tags":"","loc":"proc/alpha.html"},{"title":"yaeos_thermoprops – Yaeos","text":"Uses yaeos_models_ar yaeos_constants module~~yaeos_thermoprops~~UsesGraph module~yaeos_thermoprops yaeos_thermoprops module~yaeos_models_ar yaeos_models_ar module~yaeos_thermoprops->module~yaeos_models_ar module~yaeos_constants yaeos_constants module~yaeos_thermoprops->module~yaeos_constants module~yaeos_models_ar->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_thermoprops~~UsedByGraph module~yaeos_thermoprops yaeos_thermoprops module~yaeos yaeos module~yaeos->module~yaeos_thermoprops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines PUREFUG_CALC VCALC fugacity_tp fugacity_vt Subroutines public subroutine PUREFUG_CALC (self, nc, icomp, T, P, V, fug) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self integer, intent(in) :: nc integer, intent(in) :: icomp real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: V real(kind=pr), intent(out) :: fug public recursive subroutine VCALC (self, ITYP, nc, rn, T, P, V, max_iters) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self integer, intent(in) :: ITYP integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(out) :: V integer, intent(in), optional :: max_iters public subroutine fugacity_tp (self, n, t, p, v, root_type, lnfug, dlnphidp, dlnphidt, dlnphidn) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: p real(kind=pr), intent(out), optional :: v integer, intent(in) :: root_type real(kind=pr), intent(out) :: lnfug (size(n)) real(kind=pr), intent(out), optional :: dlnphidp (size(n)) real(kind=pr), intent(out), optional :: dlnphidt (size(n)) real(kind=pr), intent(out), optional :: dlnphidn (size(n),size(n)) public subroutine fugacity_vt (self, n, v, t, p, lnfug, dlnphidp, dlnphidt, dlnphidn) Arguments Type Intent Optional Attributes Name class( ArModel ) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: p real(kind=pr), intent(out), optional :: lnfug (size(n)) real(kind=pr), intent(out), optional :: dlnphidp (size(n)) real(kind=pr), intent(out), optional :: dlnphidt (size(n)) real(kind=pr), intent(out), optional :: dlnphidn (size(n),size(n))","tags":"","loc":"module/yaeos_thermoprops.html"},{"title":"yaeos – Yaeos","text":"Uses yaeos_substance yaeos_thermoprops yaeos_constants yaeos_models module~~yaeos~~UsesGraph module~yaeos yaeos module~yaeos_substance yaeos_substance module~yaeos->module~yaeos_substance module~yaeos_models yaeos_models module~yaeos->module~yaeos_models module~yaeos_thermoprops yaeos_thermoprops module~yaeos->module~yaeos_thermoprops module~yaeos_constants yaeos_constants module~yaeos->module~yaeos_constants module~yaeos_substance->module~yaeos_constants module~yaeos_models_ar_cubic_srk yaeos_models_ar_cubic_srk module~yaeos_models->module~yaeos_models_ar_cubic_srk module~yaeos_models_ar_cubic_pengrobinson78 yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models_ar yaeos_models_ar module~yaeos_models->module~yaeos_models_ar module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson76 yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson76 module~yaeos_thermoprops->module~yaeos_constants module~yaeos_thermoprops->module~yaeos_models_ar iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar_cubic_srk->module~yaeos_substance module~yaeos_models_ar_cubic_srk->module~yaeos_constants module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_substance module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_constants module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_substance module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_constants module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables version Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: version = \"0.1.0b\"","tags":"","loc":"module/yaeos.html"},{"title":"yaeos_constants – Yaeos","text":"Constants used on the whole package Uses iso_fortran_env module~~yaeos_constants~~UsesGraph module~yaeos_constants yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_constants~~UsedByGraph module~yaeos_constants yaeos_constants proc~genericcubic_ar GenericCubic_Ar proc~genericcubic_ar->module~yaeos_constants module~yaeos_substance yaeos_substance module~yaeos_substance->module~yaeos_constants module~yaeos_models_ar_cubic_srk yaeos_models_ar_cubic_srk module~yaeos_models_ar_cubic_srk->module~yaeos_constants module~yaeos_models_ar_cubic_srk->module~yaeos_substance module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_cubic_pengrobinson78 yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_constants module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_substance module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_cubic_alphas module~yaeos_tapenade_ar_api yaeos_tapenade_ar_api module~yaeos_tapenade_ar_api->module~yaeos_constants module~ar_interface ar_interface module~ar_interface->module~yaeos_constants module~legacy_thermo_properties legacy_thermo_properties module~legacy_thermo_properties->module~yaeos_constants module~legacy_ar_models legacy_ar_models module~legacy_thermo_properties->module~legacy_ar_models module~yaeos_thermoprops yaeos_thermoprops module~yaeos_thermoprops->module~yaeos_constants module~yaeos_thermoprops->module~yaeos_models_ar module~yaeos yaeos module~yaeos->module~yaeos_constants module~yaeos->module~yaeos_substance module~yaeos->module~yaeos_thermoprops module~yaeos_models yaeos_models module~yaeos->module~yaeos_models module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson76 yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_constants module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_substance module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_cubic_alphas module~hyperdual_mod hyperdual_mod module~hyperdual_mod->module~yaeos_constants module~yaeos_ar_models_hyperdual yaeos_ar_models_hyperdual module~yaeos_ar_models_hyperdual->module~yaeos_constants module~yaeos_ar_models_hyperdual->module~yaeos_models_ar module~yaeos_autodiff yaeos_autodiff module~yaeos_ar_models_hyperdual->module~yaeos_autodiff module~legacy_ar_models->module~yaeos_constants module~legacy_ar_models->module~ar_interface module~yaeos_models->module~yaeos_models_ar_cubic_srk module~yaeos_models->module~yaeos_models_ar module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson76 module~yaeos_autodiff->module~hyperdual_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables NOT_IMPLEMENTED R database_path path_sep pr Variables Type Visibility Attributes Name Initial real(kind=pr), public, parameter :: NOT_IMPLEMENTED = huge(R) real(kind=pr), public, parameter :: R = 0.08314472_pr Ideal Gas constant character(len=254), public :: database_path = \"database\" Path to find database character(len=1), public :: path_sep = \"/\" File separator (to preprocess on Win or Mac/linux) integer, public, parameter :: pr = real64 Machine Precision","tags":"","loc":"module/yaeos_constants.html"},{"title":"yaeos_autodiff – Yaeos","text":"This module holds the diferent ways of automatic differentiation Uses hyperdual_mod module~~yaeos_autodiff~~UsesGraph module~yaeos_autodiff yaeos_autodiff module~hyperdual_mod hyperdual_mod module~yaeos_autodiff->module~hyperdual_mod module~yaeos_constants yaeos_constants module~hyperdual_mod->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_autodiff~~UsedByGraph module~yaeos_autodiff yaeos_autodiff module~yaeos_ar_models_hyperdual yaeos_ar_models_hyperdual module~yaeos_ar_models_hyperdual->module~yaeos_autodiff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/yaeos_autodiff.html"},{"title":"hyperdual_mod – Yaeos","text":"Hyperdual number definition & type declaration Original code provided by Philipp Rehner and Gernot Bauer,\nInstitute of Thermodynamics and Thermal Process Engineering (ITT),\nUniversity of Stuttgart, Stuttgart, Germany Hypderdual numbers Hypderdual numbers extend the idea of additional, non-real\ncomponents from one non-real component (complex numbers) to four\nnon-real components: \\f$\\varepsilon_1\\f$, \\f$\\varepsilon_2\\f$ and\n\\f$\\varepsilon_1 \\varepsilon_2\\f$.\nHyperdual numbers require: \\f$(\\varepsilon_1)&#94;2 = 0\\f$,\n\\f$(\\varepsilon_2)&#94;2 = 0\\f$ and\n\\f$(\\varepsilon_1\\varepsilon_2)&#94;2 = 0\\f$\nThis leads to the fact, that the Taylor series of a function with\nhyperdual arguments can be truncated exactly after the second\nderivative term: \\f[\n   f(\\mathbf{x} + h_1 \\varepsilon_1 + h_2 \\varepsilon_2\n     + h_1 h_2 \\varepsilon_1 \\varepsilon_2)\n   = f(\\mathbf{x}) + h_1 f’(\\mathbf{x}) \\varepsilon_1\n     + h_2 f’(\\mathbf{x}) \\varepsilon_2\n     + h_1 h_2 f’‘(\\mathbf{x}) \\varepsilon_1 \\varepsilon_2\n\\f] Because there is no truncation error , all first and second order\nderivatives can be obtained exactly , regardless of the step size ‘’\n\\f$h_1\\f$ and \\f$h_2\\f$.\nThe derivatives can be obtained for a function \\f$ f(\\mathbf{x}) \\f$\nwith multiple variables \\f$ \\mathbf{x} \\in \\mathbb{R}&#94;n \\f$ via\n\\f{eqnarray*}{\n  \\frac{\\partial f(\\mathbf{x})}{\\partial x_i} &=& \\frac{\n    \\varepsilon_{1, \\mathrm{part}} \\Big{\n    f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e} i\n    + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big}}\n    {h_1}\\\n  \\frac{\\partial f(\\mathbf{x})}{\\partial x_i} &=& \\frac{\n     \\varepsilon } \\Big{\n     f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e} i\n     + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big}}\n     {h_2}\\\n  \\frac{\\partial&#94;2 f(\\mathbf{x})}{\\partial x_i \\partial x_j} &=&\n    \\frac{(\\varepsilon_1 \\varepsilon_2) \\mathrm{part} \\Big{\n    f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e}_i\n    + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big}}\n    {h_1 h_2}  \\\n\\f}\nwhere \\f$\\mathbf{e}_i\\f$ and \\f$\\mathbf{e}_j\\f$ are unit vectors,\nwhich are all zero except for the \\f$i\\f$-th and \\f$j\\f$-th\ncomponent, respectively. Computation principles for hypderdual numbers Hyperdual numbers \\f$\\mathbf{x} \\in \\mathbb{HD}\\f$ can be expressed\nas tuples: \\f$\\mathbf{x} = [x_0, x_1, x_2, x_{12}] = x_0\n+ x_1 \\varepsilon_1 + x_2 \\varepsilon_2\n+ x_{12} \\varepsilon_1\\varepsilon_2\\f$.\nBy using the Taylor expansion of the function \\f$f(\\mathbf{x})\\f$\none gets computation priniple for functions with hyperdual\narguments from \\f[\n   f(\\mathbf{x}) = f(x_0) + x_1 f’(x_0) \\varepsilon_1\n   + x_2 f’(x_0) \\varepsilon_2 + \\big( x_{12} f’(x_0)\n   + x_1 x_2 f’‘(x_0) \\big) \\varepsilon_1 \\varepsilon_2\n\\f] A hyperdual number derived type is provided by: \\ref hyperdual. References [1] Fike, Alonso: The Development of Hyper-Dual Numbers for Exact\n                     Second-Derivative Calculations. 49th AIAA Aerospace Sciences Meeting including the New\n      Horizons Forum and Aerospace Exposition (2011) \\n [2] Rehner, P. and Bauer, G.: Application of Generalized\n                                 (Hyper-) Dual Numbers in Equation\n                                 of State Modeling. Frontiers in Chemical Engineering_ (2021) \\n Uses yaeos_constants module~~hyperdual_mod~~UsesGraph module~hyperdual_mod hyperdual_mod module~yaeos_constants yaeos_constants module~hyperdual_mod->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~hyperdual_mod~~UsedByGraph module~hyperdual_mod hyperdual_mod module~yaeos_autodiff yaeos_autodiff module~yaeos_autodiff->module~hyperdual_mod module~yaeos_ar_models_hyperdual yaeos_ar_models_hyperdual module~yaeos_ar_models_hyperdual->module~yaeos_autodiff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces abs acos asin assignment (=) atan atan2 cos cosh exp int log log10 max min nint operator (*) operator (**) operator (+) operator (+) operator (-) operator (-) operator (.eq.) operator (.ge.) operator (.gt.) operator (.le.) operator (.lt.) operator (.ne.) operator (/) real sign sin sinh sqrt sum tan tanh Derived Types hyperdual Functions AddHyperDualHyperDual AddHyperDualReal AddRealHyperDual DivideHyperDualHyperDual DivideHyperDualReal DivideRealHyperDual MinusHyperDualHyperDual MultiplyHyperDualHyperDual MultiplyHyperDualInt MultiplyHyperDualReal MultiplyIntHyperDual MultiplyRealHyperDual PlusHyperDualHyperDual PowerHyperDualHyperDual PowerHyperDualInt PowerHyperDualReal SubtractHyperDualHyperDual SubtractHyperDualReal SubtractRealHyperDual SumHyperDual SumHyperDual2 absHyperDual acosHyperDual asinHyperDual atan2HyperDual atanHyperDual cosHyperDual coshHyperDual eq_dd eq_di eq_dr eq_id eq_rd expHyperDual ge_dd ge_di ge_dr ge_id ge_rd gt_dd gt_di gt_dr gt_id gt_rd intHyperDual le_dd le_di le_dr le_id le_rd log10HyperDual logHyperDual lt_dd lt_di lt_dr lt_id lt_rd max_dd max_ddd max_dr max_rd min_dd min_dr min_rd ne_dd ne_di ne_dr ne_id ne_rd nintHyperDual realHyperDual sign_dd sign_dr sign_rd sinHyperDual sinhHyperDual sqrtHyperDual tanHyperDual tanhHyperDual Subroutines EqualHyperDualHyperDual EqualHyperDualReal Interfaces public interface abs public elemental function absHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface acos public elemental function acosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface asin public elemental function asinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface assignment (=) public elemental subroutine EqualHyperDualHyperDual (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp public elemental subroutine EqualHyperDualReal (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp public interface atan public elemental function atanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface atan2 public elemental function atan2HyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public interface cos public elemental function cosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface cosh public elemental function coshHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface exp public elemental function expHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface int public elemental function intHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public interface log public elemental function logHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface log10 public elemental function log10HyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface max public elemental function max_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_ddd (v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual ) public elemental function max_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public interface min public elemental function min_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public interface nint public elemental function nintHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public interface operator (*) public elemental function MultiplyHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyIntHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public interface operator (**) public elemental function PowerHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public interface operator (+) public elemental function PlusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface operator (+) public elemental function AddHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public interface operator (-) public elemental function MinusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface operator (-) public elemental function SubtractHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public interface operator (.eq.) public function eq_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function eq_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public elemental function eq_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function eq_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function eq_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public interface operator (.ge.) public function ge_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ge_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function ge_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ge_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function ge_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public interface operator (.gt.) public function gt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function gt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function gt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function gt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function gt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public interface operator (.le.) public function le_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function le_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function le_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function le_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function le_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public interface operator (.lt.) public function lt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function lt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function lt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function lt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function lt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public interface operator (.ne.) public function ne_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ne_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function ne_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ne_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function ne_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public interface operator (/) public elemental function DivideHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public interface real public elemental function realHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr) public interface sign public elemental function sign_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public interface sin public elemental function sinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface sinh public elemental function sinhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface sqrt public elemental function sqrtHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface sum public pure function SumHyperDual (v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) public pure function SumHyperDual2 (v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ),allocatable, (:) public interface tan public elemental function tanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public interface tanh public elemental function tanhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Derived Types type, public, bind(c) :: hyperdual Derived type for hyperdual numbers Read more… Components Type Visibility Attributes Name Initial real(kind=pr), public :: f0 = 0 real part of the hyperdual number real(kind=pr), public :: f1 = 0 \\f$\\varepsilon_1\\f$-part of  the hyperdual number real(kind=pr), public :: f12 = 0 \\f$\\varepsilon_1\\varepsilon_2\\f$-part of the real(kind=pr), public :: f2 = 0 \\f$\\varepsilon_2\\f$-part of  the hyperdual number Functions public elemental function AddHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MinusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function MultiplyHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyIntHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PlusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function PowerHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public pure function SumHyperDual (v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) public pure function SumHyperDual2 (v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ),allocatable, (:) public elemental function absHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function acosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function asinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function atan2HyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function atanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function cosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function coshHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public function eq_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function eq_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public elemental function eq_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function eq_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function eq_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function expHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public function ge_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ge_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function ge_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function ge_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ge_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function gt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function gt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function gt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function gt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function gt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function intHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public function le_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function le_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function le_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function le_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function le_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function log10HyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function logHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public function lt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function lt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function lt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function lt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function lt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function max_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_ddd (v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual ) public elemental function max_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public function ne_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ne_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public function ne_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public function ne_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public function ne_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function nintHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public elemental function realHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr) public elemental function sign_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function sinhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function sqrtHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function tanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function tanhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Subroutines public elemental subroutine EqualHyperDualHyperDual (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp public elemental subroutine EqualHyperDualReal (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp","tags":"","loc":"module/hyperdual_mod.html"},{"title":"yaeos_tapenade_ar_api – Yaeos","text":"Uses yaeos_constants module~~yaeos_tapenade_ar_api~~UsesGraph module~yaeos_tapenade_ar_api yaeos_tapenade_ar_api module~yaeos_constants yaeos_constants module~yaeos_tapenade_ar_api->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces tapenade_ar tapenade_ar_b tapenade_ar_d tapenade_ar_d_b tapenade_ar_d_d Subroutines residual_helmholtz Abstract Interfaces abstract interface private subroutine tapenade_ar(n, v, t, arval) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: arval abstract interface private subroutine tapenade_ar_b(n, nb, v, vb, t, tb, arval, arvalb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: arval real(kind=pr) :: arvalb abstract interface private subroutine tapenade_ar_d(n, nd, v, vd, t, td, arval, arvald) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald abstract interface private subroutine tapenade_ar_d_b(n, nb, v, vb, t, tb, arval, arvalb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: arval real(kind=pr) :: arvalb abstract interface private subroutine tapenade_ar_d_d(n, nd, v, vd0, vd, t, td0, td, arval, arvald0, arvald, arvaldd) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd0 real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald0 real(kind=pr), intent(out) :: arvald real(kind=pr), intent(out) :: arvaldd Subroutines private subroutine residual_helmholtz (n, v, t, ar, dardn, dardv, dardt, dardn2, darnv, dardnt, dardvt, dardv2, dardt2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: ar real(kind=pr), intent(out), optional :: dardn (size(n)) real(kind=pr), intent(out), optional :: dardv real(kind=pr), intent(out), optional :: dardt real(kind=pr), intent(out), optional :: dardn2 (size(n),size(n)) real(kind=pr), intent(out), optional :: darnv (size(n)) real(kind=pr), intent(out), optional :: dardnt (size(n)) real(kind=pr), intent(out), optional :: dardvt real(kind=pr), intent(out), optional :: dardv2 real(kind=pr), intent(out), optional :: dardt2","tags":"","loc":"module/yaeos_tapenade_ar_api.html"},{"title":"yaeos_ar_models_hyperdual – Yaeos","text":"Module that contains the automatic differentiation logic for an Ar model Uses yaeos_models_ar yaeos_autodiff yaeos_constants module~~yaeos_ar_models_hyperdual~~UsesGraph module~yaeos_ar_models_hyperdual yaeos_ar_models_hyperdual module~yaeos_models_ar yaeos_models_ar module~yaeos_ar_models_hyperdual->module~yaeos_models_ar module~yaeos_constants yaeos_constants module~yaeos_ar_models_hyperdual->module~yaeos_constants module~yaeos_autodiff yaeos_autodiff module~yaeos_ar_models_hyperdual->module~yaeos_autodiff module~yaeos_models_ar->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~hyperdual_mod hyperdual_mod module~yaeos_autodiff->module~hyperdual_mod module~hyperdual_mod->module~yaeos_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces hyperdual_Ar Derived Types ArModelAdiff Subroutines residual_helmholtz Abstract Interfaces abstract interface public function hyperdual_Ar(self, n, v, t) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual ) Derived Types type, public, abstract, extends( ArModel ) :: ArModelAdiff Components Type Visibility Attributes Name Initial integer, public :: id character(len=:), public, allocatable :: name Type-Bound Procedures procedure(hyperdual_Ar), public :: Ar procedure(abs_volume_initializer), public :: get_v0 procedure, public :: residual_helmholtz Subroutines public subroutine residual_helmholtz (self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional dimension(size(n)) :: Arn real(kind=pr), intent(out), optional dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"module/yaeos_ar_models_hyperdual.html"},{"title":"ar_interface – Yaeos","text":"Generic interfaces to an ArModel compatible with legacy codes, using\n  pointers. Uses iso_fortran_env yaeos_constants module~~ar_interface~~UsesGraph module~ar_interface ar_interface iso_fortran_env iso_fortran_env module~ar_interface->iso_fortran_env module~yaeos_constants yaeos_constants module~ar_interface->module~yaeos_constants module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~ar_interface~~UsedByGraph module~ar_interface ar_interface module~legacy_ar_models legacy_ar_models module~legacy_ar_models->module~ar_interface module~legacy_thermo_properties legacy_thermo_properties module~legacy_thermo_properties->module~legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables ar_fun vinit Abstract Interfaces Ares initial_volume Variables Type Visibility Attributes Name Initial procedure( Ares ), public, pointer :: ar_fun procedure( initial_volume ), public, pointer :: vinit Abstract Interfaces abstract interface public subroutine Ares(z, v, t, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz model interface Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) abstract interface public function initial_volume(z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr)","tags":"","loc":"module/ar_interface.html"},{"title":"legacy_ar_models – Yaeos","text":"Uses ar_interface yaeos_constants module~~legacy_ar_models~~UsesGraph module~legacy_ar_models legacy_ar_models module~ar_interface ar_interface module~legacy_ar_models->module~ar_interface module~yaeos_constants yaeos_constants module~legacy_ar_models->module~yaeos_constants module~ar_interface->module~yaeos_constants iso_fortran_env iso_fortran_env module~ar_interface->iso_fortran_env module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~legacy_ar_models~~UsedByGraph module~legacy_ar_models legacy_ar_models module~legacy_thermo_properties legacy_thermo_properties module~legacy_thermo_properties->module~legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables ac b bij dc del1 k kij kij0 kinf lij mixing_rule nc pc tc tdep thermo_model tstar w z Functions cubic_v0 Subroutines ArVnder Bnder DELTAnder DandTnder HelmRKPR HelmSRKPR PR76_factory PR78_factory SRK_factory aTder aijTder ar_rkpr ar_srkpr get_Zc_OMa_OMb setup Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: ac (:) Critical attractive parameter [bar (L/mol)&#94;2] real(kind=pr), public, allocatable :: b (:) repulsive parameter [L] real(kind=pr), public, allocatable :: bij (:,:) real(kind=pr), public, allocatable :: dc (:) Critical density [mol/L] real(kind=pr), public, allocatable :: del1 (:) parameter real(kind=pr), public, allocatable :: k (:) Attractive parameter constant real(kind=pr), public, allocatable :: kij (:,:) Attractive BIP real(kind=pr), public, allocatable :: kij0 (:,:) real(kind=pr), public, allocatable :: kinf (:,:) real(kind=pr), public, allocatable :: lij (:,:) Repulsive BIP integer, public :: mixing_rule integer, public :: nc real(kind=pr), public, allocatable :: pc (:) Critical pressure [bar] real(kind=pr), public, allocatable :: tc (:) Critical temperature [K] integer, public :: tdep integer, public :: thermo_model real(kind=pr), public, allocatable :: tstar (:,:) real(kind=pr), public, allocatable :: w (:) Acentric factor real(kind=pr), public, allocatable :: z (:) Functions public function cubic_v0 (z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr) Subroutines public subroutine ArVnder (nc, nder, ntemp, z, V, T, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: nder integer, intent(in) :: ntemp real(kind=pr), intent(in) :: z (nc) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) public subroutine Bnder (nc, rn, Bmix, dBi, dBij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: Bmix real(kind=pr), intent(out) :: dBi (nc) real(kind=pr), intent(out) :: dBij (nc,nc) public subroutine DELTAnder (nc, rn, D1m, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D1m real(kind=pr), intent(out) :: dD1i (nc) real(kind=pr), intent(out) :: dD1ij (nc,nc) public subroutine DandTnder (ntd, nc, T, rn, D, dDi, dDiT, dDij, dDdT, dDdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDi (nc) real(kind=pr), intent(out) :: dDiT (nc) real(kind=pr), intent(out) :: dDij (nc,nc) real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 public subroutine HelmRKPR (nco, NDE, NTD, rn, V, T, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nco integer, intent(in) :: NDE integer, intent(in) :: NTD real(kind=pr), intent(in) :: rn (nco) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out) :: Arn (nco) real(kind=pr), intent(out) :: ArVn (nco) real(kind=pr), intent(out) :: ArTn (nco) real(kind=pr), intent(out) :: Arn2 (nco,nco) public subroutine HelmSRKPR (nc, nd, nt, rn, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: nd integer, intent(in) :: nt real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out) :: Arn (nc) real(kind=pr), intent(out) :: ArVn (nc) real(kind=pr), intent(out) :: ArTn (nc) real(kind=pr), intent(out) :: Arn2 (nc,nc) public subroutine PR76_factory (moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) public subroutine PR78_factory (moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) public subroutine SRK_factory (moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) public subroutine aTder (ac, Tc, k, T, a, dadT, dadT2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: ac real(kind=pr), intent(in) :: Tc real(kind=pr), intent(in) :: k real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: a real(kind=pr), intent(out) :: dadT real(kind=pr), intent(out) :: dadT2 public subroutine aijTder (ntd, nc, T, aij, daijdT, daijdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: aij (nc,nc) real(kind=pr), intent(out) :: daijdT (nc,nc) real(kind=pr), intent(out) :: daijdT2 (nc,nc) public subroutine ar_rkpr (z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out) :: Arn (size(z)) real(kind=pr), intent(out) :: ArVn (size(z)) real(kind=pr), intent(out) :: ArTn (size(z)) real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) public subroutine ar_srkpr (z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out) :: Arn (size(z)) real(kind=pr), intent(out) :: ArVn (size(z)) real(kind=pr), intent(out) :: ArTn (size(z)) real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) public subroutine get_Zc_OMa_OMb (del1, Zc, OMa, OMb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: del1 (:) real(kind=pr), intent(out) :: Zc (:) real(kind=pr), intent(out) :: OMa (:) real(kind=pr), intent(out) :: OMb (:) public subroutine setup (n, nmodel, ntdep, ncomb) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: nmodel integer, intent(in) :: ntdep integer, intent(in) :: ncomb","tags":"","loc":"module/legacy_ar_models.html"},{"title":"legacy_thermo_properties – Yaeos","text":"Uses legacy_ar_models yaeos_constants module~~legacy_thermo_properties~~UsesGraph module~legacy_thermo_properties legacy_thermo_properties module~legacy_ar_models legacy_ar_models module~legacy_thermo_properties->module~legacy_ar_models module~yaeos_constants yaeos_constants module~legacy_thermo_properties->module~yaeos_constants module~legacy_ar_models->module~yaeos_constants module~ar_interface ar_interface module~legacy_ar_models->module~ar_interface iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~ar_interface->module~yaeos_constants module~ar_interface->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines PUREFUG_CALC TERMO VCALC zTVTERMO Subroutines public subroutine PUREFUG_CALC (nc, icomp, T, P, V, phi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: icomp real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: V real(kind=pr), intent(out) :: phi public subroutine TERMO (nc, mtyp, indic, t, p, rn, v, PHILOG, DLPHIP, DLPHIT, FUGN) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: mtyp integer, intent(in) :: indic real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: v real(kind=pr), intent(out) :: PHILOG (nc) real(kind=pr), intent(out), optional :: DLPHIP (nc) real(kind=pr), intent(out), optional :: DLPHIT (nc) real(kind=pr), intent(out), optional :: FUGN (nc,nc) public recursive subroutine VCALC (ITYP, nc, ntemp, rn, T, P, V) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP integer, intent(in) :: nc integer, intent(in) :: ntemp real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(out) :: V public subroutine zTVTERMO (nc, indic, t, rn, v, p, dpv, PHILOG, DLPHIP, DLPHIT, FUGN) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: indic real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: v real(kind=pr), intent(out) :: p real(kind=pr), intent(out) :: dpv real(kind=pr), intent(out) :: PHILOG (nc) real(kind=pr), intent(out) :: DLPHIP (nc) real(kind=pr), intent(out) :: DLPHIT (nc) real(kind=pr), intent(out) :: FUGN (nc,nc)","tags":"","loc":"module/legacy_thermo_properties.html"},{"title":"ADMM_TAPENADE_INTERFACE – Yaeos","text":"Contents Interfaces ADMM_REBASE ADMM_REBASESHADOWED ADMM_REGISTER ADMM_REGISTERSHADOWED ADMM_UNREGISTER ADMM_UNREGISTERSHADOWED POPPOINTER8 PUSHPOINTER8 Interfaces public interface ADMM_REBASE public subroutine ADMM_REBASE(base) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: base public interface ADMM_REBASESHADOWED public subroutine ADMM_REBASESHADOWED(base, baseb) bind(c, name=     \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: base type(C_PTR) :: baseb public interface ADMM_REGISTER public subroutine ADMM_REGISTER(base, obase, size, nbelem) bind(c, name=     \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size integer, VALUE :: nbelem public interface ADMM_REGISTERSHADOWED public subroutine ADMM_REGISTERSHADOWED(base, obase, size, baseb, obaseb, sizeb, nbelem) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size type(C_PTR), VALUE :: baseb type(C_PTR), VALUE :: obaseb integer, VALUE :: sizeb integer, VALUE :: nbelem public interface ADMM_UNREGISTER public subroutine ADMM_UNREGISTER(base, nbelem) bind(c, name=     \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base integer :: nbelem public interface ADMM_UNREGISTERSHADOWED public subroutine ADMM_UNREGISTERSHADOWED(base, baseb, nbelem) bind(c,      name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: baseb integer :: nbelem public interface POPPOINTER8 public subroutine POPPOINTER8(pp) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: pp public interface PUSHPOINTER8 public subroutine PUSHPOINTER8(pp) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: pp","tags":"","loc":"module/admm_tapenade_interface.html"},{"title":"yaeos_substance – Yaeos","text":"Uses yaeos_constants module~~yaeos_substance~~UsesGraph module~yaeos_substance yaeos_substance module~yaeos_constants yaeos_constants module~yaeos_substance->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_substance~~UsedByGraph module~yaeos_substance yaeos_substance module~yaeos_models_ar_cubic_srk yaeos_models_ar_cubic_srk module~yaeos_models_ar_cubic_srk->module~yaeos_substance module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson78 yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_substance module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos yaeos module~yaeos->module~yaeos_substance module~yaeos_models yaeos_models module~yaeos->module~yaeos_models module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson76 yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_substance module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_cubic_srk module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson76 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types Substances Derived Types type, public :: Substances Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: pc (:) real(kind=pr), public, allocatable :: tc (:) real(kind=pr), public, allocatable :: w (:)","tags":"","loc":"module/yaeos_substance.html"},{"title":"yaeos_models – Yaeos","text":"Uses yaeos_models_ar_cubic_srk yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic yaeos_models_ar yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_pengrobinson78 yaeos_models_ar_cubic_pengrobinson76 module~~yaeos_models~~UsesGraph module~yaeos_models yaeos_models module~yaeos_models_ar_cubic_srk yaeos_models_ar_cubic_srk module~yaeos_models->module~yaeos_models_ar_cubic_srk module~yaeos_models_ar_cubic_pengrobinson78 yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models_ar yaeos_models_ar module~yaeos_models->module~yaeos_models_ar module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson76 yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_substance yaeos_substance module~yaeos_models_ar_cubic_srk->module~yaeos_substance module~yaeos_constants yaeos_constants module~yaeos_models_ar_cubic_srk->module~yaeos_constants module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_substance module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_constants module~yaeos_models_ar->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_substance module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_constants module~yaeos_substance->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_models~~UsedByGraph module~yaeos_models yaeos_models module~yaeos yaeos module~yaeos->module~yaeos_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/yaeos_models.html"},{"title":"yaeos_models_ar – Yaeos","text":"Uses yaeos_constants module~~yaeos_models_ar~~UsesGraph module~yaeos_models_ar yaeos_models_ar module~yaeos_constants yaeos_constants module~yaeos_models_ar->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_models_ar~~UsedByGraph module~yaeos_models_ar yaeos_models_ar module~yaeos_thermoprops yaeos_thermoprops module~yaeos_thermoprops->module~yaeos_models_ar module~yaeos_ar_models_hyperdual yaeos_ar_models_hyperdual module~yaeos_ar_models_hyperdual->module~yaeos_models_ar module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson78 yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models_ar_cubic_srk yaeos_models_ar_cubic_srk module~yaeos_models->module~yaeos_models_ar_cubic_srk module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson76 yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos yaeos module~yaeos->module~yaeos_thermoprops module~yaeos->module~yaeos_models module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces abs_residual_helmholtz abs_volume_initializer Derived Types ArModel Abstract Interfaces abstract interface public subroutine abs_residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional dimension(size(n)) :: Arn real(kind=pr), intent(out), optional dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) abstract interface public function abs_volume_initializer(self, n, p, t) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) Derived Types type, public, abstract :: ArModel Components Type Visibility Attributes Name Initial integer, public :: id character(len=:), public, allocatable :: name Type-Bound Procedures procedure(abs_volume_initializer), public :: get_v0 procedure(abs_residual_helmholtz), public :: residual_helmholtz","tags":"","loc":"module/yaeos_models_ar.html"},{"title":"yaeos_models_ar_genericcubic – Yaeos","text":"Uses yaeos_models_ar yaeos_substance yaeos_constants module~~yaeos_models_ar_genericcubic~~UsesGraph module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_substance yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_constants yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar->module~yaeos_constants module~yaeos_substance->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_models_ar_genericcubic~~UsedByGraph module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_srk yaeos_models_ar_cubic_srk module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson78 yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_cubic_srk module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson76 yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos yaeos module~yaeos->module~yaeos_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces abs_Bmix abs_Dmix abs_alpha Derived Types AlphaFunction CubicEoS CubicMixRule Functions v0 Subroutines GenericCubic_Ar Abstract Interfaces abstract interface public subroutine abs_Bmix(self, n, bi, B, dBi, dBij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) abstract interface public subroutine abs_Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) abstract interface public subroutine abs_alpha(self, Tr, a, dadt, dadt2) Arguments Type Intent Optional Attributes Name class( AlphaFunction ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:) Derived Types type, public, abstract :: AlphaFunction Type-Bound Procedures procedure(abs_alpha), public :: alpha type, public, extends( ArModel ) :: CubicEoS Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: ac (:) class( AlphaFunction ), public, allocatable :: alpha real(kind=pr), public, allocatable :: b (:) class( Substances ), public, allocatable :: components real(kind=pr), public, allocatable :: del1 (:) real(kind=pr), public, allocatable :: del2 (:) integer, public :: id class( CubicMixRule ), public, allocatable :: mixrule character(len=:), public, allocatable :: name Type-Bound Procedures procedure, public :: get_v0 => v0 procedure, public :: residual_helmholtz => GenericCubic_Ar type, public, abstract :: CubicMixRule Type-Bound Procedures procedure(abs_Bmix), public :: Bmix procedure(abs_Dmix), public :: Dmix Functions public function v0 (self, n, p, t) Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) Subroutines public subroutine GenericCubic_Ar (self, n, v, t, ar, arv, ArT, artv, arv2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: ar real(kind=pr), intent(out), optional :: arv real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: artv real(kind=pr), intent(out), optional :: arv2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"module/yaeos_models_ar_genericcubic.html"},{"title":"yaeos_models_ar_cubic_pengrobinson76 – Yaeos","text":"Uses yaeos_substance yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic yaeos_constants yaeos_models_ar_cubic_alphas module~~yaeos_models_ar_cubic_pengrobinson76~~UsesGraph module~yaeos_models_ar_cubic_pengrobinson76 yaeos_models_ar_cubic_pengrobinson76 module~yaeos_substance yaeos_substance module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_substance module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_cubic_alphas module~yaeos_constants yaeos_constants module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_substance->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar->module~yaeos_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_models_ar_cubic_pengrobinson76~~UsedByGraph module~yaeos_models_ar_cubic_pengrobinson76 yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson76 module~yaeos yaeos module~yaeos->module~yaeos_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions PengRobinson76 Functions public function PengRobinson76 (tc, pc, w, kij, lij) result(model) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) real(kind=pr), intent(in) :: pc (:) real(kind=pr), intent(in) :: w (:) real(kind=pr), intent(in), optional :: kij (:,:) real(kind=pr), intent(in), optional :: lij (:,:) Return Value type( CubicEoS )","tags":"","loc":"module/yaeos_models_ar_cubic_pengrobinson76.html"},{"title":"yaeos_models_ar_cubic_srk – Yaeos","text":"Uses yaeos_substance yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic yaeos_constants yaeos_models_ar_cubic_alphas module~~yaeos_models_ar_cubic_srk~~UsesGraph module~yaeos_models_ar_cubic_srk yaeos_models_ar_cubic_srk module~yaeos_substance yaeos_substance module~yaeos_models_ar_cubic_srk->module~yaeos_substance module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_cubic_alphas module~yaeos_constants yaeos_constants module~yaeos_models_ar_cubic_srk->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_substance->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar->module~yaeos_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_models_ar_cubic_srk~~UsedByGraph module~yaeos_models_ar_cubic_srk yaeos_models_ar_cubic_srk module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar_cubic_srk module~yaeos yaeos module~yaeos->module~yaeos_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions SoaveRedlichKwong Functions public function SoaveRedlichKwong (tc, pc, w, kij, lij) result(model) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) real(kind=pr), intent(in) :: pc (:) real(kind=pr), intent(in) :: w (:) real(kind=pr), intent(in), optional :: kij (:,:) real(kind=pr), intent(in), optional :: lij (:,:) Return Value type( CubicEoS )","tags":"","loc":"module/yaeos_models_ar_cubic_srk.html"},{"title":"yaeos_models_ar_cubic_pengrobinson78 – Yaeos","text":"Uses yaeos_substance yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic yaeos_constants yaeos_models_ar_cubic_alphas module~~yaeos_models_ar_cubic_pengrobinson78~~UsesGraph module~yaeos_models_ar_cubic_pengrobinson78 yaeos_models_ar_cubic_pengrobinson78 module~yaeos_substance yaeos_substance module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_substance module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_cubic_alphas module~yaeos_constants yaeos_constants module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_substance->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar->module~yaeos_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_models_ar_cubic_pengrobinson78~~UsedByGraph module~yaeos_models_ar_cubic_pengrobinson78 yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson78 module~yaeos yaeos module~yaeos->module~yaeos_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions PengRobinson78 Functions public function PengRobinson78 (tc, pc, w, kij, lij) result(model) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) real(kind=pr), intent(in) :: pc (:) real(kind=pr), intent(in) :: w (:) real(kind=pr), intent(in), optional :: kij (:,:) real(kind=pr), intent(in), optional :: lij (:,:) Return Value type( CubicEoS )","tags":"","loc":"module/yaeos_models_ar_cubic_pengrobinson78.html"},{"title":"yaeos_models_ar_genericcubic_quadratic_mixing – Yaeos","text":"Uses yaeos_substance yaeos_constants yaeos_models_ar_genericcubic module~~yaeos_models_ar_genericcubic_quadratic_mixing~~UsesGraph module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_substance yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_constants yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_substance->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar->module~yaeos_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_models_ar_genericcubic_quadratic_mixing~~UsedByGraph module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_srk yaeos_models_ar_cubic_srk module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_cubic_srk module~yaeos_models_ar_cubic_pengrobinson76 yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models_ar_cubic_pengrobinson78 yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos yaeos module~yaeos->module~yaeos_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces get_aij Derived Types QMR Subroutines Bmix Dmix kij_constant Abstract Interfaces abstract interface public subroutine get_aij(self, ai, daidt, daidt2, aij, daijdt, daijdt2) Arguments Type Intent Optional Attributes Name class( QMR ) :: self real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: aij (:,:) real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:) Derived Types type, public, extends( CubicMixRule ) :: QMR Components Type Visibility Attributes Name Initial procedure( get_aij ), public, pointer :: aij => kij_constant real(kind=pr), public, allocatable :: k (:,:) real(kind=pr), public, allocatable :: l (:,:) Type-Bound Procedures procedure, public :: Bmix procedure, public :: Dmix Subroutines public subroutine Bmix (self, n, bi, B, dBi, dBij) Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) public subroutine Dmix (self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) public subroutine kij_constant (self, a, dadt, dadt2, aij, daijdt, daijdt2) Arguments Type Intent Optional Attributes Name class( QMR ) :: self real(kind=pr), intent(in) :: a (:) real(kind=pr), intent(in) :: dadt (:) real(kind=pr), intent(in) :: dadt2 (:) real(kind=pr), intent(out) :: aij (:,:) real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:)","tags":"","loc":"module/yaeos_models_ar_genericcubic_quadratic_mixing.html"},{"title":"yaeos_models_ar_cubic_alphas – Yaeos","text":"Uses yaeos_substance yaeos_constants yaeos_models_ar_genericcubic module~~yaeos_models_ar_cubic_alphas~~UsesGraph module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_substance yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_constants yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_substance->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar->module~yaeos_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaeos_models_ar_cubic_alphas~~UsedByGraph module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_srk yaeos_models_ar_cubic_srk module~yaeos_models_ar_cubic_srk->module~yaeos_models_ar_cubic_alphas module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_srk module~yaeos_models_ar_cubic_pengrobinson76 yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson76 module~yaeos_models_ar_cubic_pengrobinson78 yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models->module~yaeos_models_ar_cubic_pengrobinson78 module~yaeos_models_ar_cubic_pengrobinson76->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_pengrobinson78->module~yaeos_models_ar_cubic_alphas module~yaeos yaeos module~yaeos->module~yaeos_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types AlphaSoave Subroutines alpha Derived Types type, public, extends( AlphaFunction ) :: AlphaSoave Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: k (:) Type-Bound Procedures procedure, public :: alpha Subroutines public subroutine alpha (self, Tr, a, dadt, dadt2) Arguments Type Intent Optional Attributes Name class( AlphaSoave ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","loc":"module/yaeos_models_ar_cubic_alphas.html"},{"title":"thermoprops.f90 – Yaeos","text":"This file depends on sourcefile~~thermoprops.f90~~EfferentGraph sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~constants.f90 constants.f90 sourcefile~thermoprops.f90->sourcefile~constants.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~thermoprops.f90->sourcefile~ar_models.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~thermoprops.f90~~AfferentGraph sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~thermoprops.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_thermoprops Source Code thermoprops.f90 Source Code module yaeos_thermoprops !! Residual thermodyamic properties using residual Helmholtz model use yaeos_constants , only : R , pr use yaeos_models_ar , only : ArModel implicit none contains subroutine fugacity_tp ( self , & n , T , P , V , root_type , lnfug , dlnPhidP , dlnphidT , dlnPhidn & ) use iso_fortran_env , only : error_unit class ( ArModel ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) !! Mixture mole numbers integer , intent ( in ) :: root_type !! Type of root desired (-1 vapor, 1 liquid, 0 lower Gr) real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( in ) :: p !! Pressure [bar] real ( pr ), intent ( out ) :: lnfug ( size ( n )) !! \\ln(\\phi*p) vector real ( pr ), optional , intent ( out ) :: v !! Volume [L] real ( pr ), optional , intent ( out ) :: dlnphidt ( size ( n )) !! ln(phi) Temp derivative real ( pr ), optional , intent ( out ) :: dlnphidp ( size ( n )) !! ln(phi) Presssure derivative real ( pr ), optional , intent ( out ) :: dlnphidn ( size ( n ), size ( n )) !! ln(phi) compositional derivative real ( pr ) :: v_in , p_in call VCALC ( self , root_type , size ( n ), n , T , P , V_in ) call fugacity_vt ( self , n , v_in , T , P_in , lnfug , dlnphidp , dlnphidt , dlnphidn ) if ( present ( v )) v = v_in if ( abs ( p - p_in ) > 1e-5 ) write ( error_unit , * ) & \"WARN: Possible wrong root calculating fugacity!\" , p , p_in end subroutine fugacity_tp subroutine fugacity_vt ( self , & n , V , T , P , lnfug , dlnPhidP , dlnphidT , dlnPhidn & ) class ( ArModel ) :: self real ( pr ), intent ( in ) :: n (:) !! Mixture mole numbers real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), optional , intent ( out ) :: p !! Pressure [bar] real ( pr ), optional , intent ( out ) :: lnfug ( size ( n )) !! \\ln(\\phi*p) vector real ( pr ), optional , intent ( out ) :: dlnphidt ( size ( n )) !! ln(phi) Temp derivative real ( pr ), optional , intent ( out ) :: dlnphidp ( size ( n )) !! ln(phi) Presssure derivative real ( pr ), optional , intent ( out ) :: dlnphidn ( size ( n ), size ( n )) !! ln(phi) compositional derivative real ( pr ) :: Ar , ArTV , ArV , ArV2 real ( pr ), dimension ( size ( n )) :: Arn , ArVn , ArTn real ( pr ) :: Arn2 ( size ( n ), size ( n )) real ( pr ) :: dPdV , dPdT , dPdN ( size ( n )) real ( pr ) :: RT , Z real ( pr ) :: totn integer :: nc , i , j TOTN = sum ( n ) nc = size ( n ) RT = R * T Z = V / ( TOTN * RT ) ! this is Z/P if ( present ( dlnphidn )) then call self % residual_helmholtz (& n , V , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 , ArTV = ArTV , & Arn = Arn , ArVn = ArVn , ArTn = ArTn , Arn2 = Arn2 & ) else call self % residual_helmholtz (& n , V , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 , ArTV = ArTV , & Arn = Arn , ArVn = ArVn , ArTn = ArTn & ) end if P = TOTN * RT / V - ArV dPdV = - ArV2 - RT * TOTN / V ** 2 dPdT = - ArTV + TOTN * R / V dPdN (:) = RT / V - ArVn (:) lnfug (:) = Arn (:) / RT - log ( Z ) if ( present ( dlnphidp )) dlnphidp (:) = - dPdN (:) / dPdV / RT - 1._pr / P if ( present ( dlnphidt )) then dlnphidt (:) = ( ArTn (:) - Arn (:) / T ) / RT + dPdN (:) * dPdT / dPdV / RT + 1._pr / T end if if ( present ( dlnphidn )) then do i = 1 , nc do j = i , nc dlnphidn ( i , j ) = 1._pr / TOTN + ( Arn2 ( i , j ) + dPdN ( i ) * dPdN ( j ) / dPdV ) / RT dlnphidn ( j , i ) = dlnphidn ( i , j ) end do end do end if end subroutine subroutine PUREFUG_CALC ( self , nc , icomp , T , P , V , fug ) !! Fugacity of a pure component class ( ArModel ), intent ( in ) :: self integer , intent ( in ) :: nc integer , intent ( in ) :: icomp real ( pr ), intent ( in ) :: T , P , V real ( pr ), intent ( out ) :: fug real ( pr ) :: n ( nc ), Ar , Arn ( nc ) real ( pr ) :: RT , Z , lnfug n = 0.0 n ( icomp ) = 1.0 RT = R * T Z = P * V / RT call self % residual_helmholtz ( n , V , T , Ar , Arn = Arn ) lnfug = - log ( Z ) + Arn ( icomp ) / RT fug = exp ( fug ) end subroutine purefug_calc recursive subroutine VCALC ( self , ITYP , nc , rn , T , P , V , max_iters ) !! ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE use iso_fortran_env , only : error_unit use stdlib_optval , only : optval class ( ArModel ), intent ( in ) :: self integer , intent ( in ) :: ITYP !! Type of root [-1: vapor, 1:liquid, 0:lower Gibbs energy phase] integer , intent ( in ) :: nc !! Number of components real ( pr ), intent ( in ) :: rn ( nc ) !! Mixture moles real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: P !! Pressure [bar] real ( pr ), intent ( out ) :: V !! Volume [L] integer , optional , intent ( in ) :: max_iters !! Maxiumum number of iterations, defaults to 100 real ( pr ) :: Ar , ArV , ArV2 logical :: FIRST_RUN real ( pr ) :: totn real ( pr ) :: B , CPV , S3R real ( pr ) :: ZETMIN , ZETA , ZETMAX real ( pr ) :: del , pcalc , der , AT , AVAP , VVAP integer :: iter , maximum_iterations maximum_iterations = optval ( max_iters , 100 ) FIRST_RUN = . true . TOTN = sum ( rn ) CPV = self % get_v0 ( rn , p , t ) B = CPV S3R = 1._pr / CPV ITER = 0 ZETMIN = 0._pr ZETMAX = 1._pr - 0.01 * T / ( 10000 * B ) ! improvement for cases with heavy components if ( ITYP . gt . 0 ) then ZETA = 0.5_pr else ! IDEAL GAS ESTIMATE ZETA = min (. 5 D0 , CPV * P / ( TOTN * R * T )) end if 100 continue DEL = 1 pcalc = 2 * p do while ( abs ( DEL ) > 1.e-10_pr . and . iter < maximum_iterations ) V = CPV / ZETA ITER = ITER + 1 call self % residual_helmholtz (& rn , V , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 & ) PCALC = TOTN * R * T / V - ArV if ( PCALC . gt . P ) then ZETMAX = ZETA else ZETMIN = ZETA end if ! AT is something close to Gr(P,T) AT = ( Ar + V * P ) / ( T * R ) - TOTN * log ( V ) DER = ( ArV2 * V ** 2 + TOTN * R * T ) * S3R ! this is dPdrho/B DEL = - ( PCALC - P ) / DER ZETA = ZETA + max ( min ( DEL , 0.1_pr ), - . 1_pr ) if ( ZETA . gt . ZETMAX . or . ZETA . lt . ZETMIN ) & ZETA = . 5_pr * ( ZETMAX + ZETMIN ) end do if ( iter >= maximum_iterations ) write ( error_unit , * ) & \"WARN: Volume solver exceeded maximum number of iterations\" if ( ITYP . eq . 0 ) then ! FIRST RUN WAS VAPOUR; RERUN FOR LIQUID if ( FIRST_RUN ) then VVAP = V AVAP = AT FIRST_RUN = . false . ZETA = 0.5_pr ZETMAX = 1._pr - 0.01_pr * T / 50 0._pr goto 100 else if ( AT . gt . AVAP ) V = VVAP end if end if end subroutine vcalc ! ========================================================================== end module","tags":"","loc":"sourcefile/thermoprops.f90.html"},{"title":"yaeos.f90 – Yaeos","text":"This file depends on sourcefile~~yaeos.f90~~EfferentGraph sourcefile~yaeos.f90 yaeos.f90 sourcefile~constants.f90 constants.f90 sourcefile~yaeos.f90->sourcefile~constants.f90 sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~yaeos.f90->sourcefile~thermoprops.f90 sourcefile~substance.f90 substance.f90 sourcefile~yaeos.f90->sourcefile~substance.f90 sourcefile~models.f90 models.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~thermoprops.f90->sourcefile~constants.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~thermoprops.f90->sourcefile~ar_models.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~pr76.f90 pr76.f90 sourcefile~models.f90->sourcefile~pr76.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~srk.f90 srk.f90 sourcefile~models.f90->sourcefile~srk.f90 sourcefile~models.f90->sourcefile~ar_models.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~pr78.f90 pr78.f90 sourcefile~models.f90->sourcefile~pr78.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~pr76.f90->sourcefile~constants.f90 sourcefile~pr76.f90->sourcefile~substance.f90 sourcefile~pr76.f90->sourcefile~alphas.f90 sourcefile~pr76.f90->sourcefile~generic_cubic.f90 sourcefile~pr76.f90->sourcefile~mixing_rules.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~srk.f90->sourcefile~constants.f90 sourcefile~srk.f90->sourcefile~substance.f90 sourcefile~srk.f90->sourcefile~alphas.f90 sourcefile~srk.f90->sourcefile~generic_cubic.f90 sourcefile~srk.f90->sourcefile~mixing_rules.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~pr78.f90->sourcefile~constants.f90 sourcefile~pr78.f90->sourcefile~substance.f90 sourcefile~pr78.f90->sourcefile~alphas.f90 sourcefile~pr78.f90->sourcefile~generic_cubic.f90 sourcefile~pr78.f90->sourcefile~mixing_rules.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos Source Code yaeos.f90 Source Code module yaeos use yaeos_constants use yaeos_substance use yaeos_models use yaeos_thermoprops character ( len =* ), parameter :: version = \"0.1.0b\" end module","tags":"","loc":"sourcefile/yaeos.f90.html"},{"title":"constants.f90 – Yaeos","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~thermoprops.f90->sourcefile~constants.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~thermoprops.f90->sourcefile~ar_models.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~substance.f90 substance.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~constants.f90 sourcefile~yaeos.f90->sourcefile~thermoprops.f90 sourcefile~yaeos.f90->sourcefile~substance.f90 sourcefile~models.f90 models.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~pr76.f90 pr76.f90 sourcefile~pr76.f90->sourcefile~constants.f90 sourcefile~pr76.f90->sourcefile~alphas.f90 sourcefile~pr76.f90->sourcefile~substance.f90 sourcefile~pr76.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~pr76.f90->sourcefile~mixing_rules.f90 sourcefile~srk.f90 srk.f90 sourcefile~srk.f90->sourcefile~constants.f90 sourcefile~srk.f90->sourcefile~alphas.f90 sourcefile~srk.f90->sourcefile~substance.f90 sourcefile~srk.f90->sourcefile~generic_cubic.f90 sourcefile~srk.f90->sourcefile~mixing_rules.f90 sourcefile~tapenade_ar_api.f90 tapenade_ar_api.f90 sourcefile~tapenade_ar_api.f90->sourcefile~constants.f90 sourcefile~armodel_adiff_api.f90 armodel_adiff_api.f90 sourcefile~armodel_adiff_api.f90->sourcefile~constants.f90 sourcefile~armodel_adiff_api.f90->sourcefile~ar_models.f90 sourcefile~autodiff.f90 autodiff.f90 sourcefile~armodel_adiff_api.f90->sourcefile~autodiff.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~pr78.f90 pr78.f90 sourcefile~pr78.f90->sourcefile~constants.f90 sourcefile~pr78.f90->sourcefile~alphas.f90 sourcefile~pr78.f90->sourcefile~substance.f90 sourcefile~pr78.f90->sourcefile~generic_cubic.f90 sourcefile~pr78.f90->sourcefile~mixing_rules.f90 sourcefile~hyperdual.f90 hyperdual.f90 sourcefile~hyperdual.f90->sourcefile~constants.f90 sourcefile~ar_interface.f90 ar_interface.f90 sourcefile~ar_interface.f90->sourcefile~constants.f90 sourcefile~legacy.f90 legacy.f90 sourcefile~legacy.f90->sourcefile~constants.f90 sourcefile~legacy.f90->sourcefile~ar_interface.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~models.f90->sourcefile~pr76.f90 sourcefile~models.f90->sourcefile~srk.f90 sourcefile~models.f90->sourcefile~ar_models.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~models.f90->sourcefile~pr78.f90 sourcefile~autodiff.f90->sourcefile~hyperdual.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_constants Source Code constants.f90 Source Code module yaeos_constants !-| Constants used on the whole package use iso_fortran_env , only : real32 , real64 , real128 implicit none integer , parameter :: pr = real64 !| Machine Precision real ( pr ), parameter :: R = 0.08314472_pr !| Ideal Gas constant character ( len = 254 ) :: database_path = \"database\" !| Path to find database character ( len = 1 ) :: path_sep = \"/\" !| File separator (to preprocess on Win or Mac/linux) real ( pr ), parameter :: NOT_IMPLEMENTED = huge ( R ) end module","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"autodiff.f90 – Yaeos","text":"This file depends on sourcefile~~autodiff.f90~~EfferentGraph sourcefile~autodiff.f90 autodiff.f90 sourcefile~hyperdual.f90 hyperdual.f90 sourcefile~autodiff.f90->sourcefile~hyperdual.f90 sourcefile~constants.f90 constants.f90 sourcefile~hyperdual.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~autodiff.f90~~AfferentGraph sourcefile~autodiff.f90 autodiff.f90 sourcefile~armodel_adiff_api.f90 armodel_adiff_api.f90 sourcefile~armodel_adiff_api.f90->sourcefile~autodiff.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_autodiff Source Code autodiff.f90 Source Code module yaeos_autodiff !-| This module holds the diferent ways of automatic differentiation use hyperdual_mod implicit none end module","tags":"","loc":"sourcefile/autodiff.f90.html"},{"title":"hyperdual.f90 – Yaeos","text":"This file depends on sourcefile~~hyperdual.f90~~EfferentGraph sourcefile~hyperdual.f90 hyperdual.f90 sourcefile~constants.f90 constants.f90 sourcefile~hyperdual.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~hyperdual.f90~~AfferentGraph sourcefile~hyperdual.f90 hyperdual.f90 sourcefile~autodiff.f90 autodiff.f90 sourcefile~autodiff.f90->sourcefile~hyperdual.f90 sourcefile~armodel_adiff_api.f90 armodel_adiff_api.f90 sourcefile~armodel_adiff_api.f90->sourcefile~autodiff.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules hyperdual_mod Source Code hyperdual.f90 Source Code module hyperdual_mod !-| Hyperdual number definition & type declaration ! ! Original code provided by Philipp Rehner and Gernot Bauer, ! Institute of Thermodynamics and Thermal Process Engineering (ITT), ! University of Stuttgart, Stuttgart, Germany ! ! #### Hypderdual numbers ! ! Hypderdual numbers extend the idea of additional, non-real ! components from one non-real component (complex numbers) to four ! non-real components: \\f$\\varepsilon_1\\f$, \\f$\\varepsilon_2\\f$ and ! \\f$\\varepsilon_1 \\varepsilon_2\\f$. ! Hyperdual numbers require: \\f$(\\varepsilon_1)&#94;2 = 0\\f$, ! \\f$(\\varepsilon_2)&#94;2 = 0\\f$ and ! \\f$(\\varepsilon_1\\varepsilon_2)&#94;2 = 0\\f$ ! This leads to the fact, that the Taylor series of a function with ! hyperdual arguments can be truncated _exactly_ after the second ! derivative term: ! ! \\f[ !    f(\\mathbf{x} + h_1 \\varepsilon_1 + h_2 \\varepsilon_2 !      + h_1 h_2 \\varepsilon_1 \\varepsilon_2) !    = f(\\mathbf{x}) + h_1 f'(\\mathbf{x}) \\varepsilon_1 !      + h_2 f'(\\mathbf{x}) \\varepsilon_2 !      + h_1 h_2 f''(\\mathbf{x}) \\varepsilon_1 \\varepsilon_2 ! \\f] ! ! Because there is _no truncation error_, all first and second order ! derivatives can be obtained _exactly_, regardless of the step size '' ! \\f$h_1\\f$ and \\f$h_2\\f$. ! The derivatives can be obtained for a function \\f$ f(\\mathbf{x}) \\f$ ! with multiple variables \\f$ \\mathbf{x} \\in \\mathbb{R}&#94;n \\f$ via ! \\f{eqnarray*}{ !   \\frac{\\partial f(\\mathbf{x})}{\\partial x_i} &=& \\frac{ !     \\varepsilon_{1, \\mathrm{part}} \\Big\\{ !     f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e}_i !     + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big\\}} !     {h_1}\\\\ !   \\frac{\\partial f(\\mathbf{x})}{\\partial x_i} &=& \\frac{ !      \\varepsilon_{2, \\mathrm{part}} \\Big\\{ !      f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e}_i !      + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big\\}} !      {h_2}\\\\ !   \\frac{\\partial&#94;2 f(\\mathbf{x})}{\\partial x_i \\partial x_j} &=& !     \\frac{(\\varepsilon_1 \\varepsilon_2)_\\mathrm{part} \\Big\\{ !     f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e}_i !     + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big\\}} !     {h_1 h_2}  \\\\ ! \\f} ! where \\f$\\mathbf{e}_i\\f$ and \\f$\\mathbf{e}_j\\f$ are unit vectors, ! which are all zero except for the \\f$i\\f$-th and \\f$j\\f$-th ! component, respectively. ! ! #### Computation principles for hypderdual numbers ! ! Hyperdual numbers \\f$\\mathbf{x} \\in \\mathbb{HD}\\f$ can be expressed ! as tuples: \\f$\\mathbf{x} = [x_0, x_1, x_2, x_{12}] = x_0 ! + x_1 \\varepsilon_1 + x_2 \\varepsilon_2 ! + x_{12} \\varepsilon_1\\varepsilon_2\\f$. ! By using the Taylor expansion of the function \\f$f(\\mathbf{x})\\f$ ! one gets computation priniple for functions with hyperdual ! arguments from ! ! \\f[ !    f(\\mathbf{x}) = f(x_0) + x_1 f'(x_0) \\varepsilon_1 !    + x_2 f'(x_0) \\varepsilon_2 + \\big( x_{12} f'(x_0) !    + x_1 x_2 f''(x_0) \\big) \\varepsilon_1 \\varepsilon_2 ! \\f] ! ! A hyperdual number derived type is provided by: \\ref hyperdual. ! ! #### References ! ! [[1]](https://doi.org/10.2514/6.2011-886) !      Fike, Alonso: **The Development of Hyper-Dual Numbers for Exact !                      Second-Derivative Calculations.** !      _49th AIAA Aerospace Sciences Meeting including the New !       Horizons Forum and Aerospace Exposition_ (2011) \\n ! [[2]](https://doi.org/10.3389/fceng.2021.758090) !      Rehner, P. and Bauer, G.: **Application of Generalized !                                  (Hyper-) Dual Numbers in Equation !                                  of State Modeling.** !      Frontiers in Chemical Engineering_ (2021) \\n ! use yaeos_constants , only : pr implicit none type , bind ( c ) :: hyperdual !-| Derived type for hyperdual numbers ! !  Hyperdual numbers are represented by the tuple \\f$\\mathbf{f} = !  [f_0, f_1, f_2, f_{12}] = f_0 + f_1 \\varepsilon_1 !  + f_2 \\varepsilon_2 + f_{12} \\varepsilon_1 \\varepsilon_2 \\f$. !  Calculations specificaions are defined in module hyperdual_mod. ! sequence real ( pr ) :: f0 = 0 !| real part of the hyperdual number real ( pr ) :: f1 = 0 !| \\f$\\varepsilon_1\\f$-part of  the hyperdual number real ( pr ) :: f2 = 0 !| \\f$\\varepsilon_2\\f$-part of  the hyperdual number real ( pr ) :: f12 = 0 !| \\f$\\varepsilon_1\\varepsilon_2\\f$-part of the end type hyperdual !--------------------------------------------------------------------- !--- Operator interfaces --------------------------------------------- !--------------------------------------------------------------------- ! Equal assignment interface assignment ( = ) procedure EqualHyperDualHyperDual procedure EqualHyperDualReal end interface ! Unary operator + interface operator ( + ) procedure PlusHyperDualHyperDual end interface ! Addition operator interface operator ( + ) procedure AddHyperDualHyperDual procedure AddHyperDualReal procedure AddRealHyperDual end interface ! Unary operator - interface operator ( - ) procedure MinusHyperDualHyperDual end interface ! Subtraction operator interface operator ( - ) procedure SubtractHyperDualHyperDual procedure SubtractHyperDualReal procedure SubtractRealHyperDual end interface ! Multiplication operator interface operator ( * ) procedure MultiplyHyperDualHyperDual procedure MultiplyHyperDualReal procedure MultiplyRealHyperDual procedure MultiplyHyperDualInt procedure MultiplyIntHyperDual end interface ! Division operator interface operator ( / ) procedure DivideHyperDualHyperDual procedure DivideHyperDualReal procedure DivideRealHyperDual end interface ! Power operator interface operator ( ** ) procedure PowerHyperDualInt procedure PowerHyperDualHyperDual procedure PowerHyperDualReal end interface !--------------------------------------------------------------------- !--- Summation interface --------------------------------------------- !--------------------------------------------------------------------- interface sum module procedure SumHyperDual module procedure SumHyperDual2 end interface sum !--------------------------------------------------------------------- !--- Logical operator interfaces ------------------------------------- !--------------------------------------------------------------------- ! Equal operator. interface operator (. eq .) ! or (==) procedure eq_dd procedure eq_dr procedure eq_rd procedure eq_di procedure eq_id end interface ! Not equal operator. interface operator (. ne .) ! or (/=) procedure ne_dd procedure ne_dr procedure ne_rd procedure ne_di procedure ne_id end interface ! Less than operator. interface operator (. lt .) ! or (<) procedure lt_dd procedure lt_dr procedure lt_rd procedure lt_di procedure lt_id end interface ! Less than or equal operator. interface operator (. le .) ! or (<=) procedure le_dd procedure le_dr procedure le_rd procedure le_di procedure le_id end interface ! Greater than operator. interface operator (. gt .) ! or (>) procedure gt_dd procedure gt_dr procedure gt_rd procedure gt_di procedure gt_id end interface ! Greater than or equal operator. interface operator (. ge .) ! or (>=) procedure ge_dd procedure ge_dr procedure ge_rd procedure ge_di procedure ge_id end interface !--------------------------------------------------------------------- !--- Math function interfaces ---------------------------------------- !--------------------------------------------------------------------- ! Absolute value function interface abs module procedure absHyperDual end interface ! Integer function interface int module procedure intHyperDual end interface ! Nearest integer function interface nint module procedure nintHyperDual end interface ! Real function interface real module procedure realHyperDual end interface ! Sign function interface sign module procedure sign_dd module procedure sign_dr module procedure sign_rd end interface ! Sine function interface sin module procedure sinHyperDual end interface ! Cosine function interface cos module procedure cosHyperDual end interface ! Tangent function interface tan module procedure tanHyperDual end interface ! Sqrt function interface sqrt module procedure sqrtHyperDual end interface ! Log function interface log module procedure logHyperDual end interface ! Log10 function interface log10 module procedure log10HyperDual end interface ! Exp function interface exp module procedure expHyperDual end interface ! Sinh function interface sinh module procedure sinhHyperDual end interface ! Cosh function interface cosh module procedure coshHyperDual end interface ! Tanh function interface tanh module procedure tanhHyperDual end interface ! Acos function interface acos module procedure acosHyperDual end interface ! Asin function interface asin module procedure asinHyperDual end interface ! Atan function interface atan module procedure atanHyperDual end interface ! Atan2 function interface atan2 module procedure atan2HyperDual end interface ! Max function (limited to combinations below, but that ! can be extended) interface max module procedure max_dd module procedure max_ddd module procedure max_dr module procedure max_rd end interface ! Min function (limited for now to 2 arguments, but that ! can be extended) interface min module procedure min_dd module procedure min_dr module procedure min_rd end interface !===================================================================== contains !------------------------------------------------------------------- !--- Functions for the equal assignment. --------------------------- !------------------------------------------------------------------- elemental subroutine EqualHyperDualHyperDual ( res , inp ) implicit none type ( hyperdual ), intent ( out ) :: res type ( hyperdual ), intent ( in ) :: inp res % f0 = inp % f0 res % f1 = inp % f1 res % f2 = inp % f2 res % f12 = inp % f12 end subroutine EqualHyperDualHyperDual elemental subroutine EqualHyperDualReal ( res , inp ) implicit none type ( hyperdual ), intent ( out ) :: res real ( pr ), intent ( in ) :: inp res % f0 = inp res % f1 = 0.0_pr res % f2 = 0.0_pr res % f12 = 0.0_pr end subroutine EqualHyperDualReal !------------------------------------------------------------------- !--- Function for the unary operator +. ---------------------------- !------------------------------------------------------------------- elemental function PlusHyperDualHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 v2 % f0 = v1 % f0 v2 % f1 = v1 % f1 v2 % f2 = v1 % f2 v2 % f12 = v1 % f12 end function PlusHyperDualHyperDual !------------------------------------------------------------------- !--- Functions for the addition operator. -------------------------- !------------------------------------------------------------------- elemental function AddHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 + v2 % f0 v3 % f1 = v1 % f1 + v2 % f1 v3 % f2 = v1 % f2 + v2 % f2 v3 % f12 = v1 % f12 + v2 % f12 end function AddHyperDualHyperDual elemental function AddHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 + v2 v3 % f1 = v1 % f1 v3 % f2 = v1 % f2 v3 % f12 = v1 % f12 end function AddHyperDualReal elemental function AddRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 + v2 % f0 v3 % f1 = v2 % f1 v3 % f2 = v2 % f2 v3 % f12 = v2 % f12 end function AddRealHyperDual !------------------------------------------------------------------- !--- Function for the unary operator -. ---------------------------- !------------------------------------------------------------------- elemental function MinusHyperDualHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 v2 % f0 = - v1 % f0 v2 % f1 = - v1 % f1 v2 % f2 = - v1 % f2 v2 % f12 = - v1 % f12 end function MinusHyperDualHyperDual !------------------------------------------------------------------- !--- Functions for the subtraction operator. ----------------------- !------------------------------------------------------------------- elemental function SubtractHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 - v2 % f0 v3 % f1 = v1 % f1 - v2 % f1 v3 % f2 = v1 % f2 - v2 % f2 v3 % f12 = v1 % f12 - v2 % f12 end function SubtractHyperDualHyperDual elemental function SubtractHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 - v2 v3 % f1 = v1 % f1 v3 % f2 = v1 % f2 v3 % f12 = v1 % f12 end function SubtractHyperDualReal elemental function SubtractRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 - v2 % f0 v3 % f1 = - v2 % f1 v3 % f2 = - v2 % f2 v3 % f12 = - v2 % f12 end function SubtractRealHyperDual !------------------------------------------------------------------- !--- Functions for the multiplication operator. -------------------- !------------------------------------------------------------------- elemental function MultiplyHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 * v2 % f0 v3 % f1 = v1 % f0 * v2 % f1 + v1 % f1 * v2 % f0 v3 % f2 = v1 % f0 * v2 % f2 + v1 % f2 * v2 % f0 v3 % f12 = v1 % f0 * v2 % f12 + v1 % f1 * v2 % f2 + v1 % f2 * v2 % f1 + v1 % f12 * v2 % f0 end function MultiplyHyperDualHyperDual elemental function MultiplyHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 * v2 v3 % f1 = v1 % f1 * v2 v3 % f2 = v1 % f2 * v2 v3 % f12 = v1 % f12 * v2 end function MultiplyHyperDualReal elemental function MultiplyRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 * v2 % f0 v3 % f1 = v1 * v2 % f1 v3 % f2 = v1 * v2 % f2 v3 % f12 = v1 * v2 % f12 end function MultiplyRealHyperDual elemental function MultiplyHyperDualInt ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 integer , intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 * v2 v3 % f1 = v1 % f1 * v2 v3 % f2 = v1 % f2 * v2 v3 % f12 = v1 % f12 * v2 end function MultiplyHyperDualInt elemental function MultiplyIntHyperDual ( v1 , v2 ) result ( v3 ) integer , intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 * v2 % f0 v3 % f1 = v1 * v2 % f1 v3 % f2 = v1 * v2 % f2 v3 % f12 = v1 * v2 % f12 end function MultiplyIntHyperDual !------------------------------------------------------------------- !--- Functions for the division operator. -------------------------- !------------------------------------------------------------------- elemental function DivideHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 = v1 * v2 ** ( - 1 ) end function DivideHyperDualHyperDual elemental function DivideHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ) :: invV2 invV2 = 1.0_pr / v2 v3 = v1 * invV2 end function DivideHyperDualReal elemental function DivideRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: invV2 , v3 invV2 = 1.0_pr * v2 ** ( - 1.0_pr ) v3 = v1 * invV2 end function DivideRealHyperDual !------------------------------------------------------------------- !--- Functions for the power operator. ----------------------------- !------------------------------------------------------------------- elemental function PowerHyperDualInt ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 integer , intent ( in ) :: v2 integer :: i , vv2 type ( hyperdual ) :: v3 v3 = 1.0_pr vv2 = abs ( v2 ) do i = 1 , vv2 v3 = v3 * v1 enddo if ( v2 < 0 ) v3 = 1.0_pr / v3 end function PowerHyperDualInt elemental function PowerHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 , v4 v4 = logHyperDual ( v1 ) v3 = expHyperDual ( v2 * v4 ) end function PowerHyperDualHyperDual elemental function PowerHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ), parameter :: tol = 1.0e-15_pr real ( pr ) :: xval , deriv xval = v1 % f0 if ( abs ( xval ) < tol ) then if ( xval >= 0.0_pr ) then xval = tol else xval = - tol endif endif deriv = v2 * ( xval ** ( v2 - 1.0_pr )) v3 % f0 = ( v1 % f0 ) ** v2 v3 % f1 = v1 % f1 * deriv v3 % f2 = v1 % f2 * deriv v3 % f12 = v1 % f12 * deriv & & + v2 * ( v2 - 1.0_pr ) * v1 % f1 * v1 % f2 * xval ** ( v2 - 2.0_pr ) end function PowerHyperDualReal !------------------------------------------------------------------- !--- Sum ----------------------------------------------------------- !------------------------------------------------------------------- pure type ( hyperdual ) function SumHyperDual ( v1 , mask ) type ( hyperdual ), intent ( in ) :: v1 (:) logical , intent ( in ), optional :: mask (:) integer :: i SumHyperDual = hyperdual ( 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr ) if ( present ( mask )) then do i = 1 , size ( v1 ) if ( mask ( i )) SumHyperDual = SumHyperDual + v1 ( i ) end do else do i = 1 , size ( v1 ) SumHyperDual = SumHyperDual + v1 ( i ) end do end if end function SumHyperDual pure function SumHyperDual2 ( v1 , dim ) type ( hyperdual ), intent ( in ) :: v1 (:,:) integer , intent ( in ) :: dim type ( hyperdual ), allocatable :: SumHyperDual2 (:) integer :: i allocate ( SumHyperDual2 ( size ( v1 ) / size ( v1 , dim ))) SumHyperDual2 = hyperdual ( 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr ) do i = 1 , size ( v1 , dim ) if ( dim == 1 ) then SumHyperDual2 = SumHyperDual2 + v1 ( i ,:) else SumHyperDual2 = SumHyperDual2 + v1 (:, i ) end if end do end function SumHyperDual2 !------------------------------------------------------------------- !--- Functions for the equal operator. ----------------------------- !------------------------------------------------------------------- logical function eq_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs eq_dd = lhs % f0 == rhs % f0 end function eq_dd elemental logical function eq_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs eq_dr = lhs % f0 == rhs end function eq_dr elemental logical function eq_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs eq_rd = lhs == rhs % f0 end function eq_rd logical function eq_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs eq_di = lhs % f0 == rhs end function eq_di logical function eq_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs eq_id = lhs == rhs % f0 end function eq_id !------------------------------------------------------------------- !--- Functions for the not equal operator. ------------------------- !------------------------------------------------------------------- logical function ne_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs ne_dd = lhs % f0 /= rhs % f0 end function ne_dd logical function ne_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs ne_dr = lhs % f0 /= rhs end function ne_dr logical function ne_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ne_rd = lhs /= rhs % f0 end function ne_rd logical function ne_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs ne_di = lhs % f0 /= rhs end function ne_di logical function ne_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ne_id = lhs /= rhs % f0 end function ne_id !------------------------------------------------------------------- !--- Functions for the less than operator. ------------------------- !------------------------------------------------------------------- logical function lt_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs lt_dd = lhs % f0 < rhs % f0 end function lt_dd logical function lt_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs lt_dr = lhs % f0 < rhs end function lt_dr logical function lt_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs lt_rd = lhs < rhs % f0 end function lt_rd logical function lt_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs lt_di = lhs % f0 < rhs end function lt_di logical function lt_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs lt_id = lhs < rhs % f0 end function lt_id !------------------------------------------------------------------- !--- Functions for the less than or equal operator. ---------------- !------------------------------------------------------------------- logical function le_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs le_dd = lhs % f0 <= rhs % f0 end function le_dd logical function le_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs le_dr = lhs % f0 <= rhs end function le_dr logical function le_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs le_rd = lhs <= rhs % f0 end function le_rd logical function le_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs le_di = lhs % f0 <= rhs end function le_di logical function le_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs le_id = lhs <= rhs % f0 end function le_id !------------------------------------------------------------------- !--- Functions for the greater than operator. ---------------------- !------------------------------------------------------------------- logical function gt_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs gt_dd = lhs % f0 > rhs % f0 end function gt_dd logical function gt_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs gt_dr = lhs % f0 > rhs end function gt_dr logical function gt_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs gt_rd = lhs > rhs % f0 end function gt_rd logical function gt_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs gt_di = lhs % f0 > rhs end function gt_di logical function gt_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs gt_id = lhs > rhs % f0 end function gt_id !------------------------------------------------------------------- !--- Functions for the greater than or equal operator. ------------- !------------------------------------------------------------------- logical function ge_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs ge_dd = lhs % f0 >= rhs % f0 end function ge_dd logical function ge_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs ge_dr = lhs % f0 >= rhs end function ge_dr logical function ge_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ge_rd = lhs >= rhs % f0 end function ge_rd logical function ge_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs ge_di = lhs % f0 >= rhs end function ge_di logical function ge_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ge_id = lhs >= rhs % f0 end function ge_id !------------------------------------------------------------------- !--- Math functions. ----------------------------------------------- !------------------------------------------------------------------- ! Absolute value function. elemental function absHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 if ( v1 % f0 >= 0.0 ) then v2 % f0 = v1 % f0 v2 % f1 = v1 % f1 v2 % f2 = v1 % f2 v2 % f12 = v1 % f12 else v2 % f0 = - v1 % f0 v2 % f1 = - v1 % f1 v2 % f2 = - v1 % f2 v2 % f12 = - v1 % f12 endif end function absHyperDual ! Integer function. elemental function intHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 integer :: v2 v2 = int ( v1 % f0 ) end function intHyperDual ! Nearest integer function. elemental function nintHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 integer :: v2 v2 = nint ( v1 % f0 ) end function nintHyperDual ! Real function. elemental function realHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ) :: v2 v2 = v1 % f0 end function realHyperDual ! Functions for the sign function. elemental function sign_dd ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 real ( pr ) :: ssign if ( v2 % f0 < 0.0 ) then ssign = - 1.0 else ssign = 1.0 endif v3 = ssign * v1 end function sign_dd elemental function sign_dr ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ) :: ssign if ( v2 < 0.0 ) then ssign = - 1.0 else ssign = 1.0 endif v3 = ssign * v1 end function sign_dr elemental function sign_rd ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ) :: ssign if ( v2 % f0 < 0.0 ) then ssign = - 1.0 else ssign = 1.0 endif v3 = ssign * v1 end function sign_rd ! Sine function. elemental function sinHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: f , dx f = sin ( v1 % f0 ) dx = cos ( v1 % f0 ) v2 % f0 = f v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * v1 % f12 - f * v1 % f1 * v1 % f2 end function sinHyperDual ! Cosine function. elemental function cosHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: f , dx f = cos ( v1 % f0 ) dx = - sin ( v1 % f0 ) v2 % f0 = f v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * v1 % f12 - f * v1 % f1 * v1 % f2 end function cosHyperDual ! Tangent function. elemental function tanHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: f , dx f = tan ( v1 % f0 ) dx = f * f + 1.0_pr v2 % f0 = f v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * v1 % f12 + v1 % f1 * v1 % f2 * 2.0_pr * f * dx end function tanHyperDual ! Sqrt function elemental function sqrtHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ), parameter :: expo = 3.0_pr / 2.0_pr real ( pr ) :: square square = sqrt ( v1 % f0 ) v2 % f0 = square v2 % f1 = 0.5_pr / square * v1 % f1 v2 % f2 = 0.5_pr / square * v1 % f2 v2 % f12 = 0.5_pr * v1 % f12 / square - 0.25_pr * v1 % f1 * v1 % f2 / ( v1 % f0 ** expo ) end function sqrtHyperDual ! Log function elemental function logHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: dx1 , dx2 dx1 = v1 % f1 / v1 % f0 dx2 = v1 % f2 / v1 % f0 v2 % f0 = log ( v1 % f0 ) v2 % f1 = dx1 v2 % f2 = dx2 v2 % f12 = v1 % f12 / v1 % f0 - ( dx1 * dx2 ) end function logHyperDual ! Log10 function elemental function log10HyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 v2 = log ( v1 ) / log ( 1 0.0_pr ) end function log10HyperDual ! Exp function elemental function expHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: dx dx = exp ( v1 % f0 ) v2 % f0 = dx v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * ( v1 % f12 + v1 % f1 * v1 % f2 ) end function expHyperDual ! Sinh function elemental function sinhHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: t1 , t2 , v2 t1 = exp ( v1 ) t2 = exp ( - v1 ) v2 = 0.5_pr * ( t1 - t2 ) end function sinhHyperDual ! Cosh function elemental function coshHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: t1 , t2 , v2 t1 = exp ( v1 ) t2 = exp ( - v1 ) v2 = 0.5_pr * ( t1 + t2 ) end function coshHyperDual ! Tanh function elemental function tanhHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: t1 , t2 , v2 t1 = exp ( v1 ) t2 = exp ( - v1 ) v2 = ( t1 - t2 ) / ( t1 + t2 ) end function tanhHyperDual ! Acos function elemental function acosHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: deriv , deriv1 deriv1 = 1.0_pr - v1 % f0 * v1 % f0 deriv = - 1.0_pr / sqrt ( deriv1 ) v2 % f0 = acos ( v1 % f0 ) v2 % f1 = deriv * v1 % f1 v2 % f2 = deriv * v1 % f2 v2 % f12 = deriv * v1 % f12 & & + v1 % f1 * v1 % f2 * ( - v1 % f0 * deriv1 ** ( - 1.5_pr )) end function acosHyperDual ! Asin function elemental function asinHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: deriv , deriv1 deriv1 = 1.0_pr - v1 % f0 * v1 % f0 deriv = 1.0_pr / sqrt ( deriv1 ) v2 % f0 = asin ( v1 % f0 ) v2 % f1 = deriv * v1 % f1 v2 % f2 = deriv * v1 % f2 v2 % f12 = deriv * v1 % f12 & & + v1 % f1 * v1 % f2 * ( v1 % f0 * deriv1 ** ( - 1.5_pr )) end function asinHyperDual ! Atan function elemental function atanHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: deriv , deriv1 deriv1 = 1.0_pr + v1 % f0 * v1 % f0 deriv = 1.0_pr / deriv1 v2 % f0 = atan ( v1 % f0 ) v2 % f1 = deriv * v1 % f1 v2 % f2 = deriv * v1 % f2 v2 % f12 = deriv * v1 % f12 & & + v1 % f1 * v1 % f2 * ( - 2.0_pr * v1 % f0 / ( deriv1 * deriv1 )) end function atanHyperDual ! Atan2 function elemental function atan2HyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 real ( pr ) :: a , b , c , d a = v1 % f0 b = v1 % f1 c = v2 % f0 d = v2 % f1 v3 % f0 = atan2 ( a , c ) v3 % f1 = ( c * b - a * d ) / ( a * a + c * c ) end function atan2HyperDual ! Max functions elemental function max_dd ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 if ( v1 % f0 > v2 % f0 ) then v3 = v1 else v3 = v2 endif end function max_dd elemental function max_ddd ( v1 , v2 , v3 ) result ( v4 ) type ( hyperdual ), intent ( in ) :: v1 , v2 , v3 type ( hyperdual ) :: v4 if ( v1 % f0 > v2 % f0 ) then v4 = v1 else v4 = v2 endif if ( v3 % f0 > v4 % f0 ) v4 = v3 end function max_ddd elemental function max_dr ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 % f0 > v2 ) then v3 = v1 else v3 = v2 endif end function max_dr elemental function max_rd ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 > v2 % f0 ) then v3 = v1 else v3 = v2 endif end function max_rd ! Min functions elemental function min_dd ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 if ( v1 % f0 < v2 % f0 ) then v3 = v1 else v3 = v2 endif end function min_dd elemental function min_dr ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 % f0 < v2 ) then v3 = v1 else v3 = v2 endif end function min_dr elemental function min_rd ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 < v2 % f0 ) then v3 = v1 else v3 = v2 endif end function min_rd end module","tags":"","loc":"sourcefile/hyperdual.f90.html"},{"title":"tapenade_ar_api.f90 – Yaeos","text":"This file depends on sourcefile~~tapenade_ar_api.f90~~EfferentGraph sourcefile~tapenade_ar_api.f90 tapenade_ar_api.f90 sourcefile~constants.f90 constants.f90 sourcefile~tapenade_ar_api.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_tapenade_ar_api Source Code tapenade_ar_api.f90 Source Code module yaeos_tapenade_ar_api !! Module that wraps tapenade generated routines to calculate ! !! Ar and derivatives. use yaeos_constants , only : pr implicit none private abstract interface subroutine tapenade_ar ( n , v , t , arval ) import pr real ( pr ), intent ( in ) :: n (:), v , t real ( pr ), intent ( out ) :: arval end subroutine subroutine tapenade_ar_d ( n , nd , v , vd , t , td , arval , arvald ) import pr real ( pr ), intent ( in ) :: n (:), v , t real ( pr ), intent ( in ) :: nd (:), vd , td real ( pr ), intent ( out ) :: arval , arvald end subroutine subroutine tapenade_ar_b ( n , nb , v , vb , t , tb , arval , arvalb ) import pr real ( pr ), intent ( in ) :: n (:), v , t real ( pr ) :: arvalb real ( pr ) :: nb (:), vb , tb real ( pr ) :: arval end subroutine subroutine tapenade_ar_d_b ( n , nb , v , vb , t , tb , arval , arvalb ) import pr real ( pr ), intent ( in ) :: n (:), v , t real ( pr ) :: arvalb real ( pr ) :: nb (:), vb , tb real ( pr ) :: arval end subroutine subroutine tapenade_ar_d_d ( n , nd , v , vd0 , vd , t , td0 , td , & arval , arvald0 , arvald , arvaldd ) import pr real ( pr ), intent ( in ) :: n (:), v , t real ( pr ), intent ( in ) :: vd0 , td0 real ( pr ), intent ( in ) :: nd (:), vd , td real ( pr ), intent ( out ) :: arval , arvald0 , arvald , arvaldd end subroutine end interface contains subroutine residual_helmholtz ( & n , v , t , & ar , dardn , dardv , dardt , & dardn2 , darnv , dardnt , dardvt , dardv2 , dardt2 & ) real ( pr ), intent ( in ) :: n (:), v , t real ( pr ), optional , intent ( out ) :: ar , dardn ( size ( n )), dardv , dardt real ( pr ), optional , intent ( out ) :: dardn2 ( size ( n ), size ( n )), darnv ( size ( n )), dardnt ( size ( n )) real ( pr ), optional , intent ( out ) :: dardvt , dardv2 , dardt2 end subroutine end module","tags":"","loc":"sourcefile/tapenade_ar_api.f90.html"},{"title":"armodel_adiff_api.f90 – Yaeos","text":"This file depends on sourcefile~~armodel_adiff_api.f90~~EfferentGraph sourcefile~armodel_adiff_api.f90 armodel_adiff_api.f90 sourcefile~constants.f90 constants.f90 sourcefile~armodel_adiff_api.f90->sourcefile~constants.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~armodel_adiff_api.f90->sourcefile~ar_models.f90 sourcefile~autodiff.f90 autodiff.f90 sourcefile~armodel_adiff_api.f90->sourcefile~autodiff.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~hyperdual.f90 hyperdual.f90 sourcefile~autodiff.f90->sourcefile~hyperdual.f90 sourcefile~hyperdual.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_ar_models_hyperdual Source Code armodel_adiff_api.f90 Source Code module yaeos_ar_models_hyperdual !-| Module that contains the automatic differentiation logic for an Ar model use yaeos_constants , only : pr use yaeos_models_ar , only : ArModel use yaeos_autodiff implicit none type , abstract , extends ( ArModel ) :: ArModelAdiff contains procedure ( hyperdual_ar ), deferred :: Ar procedure :: residual_helmholtz => residual_helmholtz end type abstract interface type ( hyperdual ) function hyperdual_Ar ( self , n , v , t ) import hyperdual , ArModelAdiff class ( ArModelAdiff ) :: self type ( hyperdual ), intent ( in ) :: n (:) type ( hyperdual ), intent ( in ) :: v type ( hyperdual ), intent ( in ) :: t end function end interface contains subroutine residual_helmholtz (& self , n , v , t , Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) class ( ArModelAdiff ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: v , t real ( pr ), optional , intent ( out ) :: Ar , ArV , ArT , ArT2 , ArTV , ArV2 real ( pr ), optional , dimension ( size ( n )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) type ( hyperdual ) :: d_v , d_t , d_n ( size ( n )) type ( hyperdual ) :: d_Ar if ( present ( ArV )) then if ( present ( ArV2 )) call get_dardv2 if ( present ( ArVn )) call get_dardvn if ( present ( ArTV )) call get_dardvt if (. not . ( present ( ArV2 ) . and . present ( ArVn ) . and . present ( ArTV ))) & call get_dardv end if if ( present ( ArT )) then if ( present ( ArT2 )) call get_dardt2 if ( present ( ArTn )) call get_dardtn if (. not . ( present ( ArT2 ) . and . present ( ArTn ))) call get_dardt end if if ( present ( Arn )) then if ( present ( Arn2 )) then call get_dardn2 else call get_dardn end if end if contains subroutine get_dardn () integer :: i , j do i = 1 , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i ) = d_Ar % f1 end do end subroutine subroutine get_dardn2 () integer :: i , j do i = 1 , size ( n ) do j = i , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_n ( j )% f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i ) = d_Ar % f1 Arn2 ( i , j ) = d_Ar % f12 Arn2 ( j , i ) = d_Ar % f12 end do end do end subroutine subroutine get_dardvn () integer :: i do i = 1 , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_v % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i ) = d_Ar % f1 ArV = d_Ar % f2 ArVn ( i ) = d_Ar % f12 end do end subroutine subroutine get_dardtn () integer :: i do i = 1 , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_t % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i ) = d_Ar % f1 ArT = d_Ar % f2 ArTn ( i ) = d_Ar % f12 end do end subroutine subroutine get_dardv () call reset_vars d_v % f1 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArV = d_Ar % f1 end subroutine subroutine get_dardt () call reset_vars d_t % f1 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArT = d_Ar % f1 end subroutine subroutine get_dardt2 () call reset_vars d_t % f1 = 1 d_t % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArT = d_Ar % f1 ArT2 = d_Ar % f12 end subroutine subroutine get_dardv2 () call reset_vars d_v % f1 = 1 d_v % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArV = d_Ar % f1 ArV2 = d_Ar % f12 end subroutine subroutine get_dardvt () call reset_vars d_v % f1 = 1 d_t % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArV = d_Ar % f1 ArTV = d_Ar % f12 end subroutine subroutine reset_vars () d_n = n d_v = v d_t = t end subroutine end subroutine end module","tags":"","loc":"sourcefile/armodel_adiff_api.f90.html"},{"title":"ar_interface.f90 – Yaeos","text":"This file depends on sourcefile~~ar_interface.f90~~EfferentGraph sourcefile~ar_interface.f90 ar_interface.f90 sourcefile~constants.f90 constants.f90 sourcefile~ar_interface.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~ar_interface.f90~~AfferentGraph sourcefile~ar_interface.f90 ar_interface.f90 sourcefile~legacy.f90 legacy.f90 sourcefile~legacy.f90->sourcefile~ar_interface.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ar_interface Source Code ar_interface.f90 Source Code module ar_interface !-| Generic interfaces to an ArModel compatible with legacy codes, using !   pointers. use yaeos_constants , only : pr , R use iso_fortran_env , only : error_unit implicit none procedure ( Ares ), pointer :: ar_fun procedure ( initial_volume ), pointer :: vinit abstract interface subroutine Ares ( z , v , t , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) !| Residual Helmholtz model interface import pr real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( in ) :: v , t real ( pr ), intent ( out ) :: Ar , ArV , ArTV , ArV2 real ( pr ), dimension ( size ( z )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) end subroutine function initial_volume ( z , p , t ) import pr real ( pr ) :: z (:) real ( pr ) :: p real ( pr ) :: t real ( pr ) :: initial_volume end function end interface end module","tags":"","loc":"sourcefile/ar_interface.f90.html"},{"title":"legacy.f90 – Yaeos","text":"This file depends on sourcefile~~legacy.f90~~EfferentGraph sourcefile~legacy.f90 legacy.f90 sourcefile~constants.f90 constants.f90 sourcefile~legacy.f90->sourcefile~constants.f90 sourcefile~ar_interface.f90 ar_interface.f90 sourcefile~legacy.f90->sourcefile~ar_interface.f90 sourcefile~ar_interface.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules legacy_ar_models legacy_thermo_properties Source Code legacy.f90 Source Code module legacy_ar_models !! Legacy Thermodynamic routines !! Module for a cubic eos system, made with the intention to keep !! compatiblity with legacy codes but with a better structure. !! this should be later adapted into a simple oop system where an eos object !! stores the relevant parameters (or some functional oriented approach) use yaeos_constants , only : pr , R use ar_interface , only : ar_fun , vinit implicit none ! Model settings integer :: thermo_model !! Which thermodynamic model to use integer :: tdep !! Temperature dependance of kij integer :: mixing_rule !! What mixing rule to use integer :: nc !! Number of components ! Mole fractions real ( pr ), allocatable :: z (:) !! Mole fractions vector ! ========================================================================== !  Cubic EoS Possible parameters ! -------------------------------------------------------------------------- ! Critical constants real ( pr ), allocatable :: tc (:) !| Critical temperature [K] real ( pr ), allocatable :: pc (:) !| Critical pressure [bar] real ( pr ), allocatable :: dc (:) !| Critical density [mol/L] real ( pr ), allocatable :: w (:) !| Acentric factor ! Model parameters real ( pr ), allocatable :: ac (:) !| Critical attractive parameter [bar (L/mol)&#94;2] real ( pr ), allocatable :: b (:) !| repulsive parameter [L] real ( pr ), allocatable :: del1 (:) !| \\delta_1 parameter real ( pr ), allocatable :: k (:) !| Attractive parameter constant ! Classic VdW mixing rules parameters real ( pr ), allocatable :: kij (:, :) !| Attractive BIP real ( pr ), allocatable :: lij (:, :) !| Repulsive BIP real ( pr ), allocatable :: bij (:, :) ! T dependant mixing rule parameters real ( pr ), allocatable :: kij0 (:, :), kinf (:, :), tstar (:, :) ! ========================================================================== contains ! ========================================================================== !  Initializer routines ! -------------------------------------------------------------------------- subroutine setup ( n , nmodel , ntdep , ncomb ) !! Setup the basics variables that describe the model. ! TODO: With a more integrated legacy code maybe this can be !       avoided or at least better set up integer , intent ( in ) :: n !! Number of components integer , intent ( in ) :: nmodel !! Number of model integer , intent ( in ) :: ntdep !! Kij dependant of temperature integer , intent ( in ) :: ncomb !! Combining rule thermo_model = nmodel tdep = ntdep mixing_rule = ncomb nc = n if ( allocated ( tc )) deallocate ( tc ) if ( allocated ( pc )) deallocate ( pc ) if ( allocated ( dc )) deallocate ( dc ) if ( allocated ( w )) deallocate ( w ) if ( allocated ( ac )) deallocate ( ac ) if ( allocated ( b )) deallocate ( b ) if ( allocated ( del1 )) deallocate ( del1 ) if ( allocated ( k )) deallocate ( k ) if ( allocated ( kij )) deallocate ( kij ) if ( allocated ( lij )) deallocate ( lij ) if ( allocated ( kinf )) deallocate ( kinf ) if ( allocated ( tstar )) deallocate ( tstar ) if ( allocated ( bij )) deallocate ( bij ) allocate ( tc ( n )) allocate ( pc ( n )) allocate ( dc ( n )) allocate ( w ( n )) allocate ( ac ( n )) allocate ( b ( n )) allocate ( del1 ( n )) allocate ( k ( n )) allocate ( kij ( n , n )) allocate ( lij ( n , n )) allocate ( kinf ( n , n )) allocate ( tstar ( n , n )) allocate ( bij ( n , n )) end subroutine setup subroutine PR78_factory ( moles_in , ac_in , b_in , tc_in , pc_in , w_in , k_in ) !! PengRobinson 78 factory !! !! Takes either the critical parameters or the fitted model parameters !! and gets ones in base of the others real ( pr ), intent ( in ) :: moles_in ( nc ) real ( pr ), optional , intent ( in ) :: ac_in ( nc ) real ( pr ), optional , intent ( in ) :: b_in ( nc ) real ( pr ), optional , intent ( in ) :: tc_in ( nc ) real ( pr ), optional , intent ( in ) :: pc_in ( nc ) real ( pr ), optional , intent ( in ) :: w_in ( nc ) real ( pr ), optional , intent ( in ) :: k_in ( nc ) integer :: i logical :: params_spec , critical_spec real ( pr ) :: zc ( nc ), oma ( nc ), omb ( nc ) real ( pr ) :: vceos ( nc ), al , be , ga ( nc ) real ( pr ) :: RTc ( nc ) ar_fun => ar_srkpr vinit => cubic_v0 del1 = 1 + sqrt ( 2.0_pr ) z = moles_in params_spec = ( present ( ac_in ) . and . present ( b_in ) . and . present ( k_in )) critical_spec = ( present ( tc_in ) . and . present ( pc_in ) . and . present ( w_in )) if ( params_spec ) then ac = ac_in b = b_in k = k_in call get_Zc_OMa_OMb ( del1 , zc , oma , omb ) Tc = OMb * ac / ( OMa * R * b ) RTc = R * Tc Pc = OMb * RTc / b Vceos = Zc * RTc / Pc al = - 0.26992 be = 1.54226 ga = 0.37464 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al else if ( critical_spec ) then tc = tc_in pc = pc_in w = w_in RTc = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RTc ** 2 / Pc b = OMb * RTc / Pc Vceos = Zc * RTc / Pc ! k (or m) constant to calculate attractive parameter depending on temperature do i = 1 , nc if ( w ( i ) <= 0.491 ) then ! m from PR k ( i ) = 0.37464 + 1.54226 * w ( i ) - 0.26992 * w ( i ) ** 2 else ! PR78 k ( i ) = 0.379642 + 1.48503 * w ( i ) - 0.164423 * w ( i ) ** 2 + 0.016666 * w ( i ) ** 3 end if end do end if end subroutine subroutine PR76_factory ( moles_in , ac_in , b_in , tc_in , pc_in , w_in , k_in ) !! PengRobinson 76 factory !! !! Takes either the critical parameters or the fitted model parameters !! and gets ones in base of the others real ( pr ), intent ( in ) :: moles_in ( nc ) real ( pr ), optional , intent ( in ) :: ac_in ( nc ) real ( pr ), optional , intent ( in ) :: b_in ( nc ) real ( pr ), optional , intent ( in ) :: tc_in ( nc ) real ( pr ), optional , intent ( in ) :: pc_in ( nc ) real ( pr ), optional , intent ( in ) :: w_in ( nc ) real ( pr ), optional , intent ( in ) :: k_in ( nc ) integer :: i logical :: params_spec , critical_spec real ( pr ) :: zc ( nc ), oma ( nc ), omb ( nc ) real ( pr ) :: vceos ( nc ), al , be , ga ( nc ) real ( pr ) :: RTc ( nc ) ar_fun => ar_srkpr vinit => cubic_v0 del1 = 1 + sqrt ( 2.0_pr ) z = moles_in params_spec = ( present ( ac_in ) . and . present ( b_in ) . and . present ( k_in )) critical_spec = ( present ( tc_in ) . and . present ( pc_in ) . and . present ( w_in )) if ( params_spec ) then ac = ac_in b = b_in k = k_in call get_Zc_OMa_OMb ( del1 , zc , oma , omb ) Tc = OMb * ac / ( OMa * R * b ) RTc = R * Tc Pc = OMb * RTc / b Vceos = Zc * RTc / Pc al = - 0.26992 be = 1.54226 ga = 0.37464 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al else if ( critical_spec ) then tc = tc_in pc = pc_in w = w_in RTc = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RTc ** 2 / Pc b = OMb * RTc / Pc Vceos = Zc * RTc / Pc ! k (or m) constant to calculate attractive parameter depending on temperature do i = 1 , nc k ( i ) = 0.37464 + 1.54226 * w ( i ) - 0.26992 * w ( i ) ** 2 end do end if ! ac = 0.45723553_pr * R**2 * tc**2 / pc ! b = 0.07779607_pr * R * tc/pc ! k = 0.37464_pr + 1.54226_pr * w - 0.26993_pr * w**2 end subroutine subroutine SRK_factory ( moles_in , ac_in , b_in , tc_in , pc_in , w_in , k_in ) !! SoaveRedlichKwong factory !! !! Takes either the critical parameters or the fitted model parameters !! and gets ones in base of the others real ( pr ), intent ( in ) :: moles_in ( nc ) real ( pr ), optional , intent ( in ) :: ac_in ( nc ) real ( pr ), optional , intent ( in ) :: b_in ( nc ) real ( pr ), optional , intent ( in ) :: tc_in ( nc ) real ( pr ), optional , intent ( in ) :: pc_in ( nc ) real ( pr ), optional , intent ( in ) :: w_in ( nc ) real ( pr ), optional , intent ( in ) :: k_in ( nc ) logical :: params_spec , critical_spec real ( pr ) :: zc ( nc ), oma ( nc ), omb ( nc ) real ( pr ) :: vceos ( nc ), al , be , ga ( nc ) real ( pr ) :: RTc ( nc ) integer :: i , j ar_fun => ar_srkpr vinit => cubic_v0 del1 = 1 z = moles_in params_spec = ( present ( ac_in ) . and . present ( b_in ) . and . present ( k_in )) critical_spec = ( present ( tc_in ) . and . present ( pc_in ) . and . present ( w_in )) if ( params_spec ) then ac = ac_in b = b_in k = k_in call get_Zc_OMa_OMb ( del1 , zc , oma , omb ) Tc = OMb * ac / ( OMa * R * b ) RTc = R * Tc Pc = OMb * RTc / b Vceos = Zc * RTc / Pc dc = 1 / vceos al = - 0.26992 be = 1.54226 ga = 0.37464 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al else if ( critical_spec ) then tc = tc_in pc = pc_in w = w_in RTc = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RTc ** 2 / Pc b = OMb * RTc / Pc Vceos = Zc * RTc / Pc k = 0.48 + 1.574 * w - 0.175 * w ** 2 end if end subroutine subroutine get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) !! Calculate Zc, OMa and OMb from the delta_1 parameter. real ( pr ), intent ( in ) :: del1 (:) !! delta_1 parameter real ( pr ), intent ( out ) :: Zc (:) !! Critical compressibility factor real ( pr ), intent ( out ) :: OMa (:) !! OMa real ( pr ), intent ( out ) :: OMb (:) !! OMb real ( pr ) :: d1 ( size ( del1 )), y ( size ( del1 )) d1 = ( 1._pr + del1 ** 2._pr ) / ( 1._pr + del1 ) y = 1._pr + ( 2._pr * ( 1._pr + del1 )) ** ( 1.0_pr / 3._pr ) + ( 4._pr / ( 1._pr + del1 )) ** ( 1.0_pr / 3 ) OMa = ( 3._pr * y * y + 3._pr * y * d1 + d1 ** 2._pr + d1 - 1.0_pr ) / ( 3._pr * y + d1 - 1.0_pr ) ** 2._pr OMb = 1._pr / ( 3._pr * y + d1 - 1.0_pr ) Zc = y / ( 3._pr * y + d1 - 1.0_pr ) end subroutine get_Zc_OMa_OMb ! ========================================================================== ! ========================================================================== !  Ar Functions ! -------------------------------------------------------------------------- subroutine ar_srkpr ( z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) !! Wrapper subroutine to the SRK/PR Residula Helmholtz function to !! use the general interface real ( pr ), intent ( in ) :: z (:) !! Number of moles real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( out ) :: ar !! Residual Helmholtz real ( pr ), intent ( out ) :: arv !! dAr/dV real ( pr ), intent ( out ) :: artv !! dAr2/dTV real ( pr ), intent ( out ) :: arv2 !! dAr2/dV2 real ( pr ), intent ( out ) :: Arn ( size ( z )) !! dAr/dn real ( pr ), intent ( out ) :: ArVn ( size ( z )) !! dAr2/dVn real ( pr ), intent ( out ) :: ArTn ( size ( z )) !! dAr2/dTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) !! dAr2/dn2 integer :: nd !! Compositional derivatives integer :: nt !! Temperature derivatives nd = 2 nt = 1 call HelmSRKPR ( size ( z ), nd , nt , z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) end subroutine subroutine ar_rkpr ( z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) real ( pr ), intent ( in ) :: z (:) !! Number of moles real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( out ) :: ar !! Residual Helmholtz real ( pr ), intent ( out ) :: arv !! dAr/dV real ( pr ), intent ( out ) :: artv !! dAr2/dTV real ( pr ), intent ( out ) :: arv2 !! dAr2/dV2 real ( pr ), intent ( out ) :: Arn ( size ( z )) !! dAr/dn real ( pr ), intent ( out ) :: ArVn ( size ( z )) !! dAr2/dVn real ( pr ), intent ( out ) :: ArTn ( size ( z )) !! dAr2/dTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) !! dAr2/dn2 integer :: nd !! Compositional derivatives integer :: nt !! Temperature derivatives nd = 2 nt = 1 call HelmRKPR ( size ( z ), nd , nt , z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) end subroutine subroutine HelmSRKPR ( nc , ND , NT , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) integer , intent ( in ) :: nc !! Number of components integer , intent ( in ) :: nd !! Compositional derivatives integer , intent ( in ) :: nt !! Temperature derivatives real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( in ) :: rn ( nc ) !! Number of moles real ( pr ), intent ( out ) :: ar !! Residual Helmholtz real ( pr ), intent ( out ) :: arv !! dAr/dV real ( pr ), intent ( out ) :: artv !! dAr2/dTV real ( pr ), intent ( out ) :: arv2 !! dAr2/dV2 real ( pr ), intent ( out ) :: Arn ( nc ) !! dAr/dn real ( pr ), intent ( out ) :: ArVn ( nc ) !! dAr2/dVn real ( pr ), intent ( out ) :: ArTn ( nc ) !! dAr2/dTn real ( pr ), intent ( out ) :: Arn2 ( nc , nc ) !! dAr2/dn2 real ( pr ) :: ArT , ArTT real ( pr ) :: Bmix , dBi ( nc ), dBij ( nc , nc ) real ( pr ) :: D , dDi ( nc ), dDij ( nc , nc ), dDiT ( nc ), dDdT , dDdT2 real ( pr ) :: totn , d1 , d2 real ( pr ) :: f , g , fv , fB , gv , fv2 , gv2 , AUX , FFB , FFBV , FFBB integer :: i , j real ( pr ) :: b_v , a TOTN = sum ( rn ) D1 = del1 ( 1 ) D2 = ( 1._pr - D1 ) / ( 1._pr + D1 ) if ( mixing_rule . lt . 2 ) then call Bnder ( nc , rn , Bmix , dBi , dBij ) call DandTnder ( NT , nc , T , rn , D , dDi , dDiT , dDij , dDdT , dDdT2 ) end if ! The f's and g's used here are for Ar, not F (reduced Ar) ! This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = R * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) fB = - ( f + V * fv ) / Bmix gv = R * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = R * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) ! Reduced Helmholtz Energy and derivatives Ar = - TOTN * g * T - D * f ArV = - TOTN * gv * T - D * fv ArV2 = - TOTN * gv2 * T - D * fv2 AUX = R * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 do i = 1 , nc Arn ( i ) = - g * T + FFB * dBi ( i ) - f * dDi ( i ) ArVn ( i ) = - gv * T + FFBV * dBi ( i ) - fv * dDi ( i ) if ( ND . eq . 2 ) then do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end if end do ! TEMPERATURE DERIVATIVES if ( NT . eq . 1 ) then ArT = - TOTN * g - dDdT * f ArTV = - TOTN * gv - dDdT * fV ArTT = - dDdT2 * f do i = 1 , nc ArTn ( i ) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi ( i ) - f * dDiT ( i ) end do end if end subroutine HelmSRKPR subroutine HelmRKPR ( nco , NDE , NTD , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) !! Calculate the reduced residual Helmholtz Energy and it's derivatives with the RKPR EOS integer , intent ( in ) :: nco integer , intent ( in ) :: NDE integer , intent ( in ) :: NTD real ( pr ), intent ( in ) :: rn ( nco ) real ( pr ), intent ( in ) :: V real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: Ar , ArV , ArTV , ArV2 real ( pr ), intent ( out ) :: Arn ( nco ), ArVn ( nco ), ArTn ( nco ), Arn2 ( nco , nco ) real ( pr ) :: totn real ( pr ) :: Bmix , dBi ( nco ), dBij ( nco , nco ), dD1i ( nco ), dD1ij ( nco , nco ) real ( pr ) :: D , dDi ( nco ), dDij ( nco , nco ), dDiT ( nco ), dDdT , dDdT2 real ( pr ) :: D1 , D2 ! Auxiliar functions for Ar real ( pr ) :: f , g , fv , fB , gv , fv2 , gv2 , AUX , FFB , FFBV , FFBB ! Extra auxiliar functions for RKPR real ( pr ) :: auxD2 , fD1 , fBD1 , fVD1 , fD1D1 real ( pr ) :: ArT , ArTT integer :: i , j nc = nco TOTN = sum ( rn ) call DELTAnder ( nc , rn , D1 , dD1i , dD1ij ) D2 = ( 1 - D1 ) / ( 1 + D1 ) if ( mixing_rule . lt . 2 ) then call Bnder ( nc , rn , Bmix , dBi , dBij ) call DandTnder ( NTD , nc , T , rn , D , dDi , dDiT , dDij , dDdT , dDdT2 ) else ! call Bcubicnder(nc,rn,Bmix,dBi,dBij) ! call DCubicandTnder(NTD,nc,T,rn,D,dDi,dDiT,dDij,dDdT,dDdT2) end if !  The f's and g's used here are for Ar, not F (reduced Ar) !  This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = R * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) fB = - ( f + V * fv ) / Bmix gv = R * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = R * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) ! DERIVATIVES OF f WITH RESPECT TO DELTA1 auxD2 = ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1 = ( 1 / ( V + D1 * Bmix ) + 2 / ( V + D2 * Bmix ) / ( 1 + D1 ) ** 2 ) - f * auxD2 fD1 = fD1 / ( D1 - D2 ) fBD1 = - ( fB * auxD2 + D1 / ( V + D1 * Bmix ) ** 2 + 2 * D2 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 2 ) fBD1 = fBD1 / ( D1 - D2 ) fVD1 = - ( fV * auxD2 + 1 / ( V + D1 * Bmix ) ** 2 + 2 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 2 ) / ( D1 - D2 ) fD1D1 = 4 * ( f - 1 / ( V + D2 * Bmix )) / ( 1 + D1 ) ** 3 + Bmix * ( - 1 / ( V + D1 * Bmix ) ** 2 & + 4 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 4 ) - 2 * fD1 * ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1D1 = fD1D1 / ( D1 - D2 ) ! Reduced Helmholtz Energy and derivatives Ar = - TOTN * g * T - D * f ArV = - TOTN * gv * T - D * fv ArV2 = - TOTN * gv2 * T - D * fv2 AUX = R * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 do i = 1 , nc Arn ( i ) = - g * T + FFB * dBi ( i ) - f * dDi ( i ) - D * fD1 * dD1i ( i ) ArVn ( i ) = - gv * T + FFBV * dBi ( i ) - fv * dDi ( i ) - D * fVD1 * dD1i ( i ) if ( NDE . eq . 2 ) then do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( i , j ) = Arn2 ( i , j ) - D * fBD1 * ( dBi ( i ) * dD1i ( j ) + dBi ( j ) * dD1i ( i )) & - fD1 * ( dDi ( i ) * dD1i ( j ) + dDi ( j ) * dD1i ( i )) & - D * fD1 * dD1ij ( i , j ) - D * fD1D1 * dD1i ( i ) * dD1i ( j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end if end do ! TEMPERATURE DERIVATIVES if ( NTD . eq . 1 ) then ArT = - TOTN * g - dDdT * f ArTV = - TOTN * gv - dDdT * fV ArTT = - dDdT2 * f do i = 1 , nc ArTn ( i ) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi ( i ) - f * dDiT ( i ) - dDdT * fD1 * dD1i ( i ) end do end if end subroutine HelmRKPR subroutine ArVnder ( nc , NDER , NTEMP , z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) integer , intent ( in ) :: nc integer , intent ( in ) :: nder ! Get compositional derivatives integer , intent ( in ) :: ntemp ! Get temperature derivatives real ( pr ), intent ( in ) :: z ( nc ) real ( pr ), intent ( in ) :: V real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: ar , arv , artv , arv2 real ( pr ), dimension ( size ( z )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) vinit => cubic_v0 call ar_fun ( z , v , t , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) end subroutine ArVnder ! ========================================================================== ! ========================================================================== !  Attractive parameter routines ! -------------------------------------------------------------------------- subroutine aTder ( ac , Tc , k , T , a , dadT , dadT2 ) ! Given ac,Tc and the k parameter of the RKPR correlation, as well as the actual T, ! this subroutine calculates a(T) and its first and second derivatives with T. real ( pr ), intent ( in ) :: ac real ( pr ), intent ( in ) :: Tc real ( pr ), intent ( in ) :: k real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: a real ( pr ), intent ( out ) :: dadT real ( pr ), intent ( out ) :: dadT2 real ( pr ) :: Tr Tr = T / Tc if ( thermo_model . le . 3 ) then a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc dadT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5D0 ) else if ( thermo_model == 4 ) then a = ac * ( 3 / ( 2 + Tr )) ** k dadT = - k * a / Tc / ( 2 + Tr ) dadT2 = - ( k + 1 ) * dadT / Tc / ( 2 + Tr ) end if end subroutine aTder subroutine aijTder ( NTD , nc , T , aij , daijdT , daijdT2 ) integer , intent ( in ) :: ntd integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: aij ( nc , nc ), daijdT ( nc , nc ), daijdT2 ( nc , nc ) real ( pr ) :: ai ( nc ), daidT ( nc ), daidT2 ( nc ) real ( pr ) :: aux ( nc , nc ), ratK ( nc , nc ) integer :: i , j if ( tdep . ge . 1 ) then Kij = 0.0D0 do i = 1 , nc Kij (: i - 1 , i ) = Kinf (: i - 1 , i ) + Kij0 (: i - 1 , i ) * exp ( - T / Tstar (: i - 1 , i )) end do end if do i = 1 , nc call aTder ( ac ( i ), Tc ( i ), k ( i ), T , ai ( i ), daidT ( i ), daidT2 ( i )) aij ( i , i ) = ai ( i ) daijdT ( i , i ) = daidT ( i ) daijdT2 ( i , i ) = daidT2 ( i ) if ( i . gt . 1 ) then do j = 1 , i - 1 aij ( j , i ) = sqrt ( ai ( i ) * ai ( j )) * ( 1 - Kij ( j , i )) aij ( i , j ) = aij ( j , i ) if ( NTD . eq . 1 ) then daijdT ( j , i ) = ( 1 - Kij ( j , i )) * ( sqrt ( ai ( i ) / ai ( j )) * daidT ( j ) & + sqrt ( ai ( j ) / ai ( i )) * daidT ( i )) / 2 daijdT2 ( j , i ) = ( 1 - Kij ( j , i )) * ( daidT ( j ) * daidT ( i ) / sqrt ( ai ( i ) * ai ( j )) & + sqrt ( ai ( i ) / ai ( j )) * ( daidT2 ( j ) - daidT ( j ) ** 2 / ( 2 * ai ( j ))) & + sqrt ( ai ( j ) / ai ( i )) * ( daidT2 ( i ) - daidT ( i ) ** 2 / ( 2 * ai ( i )))) / 2 daijdT ( i , j ) = daijdT ( j , i ) daijdT2 ( i , j ) = daijdT2 ( j , i ) end if end do end if end do end subroutine aijTder subroutine DandTnder ( NTD , nc , T , rn , D , dDi , dDiT , dDij , dDdT , dDdT2 ) integer , intent ( in ) :: ntd integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: T real ( pr ), intent ( in ) :: rn ( nc ) real ( pr ), intent ( out ) :: D real ( pr ), intent ( out ) :: dDiT ( nc ) real ( pr ), intent ( out ) :: dDdT real ( pr ), intent ( out ) :: dDdT2 real ( pr ), intent ( out ) :: dDi ( nc ) real ( pr ), intent ( out ) :: dDij ( nc , nc ) real ( pr ) :: aij ( nc , nc ), daijdT ( nc , nc ), daijdT2 ( nc , nc ) real ( pr ) :: aux , aux2 integer :: i , j call aijTder ( NTD , nc , T , aij , daijdT , daijdT2 ) D = 0 dDdT = 0 dDdT2 = 0 do i = 1 , nc aux = 0 aux2 = 0 dDi ( i ) = 0 dDiT ( i ) = 0 do j = 1 , nc dDi ( i ) = dDi ( i ) + 2 * rn ( j ) * aij ( i , j ) if ( NTD . eq . 1 ) then dDiT ( i ) = dDiT ( i ) + 2 * rn ( j ) * daijdT ( i , j ) aux2 = aux2 + rn ( j ) * daijdT2 ( i , j ) end if dDij ( i , j ) = 2 * aij ( i , j ) aux = aux + rn ( j ) * aij ( i , j ) end do D = D + rn ( i ) * aux if ( NTD . eq . 1 ) then dDdT = dDdT + rn ( i ) * dDiT ( i ) / 2 dDdT2 = dDdT2 + rn ( i ) * aux2 end if end do end subroutine DandTnder ! ========================================================================== subroutine DELTAnder ( nc , rn , D1m , dD1i , dD1ij ) integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: rn ( nc ) real ( pr ), intent ( out ) :: D1m , dD1i ( nc ), dD1ij ( nc , nc ) real ( pr ) :: totn integer :: i , j D1m = 0.0_pr do i = 1 , nc D1m = D1m + rn ( i ) * del1 ( i ) end do TOTN = sum ( rn ) D1m = D1m / totn do i = 1 , nc dD1i ( i ) = ( del1 ( i ) - D1m ) / totn do j = 1 , nc dD1ij ( i , j ) = ( 2.0_pr * D1m - del1 ( i ) - del1 ( j )) / totn ** 2 end do end do end subroutine DELTAnder ! ========================================================================== !  Repulsive parameter routines ! -------------------------------------------------------------------------- subroutine Bnder ( nc , rn , Bmix , dBi , dBij ) integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: rn ( nc ) real ( pr ), intent ( out ) :: Bmix , dBi ( nc ), dBij ( nc , nc ) real ( pr ) :: totn , aux ( nc ) integer :: i , j TOTN = sum ( rn ) Bmix = 0.0_pr aux = 0.0_pr do i = 1 , nc do j = 1 , nc bij ( i , j ) = ( b ( i ) + b ( j )) * 0.5_pr * ( 1.0_pr - lij ( i , j )) aux ( i ) = aux ( i ) + rn ( j ) * bij ( i , j ) end do Bmix = Bmix + rn ( i ) * aux ( i ) end do Bmix = Bmix / totn do i = 1 , nc dBi ( i ) = ( 2 * aux ( i ) - Bmix ) / totn do j = 1 , i dBij ( i , j ) = ( 2 * bij ( i , j ) - dBi ( i ) - dBi ( j )) / totn dBij ( j , i ) = dBij ( i , j ) end do end do end subroutine Bnder ! ========================================================================== ! ========================================================================== !  Properties ! -------------------------------------------------------------------------- function cubic_v0 ( z , p , t ) real ( pr ) :: z (:) real ( pr ) :: p real ( pr ) :: t real ( pr ) :: cubic_v0 real ( pr ) :: dbi ( nc ), dbij ( nc , nc ) call bnder ( nc , z , cubic_v0 , dBi , dBij ) end function end module module legacy_thermo_properties use yaeos_constants , only : R , pr use legacy_ar_models , only : ArVnder , vinit implicit none contains subroutine TERMO ( nc , MTYP , INDIC , T , P , rn , V , PHILOG , DLPHIP , DLPHIT , FUGN ) !  MTYP      TYPE OF ROOT DESIRED (-1 vapor, 1 liquid, 0 lower Gibbs energy phase) !  rn        mixture mole numbers                        (input) !  t         temperature (k)                             (input)x, y !  p         pressure    (bar)                          (input) !  v         volume      (L)                            (output) !  PHILOG    vector of ln(phi(i)*P)                     (output)   INDIC < 5 !  DLPHIT    t-derivative of ln(phi(i)) (const P, n)    (output)   INDIC = 2 or 4 !  DLPHIP    P-derivative of ln(phi(i)) (const T, n)    (output)   INDIC < 5 !  FUGN      comp-derivative of ln(phi(i)) (const t & P)(output)   INDIC > 2 !  ------------------------------------------------------------------------- integer , intent ( in ) :: nc !! Number of components integer , intent ( in ) :: indic !! Desired element, this should be setted with optionals integer , intent ( in ) :: mtyp !! Type of root desired (-1 vapor, 1 liquid, 0 lower Gr) real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( in ) :: p !! Pressure [bar] real ( pr ), intent ( in ) :: rn ( nc ) !! Mixture mole numbers real ( pr ), intent ( out ) :: v !! Volume [L] real ( pr ), intent ( out ) :: PHILOG ( nc ) !! ln(phi*p) vector real ( pr ), optional , intent ( out ) :: DLPHIT ( nc ) !! ln(phi) Temp derivative real ( pr ), optional , intent ( out ) :: DLPHIP ( nc ) !! ln(phi) Presssure derivative real ( pr ), optional , intent ( out ) :: FUGN ( nc , nc ) !! ln(phi) compositional derivative real ( pr ) :: ar , arv , artv , arv2 real ( pr ) :: RT , Z , dpv , dpdt real ( pr ) :: Arn ( nc ) real ( pr ) :: ArVn ( nc ) real ( pr ) :: ArTn ( nc ) real ( pr ) :: Arn2 ( nc , nc ) real ( pr ) :: DPDN ( nc ) real ( pr ) :: totn integer :: ntemp , igz , nder , i , k !  The output PHILOG is actually the vector ln(phi(i)*P) NTEMP = 0 IGZ = 0 NDER = 1 if ( INDIC . gt . 2 ) NDER = 2 if ( INDIC . eq . 2 . or . INDIC . eq . 4 ) NTEMP = 1 TOTN = sum ( rn ) ! if (P .le. 0.0d0) MTYP = 1 call VCALC ( MTYP , NC , NTEMP , rn , T , P , V ) RT = R * T Z = V / ( TOTN * RT ) ! this is Z/P call ArVnder ( nc , NDER , NTEMP , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) DPV = - ArV2 - RT * TOTN / V ** 2 DPDT = - ArTV + TOTN * R / V do I = 1 , NC PHILOG ( I ) = - log ( Z ) + Arn ( I ) / RT DPDN ( I ) = RT / V - ArVn ( I ) if ( present ( dlphip )) DLPHIP ( I ) = - DPDN ( I ) / DPV / RT - 1.D0 / P if ( NTEMP . ne . 0 ) then if ( present ( dlphit )) then DLPHIT ( I ) = ( ArTn ( I ) - Arn ( I ) / T ) / RT + DPDN ( I ) * DPDT / DPV / RT + 1.D0 / T end if end if end do if ( present ( fugn )) then do I = 1 , NC do K = I , NC FUGN ( I , K ) = 1.D0 / TOTN + ( Arn2 ( I , K ) + DPDN ( I ) * DPDN ( K ) / DPV ) / RT FUGN ( K , I ) = FUGN ( I , K ) end do end do end if end subroutine TERMO subroutine zTVTERMO ( nc , INDIC , T , rn , V , P , DPV , PHILOG , DLPHIP , DLPHIT , FUGN ) !! Calculation of lnphi*P and derivatives !!  rn        mixture mole numbers                       (input) !!  t         temperature (k)                            (input) !!  v         volume      (L)                            (input) !!  p         pressure    (bar)                          (output) !!  PHILOG    vector of ln(phi(i)*P)                     (output)  0 < INDIC < 5 !!  DLPHIT    t-derivative of ln(phi(i)) (const P, n)    (output)  0 < INDIC = 2 or 4 !!  DLPHIP    P-derivative of ln(phi(i)) (const T, n)    (output)  0 < INDIC < 5 !!  FUGN      comp-derivative of ln(phi(i)) (const t & P)(output)  2 < INDIC !!  ------------------------------------------------------------------------- implicit none integer , intent ( in ) :: nc , indic real ( pr ), intent ( in ) :: t , rn ( nc ), v real ( pr ), intent ( out ) :: p , dpv real ( pr ), intent ( out ) :: PHILOG ( nc ), DLPHIT ( nc ), DLPHIP ( nc ) real ( pr ), intent ( out ) :: FUGN ( nc , nc ) real ( pr ) :: Arn ( nc ), ArVn ( nc ), ArTn ( nc ), Arn2 ( nc , nc ), DPDN ( nc ), totn real ( pr ) :: ar , arv , artv , arv2 , RT , Z , dpdt integer :: ntemp , igz , nder , i , k NTEMP = 0 IGZ = 0 NDER = 1 if ( INDIC . gt . 2 ) NDER = 2 if ( INDIC . eq . 2 . or . INDIC . eq . 4 ) NTEMP = 1 TOTN = sum ( rn ) RT = R * T Z = V / ( TOTN * RT ) ! this is Z/P call ArVnder ( nc , NDER , NTEMP , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) P = TOTN * RT / V - ArV DPV = - ArV2 - RT * TOTN / V ** 2 DPDT = - ArTV + TOTN * R / V if ( INDIC > 0 ) then do I = 1 , NC PHILOG ( I ) = - log ( Z ) + Arn ( I ) / RT DPDN ( I ) = RT / V - ArVn ( I ) DLPHIP ( I ) = - DPDN ( I ) / DPV / RT - 1.D0 / P if ( NTEMP . ne . 0 ) then DLPHIT ( I ) = ( ArTn ( I ) - Arn ( I ) / T ) / RT + DPDN ( I ) * DPDT / DPV / RT + 1.D0 / T end if end do end if if ( NDER . ge . 2 ) then do I = 1 , NC do K = I , NC FUGN ( I , K ) = 1.D0 / TOTN + ( Arn2 ( I , K ) + DPDN ( I ) * DPDN ( K ) / DPV ) / RT FUGN ( K , I ) = FUGN ( I , K ) end do end do end if end subroutine zTVTERMO subroutine PUREFUG_CALC ( nc , icomp , T , P , V , phi ) !! Fugacity of a pure component integer , intent ( in ) :: nc integer , intent ( in ) :: icomp real ( pr ), intent ( in ) :: T , P , V real ( pr ), intent ( out ) :: phi real ( pr ) :: rn ( nc ), Ar , Arv , ArTV , ArV2 , Arn ( nc ), ArVn ( nc ), ArTn ( nc ), Arn2 ( nc , nc ) real ( pr ) :: RT , Z , philog rn = 0.0 rn ( icomp ) = 1.0 RT = R * T Z = P * V / RT call ArVnder ( nc , 0 , 0 , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) PHILOG = - log ( Z ) + Arn ( icomp ) / RT phi = exp ( PHILOG ) end subroutine purefug_calc recursive subroutine VCALC ( ITYP , nc , NTEMP , rn , T , P , V ) !! ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE integer , intent ( in ) :: ITYP !! TYPE OF ROOT DESIRED (-1 vapor, 1 liquid, 0 lower Gibbs energy phase) integer , intent ( in ) :: nc !! NO. OF COMPONENTS integer , intent ( in ) :: ntemp !! 1 if T-derivatives are required real ( pr ), intent ( in ) :: rn ( nc ) !! FEED MOELS real ( pr ), intent ( in ) :: T !! TEMPERATURE real ( pr ), intent ( in ) :: P !! PRESURE real ( pr ), intent ( out ) :: V !! VOLUME real ( pr ) :: Ar , ArV , ArTV , ArV2 , Arn ( nc ), ArVn ( nc ), ArTn ( nc ), Arn2 ( nc , nc ) logical :: FIRST_RUN integer :: nder real ( pr ) :: totn real ( pr ) :: B , CPV , S3R real ( pr ) :: ZETMIN , ZETA , ZETMAX real ( pr ) :: del , pcalc , der , AT , AVAP , VVAP integer :: iter NDER = 0 FIRST_RUN = . true . TOTN = sum ( rn ) CPV = vinit ( rn , p , t ) B = CPV S3R = 1.D0 / CPV ITER = 0 ZETMIN = 0.D0 !ZETMAX = 1.D0-0.01*T/5000        !.99D0  This is flexible for low T (V very close to B) ZETMAX = 1.D0 - 0.01 * T / ( 10000 * B ) ! improvement for cases with heavy components if ( ITYP . gt . 0 ) then ZETA = . 5 D0 else ! IDEAL GAS ESTIMATE ZETA = min (. 5 D0 , CPV * P / ( TOTN * R * T )) end if 100 continue DEL = 1 pcalc = 2 * p do while ( abs ( DEL ) > 1 d - 10 . and . iter < 100 ) V = CPV / ZETA ITER = ITER + 1 call ArVnder (& nc , NDER , NTEMP , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 & ) PCALC = TOTN * R * T / V - ArV if ( PCALC . gt . P ) then ZETMAX = ZETA else ZETMIN = ZETA end if AT = ( Ar + V * P ) / ( T * R ) - TOTN * log ( V ) ! AT is something close to Gr(P,T) DER = ( ArV2 * V ** 2 + TOTN * R * T ) * S3R ! this is dPdrho/B DEL = - ( PCALC - P ) / DER ZETA = ZETA + max ( min ( DEL , 0.1D0 ), - . 1 D0 ) if ( ZETA . gt . ZETMAX . or . ZETA . lt . ZETMIN ) & ZETA = . 5 D0 * ( ZETMAX + ZETMIN ) end do if ( ITYP . eq . 0 ) then ! FIRST RUN WAS VAPOUR; RERUN FOR LIQUID if ( FIRST_RUN ) then VVAP = V AVAP = AT FIRST_RUN = . false . ZETA = 0.5D0 ZETMAX = 1.D0 - 0.01 * T / 500 goto 100 else if ( AT . gt . AVAP ) V = VVAP end if end if end subroutine vcalc ! ========================================================================== end module","tags":"","loc":"sourcefile/legacy.f90.html"},{"title":"admm_tapenade_interface.f90 – Yaeos","text":"Contents Modules ADMM_TAPENADE_INTERFACE Source Code admm_tapenade_interface.f90 Source Code MODULE ADMM_TAPENADE_INTERFACE IMPLICIT NONE INTERFACE PUSHPOINTER8 SUBROUTINE PUSHPOINTER8 ( pp ) BIND ( c , name = 'pushPointer8' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: pp END SUBROUTINE PUSHPOINTER8 END INTERFACE PUSHPOINTER8 INTERFACE POPPOINTER8 SUBROUTINE POPPOINTER8 ( pp ) BIND ( c , name = 'popPointer8' ) USE ISO_C_BINDING TYPE ( C_PTR ) :: pp END SUBROUTINE POPPOINTER8 END INTERFACE POPPOINTER8 INTERFACE ADMM_REGISTERSHADOWED SUBROUTINE ADMM_REGISTERSHADOWED ( base , obase , size , baseb , obaseb & & , sizeb , nbelem ) BIND ( c , name = 'ADMM_registerShadowed' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base , obase TYPE ( C_PTR ), VALUE :: baseb , obaseb INTEGER , VALUE :: size , sizeb INTEGER , VALUE :: nbelem END SUBROUTINE ADMM_REGISTERSHADOWED END INTERFACE ADMM_REGISTERSHADOWED INTERFACE ADMM_REGISTER SUBROUTINE ADMM_REGISTER ( base , obase , size , nbelem ) BIND ( c , name = & & 'ADMM_register' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base , obase INTEGER , VALUE :: size INTEGER , VALUE :: nbelem END SUBROUTINE ADMM_REGISTER END INTERFACE ADMM_REGISTER INTERFACE ADMM_UNREGISTERSHADOWED SUBROUTINE ADMM_UNREGISTERSHADOWED ( base , baseb , nbelem ) BIND ( c , & & name = 'ADMM_unregisterShadowed' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base , baseb INTEGER :: nbelem END SUBROUTINE ADMM_UNREGISTERSHADOWED END INTERFACE ADMM_UNREGISTERSHADOWED INTERFACE ADMM_UNREGISTER SUBROUTINE ADMM_UNREGISTER ( base , nbelem ) BIND ( c , name = & & 'ADMM_unregister' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base INTEGER :: nbelem END SUBROUTINE ADMM_UNREGISTER END INTERFACE ADMM_UNREGISTER INTERFACE ADMM_REBASESHADOWED SUBROUTINE ADMM_REBASESHADOWED ( base , baseb ) BIND ( c , name = & & 'ADMM_rebaseShadowed' ) USE ISO_C_BINDING TYPE ( C_PTR ) :: base , baseb END SUBROUTINE ADMM_REBASESHADOWED END INTERFACE ADMM_REBASESHADOWED INTERFACE ADMM_REBASE SUBROUTINE ADMM_REBASE ( base ) BIND ( c , name = 'ADMM_rebase' ) USE ISO_C_BINDING TYPE ( C_PTR ) :: base END SUBROUTINE ADMM_REBASE END INTERFACE ADMM_REBASE END MODULE ADMM_TAPENADE_INTERFACE","tags":"","loc":"sourcefile/admm_tapenade_interface.f90.html"},{"title":"substance.f90 – Yaeos","text":"This file depends on sourcefile~~substance.f90~~EfferentGraph sourcefile~substance.f90 substance.f90 sourcefile~constants.f90 constants.f90 sourcefile~substance.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~substance.f90~~AfferentGraph sourcefile~substance.f90 substance.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~substance.f90 sourcefile~models.f90 models.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~pr76.f90 pr76.f90 sourcefile~pr76.f90->sourcefile~substance.f90 sourcefile~pr76.f90->sourcefile~alphas.f90 sourcefile~pr76.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~pr76.f90->sourcefile~mixing_rules.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~srk.f90 srk.f90 sourcefile~srk.f90->sourcefile~substance.f90 sourcefile~srk.f90->sourcefile~alphas.f90 sourcefile~srk.f90->sourcefile~generic_cubic.f90 sourcefile~srk.f90->sourcefile~mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~pr78.f90 pr78.f90 sourcefile~pr78.f90->sourcefile~substance.f90 sourcefile~pr78.f90->sourcefile~alphas.f90 sourcefile~pr78.f90->sourcefile~generic_cubic.f90 sourcefile~pr78.f90->sourcefile~mixing_rules.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~models.f90->sourcefile~pr76.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~models.f90->sourcefile~srk.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~models.f90->sourcefile~pr78.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_substance Source Code substance.f90 Source Code module yaeos_substance use yaeos_constants , only : pr type :: Substances !! A set of substances real ( pr ), allocatable :: tc (:), pc (:), w (:) end type end module","tags":"","loc":"sourcefile/substance.f90.html"},{"title":"models.f90 – Yaeos","text":"This file depends on sourcefile~~models.f90~~EfferentGraph sourcefile~models.f90 models.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~pr76.f90 pr76.f90 sourcefile~models.f90->sourcefile~pr76.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~srk.f90 srk.f90 sourcefile~models.f90->sourcefile~srk.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~models.f90->sourcefile~ar_models.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~pr78.f90 pr78.f90 sourcefile~models.f90->sourcefile~pr78.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~constants.f90 constants.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~substance.f90 substance.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~pr76.f90->sourcefile~alphas.f90 sourcefile~pr76.f90->sourcefile~generic_cubic.f90 sourcefile~pr76.f90->sourcefile~mixing_rules.f90 sourcefile~pr76.f90->sourcefile~constants.f90 sourcefile~pr76.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~srk.f90->sourcefile~alphas.f90 sourcefile~srk.f90->sourcefile~generic_cubic.f90 sourcefile~srk.f90->sourcefile~mixing_rules.f90 sourcefile~srk.f90->sourcefile~constants.f90 sourcefile~srk.f90->sourcefile~substance.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~pr78.f90->sourcefile~alphas.f90 sourcefile~pr78.f90->sourcefile~generic_cubic.f90 sourcefile~pr78.f90->sourcefile~mixing_rules.f90 sourcefile~pr78.f90->sourcefile~constants.f90 sourcefile~pr78.f90->sourcefile~substance.f90 sourcefile~substance.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~models.f90~~AfferentGraph sourcefile~models.f90 models.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_models Source Code models.f90 Source Code module yaeos_models use yaeos_models_ar , only : ArModel use yaeos_models_ar_genericcubic , only : CubicEoS , GenericCubic_Ar use yaeos_models_ar_cubic_alphas , only : AlphaSoave use yaeos_models_ar_genericcubic_quadratic_mixing , only : QMR use yaeos_models_ar_cubic_pengrobinson76 , only : PengRobinson76 use yaeos_models_ar_cubic_pengrobinson78 , only : PengRobinson78 use yaeos_models_ar_cubic_srk , only : SoaveRedlichKwong end module","tags":"","loc":"sourcefile/models.f90.html"},{"title":"ar_models.f90 – Yaeos","text":"This file depends on sourcefile~~ar_models.f90~~EfferentGraph sourcefile~ar_models.f90 ar_models.f90 sourcefile~constants.f90 constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~ar_models.f90~~AfferentGraph sourcefile~ar_models.f90 ar_models.f90 sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~thermoprops.f90->sourcefile~ar_models.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~pr76.f90 pr76.f90 sourcefile~models.f90->sourcefile~pr76.f90 sourcefile~srk.f90 srk.f90 sourcefile~models.f90->sourcefile~srk.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~pr78.f90 pr78.f90 sourcefile~models.f90->sourcefile~pr78.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~armodel_adiff_api.f90 armodel_adiff_api.f90 sourcefile~armodel_adiff_api.f90->sourcefile~ar_models.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~thermoprops.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~pr76.f90->sourcefile~generic_cubic.f90 sourcefile~pr76.f90->sourcefile~alphas.f90 sourcefile~pr76.f90->sourcefile~mixing_rules.f90 sourcefile~srk.f90->sourcefile~generic_cubic.f90 sourcefile~srk.f90->sourcefile~alphas.f90 sourcefile~srk.f90->sourcefile~mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~pr78.f90->sourcefile~generic_cubic.f90 sourcefile~pr78.f90->sourcefile~alphas.f90 sourcefile~pr78.f90->sourcefile~mixing_rules.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_models_ar Source Code ar_models.f90 Source Code module yaeos_models_ar !! Module that defines the basics of a residual Helmholtz energy. use yaeos_constants , only : pr implicit none type , abstract :: ArModel !! Abstract residual Helmholtz model. integer :: id character ( len = :), allocatable :: name contains procedure ( abs_residual_helmholtz ), deferred :: residual_helmholtz !! Method to calculate residual helmholtz energy and derivatives. procedure ( abs_volume_initializer ), deferred :: get_v0 !! Volume initializer end type abstract interface subroutine abs_residual_helmholtz (& self , n , v , t , Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) !! Residual Helmholtz model generic interface import ArModel , pr class ( ArModel ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: v , t real ( pr ), optional , intent ( out ) :: Ar , ArV , ArT , ArT2 , ArTV , ArV2 real ( pr ), optional , dimension ( size ( n )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) end subroutine function abs_volume_initializer ( self , n , p , t ) !! Initialization of volume import ArModel , pr class ( ArModel ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: p real ( pr ), intent ( in ) :: t real ( pr ) :: abs_volume_initializer end function end interface end module","tags":"","loc":"sourcefile/ar_models.f90.html"},{"title":"generic_cubic.f90 – Yaeos","text":"This file depends on sourcefile~~generic_cubic.f90~~EfferentGraph sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~constants.f90 constants.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~substance.f90 substance.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~generic_cubic.f90~~AfferentGraph sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~pr76.f90 pr76.f90 sourcefile~models.f90->sourcefile~pr76.f90 sourcefile~srk.f90 srk.f90 sourcefile~models.f90->sourcefile~srk.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~pr78.f90 pr78.f90 sourcefile~models.f90->sourcefile~pr78.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~pr76.f90->sourcefile~generic_cubic.f90 sourcefile~pr76.f90->sourcefile~alphas.f90 sourcefile~pr76.f90->sourcefile~mixing_rules.f90 sourcefile~srk.f90->sourcefile~generic_cubic.f90 sourcefile~srk.f90->sourcefile~alphas.f90 sourcefile~srk.f90->sourcefile~mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~pr78.f90->sourcefile~generic_cubic.f90 sourcefile~pr78.f90->sourcefile~alphas.f90 sourcefile~pr78.f90->sourcefile~mixing_rules.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_models_ar_genericcubic Source Code generic_cubic.f90 Source Code module yaeos_models_ar_genericcubic use yaeos_constants , only : pr use yaeos_models_ar , only : ArModel use yaeos_substance , only : Substances implicit none type , abstract :: AlphaFunction contains procedure ( abs_alpha ), deferred :: alpha end type type , abstract :: CubicMixRule contains procedure ( abs_Dmix ), deferred :: Dmix procedure ( abs_Bmix ), deferred :: Bmix end type type , extends ( ArModel ) :: CubicEoS !! Cubic Equation of State. class ( Substances ), allocatable :: components class ( CubicMixRule ), allocatable :: mixrule class ( AlphaFunction ), allocatable :: alpha real ( pr ), allocatable :: ac (:), b (:), del1 (:), del2 (:) contains procedure :: residual_helmholtz => GenericCubic_Ar procedure :: get_v0 => v0 end type abstract interface subroutine abs_alpha ( self , Tr , a , dadt , dadt2 ) import AlphaFunction , pr class ( AlphaFunction ), intent ( in ) :: self real ( pr ), intent ( in ) :: Tr (:) real ( pr ), intent ( out ) :: a (:), dadt (:), dadt2 (:) end subroutine subroutine abs_Dmix ( self , n , T , & ai , daidt , daidt2 , & D , dDdT , dDdT2 , dDi , dDidT , dDij & ) import CubicMixRule , pr class ( CubicMixRule ), intent ( in ) :: self real ( pr ), intent ( in ) :: T , n (:) real ( pr ), intent ( in ) :: ai (:), daidt (:), daidt2 (:) real ( pr ), intent ( out ) :: D , dDdT , dDdT2 , dDi (:), dDidT (:), dDij (:, :) end subroutine subroutine abs_Bmix ( self , n , bi , B , dBi , dBij ) import CubicMixRule , pr class ( CubicMixRule ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: bi (:) real ( pr ), intent ( out ) :: B , dBi (:), dBij (:, :) end subroutine end interface contains subroutine GenericCubic_Ar (& self , n , V , T , Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) !! Residual Helmholtz Energy for a generic Cubic Equation of State. !! !! Calculates the residual Helmholtz Energy for a generic Cubic EoS as !! defined by Michelsen and Møllerup: !! !! P = \\frac{RT}{V-b} - \\frac{a_c\\alpha(T_r)}{(V+b\\delta_1)(V+b\\delta_2)} use yaeos_constants , only : R class ( CubicEoS ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) !! Number of moles real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), optional , intent ( out ) :: ar !! Residual Helmholtz real ( pr ), optional , intent ( out ) :: arv !! dAr/dV real ( pr ), optional , intent ( out ) :: ArT !! dAr/dT real ( pr ), optional , intent ( out ) :: artv !! dAr2/dTV real ( pr ), optional , intent ( out ) :: arv2 !! dAr2/dV2 real ( pr ), optional , intent ( out ) :: ArT2 !! dAr2/dT2 real ( pr ), optional , intent ( out ) :: Arn ( size ( n )) !! dAr/dn real ( pr ), optional , intent ( out ) :: ArVn ( size ( n )) !! dAr2/dVn real ( pr ), optional , intent ( out ) :: ArTn ( size ( n )) !! dAr2/dTn real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) !! dAr2/dn2 real ( pr ) :: Bmix , dBi ( size ( n )), dBij ( size ( n ), size ( n )) real ( pr ) :: D , dDi ( size ( n )), dDij ( size ( n ), size ( n )), dDidT ( size ( n )), dDdT , dDdT2 real ( pr ) :: totn , d1 , d2 real ( pr ) :: f , g , fv , fB , gv , fv2 , gv2 , AUX , FFB , FFBV , FFBB real ( pr ) :: Tr ( size ( n )), a ( size ( n )), dadt ( size ( n )), dadt2 ( size ( n )) integer :: i , j , nc nc = size ( n ) TOTN = sum ( n ) D1 = self % del1 ( 1 ) D2 = ( 1._pr - D1 ) / ( 1._pr + D1 ) Tr = T / self % components % Tc call self % alpha % alpha ( Tr , a , dadt , dadt2 ) call self % mixrule % Bmix ( n , self % b , Bmix , dBi , dBij ) a = self % ac * a dadt = self % ac * dadt / self % components % Tc dadt2 = self % ac * dadt2 / self % components % Tc ** 2 call self % mixrule % Dmix (& n , T , a , dadt , dadt2 , D , dDdT , dDdT2 , dDi , dDidT , dDij & ) ! The f's and g's used here are for Ar, not F (reduced Ar) ! This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = R * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) fB = - ( f + V * fv ) / Bmix gv = R * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = R * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) ! Reduced Helmholtz Energy and derivatives if ( present ( Ar )) Ar = - TOTN * g * T - D * f if ( present ( ArV )) ArV = - TOTN * gv * T - D * fv if ( present ( ArV2 )) ArV2 = - TOTN * gv2 * T - D * fv2 AUX = R * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 if ( present ( Arn )) Arn (:) = - g * T + FFB * dBi (:) - f * dDi (:) if ( present ( ArVn )) ArVn (:) = - gv * T + FFBV * dBi (:) - fv * dDi (:) if ( present ( ArTn )) ArTn (:) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi (:) - f * dDidT (:) if ( present ( Arn2 )) then do i = 1 , nc do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end do end if ! TEMPERATURE DERIVATIVES if ( present ( ArT )) ArT = - TOTN * g - dDdT * f if ( present ( ArTV )) ArTV = - TOTN * gv - dDdT * fV if ( present ( ArT2 )) ArT2 = - dDdT2 * f end subroutine GenericCubic_Ar function v0 ( self , n , p , t ) class ( CubicEoS ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:), p , t real ( pr ) :: v0 real ( pr ) :: dbi ( size ( n )), dbij ( size ( n ), size ( n )) call self % mixrule % Bmix ( n , self % b , v0 , dbi , dbij ) end function end module","tags":"","loc":"sourcefile/generic_cubic.f90.html"},{"title":"pr76.f90 – Yaeos","text":"This file depends on sourcefile~~pr76.f90~~EfferentGraph sourcefile~pr76.f90 pr76.f90 sourcefile~substance.f90 substance.f90 sourcefile~pr76.f90->sourcefile~substance.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~pr76.f90->sourcefile~alphas.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~pr76.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~pr76.f90->sourcefile~mixing_rules.f90 sourcefile~constants.f90 constants.f90 sourcefile~pr76.f90->sourcefile~constants.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pr76.f90~~AfferentGraph sourcefile~pr76.f90 pr76.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~pr76.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_models_ar_cubic_pengrobinson76 Source Code pr76.f90 Source Code module yaeos_models_ar_cubic_pengrobinson76 use yaeos_constants , only : R , pr use yaeos_substance , only : Substances use yaeos_models_ar_genericcubic , only : CubicEoS , AlphaFunction , CubicMixRule use yaeos_models_ar_genericcubic_quadratic_mixing , only : QMR use yaeos_models_ar_cubic_alphas , only : AlphaSoave implicit none private public :: PengRobinson76 contains type ( CubicEoS ) function PengRobinson76 ( tc , pc , w , kij , lij ) result ( model ) real ( pr ), intent ( in ) :: tc (:), pc (:), w (:) real ( pr ), optional , intent ( in ) :: kij (:, :), lij (:, :) type ( Substances ) :: composition type ( QMR ) :: mixrule type ( AlphaSoave ) :: alpha integer :: nc integer :: i nc = size ( tc ) composition % tc = tc composition % pc = pc composition % w = w alpha % k = 0.37464_pr & + 1.54226_pr * composition % w & - 0.26993_pr * composition % w ** 2 if ( present ( kij )) then mixrule % k = kij else mixrule % k = reshape ([( i , i = 1 , nc ** 2 )], [ nc , nc ]) endif if ( present ( lij )) then mixrule % l = lij else mixrule % l = reshape ([( i , i = 1 , nc ** 2 )], [ nc , nc ]) endif model % components = composition model % ac = 0.45723553_pr * R ** 2 * composition % tc ** 2 / composition % pc model % b = 0.07779607_pr * R * composition % tc / composition % pc model % del1 = [ 1 + sqrt ( 2.0_pr )] model % del2 = [ 1 - sqrt ( 2.0_pr )] model % alpha = alpha model % mixrule = mixrule end function end module","tags":"","loc":"sourcefile/pr76.f90.html"},{"title":"srk.f90 – Yaeos","text":"This file depends on sourcefile~~srk.f90~~EfferentGraph sourcefile~srk.f90 srk.f90 sourcefile~substance.f90 substance.f90 sourcefile~srk.f90->sourcefile~substance.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~srk.f90->sourcefile~alphas.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~srk.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~srk.f90->sourcefile~mixing_rules.f90 sourcefile~constants.f90 constants.f90 sourcefile~srk.f90->sourcefile~constants.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~srk.f90~~AfferentGraph sourcefile~srk.f90 srk.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~srk.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_models_ar_cubic_srk Source Code srk.f90 Source Code module yaeos_models_ar_cubic_srk use yaeos_constants , only : R , pr use yaeos_substance , only : Substances use yaeos_models_ar_genericcubic , only : CubicEoS , AlphaFunction , CubicMixRule use yaeos_models_ar_genericcubic_quadratic_mixing , only : QMR use yaeos_models_ar_cubic_alphas , only : AlphaSoave implicit none private public :: SoaveRedlichKwong contains type ( CubicEoS ) function SoaveRedlichKwong ( tc , pc , w , kij , lij ) result ( model ) real ( pr ), intent ( in ) :: tc (:), pc (:), w (:) real ( pr ), optional , intent ( in ) :: kij (:, :), lij (:, :) type ( Substances ) :: composition type ( QMR ) :: mixrule type ( AlphaSoave ) :: alpha integer :: nc integer :: i nc = size ( tc ) composition % tc = tc composition % pc = pc composition % w = w alpha % k = 0.48_pr + 1.574_pr * composition % w - 0.175_pr * composition % w ** 2 if ( present ( kij )) then mixrule % k = kij else mixrule % k = reshape ([( i , i = 1 , nc ** 2 )], [ nc , nc ]) endif if ( present ( lij )) then mixrule % l = lij else mixrule % l = reshape ([( i , i = 1 , nc ** 2 )], [ nc , nc ]) endif model % components = composition model % ac = 0.427480_pr * R ** 2 * composition % tc ** 2 / composition % pc model % b = 0.086640_pr * R * composition % tc / composition % pc model % del1 = [ 1 ] model % del2 = [ 0 ] model % alpha = alpha model % mixrule = mixrule end function end module","tags":"","loc":"sourcefile/srk.f90.html"},{"title":"pr78.f90 – Yaeos","text":"This file depends on sourcefile~~pr78.f90~~EfferentGraph sourcefile~pr78.f90 pr78.f90 sourcefile~substance.f90 substance.f90 sourcefile~pr78.f90->sourcefile~substance.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~pr78.f90->sourcefile~alphas.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~pr78.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~pr78.f90->sourcefile~mixing_rules.f90 sourcefile~constants.f90 constants.f90 sourcefile~pr78.f90->sourcefile~constants.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pr78.f90~~AfferentGraph sourcefile~pr78.f90 pr78.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~pr78.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_models_ar_cubic_pengrobinson78 Source Code pr78.f90 Source Code module yaeos_models_ar_cubic_pengrobinson78 use yaeos_constants , only : R , pr use yaeos_substance , only : Substances use yaeos_models_ar_genericcubic , only : CubicEoS , AlphaFunction , CubicMixRule use yaeos_models_ar_genericcubic_quadratic_mixing , only : QMR use yaeos_models_ar_cubic_alphas , only : AlphaSoave implicit none private public :: PengRobinson78 contains type ( CubicEoS ) function PengRobinson78 ( tc , pc , w , kij , lij ) result ( model ) real ( pr ), intent ( in ) :: tc (:), pc (:), w (:) real ( pr ), optional , intent ( in ) :: kij (:, :), lij (:, :) type ( Substances ) :: composition type ( QMR ) :: mixrule type ( AlphaSoave ) :: alpha integer :: nc integer :: i nc = size ( tc ) composition % tc = tc composition % pc = pc composition % w = w alpha % k = 0.37464_pr & + 1.54226_pr * composition % w & - 0.26993_pr * composition % w ** 2 where ( composition % w <= 0.491 ) alpha % k = 0.37464 + 1.54226 * composition % w ( i ) - 0.26992 * composition % w ** 2 elsewhere alpha % k = 0.379642 + 1.48503 * composition % w - 0.164423 * composition % w ** 2 + 0.016666 * composition % w ** 3 end where if ( present ( kij )) then mixrule % k = kij else mixrule % k = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif if ( present ( lij )) then mixrule % l = lij else mixrule % l = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif model % components = composition model % ac = 0.45723553_pr * R ** 2 * composition % tc ** 2 / composition % pc model % b = 0.07779607_pr * R * composition % tc / composition % pc model % del1 = [ 1 + sqrt ( 2.0_pr )] model % del2 = [ 1 - sqrt ( 2.0_pr )] model % alpha = alpha model % mixrule = mixrule end function end module","tags":"","loc":"sourcefile/pr78.f90.html"},{"title":"mixing_rules.f90 – Yaeos","text":"This file depends on sourcefile~~mixing_rules.f90~~EfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~constants.f90 constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~substance.f90 substance.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mixing_rules.f90~~AfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~pr76.f90 pr76.f90 sourcefile~models.f90->sourcefile~pr76.f90 sourcefile~pr78.f90 pr78.f90 sourcefile~models.f90->sourcefile~pr78.f90 sourcefile~srk.f90 srk.f90 sourcefile~models.f90->sourcefile~srk.f90 sourcefile~pr76.f90->sourcefile~mixing_rules.f90 sourcefile~pr78.f90->sourcefile~mixing_rules.f90 sourcefile~srk.f90->sourcefile~mixing_rules.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_models_ar_genericcubic_quadratic_mixing Source Code mixing_rules.f90 Source Code module yaeos_models_ar_genericcubic_quadratic_mixing use yaeos_constants , only : pr use yaeos_substance , only : substances use yaeos_models_ar_genericcubic , only : CubicMixRule implicit none type , extends ( CubicMixRule ) :: QMR real ( pr ), allocatable :: k (:, :), l (:, :) procedure ( get_aij ), pointer :: aij => kij_constant contains procedure :: Dmix procedure :: Bmix end type abstract interface subroutine get_aij (& self , ai , daidt , daidt2 , & aij , daijdt , daijdt2 ) import pr , QMR class ( QMR ) :: self real ( pr ), intent ( in ) :: ai (:), daidt (:), daidt2 (:) real ( pr ), intent ( out ) :: aij (:, :), daijdt (:, :), daijdt2 (:, :) end subroutine end interface contains subroutine Dmix ( self , n , T , & ai , daidt , daidt2 , & D , dDdT , dDdT2 , dDi , dDidT , dDij ) class ( QMR ), intent ( in ) :: self real ( pr ), intent ( in ) :: T , n (:) real ( pr ), intent ( in ) :: ai (:), daidt (:), daidt2 (:) real ( pr ), intent ( out ) :: D , dDdT , dDdT2 , dDi (:), dDidT (:), dDij (:, :) integer :: i , j , nc real ( pr ) :: aux , aux2 real ( pr ) :: aij ( size ( ai ), size ( ai )) real ( pr ) :: daijdt ( size ( ai ), size ( ai )) real ( pr ) :: daijdt2 ( size ( ai ), size ( ai )) nc = size ( ai ) if ( associated ( self % aij )) & call self % aij ( ai , daidt , daidt2 , aij , daijdt , daijdt2 ) D = 0 dDdT = 0 dDdT2 = 0 do i = 1 , nc aux = 0 aux2 = 0 dDi ( i ) = 0 dDidT ( i ) = 0 do j = 1 , nc dDi ( i ) = dDi ( i ) + 2 * n ( j ) * aij ( i , j ) dDidT ( i ) = dDidT ( i ) + 2 * n ( j ) * daijdT ( i , j ) aux2 = aux2 + n ( j ) * daijdT2 ( i , j ) dDij ( i , j ) = 2 * aij ( i , j ) aux = aux + n ( j ) * aij ( i , j ) end do D = D + n ( i ) * aux dDdT = dDdT + n ( i ) * dDidT ( i ) * 0.5_pr dDdT2 = dDdT2 + n ( i ) * aux2 end do end subroutine subroutine Bmix ( self , n , bi , B , dBi , dBij ) !! Mixture repulsive parameter. class ( QMR ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: bi (:) real ( pr ), intent ( out ) :: B , dBi (:), dBij (:, :) real ( pr ) :: bij ( size ( n ), size ( n )) real ( pr ) :: totn , aux ( size ( n )) integer :: i , j , nc nc = size ( n ) TOTN = sum ( n ) B = 0.0_pr aux = 0.0_pr do i = 1 , nc do j = 1 , nc bij ( i , j ) = 0.5_pr * ( bi ( i ) + bi ( j )) * ( 1.0_pr - self % l ( i , j )) aux ( i ) = aux ( i ) + n ( j ) * bij ( i , j ) end do B = B + n ( i ) * aux ( i ) end do B = B / totn do i = 1 , nc dBi ( i ) = ( 2 * aux ( i ) - B ) / totn do j = 1 , i dBij ( i , j ) = ( 2 * bij ( i , j ) - dBi ( i ) - dBi ( j )) / totn dBij ( j , i ) = dBij ( i , j ) end do end do end subroutine subroutine kij_constant (& self , a , dadt , dadt2 , & aij , daijdt , daijdt2 & ) class ( QMR ) :: self real ( pr ), intent ( in ) :: a (:), dadt (:), dadt2 (:) real ( pr ), intent ( out ) :: aij (:, :), daijdt (:, :), daijdt2 (:, :) integer :: i , j real ( pr ) :: sqrt_aii_ajj real ( pr ) :: ai2 ( size ( a )), inner_sum , inner_sum_2 real ( pr ) :: aij_daidt ai2 = a * a do i = 1 , size ( a ) aij ( i , i ) = a ( i ) daijdt ( i , i ) = dadt ( i ) daijdt2 ( i , i ) = dadt2 ( i ) do j = i + 1 , size ( a ) sqrt_aii_ajj = sqrt ( a ( i ) * a ( j )) aij ( i , j ) = sqrt_aii_ajj * ( 1 - self % k ( i , j )) inner_sum = a ( i ) * dadt ( j ) + a ( j ) * dadt ( i ) aij_daidt = aij ( i , j ) * ( 0.5_pr * inner_sum ) daijdt ( i , j ) = 0.5_pr * aij ( i , j ) * ( inner_sum ) / ( a ( i ) * a ( j )) daijdt2 ( i , j ) = & aij_daidt / ( ai2 ( i ) * ai2 ( j )) & - aij_daidt * dadt ( j ) / ( a ( i ) * ai2 ( j )) & - aij_daidt * dadt ( i ) / ( a ( j ) * ai2 ( i )) & + aij ( i , j ) * (& 0.5_pr * ( a ( i ) * dadt2 ( j ) + a ( j ) * dadt2 ( i )) & + dadt ( i ) * dadt ( j )& ) / ( a ( i ) * a ( j )) aij ( j , i ) = aij ( i , j ) daijdt ( j , i ) = daijdt ( i , j ) daijdt2 ( j , i ) = daijdt2 ( i , j ) end do end do end subroutine end module","tags":"","loc":"sourcefile/mixing_rules.f90.html"},{"title":"alphas.f90 – Yaeos","text":"This file depends on sourcefile~~alphas.f90~~EfferentGraph sourcefile~alphas.f90 alphas.f90 sourcefile~constants.f90 constants.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~substance.f90 substance.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~alphas.f90~~AfferentGraph sourcefile~alphas.f90 alphas.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~pr76.f90 pr76.f90 sourcefile~models.f90->sourcefile~pr76.f90 sourcefile~pr78.f90 pr78.f90 sourcefile~models.f90->sourcefile~pr78.f90 sourcefile~srk.f90 srk.f90 sourcefile~models.f90->sourcefile~srk.f90 sourcefile~pr76.f90->sourcefile~alphas.f90 sourcefile~pr78.f90->sourcefile~alphas.f90 sourcefile~srk.f90->sourcefile~alphas.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaeos_models_ar_cubic_alphas Source Code alphas.f90 Source Code module yaeos_models_ar_cubic_alphas use yaeos_constants , only : pr use yaeos_substance , only : substances use yaeos_models_ar_genericcubic , only : CubicEoS , AlphaFunction implicit none type , extends ( AlphaFunction ) :: AlphaSoave real ( pr ), allocatable :: k (:) contains procedure :: alpha end type contains subroutine alpha ( self , Tr , a , dadt , dadt2 ) class ( AlphaSoave ), intent ( in ) :: self real ( pr ), intent ( in ) :: Tr (:) real ( pr ), intent ( out ) :: a (:), dadt (:), dadt2 (:) associate ( k => self % k ) a = ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 dadT = k * ( k * ( sqrt ( Tr ) - 1 ) - 1 ) / sqrt ( Tr ) dadT2 = ( 1.0d0 / 2.0d0 ) * k * ( k + 1 ) / Tr ** ( 1.5_pr ) end associate end subroutine end module","tags":"","loc":"sourcefile/alphas.f90.html"},{"title":"User documentation – Yaeos","text":"","tags":"","loc":"page/index.html"},{"title":"Adding new models – Yaeos","text":"","tags":"","loc":"page/subdir/index.html"}]}