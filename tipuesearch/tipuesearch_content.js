var tipuesearch = {"pages":[{"title":" yaeos ","text":"yaeos A little taste of yaeos How to install/run it Including new models with Automatic Differentiation. Documentation There are multiple open source equations of state libraries, like: Clapeyron julia FeOs rust with Python bindings teqp C++ with Python bindings thermo python thermopack Fortran with Python bindings CoolProp C++ with Python bindings Here we are presenting yet another (still in development) one, that tackles the\nsame problem just, in another way. Mostly exploiting the readability and\nextensibility of Modern Fortran for scientists to have an easy way to implement\nnew thermodynamic models without dealing with lower-level languages but still\ngetting decent performance.\nAnd also this framework provides the possibility of using analytically obtained\nderivatives so both options are easily available. This is an experimental work in progress and we recommend the before\nmentioned libraries if you are intending to use some of this in real work.\nBig part of the code comes from a refactoring process of older codes so\nnot all parts are easily readable, yet. We focus mainly on that the addition of a new thermodynamic model as easily as\npossible. Also providing our models too! For now, we only include residual Helmholtz model (like Cubic or Saft Equations\nof State). But we’ll be adding other models like $G&#94;E$ (UNIFAC for example). A little taste of yaeos A lot of users get the bad picture of Fortran being old and archaic since most\nof the codes they’ve seen are written in ancient F77 . use yaeos , only : PengRobinson76 , pressure , ArModel integer , parameter :: n = 2 ! Number of components real ( 8 ) :: V , T , P , dPdN ( n ) ! variables to calculate class ( ArModel ), allocatable :: model ! Model real ( pr ) :: z ( n ), tc ( n ), pc ( n ), w ( n ), kij ( n , n ), lij ( n , n ) z = [ 0.3 , 0.7 ] tc = [ 19 0. , 31 0. ] pc = [ 1 4. , 3 0. ] w = [ 0.001 , 0.03 ] kij = reshape ([ 0. , 0.1 , 0.1 , 0. ], [ n , n ]) lij = kij / 2 model = PengRobinson76 ( tc , pc , w , kij , lij ) V = 1 T = 150 call pressure ( model , z , V , T , P ) print * , P ! Obtain derivatives adding them as optional arguments! call pressure ( model , z , V , T , P , dPdN = dPdN ) print * , dPdN How to install/run it yaeos is intended to use as a fpm You can either: Generate a new project that uses yaeos as a dependency fpm new my_project In the fpm.toml file add: [dependencies] yaeos = { git = \"https://github.com/ipqa-research/yaeos\" } Clone this repository and just modify the executables in the app directory git clone https://github.com/ipqa-research/yaeos cd yaeos\nfpm run Including new models with Automatic Differentiation. We are using the hyperdual module developed by Philipp Rehner and Gernot Bauer The automatic differentiation API isn’t fully optimized yet so performance is\nmuch slower than it should be. type , extends ( ArModelAdiff ) :: YourNewModel type ( Substances ) :: composition real ( 8 ), allocatable :: parameters (:) ! A vector of parameters contains procedure :: Ar => arfun procedure :: get_v0 => v0 end type subroutine arfun ( self , n , v , t , Ar ) class ( YourNewModel ), intent ( in ) :: self type ( hyperdual ), intent ( in ) :: n (:) ! Number of moles type ( hyperdual ), intent ( in ) :: v ! Volume [L] type ( hyperdual ), intent ( in ) :: t ! Temperature [K] type ( hyperdual ), intent ( out ) :: ar_value ! Residual Helmholtz Energy ! A very complicated residual helmholtz function of a mixture Ar = sum ( n ) * v * t / self % parameters ( 1 ) end subroutine function v0 ( self , n , p , t ) class ( YourNewModel ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) ! Number of moles real ( pr ), intent ( in ) :: p ! Pressure [bar] real ( pr ), intent ( in ) :: t ! Temperature [K] real ( pr ) :: v0 v0 = self % parameters ( 3 ) end function A complete implementation of the PR76 Equation of State can me found in example/adiff/adiff_pr76.f90 . All the thermodynamic properties can be found in yaeos_thermoprops and called\nlike: use yaeos_thermoprops , only : fugacity_vt use my_new_model , only : YourNewModel ... type ( YourNewModel ) :: eos eos % parameters = [ 1 , 2 , 3 ] call fugacity_vt ( eos , n , v , t , lnfug = lnfug , dlnphidn = dlnphidn ) Documentation The latest API documentation for the main branch can be found here . This was generated from the source\ncode using FORD . We’re\nworking in extending it more. Developer Info Federico Benelli PhD student with focus on reservoir PVT simulation.","tags":"home","loc":"index.html"},{"title":"ArModelAdiff – yaeos ","text":"type, public, extends( ArModel ) :: ArModelAdiff Inherits type~~armodeladiff~~InheritsGraph type~armodeladiff ArModelAdiff type~armodel ArModel type~armodeladiff->type~armodel Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure( hyperdual_Ar ), public, deferred :: Ar function hyperdual_Ar(self, n, v, t) Prototype Arguments Type Intent Optional Attributes Name class( ArModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual ) procedure( abs_volume_initializer ), public, deferred :: get_v0 Volume initializer function abs_volume_initializer(self, n, p, t) Prototype Initialization of volume. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Ar Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: t Temperature [K] Return Value real(kind=pr) Initial volume [L] procedure, public :: residual_helmholtz public  subroutine residual_helmholtz (self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"type/armodeladiff.html"},{"title":"AlphaSoave – yaeos ","text":"type, public, extends( AlphaFunction ) :: AlphaSoave Soave function. Inherits type~~alphasoave~~InheritsGraph type~alphasoave AlphaSoave type~alphafunction AlphaFunction type~alphasoave->type~alphafunction Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: k (:) parameter. Type-Bound Procedures procedure, public :: alpha Alpha function public  subroutine alpha (self, Tr, a, dadt, dadt2) Soave function and it’s derivatives. Arguments Type Intent Optional Attributes Name class( AlphaSoave ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) Reduced temperature real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","loc":"type/alphasoave.html"},{"title":"hyperdual – yaeos ","text":"type, public :: hyperdual Components Type Visibility Attributes Name Initial real(kind=pr), public :: f0 = 0 real part of the hyperdual number real(kind=pr), public :: f1 = 0 \\f$\\varepsilon_1\\f$-part of  the hyperdual number real(kind=pr), public :: f12 = 0 \\f$\\varepsilon_1\\varepsilon_2\\f$-part of the real(kind=pr), public :: f2 = 0 \\f$\\varepsilon_2\\f$-part of  the hyperdual number","tags":"","loc":"type/hyperdual.html"},{"title":"ArModel – yaeos ","text":"type, public :: ArModel Abstract residual Helmholtz model. This derived type defines the basics needed for the calculation\nof residual properties.\nThe basics of a residual Helmholtz model is a routine that calculates\nall the needed derivatives of residual_helmholtz and\na volume initializer function, that is used to initialize a Newton\nsolver of volume when specifying pressure. Inherited by type~~armodel~~InheritedByGraph type~armodel ArModel type~armodeladiff ArModelAdiff type~armodeladiff->type~armodel type~armodeltapenade ArModelTapenade type~armodeltapenade->type~armodel type~cubiceos CubicEoS type~cubiceos->type~armodel Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure( abs_volume_initializer ), public, deferred :: get_v0 Volume initializer function abs_volume_initializer(self, n, p, t) Prototype Initialization of volume. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Ar Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: t Temperature [K] Return Value real(kind=pr) Initial volume [L] procedure( abs_residual_helmholtz ), public, deferred :: residual_helmholtz Method to calculate residual helmholtz energy and derivatives. subroutine abs_residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Prototype Residual Helmholtz model generic interface. This interface represents how an Ar model should be implemented.\nBy our standard, a Resiudal Helmholtz model takes as input: The mixture’s number of moles vector. Volume, by default in liters. Temperature, by default in Kelvin. All the output arguments are optional. While this keeps a long\nsignature for the implementation, this is done this way to take\nadvantage of any inner optimizations to calculate derivatives\ninside the procedure. Once the model is implemented, the signature can be short like model%residual_helmholtz(n, v, t, ArT2=dArdT2) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self ArModel real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: Ar Residual Helmoltz energy real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"type/armodel.html"},{"title":"QMR – yaeos ","text":"type, public, extends( CubicMixRule ) :: QMR Quadratic Mixing Rule (QMR) derived type. Classic Van der Waals mixing\nrules. QMR depends on binary interaction parameters, on a Cubic EoS\nthe mixture is obtained by the combination of an attractive and\nrepulsive parameter matrices. By default the attractive parameter matrix is calculated with: generating the matrix, but this procedure can be overriden\nreplacing the aij pointer procedure. Inherits type~~qmr~~InheritsGraph type~qmr QMR type~cubicmixrule CubicMixRule type~qmr->type~cubicmixrule Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial procedure( get_aij ), public, pointer :: aij => kij_constant Procedure to calculate matrix. Can be overloaded\nby any method that respets the interface get_aij . real(kind=pr), public, allocatable :: k (:,:) Attractive Binary Interatction parameter matrix real(kind=pr), public, allocatable :: l (:,:) Repulsive Binary Interatction parameter matrix Type-Bound Procedures procedure, public :: Bmix Repulsive parameter mixing rule public  subroutine Bmix (self, n, bi, B, dBi, dBij) Mixture repulsive parameter. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector. real(kind=pr), intent(in) :: bi (:) Pure components repulsive parameters. real(kind=pr), intent(out) :: B Mixture repulsive parameter. real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) procedure, public :: Dmix Attractive parameter mixing rule public  subroutine Dmix (self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Attractive parameter mixing rule with quadratic mix. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: ai (:) Pure components attractive parameters real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D Mixture attractive parameter real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:)","tags":"","loc":"type/qmr.html"},{"title":"ArModelTapenade – yaeos ","text":"type, public, extends( ArModel ) :: ArModelTapenade Inherits type~~armodeltapenade~~InheritsGraph type~armodeltapenade ArModelTapenade type~armodel ArModel type~armodeltapenade->type~armodel Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial procedure( tapenade_ar ), public, pointer, nopass :: ar procedure( tapenade_ar_b ), public, pointer, nopass :: ar_b procedure( tapenade_ar_d ), public, pointer, nopass :: ar_d procedure( tapenade_ar_d_b ), public, pointer, nopass :: ar_d_b procedure( tapenade_ar_d_d ), public, pointer, nopass :: ar_d_d character(len=:), public, allocatable :: name Name of the model procedure( tapenade_v0 ), public, pointer, nopass :: v0 Type-Bound Procedures procedure, public :: get_v0 private  function get_v0 (self, n, p, t) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) procedure, public :: residual_helmholtz private  subroutine residual_helmholtz (self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz model generic interface Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"type/armodeltapenade.html"},{"title":"AlphaFunction – yaeos ","text":"type, public :: AlphaFunction Abstract derived type that describe the required\nprocedure for an alpha function. Inherited by type~~alphafunction~~InheritedByGraph type~alphafunction AlphaFunction type~alphasoave AlphaSoave type~alphasoave->type~alphafunction type~cubiceos CubicEoS type~cubiceos->type~alphafunction alpha Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure( abs_alpha ), public, deferred :: alpha subroutine abs_alpha(self, Tr, a, dadt, dadt2) Prototype Arguments Type Intent Optional Attributes Name class( AlphaFunction ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","loc":"type/alphafunction.html"},{"title":"CubicEoS – yaeos ","text":"type, public, extends( ArModel ) :: CubicEoS Cubic Equation of State. Generic Cubic Equation of State as defined by Michelsen and Mollerup\nwith constant and parameters. Inherits type~~cubiceos~~InheritsGraph type~cubiceos CubicEoS type~alphafunction AlphaFunction type~cubiceos->type~alphafunction alpha type~armodel ArModel type~cubiceos->type~armodel type~cubicmixrule CubicMixRule type~cubiceos->type~cubicmixrule mixrule type~substances Substances type~cubiceos->type~substances components Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: ac (:) Attractive critical parameter class( AlphaFunction ), public, allocatable :: alpha real(kind=pr), public, allocatable :: b (:) Repulsive parameter class( Substances ), public, allocatable :: components real(kind=pr), public, allocatable :: del1 (:) paramter real(kind=pr), public, allocatable :: del2 (:) paramter class( CubicMixRule ), public, allocatable :: mixrule character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure, public :: get_v0 => v0 public  function v0 (self, n, p, t) Cubic EoS volume initializer.\nFor a Cubic Equation of State, the covolume calculated with the mixing\nrule is a good estimate for the initial volume solver on the liquid\nregion. Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) procedure, public :: residual_helmholtz => GenericCubic_Ar public  subroutine GenericCubic_Ar (self, n, v, t, ar, arv, ArT, artv, arv2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz Energy for a generic Cubic Equation of State. Read more… Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: ar Residual Helmholtz real(kind=pr), intent(out), optional :: arv real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: artv real(kind=pr), intent(out), optional :: arv2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"type/cubiceos.html"},{"title":"CubicMixRule – yaeos ","text":"type, public :: CubicMixRule Abstract derived type that describe the required\nprocedure for a mixing rule on a Cubic EoS Inherited by type~~cubicmixrule~~InheritedByGraph type~cubicmixrule CubicMixRule type~cubiceos CubicEoS type~cubiceos->type~cubicmixrule mixrule type~qmr QMR type~qmr->type~cubicmixrule Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure( abs_Bmix ), public, deferred :: Bmix subroutine abs_Bmix(self, n, bi, B, dBi, dBij) Prototype Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) procedure( abs_Dmix ), public, deferred :: Dmix subroutine abs_Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Prototype Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:)","tags":"","loc":"type/cubicmixrule.html"},{"title":"EquilibriaState – yaeos ","text":"type, public :: EquilibriaState Components Type Visibility Attributes Name Initial real(kind=pr), public :: Vx Liquid volume [L/mol] real(kind=pr), public :: Vy Vapor volume [L/mol] integer, public :: iters Iterations needed to reach the state real(kind=pr), public :: p Pressure [bar] real(kind=pr), public :: t Temperature [K] real(kind=pr), public, allocatable :: x (:) Liquid molar fractions real(kind=pr), public, allocatable :: y (:) Vapour molar fractions","tags":"","loc":"type/equilibriastate.html"},{"title":"Substances – yaeos ","text":"type, public :: Substances Set of pure components Inherited by type~~substances~~InheritedByGraph type~substances Substances type~cubiceos CubicEoS type~cubiceos->type~substances components Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=50), public, allocatable :: names (:) Composition names. real(kind=pr), public, allocatable :: pc (:) Critical Pressure [bar] real(kind=pr), public, allocatable :: tc (:) Critical Temperature [K] real(kind=pr), public, allocatable :: w (:) Acentric factor","tags":"","loc":"type/substances.html"},{"title":"hyperdual_Ar – yaeos","text":"interface public  function hyperdual_Ar(self, n, v, t) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual )","tags":"","loc":"interface/hyperdual_ar.html"},{"title":"Ares – yaeos","text":"interface public  subroutine Ares(z, v, t, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z))","tags":"","loc":"interface/ares.html"},{"title":"initial_volume – yaeos","text":"interface public  function initial_volume(z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr)","tags":"","loc":"interface/initial_volume.html"},{"title":"abs_residual_helmholtz – yaeos","text":"interface public  subroutine abs_residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self ArModel real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: Ar Residual Helmoltz energy real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Description Residual Helmholtz model generic interface. This interface represents how an Ar model should be implemented.\nBy our standard, a Resiudal Helmholtz model takes as input: The mixture’s number of moles vector. Volume, by default in liters. Temperature, by default in Kelvin. All the output arguments are optional. While this keeps a long\nsignature for the implementation, this is done this way to take\nadvantage of any inner optimizations to calculate derivatives\ninside the procedure. Once the model is implemented, the signature can be short like model%residual_helmholtz(n, v, t, ArT2=dArdT2)","tags":"","loc":"interface/abs_residual_helmholtz.html"},{"title":"abs_volume_initializer – yaeos","text":"interface public  function abs_volume_initializer(self, n, p, t) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Ar Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: t Temperature [K] Return Value real(kind=pr) Initial volume [L] Description Initialization of volume.","tags":"","loc":"interface/abs_volume_initializer.html"},{"title":"get_aij – yaeos","text":"interface public  subroutine get_aij(self, ai, daidt, daidt2, aij, daijdt, daijdt2) Arguments Type Intent Optional Attributes Name class( QMR ) :: self real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: aij (:,:) real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:) Description Combining rule for the attractive parameter. From previously calculated attractive parameters calculate the matrix and it’s corresponding derivatives.","tags":"","loc":"interface/get_aij.html"},{"title":"tapenade_ar – yaeos","text":"interface private  subroutine tapenade_ar(n, v, t, arval) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: arval","tags":"","loc":"interface/tapenade_ar.html"},{"title":"tapenade_ar_b – yaeos","text":"interface private  subroutine tapenade_ar_b(n, nb, v, vb, t, tb, arval, arvalb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: arval real(kind=pr) :: arvalb","tags":"","loc":"interface/tapenade_ar_b.html"},{"title":"tapenade_ar_d – yaeos","text":"interface private  subroutine tapenade_ar_d(n, nd, v, vd, t, td, arval, arvald) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald","tags":"","loc":"interface/tapenade_ar_d.html"},{"title":"tapenade_ar_d_b – yaeos","text":"interface private  subroutine tapenade_ar_d_b(n, nb, nd, ndb, v, vb, vd, vdb, t, tb, td, tdb, arval, arvalb, arvald, arvaldb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr) :: ndb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: vd real(kind=pr) :: vdb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr), intent(in) :: td real(kind=pr) :: tdb real(kind=pr) :: arval real(kind=pr) :: arvalb real(kind=pr) :: arvald real(kind=pr) :: arvaldb","tags":"","loc":"interface/tapenade_ar_d_b.html"},{"title":"tapenade_ar_d_d – yaeos","text":"interface private  subroutine tapenade_ar_d_d(n, nd, v, vd0, vd, t, td0, td, arval, arvald0, arvald, arvaldd) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd0 real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald0 real(kind=pr), intent(out) :: arvald real(kind=pr), intent(out) :: arvaldd","tags":"","loc":"interface/tapenade_ar_d_d.html"},{"title":"tapenade_v0 – yaeos","text":"interface private  function tapenade_v0(n, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr)","tags":"","loc":"interface/tapenade_v0.html"},{"title":"abs_Bmix – yaeos","text":"interface public  subroutine abs_Bmix(self, n, bi, B, dBi, dBij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:)","tags":"","loc":"interface/abs_bmix.html"},{"title":"abs_Dmix – yaeos","text":"interface public  subroutine abs_Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:)","tags":"","loc":"interface/abs_dmix.html"},{"title":"abs_alpha – yaeos","text":"interface public  subroutine abs_alpha(self, Tr, a, dadt, dadt2) Arguments Type Intent Optional Attributes Name class( AlphaFunction ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","loc":"interface/abs_alpha.html"},{"title":"PengRobinson76 – yaeos","text":"public  function PengRobinson76(tc, pc, w, kij, lij) result(model) Uses yaeos_substance yaeos_models_ar_cubic_alphas yaeos_constants yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic proc~~pengrobinson76~~UsesGraph proc~pengrobinson76 yaeos_models_ar_cubic_implementations::PengRobinson76 module~yaeos_constants yaeos_constants proc~pengrobinson76->module~yaeos_constants module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas proc~pengrobinson76->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic proc~pengrobinson76->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing proc~pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_substance yaeos_substance proc~pengrobinson76->module~yaeos_substance iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_substance->module~yaeos_constants module~yaeos_models_ar->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. PengRobinson76. Using the critical constants setup the parameters to use the \nPengRobinson Equation of State There is also the optional posibility to include the and matrices. Using by default Classic Van der Waals mixing\nrules. After setting up the model, it is possible to redefine either the\nmixing rule or the alpha function using a different derived type\ndefined outside the function. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical Temperatures [K] real(kind=pr), intent(in) :: pc (:) Critical Pressures [bar] real(kind=pr), intent(in) :: w (:) Acentric Factors real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS ) Variables Type Visibility Attributes Name Initial type( AlphaSoave ), private :: alpha type( Substances ), private :: composition integer, private :: i type( QMR ), private :: mixrule integer, private :: nc","tags":"","loc":"proc/pengrobinson76.html"},{"title":"PengRobinson78 – yaeos","text":"public  function PengRobinson78(tc, pc, w, kij, lij) result(model) Uses yaeos_substance yaeos_models_ar_cubic_alphas yaeos_constants yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic proc~~pengrobinson78~~UsesGraph proc~pengrobinson78 yaeos_models_ar_cubic_implementations::PengRobinson78 module~yaeos_constants yaeos_constants proc~pengrobinson78->module~yaeos_constants module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas proc~pengrobinson78->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic proc~pengrobinson78->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing proc~pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_substance yaeos_substance proc~pengrobinson78->module~yaeos_substance iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_substance->module~yaeos_constants module~yaeos_models_ar->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. PengRobinson78. Using the critical constants setup the parameters to use the \nPengRobinson Equation of State There is also the optional posibility to include the and matrices. Using by default Classic Van der Waals mixing\nrules. After setting up the model, it is possible to redefine either the\nmixing rule or the alpha function using a different derived type\ndefined outside the function. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical Temperatures [K] real(kind=pr), intent(in) :: pc (:) Critical Pressures [bar] real(kind=pr), intent(in) :: w (:) Acentric Factors real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS ) Variables Type Visibility Attributes Name Initial type( AlphaSoave ), private :: alpha type( Substances ), private :: composition integer, private :: i type( QMR ), private :: mixrule integer, private :: nc","tags":"","loc":"proc/pengrobinson78.html"},{"title":"SoaveRedlichKwong – yaeos","text":"public  function SoaveRedlichKwong(tc, pc, w, kij, lij) result(model) Uses yaeos_substance yaeos_models_ar_cubic_alphas yaeos_constants yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic proc~~soaveredlichkwong~~UsesGraph proc~soaveredlichkwong yaeos_models_ar_cubic_implementations::SoaveRedlichKwong module~yaeos_constants yaeos_constants proc~soaveredlichkwong->module~yaeos_constants module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas proc~soaveredlichkwong->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic proc~soaveredlichkwong->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing proc~soaveredlichkwong->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_substance yaeos_substance proc~soaveredlichkwong->module~yaeos_substance iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_substance->module~yaeos_constants module~yaeos_models_ar->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. SoaveRedlichKwong. Using the critical constants setup the parameters to use the \nSoaveRedlichKwong Equation of State There is also the optional posibility to include the k_{ij} and l_{ij}\nmatrices. Using by default Classic Van der Waals mixing rules. After setting up the model, it is possible to redefine either the\nmixing rule or the alpha function using a different derived type\ndefined outside the function. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical temperature [K] real(kind=pr), intent(in) :: pc (:) Critical pressure [bar] real(kind=pr), intent(in) :: w (:) Acentric factor real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS ) Variables Type Visibility Attributes Name Initial type( AlphaSoave ), private :: alpha type( Substances ), private :: composition integer, private :: i type( QMR ), private :: mixrule integer, private :: nc","tags":"","loc":"proc/soaveredlichkwong.html"},{"title":"popinteger4 – yaeos","text":"public interface popinteger4 Subroutines public  subroutine popinteger4(intnum) Arguments Type Intent Optional Attributes Name integer :: intnum","tags":"","loc":"interface/popinteger4.html"},{"title":"popreal8 – yaeos","text":"public interface popreal8 Subroutines public  subroutine popreal8(realnum) Arguments Type Intent Optional Attributes Name real(kind=8) :: realnum","tags":"","loc":"interface/popreal8.html"},{"title":"pushcontrol1b – yaeos","text":"public interface pushcontrol1b Subroutines public  subroutine pushcontrol1b(intnum) Arguments Type Intent Optional Attributes Name integer :: intnum","tags":"","loc":"interface/pushcontrol1b.html"},{"title":"pushinteger4 – yaeos","text":"public interface pushinteger4 Subroutines public  subroutine pushinteger4(intnum) Arguments Type Intent Optional Attributes Name integer :: intnum","tags":"","loc":"interface/pushinteger4.html"},{"title":"pushreal8 – yaeos","text":"public interface pushreal8 Subroutines public  subroutine pushreal8(realnum) Arguments Type Intent Optional Attributes Name real(kind=8) :: realnum public  subroutine pushreal8array(realnum) Arguments Type Intent Optional Attributes Name real(kind=8) :: realnum (:)","tags":"","loc":"interface/pushreal8.html"},{"title":"residual_helmholtz – yaeos","text":"public  subroutine residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Type Bound ArModelAdiff Arguments Type Intent Optional Attributes Name class( ArModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Calls proc~~residual_helmholtz~~CallsGraph proc~residual_helmholtz yaeos_ar_models_hyperdual::ArModelAdiff%residual_helmholtz none~get_dardn residual_helmholtz::get_dardn proc~residual_helmholtz->none~get_dardn none~get_dardn2 residual_helmholtz::get_dardn2 proc~residual_helmholtz->none~get_dardn2 none~get_dardt residual_helmholtz::get_dardt proc~residual_helmholtz->none~get_dardt none~get_dardt2 residual_helmholtz::get_dardt2 proc~residual_helmholtz->none~get_dardt2 none~get_dardtn residual_helmholtz::get_dardtn proc~residual_helmholtz->none~get_dardtn none~get_dardv residual_helmholtz::get_dardv proc~residual_helmholtz->none~get_dardv none~get_dardv2 residual_helmholtz::get_dardv2 proc~residual_helmholtz->none~get_dardv2 none~get_dardvn residual_helmholtz::get_dardvn proc~residual_helmholtz->none~get_dardvn none~get_dardvt residual_helmholtz::get_dardvt proc~residual_helmholtz->none~get_dardvt Ar Ar none~get_dardn->Ar none~reset_vars residual_helmholtz::reset_vars none~get_dardn->none~reset_vars none~get_dardn2->Ar none~get_dardn2->none~reset_vars none~get_dardt->Ar none~get_dardt->none~reset_vars none~get_dardt2->Ar none~get_dardt2->none~reset_vars none~get_dardtn->Ar none~get_dardtn->none~reset_vars none~get_dardv->Ar none~get_dardv->none~reset_vars none~get_dardv2->Ar none~get_dardv2->none~reset_vars none~get_dardvn->Ar none~get_dardvn->none~reset_vars none~get_dardvt->Ar none~get_dardvt->none~reset_vars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: d_Ar type( hyperdual ), public :: d_n (size(n)) type( hyperdual ), public :: d_t type( hyperdual ), public :: d_v Subroutines subroutine get_dardn () Arguments None subroutine get_dardn2 () Arguments None subroutine get_dardt () Arguments None subroutine get_dardt2 () Arguments None subroutine get_dardtn () Arguments None subroutine get_dardv () Arguments None subroutine get_dardv2 () Arguments None subroutine get_dardvn () Arguments None subroutine get_dardvt () Arguments None subroutine reset_vars () Arguments None","tags":"","loc":"proc/residual_helmholtz.html"},{"title":"alpha – yaeos","text":"public  subroutine alpha(self, Tr, a, dadt, dadt2) Soave function and it’s derivatives. Type Bound AlphaSoave Arguments Type Intent Optional Attributes Name class( AlphaSoave ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) Reduced temperature real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","loc":"proc/alpha.html"},{"title":"AddHyperDualHyperDual – yaeos","text":"public elemental function AddHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~addhyperdualhyperdual~~CalledByGraph proc~addhyperdualhyperdual hyperdual_mod::AddHyperDualHyperDual interface~operator (+)~2 hyperdual_mod::operator (+) interface~operator (+)~2->proc~addhyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/addhyperdualhyperdual.html"},{"title":"AddHyperDualReal – yaeos","text":"public elemental function AddHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~addhyperdualreal~~CalledByGraph proc~addhyperdualreal hyperdual_mod::AddHyperDualReal interface~operator (+)~2 hyperdual_mod::operator (+) interface~operator (+)~2->proc~addhyperdualreal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/addhyperdualreal.html"},{"title":"AddRealHyperDual – yaeos","text":"public elemental function AddRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~addrealhyperdual~~CalledByGraph proc~addrealhyperdual hyperdual_mod::AddRealHyperDual interface~operator (+)~2 hyperdual_mod::operator (+) interface~operator (+)~2->proc~addrealhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/addrealhyperdual.html"},{"title":"DivideHyperDualHyperDual – yaeos","text":"public elemental function DivideHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~dividehyperdualhyperdual~~CalledByGraph proc~dividehyperdualhyperdual hyperdual_mod::DivideHyperDualHyperDual interface~operator (SLASH) hyperdual_mod::operator (/) interface~operator (SLASH)->proc~dividehyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/dividehyperdualhyperdual.html"},{"title":"DivideHyperDualReal – yaeos","text":"public elemental function DivideHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~dividehyperdualreal~~CalledByGraph proc~dividehyperdualreal hyperdual_mod::DivideHyperDualReal interface~operator (SLASH) hyperdual_mod::operator (/) interface~operator (SLASH)->proc~dividehyperdualreal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: invV2","tags":"","loc":"proc/dividehyperdualreal.html"},{"title":"DivideRealHyperDual – yaeos","text":"public elemental function DivideRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~dividerealhyperdual~~CalledByGraph proc~dividerealhyperdual hyperdual_mod::DivideRealHyperDual interface~operator (SLASH) hyperdual_mod::operator (/) interface~operator (SLASH)->proc~dividerealhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: invV2","tags":"","loc":"proc/dividerealhyperdual.html"},{"title":"MinusHyperDualHyperDual – yaeos","text":"public elemental function MinusHyperDualHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~minushyperdualhyperdual~~CalledByGraph proc~minushyperdualhyperdual hyperdual_mod::MinusHyperDualHyperDual interface~operator (-) hyperdual_mod::operator (-) interface~operator (-)->proc~minushyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/minushyperdualhyperdual.html"},{"title":"MultiplyHyperDualHyperDual – yaeos","text":"public elemental function MultiplyHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~multiplyhyperdualhyperdual~~CalledByGraph proc~multiplyhyperdualhyperdual hyperdual_mod::MultiplyHyperDualHyperDual interface~operator (ASTERISK) hyperdual_mod::operator (*) interface~operator (ASTERISK)->proc~multiplyhyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/multiplyhyperdualhyperdual.html"},{"title":"MultiplyHyperDualInt – yaeos","text":"public elemental function MultiplyHyperDualInt(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~multiplyhyperdualint~~CalledByGraph proc~multiplyhyperdualint hyperdual_mod::MultiplyHyperDualInt interface~operator (ASTERISK) hyperdual_mod::operator (*) interface~operator (ASTERISK)->proc~multiplyhyperdualint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/multiplyhyperdualint.html"},{"title":"MultiplyHyperDualReal – yaeos","text":"public elemental function MultiplyHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~multiplyhyperdualreal~~CalledByGraph proc~multiplyhyperdualreal hyperdual_mod::MultiplyHyperDualReal interface~operator (ASTERISK) hyperdual_mod::operator (*) interface~operator (ASTERISK)->proc~multiplyhyperdualreal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/multiplyhyperdualreal.html"},{"title":"MultiplyIntHyperDual – yaeos","text":"public elemental function MultiplyIntHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~multiplyinthyperdual~~CalledByGraph proc~multiplyinthyperdual hyperdual_mod::MultiplyIntHyperDual interface~operator (ASTERISK) hyperdual_mod::operator (*) interface~operator (ASTERISK)->proc~multiplyinthyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/multiplyinthyperdual.html"},{"title":"MultiplyRealHyperDual – yaeos","text":"public elemental function MultiplyRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~multiplyrealhyperdual~~CalledByGraph proc~multiplyrealhyperdual hyperdual_mod::MultiplyRealHyperDual interface~operator (ASTERISK) hyperdual_mod::operator (*) interface~operator (ASTERISK)->proc~multiplyrealhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/multiplyrealhyperdual.html"},{"title":"PlusHyperDualHyperDual – yaeos","text":"public elemental function PlusHyperDualHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~plushyperdualhyperdual~~CalledByGraph proc~plushyperdualhyperdual hyperdual_mod::PlusHyperDualHyperDual interface~operator (+) hyperdual_mod::operator (+) interface~operator (+)->proc~plushyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/plushyperdualhyperdual.html"},{"title":"PowerHyperDualHyperDual – yaeos","text":"public elemental function PowerHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Calls proc~~powerhyperdualhyperdual~~CallsGraph proc~powerhyperdualhyperdual hyperdual_mod::PowerHyperDualHyperDual proc~exphyperdual hyperdual_mod::expHyperDual proc~powerhyperdualhyperdual->proc~exphyperdual proc~loghyperdual hyperdual_mod::logHyperDual proc~powerhyperdualhyperdual->proc~loghyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~powerhyperdualhyperdual~~CalledByGraph proc~powerhyperdualhyperdual hyperdual_mod::PowerHyperDualHyperDual interface~operator (ASTERISKASTERISK) hyperdual_mod::operator (**) interface~operator (ASTERISKASTERISK)->proc~powerhyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: v4","tags":"","loc":"proc/powerhyperdualhyperdual.html"},{"title":"PowerHyperDualInt – yaeos","text":"public elemental function PowerHyperDualInt(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~powerhyperdualint~~CalledByGraph proc~powerhyperdualint hyperdual_mod::PowerHyperDualInt interface~operator (ASTERISKASTERISK) hyperdual_mod::operator (**) interface~operator (ASTERISKASTERISK)->proc~powerhyperdualint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: vv2","tags":"","loc":"proc/powerhyperdualint.html"},{"title":"PowerHyperDualReal – yaeos","text":"public elemental function PowerHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~powerhyperdualreal~~CalledByGraph proc~powerhyperdualreal hyperdual_mod::PowerHyperDualReal interface~operator (ASTERISKASTERISK) hyperdual_mod::operator (**) interface~operator (ASTERISKASTERISK)->proc~powerhyperdualreal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public, parameter :: tol = 1.0e-15_pr real(kind=pr), public :: xval","tags":"","loc":"proc/powerhyperdualreal.html"},{"title":"SubtractHyperDualHyperDual – yaeos","text":"public elemental function SubtractHyperDualHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~subtracthyperdualhyperdual~~CalledByGraph proc~subtracthyperdualhyperdual hyperdual_mod::SubtractHyperDualHyperDual interface~operator (-)~2 hyperdual_mod::operator (-) interface~operator (-)~2->proc~subtracthyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/subtracthyperdualhyperdual.html"},{"title":"SubtractHyperDualReal – yaeos","text":"public elemental function SubtractHyperDualReal(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~subtracthyperdualreal~~CalledByGraph proc~subtracthyperdualreal hyperdual_mod::SubtractHyperDualReal interface~operator (-)~2 hyperdual_mod::operator (-) interface~operator (-)~2->proc~subtracthyperdualreal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/subtracthyperdualreal.html"},{"title":"SubtractRealHyperDual – yaeos","text":"public elemental function SubtractRealHyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~subtractrealhyperdual~~CalledByGraph proc~subtractrealhyperdual hyperdual_mod::SubtractRealHyperDual interface~operator (-)~2 hyperdual_mod::operator (-) interface~operator (-)~2->proc~subtractrealhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/subtractrealhyperdual.html"},{"title":"SumHyperDual – yaeos","text":"public pure function SumHyperDual(v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) Called by proc~~sumhyperdual~~CalledByGraph proc~sumhyperdual hyperdual_mod::SumHyperDual interface~sum hyperdual_mod::sum interface~sum->proc~sumhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/sumhyperdual.html"},{"title":"SumHyperDual2 – yaeos","text":"public pure function SumHyperDual2(v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ), allocatable, (:) Called by proc~~sumhyperdual2~~CalledByGraph proc~sumhyperdual2 hyperdual_mod::SumHyperDual2 interface~sum hyperdual_mod::sum interface~sum->proc~sumhyperdual2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/sumhyperdual2.html"},{"title":"absHyperDual – yaeos","text":"public elemental function absHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~abshyperdual~~CalledByGraph proc~abshyperdual hyperdual_mod::absHyperDual interface~abs hyperdual_mod::abs interface~abs->proc~abshyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/abshyperdual.html"},{"title":"acosHyperDual – yaeos","text":"public elemental function acosHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~acoshyperdual~~CalledByGraph proc~acoshyperdual hyperdual_mod::acosHyperDual interface~acos hyperdual_mod::acos interface~acos->proc~acoshyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public :: deriv1","tags":"","loc":"proc/acoshyperdual.html"},{"title":"asinHyperDual – yaeos","text":"public elemental function asinHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~asinhyperdual~~CalledByGraph proc~asinhyperdual hyperdual_mod::asinHyperDual interface~asin hyperdual_mod::asin interface~asin->proc~asinhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public :: deriv1","tags":"","loc":"proc/asinhyperdual.html"},{"title":"atan2HyperDual – yaeos","text":"public elemental function atan2HyperDual(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~atan2hyperdual~~CalledByGraph proc~atan2hyperdual hyperdual_mod::atan2HyperDual interface~atan2 hyperdual_mod::atan2 interface~atan2->proc~atan2hyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a real(kind=pr), public :: b real(kind=pr), public :: c real(kind=pr), public :: d","tags":"","loc":"proc/atan2hyperdual.html"},{"title":"atanHyperDual – yaeos","text":"public elemental function atanHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~atanhyperdual~~CalledByGraph proc~atanhyperdual hyperdual_mod::atanHyperDual interface~atan hyperdual_mod::atan interface~atan->proc~atanhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: deriv real(kind=pr), public :: deriv1","tags":"","loc":"proc/atanhyperdual.html"},{"title":"cosHyperDual – yaeos","text":"public elemental function cosHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~coshyperdual~~CalledByGraph proc~coshyperdual hyperdual_mod::cosHyperDual interface~cos hyperdual_mod::cos interface~cos->proc~coshyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx real(kind=pr), public :: f","tags":"","loc":"proc/coshyperdual.html"},{"title":"coshHyperDual – yaeos","text":"public elemental function coshHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~coshhyperdual~~CalledByGraph proc~coshhyperdual hyperdual_mod::coshHyperDual interface~cosh hyperdual_mod::cosh interface~cosh->proc~coshhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: t1 type( hyperdual ), public :: t2","tags":"","loc":"proc/coshhyperdual.html"},{"title":"eq_dd – yaeos","text":"public  function eq_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~eq_dd~~CalledByGraph proc~eq_dd hyperdual_mod::eq_dd interface~operator (.eq.) hyperdual_mod::operator (.eq.) interface~operator (.eq.)->proc~eq_dd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/eq_dd.html"},{"title":"eq_di – yaeos","text":"public  function eq_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~eq_di~~CalledByGraph proc~eq_di hyperdual_mod::eq_di interface~operator (.eq.) hyperdual_mod::operator (.eq.) interface~operator (.eq.)->proc~eq_di Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/eq_di.html"},{"title":"eq_dr – yaeos","text":"public elemental function eq_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~eq_dr~~CalledByGraph proc~eq_dr hyperdual_mod::eq_dr interface~operator (.eq.) hyperdual_mod::operator (.eq.) interface~operator (.eq.)->proc~eq_dr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/eq_dr.html"},{"title":"eq_id – yaeos","text":"public  function eq_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~eq_id~~CalledByGraph proc~eq_id hyperdual_mod::eq_id interface~operator (.eq.) hyperdual_mod::operator (.eq.) interface~operator (.eq.)->proc~eq_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/eq_id.html"},{"title":"eq_rd – yaeos","text":"public elemental function eq_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~eq_rd~~CalledByGraph proc~eq_rd hyperdual_mod::eq_rd interface~operator (.eq.) hyperdual_mod::operator (.eq.) interface~operator (.eq.)->proc~eq_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/eq_rd.html"},{"title":"expHyperDual – yaeos","text":"public elemental function expHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~exphyperdual~~CalledByGraph proc~exphyperdual hyperdual_mod::expHyperDual interface~exp hyperdual_mod::exp interface~exp->proc~exphyperdual proc~powerhyperdualhyperdual hyperdual_mod::PowerHyperDualHyperDual proc~powerhyperdualhyperdual->proc~exphyperdual interface~operator (ASTERISKASTERISK) hyperdual_mod::operator (**) interface~operator (ASTERISKASTERISK)->proc~powerhyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx","tags":"","loc":"proc/exphyperdual.html"},{"title":"ge_dd – yaeos","text":"public  function ge_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ge_dd~~CalledByGraph proc~ge_dd hyperdual_mod::ge_dd interface~operator (.ge.) hyperdual_mod::operator (.ge.) interface~operator (.ge.)->proc~ge_dd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ge_dd.html"},{"title":"ge_di – yaeos","text":"public  function ge_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~ge_di~~CalledByGraph proc~ge_di hyperdual_mod::ge_di interface~operator (.ge.) hyperdual_mod::operator (.ge.) interface~operator (.ge.)->proc~ge_di Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ge_di.html"},{"title":"ge_dr – yaeos","text":"public  function ge_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~ge_dr~~CalledByGraph proc~ge_dr hyperdual_mod::ge_dr interface~operator (.ge.) hyperdual_mod::operator (.ge.) interface~operator (.ge.)->proc~ge_dr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ge_dr.html"},{"title":"ge_id – yaeos","text":"public  function ge_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ge_id~~CalledByGraph proc~ge_id hyperdual_mod::ge_id interface~operator (.ge.) hyperdual_mod::operator (.ge.) interface~operator (.ge.)->proc~ge_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ge_id.html"},{"title":"ge_rd – yaeos","text":"public  function ge_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ge_rd~~CalledByGraph proc~ge_rd hyperdual_mod::ge_rd interface~operator (.ge.) hyperdual_mod::operator (.ge.) interface~operator (.ge.)->proc~ge_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ge_rd.html"},{"title":"gt_dd – yaeos","text":"public  function gt_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~gt_dd~~CalledByGraph proc~gt_dd hyperdual_mod::gt_dd interface~operator (.gt.) hyperdual_mod::operator (.gt.) interface~operator (.gt.)->proc~gt_dd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/gt_dd.html"},{"title":"gt_di – yaeos","text":"public  function gt_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~gt_di~~CalledByGraph proc~gt_di hyperdual_mod::gt_di interface~operator (.gt.) hyperdual_mod::operator (.gt.) interface~operator (.gt.)->proc~gt_di Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/gt_di.html"},{"title":"gt_dr – yaeos","text":"public  function gt_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~gt_dr~~CalledByGraph proc~gt_dr hyperdual_mod::gt_dr interface~operator (.gt.) hyperdual_mod::operator (.gt.) interface~operator (.gt.)->proc~gt_dr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/gt_dr.html"},{"title":"gt_id – yaeos","text":"public  function gt_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~gt_id~~CalledByGraph proc~gt_id hyperdual_mod::gt_id interface~operator (.gt.) hyperdual_mod::operator (.gt.) interface~operator (.gt.)->proc~gt_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/gt_id.html"},{"title":"gt_rd – yaeos","text":"public  function gt_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~gt_rd~~CalledByGraph proc~gt_rd hyperdual_mod::gt_rd interface~operator (.gt.) hyperdual_mod::operator (.gt.) interface~operator (.gt.)->proc~gt_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/gt_rd.html"},{"title":"intHyperDual – yaeos","text":"public elemental function intHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer Called by proc~~inthyperdual~~CalledByGraph proc~inthyperdual hyperdual_mod::intHyperDual interface~int hyperdual_mod::int interface~int->proc~inthyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/inthyperdual.html"},{"title":"le_dd – yaeos","text":"public  function le_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~le_dd~~CalledByGraph proc~le_dd hyperdual_mod::le_dd interface~operator (.le.) hyperdual_mod::operator (.le.) interface~operator (.le.)->proc~le_dd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/le_dd.html"},{"title":"le_di – yaeos","text":"public  function le_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~le_di~~CalledByGraph proc~le_di hyperdual_mod::le_di interface~operator (.le.) hyperdual_mod::operator (.le.) interface~operator (.le.)->proc~le_di Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/le_di.html"},{"title":"le_dr – yaeos","text":"public  function le_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~le_dr~~CalledByGraph proc~le_dr hyperdual_mod::le_dr interface~operator (.le.) hyperdual_mod::operator (.le.) interface~operator (.le.)->proc~le_dr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/le_dr.html"},{"title":"le_id – yaeos","text":"public  function le_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~le_id~~CalledByGraph proc~le_id hyperdual_mod::le_id interface~operator (.le.) hyperdual_mod::operator (.le.) interface~operator (.le.)->proc~le_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/le_id.html"},{"title":"le_rd – yaeos","text":"public  function le_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~le_rd~~CalledByGraph proc~le_rd hyperdual_mod::le_rd interface~operator (.le.) hyperdual_mod::operator (.le.) interface~operator (.le.)->proc~le_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/le_rd.html"},{"title":"log10HyperDual – yaeos","text":"public elemental function log10HyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~log10hyperdual~~CalledByGraph proc~log10hyperdual hyperdual_mod::log10HyperDual interface~log10 hyperdual_mod::log10 interface~log10->proc~log10hyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/log10hyperdual.html"},{"title":"logHyperDual – yaeos","text":"public elemental function logHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~loghyperdual~~CalledByGraph proc~loghyperdual hyperdual_mod::logHyperDual interface~log hyperdual_mod::log interface~log->proc~loghyperdual proc~powerhyperdualhyperdual hyperdual_mod::PowerHyperDualHyperDual proc~powerhyperdualhyperdual->proc~loghyperdual interface~operator (ASTERISKASTERISK) hyperdual_mod::operator (**) interface~operator (ASTERISKASTERISK)->proc~powerhyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx1 real(kind=pr), public :: dx2","tags":"","loc":"proc/loghyperdual.html"},{"title":"lt_dd – yaeos","text":"public  function lt_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~lt_dd~~CalledByGraph proc~lt_dd hyperdual_mod::lt_dd interface~operator (.lt.) hyperdual_mod::operator (.lt.) interface~operator (.lt.)->proc~lt_dd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/lt_dd.html"},{"title":"lt_di – yaeos","text":"public  function lt_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~lt_di~~CalledByGraph proc~lt_di hyperdual_mod::lt_di interface~operator (.lt.) hyperdual_mod::operator (.lt.) interface~operator (.lt.)->proc~lt_di Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/lt_di.html"},{"title":"lt_dr – yaeos","text":"public  function lt_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~lt_dr~~CalledByGraph proc~lt_dr hyperdual_mod::lt_dr interface~operator (.lt.) hyperdual_mod::operator (.lt.) interface~operator (.lt.)->proc~lt_dr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/lt_dr.html"},{"title":"lt_id – yaeos","text":"public  function lt_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~lt_id~~CalledByGraph proc~lt_id hyperdual_mod::lt_id interface~operator (.lt.) hyperdual_mod::operator (.lt.) interface~operator (.lt.)->proc~lt_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/lt_id.html"},{"title":"lt_rd – yaeos","text":"public  function lt_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~lt_rd~~CalledByGraph proc~lt_rd hyperdual_mod::lt_rd interface~operator (.lt.) hyperdual_mod::operator (.lt.) interface~operator (.lt.)->proc~lt_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/lt_rd.html"},{"title":"max_dd – yaeos","text":"public elemental function max_dd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~max_dd~~CalledByGraph proc~max_dd hyperdual_mod::max_dd interface~max hyperdual_mod::max interface~max->proc~max_dd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/max_dd.html"},{"title":"max_ddd – yaeos","text":"public elemental function max_ddd(v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual ) Called by proc~~max_ddd~~CalledByGraph proc~max_ddd hyperdual_mod::max_ddd interface~max hyperdual_mod::max interface~max->proc~max_ddd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/max_ddd.html"},{"title":"max_dr – yaeos","text":"public elemental function max_dr(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~max_dr~~CalledByGraph proc~max_dr hyperdual_mod::max_dr interface~max hyperdual_mod::max interface~max->proc~max_dr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/max_dr.html"},{"title":"max_rd – yaeos","text":"public elemental function max_rd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~max_rd~~CalledByGraph proc~max_rd hyperdual_mod::max_rd interface~max hyperdual_mod::max interface~max->proc~max_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/max_rd.html"},{"title":"min_dd – yaeos","text":"public elemental function min_dd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~min_dd~~CalledByGraph proc~min_dd hyperdual_mod::min_dd interface~min hyperdual_mod::min interface~min->proc~min_dd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/min_dd.html"},{"title":"min_dr – yaeos","text":"public elemental function min_dr(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~min_dr~~CalledByGraph proc~min_dr hyperdual_mod::min_dr interface~min hyperdual_mod::min interface~min->proc~min_dr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/min_dr.html"},{"title":"min_rd – yaeos","text":"public elemental function min_rd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~min_rd~~CalledByGraph proc~min_rd hyperdual_mod::min_rd interface~min hyperdual_mod::min interface~min->proc~min_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/min_rd.html"},{"title":"ne_dd – yaeos","text":"public  function ne_dd(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ne_dd~~CalledByGraph proc~ne_dd hyperdual_mod::ne_dd interface~operator (.ne.) hyperdual_mod::operator (.ne.) interface~operator (.ne.)->proc~ne_dd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ne_dd.html"},{"title":"ne_di – yaeos","text":"public  function ne_di(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical Called by proc~~ne_di~~CalledByGraph proc~ne_di hyperdual_mod::ne_di interface~operator (.ne.) hyperdual_mod::operator (.ne.) interface~operator (.ne.)->proc~ne_di Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ne_di.html"},{"title":"ne_dr – yaeos","text":"public  function ne_dr(lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical Called by proc~~ne_dr~~CalledByGraph proc~ne_dr hyperdual_mod::ne_dr interface~operator (.ne.) hyperdual_mod::operator (.ne.) interface~operator (.ne.)->proc~ne_dr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ne_dr.html"},{"title":"ne_id – yaeos","text":"public  function ne_id(lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ne_id~~CalledByGraph proc~ne_id hyperdual_mod::ne_id interface~operator (.ne.) hyperdual_mod::operator (.ne.) interface~operator (.ne.)->proc~ne_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ne_id.html"},{"title":"ne_rd – yaeos","text":"public  function ne_rd(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical Called by proc~~ne_rd~~CalledByGraph proc~ne_rd hyperdual_mod::ne_rd interface~operator (.ne.) hyperdual_mod::operator (.ne.) interface~operator (.ne.)->proc~ne_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ne_rd.html"},{"title":"nintHyperDual – yaeos","text":"public elemental function nintHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer Called by proc~~ninthyperdual~~CalledByGraph proc~ninthyperdual hyperdual_mod::nintHyperDual interface~nint hyperdual_mod::nint interface~nint->proc~ninthyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ninthyperdual.html"},{"title":"realHyperDual – yaeos","text":"public elemental function realHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr) Called by proc~~realhyperdual~~CalledByGraph proc~realhyperdual hyperdual_mod::realHyperDual interface~real hyperdual_mod::real interface~real->proc~realhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/realhyperdual.html"},{"title":"sign_dd – yaeos","text":"public elemental function sign_dd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~sign_dd~~CalledByGraph proc~sign_dd hyperdual_mod::sign_dd interface~sign hyperdual_mod::sign interface~sign->proc~sign_dd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ssign","tags":"","loc":"proc/sign_dd.html"},{"title":"sign_dr – yaeos","text":"public elemental function sign_dr(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~sign_dr~~CalledByGraph proc~sign_dr hyperdual_mod::sign_dr interface~sign hyperdual_mod::sign interface~sign->proc~sign_dr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ssign","tags":"","loc":"proc/sign_dr.html"},{"title":"sign_rd – yaeos","text":"public elemental function sign_rd(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) Called by proc~~sign_rd~~CalledByGraph proc~sign_rd hyperdual_mod::sign_rd interface~sign hyperdual_mod::sign interface~sign->proc~sign_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ssign","tags":"","loc":"proc/sign_rd.html"},{"title":"sinHyperDual – yaeos","text":"public elemental function sinHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~sinhyperdual~~CalledByGraph proc~sinhyperdual hyperdual_mod::sinHyperDual interface~sin hyperdual_mod::sin interface~sin->proc~sinhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx real(kind=pr), public :: f","tags":"","loc":"proc/sinhyperdual.html"},{"title":"sinhHyperDual – yaeos","text":"public elemental function sinhHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~sinhhyperdual~~CalledByGraph proc~sinhhyperdual hyperdual_mod::sinhHyperDual interface~sinh hyperdual_mod::sinh interface~sinh->proc~sinhhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: t1 type( hyperdual ), public :: t2","tags":"","loc":"proc/sinhhyperdual.html"},{"title":"sqrtHyperDual – yaeos","text":"public elemental function sqrtHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~sqrthyperdual~~CalledByGraph proc~sqrthyperdual hyperdual_mod::sqrtHyperDual interface~sqrt hyperdual_mod::sqrt interface~sqrt->proc~sqrthyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public, parameter :: expo = 3.0_pr/2.0_pr real(kind=pr), public :: square","tags":"","loc":"proc/sqrthyperdual.html"},{"title":"tanHyperDual – yaeos","text":"public elemental function tanHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~tanhyperdual~~CalledByGraph proc~tanhyperdual hyperdual_mod::tanHyperDual interface~tan hyperdual_mod::tan interface~tan->proc~tanhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dx real(kind=pr), public :: f","tags":"","loc":"proc/tanhyperdual.html"},{"title":"tanhHyperDual – yaeos","text":"public elemental function tanhHyperDual(v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Called by proc~~tanhhyperdual~~CalledByGraph proc~tanhhyperdual hyperdual_mod::tanhHyperDual interface~tanh hyperdual_mod::tanh interface~tanh->proc~tanhhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( hyperdual ), public :: t1 type( hyperdual ), public :: t2","tags":"","loc":"proc/tanhhyperdual.html"},{"title":"EqualHyperDualHyperDual – yaeos","text":"public elemental subroutine EqualHyperDualHyperDual(res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp Called by proc~~equalhyperdualhyperdual~~CalledByGraph proc~equalhyperdualhyperdual hyperdual_mod::EqualHyperDualHyperDual interface~assignment (=) hyperdual_mod::assignment (=) interface~assignment (=)->proc~equalhyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/equalhyperdualhyperdual.html"},{"title":"EqualHyperDualReal – yaeos","text":"public elemental subroutine EqualHyperDualReal(res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp Called by proc~~equalhyperdualreal~~CalledByGraph proc~equalhyperdualreal hyperdual_mod::EqualHyperDualReal interface~assignment (=) hyperdual_mod::assignment (=) interface~assignment (=)->proc~equalhyperdualreal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/equalhyperdualreal.html"},{"title":"abs – yaeos","text":"public interface abs Calls interface~~abs~~CallsGraph interface~abs hyperdual_mod::abs proc~abshyperdual hyperdual_mod::absHyperDual interface~abs->proc~abshyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function absHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/abs.html"},{"title":"acos – yaeos","text":"public interface acos Calls interface~~acos~~CallsGraph interface~acos hyperdual_mod::acos proc~acoshyperdual hyperdual_mod::acosHyperDual interface~acos->proc~acoshyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function acosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/acos.html"},{"title":"asin – yaeos","text":"public interface asin Calls interface~~asin~~CallsGraph interface~asin hyperdual_mod::asin proc~asinhyperdual hyperdual_mod::asinHyperDual interface~asin->proc~asinhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function asinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/asin.html"},{"title":"assignment (=) – yaeos","text":"public interface assignment (=) Calls interface~~assignment (=)~~CallsGraph interface~assignment (=) hyperdual_mod::assignment (=) proc~equalhyperdualhyperdual hyperdual_mod::EqualHyperDualHyperDual interface~assignment (=)->proc~equalhyperdualhyperdual proc~equalhyperdualreal hyperdual_mod::EqualHyperDualReal interface~assignment (=)->proc~equalhyperdualreal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental subroutine EqualHyperDualHyperDual (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp public elemental subroutine EqualHyperDualReal (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp","tags":"","loc":"interface/assignment (=).html"},{"title":"atan – yaeos","text":"public interface atan Calls interface~~atan~~CallsGraph interface~atan hyperdual_mod::atan proc~atanhyperdual hyperdual_mod::atanHyperDual interface~atan->proc~atanhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function atanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/atan.html"},{"title":"atan2 – yaeos","text":"public interface atan2 Calls interface~~atan2~~CallsGraph interface~atan2 hyperdual_mod::atan2 proc~atan2hyperdual hyperdual_mod::atan2HyperDual interface~atan2->proc~atan2hyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function atan2HyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/atan2.html"},{"title":"cos – yaeos","text":"public interface cos Calls interface~~cos~~CallsGraph interface~cos hyperdual_mod::cos proc~coshyperdual hyperdual_mod::cosHyperDual interface~cos->proc~coshyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function cosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/cos.html"},{"title":"cosh – yaeos","text":"public interface cosh Calls interface~~cosh~~CallsGraph interface~cosh hyperdual_mod::cosh proc~coshhyperdual hyperdual_mod::coshHyperDual interface~cosh->proc~coshhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function coshHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/cosh.html"},{"title":"exp – yaeos","text":"public interface exp Calls interface~~exp~~CallsGraph interface~exp hyperdual_mod::exp proc~exphyperdual hyperdual_mod::expHyperDual interface~exp->proc~exphyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function expHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/exp.html"},{"title":"int – yaeos","text":"public interface int Calls interface~~int~~CallsGraph interface~int hyperdual_mod::int proc~inthyperdual hyperdual_mod::intHyperDual interface~int->proc~inthyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function intHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer","tags":"","loc":"interface/int.html"},{"title":"log – yaeos","text":"public interface log Calls interface~~log~~CallsGraph interface~log hyperdual_mod::log proc~loghyperdual hyperdual_mod::logHyperDual interface~log->proc~loghyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function logHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/log.html"},{"title":"log10 – yaeos","text":"public interface log10 Calls interface~~log10~~CallsGraph interface~log10 hyperdual_mod::log10 proc~log10hyperdual hyperdual_mod::log10HyperDual interface~log10->proc~log10hyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function log10HyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/log10.html"},{"title":"max – yaeos","text":"public interface max Calls interface~~max~~CallsGraph interface~max hyperdual_mod::max proc~max_dd hyperdual_mod::max_dd interface~max->proc~max_dd proc~max_ddd hyperdual_mod::max_ddd interface~max->proc~max_ddd proc~max_dr hyperdual_mod::max_dr interface~max->proc~max_dr proc~max_rd hyperdual_mod::max_rd interface~max->proc~max_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function max_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_ddd (v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual ) public elemental function max_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/max.html"},{"title":"min – yaeos","text":"public interface min Calls interface~~min~~CallsGraph interface~min hyperdual_mod::min proc~min_dd hyperdual_mod::min_dd interface~min->proc~min_dd proc~min_dr hyperdual_mod::min_dr interface~min->proc~min_dr proc~min_rd hyperdual_mod::min_rd interface~min->proc~min_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function min_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/min.html"},{"title":"nint – yaeos","text":"public interface nint Calls interface~~nint~~CallsGraph interface~nint hyperdual_mod::nint proc~ninthyperdual hyperdual_mod::nintHyperDual interface~nint->proc~ninthyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function nintHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer","tags":"","loc":"interface/nint.html"},{"title":"operator (*) – yaeos","text":"public interface operator (*) Calls interface~~operator (ASTERISK)~~CallsGraph interface~operator (ASTERISK) hyperdual_mod::operator (*) proc~multiplyhyperdualhyperdual hyperdual_mod::MultiplyHyperDualHyperDual interface~operator (ASTERISK)->proc~multiplyhyperdualhyperdual proc~multiplyhyperdualint hyperdual_mod::MultiplyHyperDualInt interface~operator (ASTERISK)->proc~multiplyhyperdualint proc~multiplyhyperdualreal hyperdual_mod::MultiplyHyperDualReal interface~operator (ASTERISK)->proc~multiplyhyperdualreal proc~multiplyinthyperdual hyperdual_mod::MultiplyIntHyperDual interface~operator (ASTERISK)->proc~multiplyinthyperdual proc~multiplyrealhyperdual hyperdual_mod::MultiplyRealHyperDual interface~operator (ASTERISK)->proc~multiplyrealhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function MultiplyHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyIntHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/operator (ASTERISK).html"},{"title":"operator (**) – yaeos","text":"public interface operator (**) Calls interface~~operator (ASTERISKASTERISK)~~CallsGraph interface~operator (ASTERISKASTERISK) hyperdual_mod::operator (**) proc~powerhyperdualhyperdual hyperdual_mod::PowerHyperDualHyperDual interface~operator (ASTERISKASTERISK)->proc~powerhyperdualhyperdual proc~powerhyperdualint hyperdual_mod::PowerHyperDualInt interface~operator (ASTERISKASTERISK)->proc~powerhyperdualint proc~powerhyperdualreal hyperdual_mod::PowerHyperDualReal interface~operator (ASTERISKASTERISK)->proc~powerhyperdualreal proc~exphyperdual hyperdual_mod::expHyperDual proc~powerhyperdualhyperdual->proc~exphyperdual proc~loghyperdual hyperdual_mod::logHyperDual proc~powerhyperdualhyperdual->proc~loghyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function PowerHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/operator (ASTERISKASTERISK).html"},{"title":"operator (+) – yaeos","text":"public interface operator (+) Calls interface~~operator (+)~~CallsGraph interface~operator (+) hyperdual_mod::operator (+) proc~plushyperdualhyperdual hyperdual_mod::PlusHyperDualHyperDual interface~operator (+)->proc~plushyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function PlusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/operator (+).html"},{"title":"operator (+) – yaeos","text":"public interface operator (+) Calls interface~~operator (+)~2~~CallsGraph interface~operator (+)~2 hyperdual_mod::operator (+) proc~addhyperdualhyperdual hyperdual_mod::AddHyperDualHyperDual interface~operator (+)~2->proc~addhyperdualhyperdual proc~addhyperdualreal hyperdual_mod::AddHyperDualReal interface~operator (+)~2->proc~addhyperdualreal proc~addrealhyperdual hyperdual_mod::AddRealHyperDual interface~operator (+)~2->proc~addrealhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function AddHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/operator (+)~2.html"},{"title":"operator (-) – yaeos","text":"public interface operator (-) Calls interface~~operator (-)~~CallsGraph interface~operator (-) hyperdual_mod::operator (-) proc~minushyperdualhyperdual hyperdual_mod::MinusHyperDualHyperDual interface~operator (-)->proc~minushyperdualhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function MinusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/operator (-).html"},{"title":"operator (-) – yaeos","text":"public interface operator (-) Calls interface~~operator (-)~2~~CallsGraph interface~operator (-)~2 hyperdual_mod::operator (-) proc~subtracthyperdualhyperdual hyperdual_mod::SubtractHyperDualHyperDual interface~operator (-)~2->proc~subtracthyperdualhyperdual proc~subtracthyperdualreal hyperdual_mod::SubtractHyperDualReal interface~operator (-)~2->proc~subtracthyperdualreal proc~subtractrealhyperdual hyperdual_mod::SubtractRealHyperDual interface~operator (-)~2->proc~subtractrealhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function SubtractHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/operator (-)~2.html"},{"title":"operator (.eq.) – yaeos","text":"public interface operator (.eq.) Calls interface~~operator (.eq.)~~CallsGraph interface~operator (.eq.) hyperdual_mod::operator (.eq.) proc~eq_dd hyperdual_mod::eq_dd interface~operator (.eq.)->proc~eq_dd proc~eq_di hyperdual_mod::eq_di interface~operator (.eq.)->proc~eq_di proc~eq_dr hyperdual_mod::eq_dr interface~operator (.eq.)->proc~eq_dr proc~eq_id hyperdual_mod::eq_id interface~operator (.eq.)->proc~eq_id proc~eq_rd hyperdual_mod::eq_rd interface~operator (.eq.)->proc~eq_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function eq_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function eq_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public elemental function eq_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function eq_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function eq_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.eq.).html"},{"title":"operator (.ge.) – yaeos","text":"public interface operator (.ge.) Calls interface~~operator (.ge.)~~CallsGraph interface~operator (.ge.) hyperdual_mod::operator (.ge.) proc~ge_dd hyperdual_mod::ge_dd interface~operator (.ge.)->proc~ge_dd proc~ge_di hyperdual_mod::ge_di interface~operator (.ge.)->proc~ge_di proc~ge_dr hyperdual_mod::ge_dr interface~operator (.ge.)->proc~ge_dr proc~ge_id hyperdual_mod::ge_id interface~operator (.ge.)->proc~ge_id proc~ge_rd hyperdual_mod::ge_rd interface~operator (.ge.)->proc~ge_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function ge_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ge_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ge_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.ge.).html"},{"title":"operator (.gt.) – yaeos","text":"public interface operator (.gt.) Calls interface~~operator (.gt.)~~CallsGraph interface~operator (.gt.) hyperdual_mod::operator (.gt.) proc~gt_dd hyperdual_mod::gt_dd interface~operator (.gt.)->proc~gt_dd proc~gt_di hyperdual_mod::gt_di interface~operator (.gt.)->proc~gt_di proc~gt_dr hyperdual_mod::gt_dr interface~operator (.gt.)->proc~gt_dr proc~gt_id hyperdual_mod::gt_id interface~operator (.gt.)->proc~gt_id proc~gt_rd hyperdual_mod::gt_rd interface~operator (.gt.)->proc~gt_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function gt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function gt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function gt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.gt.).html"},{"title":"operator (.le.) – yaeos","text":"public interface operator (.le.) Calls interface~~operator (.le.)~~CallsGraph interface~operator (.le.) hyperdual_mod::operator (.le.) proc~le_dd hyperdual_mod::le_dd interface~operator (.le.)->proc~le_dd proc~le_di hyperdual_mod::le_di interface~operator (.le.)->proc~le_di proc~le_dr hyperdual_mod::le_dr interface~operator (.le.)->proc~le_dr proc~le_id hyperdual_mod::le_id interface~operator (.le.)->proc~le_id proc~le_rd hyperdual_mod::le_rd interface~operator (.le.)->proc~le_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function le_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function le_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function le_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.le.).html"},{"title":"operator (.lt.) – yaeos","text":"public interface operator (.lt.) Calls interface~~operator (.lt.)~~CallsGraph interface~operator (.lt.) hyperdual_mod::operator (.lt.) proc~lt_dd hyperdual_mod::lt_dd interface~operator (.lt.)->proc~lt_dd proc~lt_di hyperdual_mod::lt_di interface~operator (.lt.)->proc~lt_di proc~lt_dr hyperdual_mod::lt_dr interface~operator (.lt.)->proc~lt_dr proc~lt_id hyperdual_mod::lt_id interface~operator (.lt.)->proc~lt_id proc~lt_rd hyperdual_mod::lt_rd interface~operator (.lt.)->proc~lt_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function lt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function lt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function lt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.lt.).html"},{"title":"operator (.ne.) – yaeos","text":"public interface operator (.ne.) Calls interface~~operator (.ne.)~~CallsGraph interface~operator (.ne.) hyperdual_mod::operator (.ne.) proc~ne_dd hyperdual_mod::ne_dd interface~operator (.ne.)->proc~ne_dd proc~ne_di hyperdual_mod::ne_di interface~operator (.ne.)->proc~ne_di proc~ne_dr hyperdual_mod::ne_dr interface~operator (.ne.)->proc~ne_dr proc~ne_id hyperdual_mod::ne_id interface~operator (.ne.)->proc~ne_id proc~ne_rd hyperdual_mod::ne_rd interface~operator (.ne.)->proc~ne_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function ne_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ne_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ne_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator (.ne.).html"},{"title":"operator (/) – yaeos","text":"public interface operator (/) Calls interface~~operator (SLASH)~~CallsGraph interface~operator (SLASH) hyperdual_mod::operator (/) proc~dividehyperdualhyperdual hyperdual_mod::DivideHyperDualHyperDual interface~operator (SLASH)->proc~dividehyperdualhyperdual proc~dividehyperdualreal hyperdual_mod::DivideHyperDualReal interface~operator (SLASH)->proc~dividehyperdualreal proc~dividerealhyperdual hyperdual_mod::DivideRealHyperDual interface~operator (SLASH)->proc~dividerealhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function DivideHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/operator (SLASH).html"},{"title":"real – yaeos","text":"public interface real Calls interface~~real~~CallsGraph interface~real hyperdual_mod::real proc~realhyperdual hyperdual_mod::realHyperDual interface~real->proc~realhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function realHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr)","tags":"","loc":"interface/real.html"},{"title":"sign – yaeos","text":"public interface sign Calls interface~~sign~~CallsGraph interface~sign hyperdual_mod::sign proc~sign_dd hyperdual_mod::sign_dd interface~sign->proc~sign_dd proc~sign_dr hyperdual_mod::sign_dr interface~sign->proc~sign_dr proc~sign_rd hyperdual_mod::sign_rd interface~sign->proc~sign_rd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function sign_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual )","tags":"","loc":"interface/sign.html"},{"title":"sin – yaeos","text":"public interface sin Calls interface~~sin~~CallsGraph interface~sin hyperdual_mod::sin proc~sinhyperdual hyperdual_mod::sinHyperDual interface~sin->proc~sinhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function sinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/sin.html"},{"title":"sinh – yaeos","text":"public interface sinh Calls interface~~sinh~~CallsGraph interface~sinh hyperdual_mod::sinh proc~sinhhyperdual hyperdual_mod::sinhHyperDual interface~sinh->proc~sinhhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function sinhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/sinh.html"},{"title":"sqrt – yaeos","text":"public interface sqrt Calls interface~~sqrt~~CallsGraph interface~sqrt hyperdual_mod::sqrt proc~sqrthyperdual hyperdual_mod::sqrtHyperDual interface~sqrt->proc~sqrthyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function sqrtHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/sqrt.html"},{"title":"sum – yaeos","text":"public interface sum Calls interface~~sum~~CallsGraph interface~sum hyperdual_mod::sum proc~sumhyperdual hyperdual_mod::SumHyperDual interface~sum->proc~sumhyperdual proc~sumhyperdual2 hyperdual_mod::SumHyperDual2 interface~sum->proc~sumhyperdual2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public pure function SumHyperDual (v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) public pure function SumHyperDual2 (v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ), allocatable, (:)","tags":"","loc":"interface/sum.html"},{"title":"tan – yaeos","text":"public interface tan Calls interface~~tan~~CallsGraph interface~tan hyperdual_mod::tan proc~tanhyperdual hyperdual_mod::tanHyperDual interface~tan->proc~tanhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function tanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/tan.html"},{"title":"tanh – yaeos","text":"public interface tanh Calls interface~~tanh~~CallsGraph interface~tanh hyperdual_mod::tanh proc~tanhhyperdual hyperdual_mod::tanhHyperDual interface~tanh->proc~tanhhyperdual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function tanhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual )","tags":"","loc":"interface/tanh.html"},{"title":"Bmix – yaeos","text":"public  subroutine Bmix(self, n, bi, B, dBi, dBij) Mixture repulsive parameter. Calculate the mixture’s repulsive parameter and it’s derivatives\nwith respect to composition: Type Bound QMR Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector. real(kind=pr), intent(in) :: bi (:) Pure components repulsive parameters. real(kind=pr), intent(out) :: B Mixture repulsive parameter. real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aux (size(n)) real(kind=pr), public :: bij (size(n),size(n)) integer, public :: i integer, public :: j integer, public :: nc real(kind=pr), public :: totn","tags":"","loc":"proc/bmix.html"},{"title":"Dmix – yaeos","text":"public  subroutine Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Attractive parameter mixing rule with quadratic mix. Takes the all the pure components attractive parameters and their\nderivatives with respect to temperature and mix them with the\nVan der Waals quadratic mixing rule: Inside the routine the matrix is calculated using the\nprocedure contained in the QMR object, this procedures defaults\nto the common combining rule: The procedure can be overloaded by a common one that respects the\ninterface get_aij type ( QMR ) :: my_mixing_rule my_mixing_rule % aij => new_aij_procedure Type Bound QMR Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: ai (:) Pure components attractive parameters real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D Mixture attractive parameter real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aij (size(ai),size(ai)) real(kind=pr), public :: aux real(kind=pr), public :: aux2 real(kind=pr), public :: daijdt (size(ai),size(ai)) real(kind=pr), public :: daijdt2 (size(ai),size(ai)) integer, public :: i integer, public :: j integer, public :: nc","tags":"","loc":"proc/dmix.html"},{"title":"kij_constant – yaeos","text":"public  subroutine kij_constant(self, a, dadt, dadt2, aij, daijdt, daijdt2) Combining rule that uses constant values. Arguments Type Intent Optional Attributes Name class( QMR ) :: self real(kind=pr), intent(in) :: a (:) Pure components attractive parameters (\\a) real(kind=pr), intent(in) :: dadt (:) real(kind=pr), intent(in) :: dadt2 (:) real(kind=pr), intent(out) :: aij (:,:) Matrix real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:) Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ai2 (size(a)) real(kind=pr), public :: aij_daidt integer, public :: i real(kind=pr), public :: inner_sum real(kind=pr), public :: inner_sum_2 integer, public :: j real(kind=pr), public :: sqrt_aii_ajj","tags":"","loc":"proc/kij_constant.html"},{"title":"cubic_v0 – yaeos","text":"public  function cubic_v0(z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr) Calls proc~~cubic_v0~~CallsGraph proc~cubic_v0 legacy_ar_models::cubic_v0 proc~bnder legacy_ar_models::Bnder proc~cubic_v0->proc~bnder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dbi (nc) real(kind=pr), public :: dbij (nc,nc)","tags":"","loc":"proc/cubic_v0.html"},{"title":"ArVnder – yaeos","text":"public  subroutine ArVnder(nc, nder, ntemp, z, V, T, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: nder integer, intent(in) :: ntemp real(kind=pr), intent(in) :: z (nc) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) Called by proc~~arvnder~~CalledByGraph proc~arvnder legacy_ar_models::ArVnder proc~purefug_calc legacy_thermo_properties::PUREFUG_CALC proc~purefug_calc->proc~arvnder proc~termo legacy_thermo_properties::TERMO proc~termo->proc~arvnder proc~vcalc legacy_thermo_properties::VCALC proc~termo->proc~vcalc proc~vcalc->proc~arvnder proc~ztvtermo legacy_thermo_properties::zTVTERMO proc~ztvtermo->proc~arvnder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/arvnder.html"},{"title":"Bnder – yaeos","text":"public  subroutine Bnder(nc, rn, Bmix, dBi, dBij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: Bmix real(kind=pr), intent(out) :: dBi (nc) real(kind=pr), intent(out) :: dBij (nc,nc) Called by proc~~bnder~~CalledByGraph proc~bnder legacy_ar_models::Bnder proc~cubic_v0 legacy_ar_models::cubic_v0 proc~cubic_v0->proc~bnder proc~helmrkpr legacy_ar_models::HelmRKPR proc~helmrkpr->proc~bnder proc~helmsrkpr legacy_ar_models::HelmSRKPR proc~helmsrkpr->proc~bnder proc~ar_rkpr legacy_ar_models::ar_rkpr proc~ar_rkpr->proc~helmrkpr proc~ar_srkpr legacy_ar_models::ar_srkpr proc~ar_srkpr->proc~helmsrkpr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aux (nc) integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","loc":"proc/bnder.html"},{"title":"DELTAnder – yaeos","text":"public  subroutine DELTAnder(nc, rn, D1m, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D1m real(kind=pr), intent(out) :: dD1i (nc) real(kind=pr), intent(out) :: dD1ij (nc,nc) Called by proc~~deltander~~CalledByGraph proc~deltander legacy_ar_models::DELTAnder proc~helmrkpr legacy_ar_models::HelmRKPR proc~helmrkpr->proc~deltander proc~ar_rkpr legacy_ar_models::ar_rkpr proc~ar_rkpr->proc~helmrkpr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","loc":"proc/deltander.html"},{"title":"DandTnder – yaeos","text":"public  subroutine DandTnder(ntd, nc, T, rn, D, dDi, dDiT, dDij, dDdT, dDdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDi (nc) real(kind=pr), intent(out) :: dDiT (nc) real(kind=pr), intent(out) :: dDij (nc,nc) real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 Calls proc~~dandtnder~~CallsGraph proc~dandtnder legacy_ar_models::DandTnder proc~aijtder legacy_ar_models::aijTder proc~dandtnder->proc~aijtder proc~atder legacy_ar_models::aTder proc~aijtder->proc~atder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dandtnder~~CalledByGraph proc~dandtnder legacy_ar_models::DandTnder proc~helmrkpr legacy_ar_models::HelmRKPR proc~helmrkpr->proc~dandtnder proc~helmsrkpr legacy_ar_models::HelmSRKPR proc~helmsrkpr->proc~dandtnder proc~ar_rkpr legacy_ar_models::ar_rkpr proc~ar_rkpr->proc~helmrkpr proc~ar_srkpr legacy_ar_models::ar_srkpr proc~ar_srkpr->proc~helmsrkpr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aij (nc,nc) real(kind=pr), public :: aux real(kind=pr), public :: aux2 real(kind=pr), public :: daijdT (nc,nc) real(kind=pr), public :: daijdT2 (nc,nc) integer, public :: i integer, public :: j","tags":"","loc":"proc/dandtnder.html"},{"title":"HelmRKPR – yaeos","text":"public  subroutine HelmRKPR(nco, NDE, NTD, rn, V, T, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Calculate the reduced residual Helmholtz Energy and it’s derivatives with the RKPR EOS Arguments Type Intent Optional Attributes Name integer, intent(in) :: nco integer, intent(in) :: NDE integer, intent(in) :: NTD real(kind=pr), intent(in) :: rn (nco) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out) :: Arn (nco) real(kind=pr), intent(out) :: ArVn (nco) real(kind=pr), intent(out) :: ArTn (nco) real(kind=pr), intent(out) :: Arn2 (nco,nco) Calls proc~~helmrkpr~~CallsGraph proc~helmrkpr legacy_ar_models::HelmRKPR proc~bnder legacy_ar_models::Bnder proc~helmrkpr->proc~bnder proc~dandtnder legacy_ar_models::DandTnder proc~helmrkpr->proc~dandtnder proc~deltander legacy_ar_models::DELTAnder proc~helmrkpr->proc~deltander proc~aijtder legacy_ar_models::aijTder proc~dandtnder->proc~aijtder proc~atder legacy_ar_models::aTder proc~aijtder->proc~atder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~helmrkpr~~CalledByGraph proc~helmrkpr legacy_ar_models::HelmRKPR proc~ar_rkpr legacy_ar_models::ar_rkpr proc~ar_rkpr->proc~helmrkpr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AUX real(kind=pr), public :: ArT real(kind=pr), public :: ArTT real(kind=pr), public :: Bmix real(kind=pr), public :: D real(kind=pr), public :: D1 real(kind=pr), public :: D2 real(kind=pr), public :: FFB real(kind=pr), public :: FFBB real(kind=pr), public :: FFBV real(kind=pr), public :: auxD2 real(kind=pr), public :: dBi (nco) real(kind=pr), public :: dBij (nco,nco) real(kind=pr), public :: dD1i (nco) real(kind=pr), public :: dD1ij (nco,nco) real(kind=pr), public :: dDdT real(kind=pr), public :: dDdT2 real(kind=pr), public :: dDi (nco) real(kind=pr), public :: dDiT (nco) real(kind=pr), public :: dDij (nco,nco) real(kind=pr), public :: f real(kind=pr), public :: fB real(kind=pr), public :: fBD1 real(kind=pr), public :: fD1 real(kind=pr), public :: fD1D1 real(kind=pr), public :: fVD1 real(kind=pr), public :: fv real(kind=pr), public :: fv2 real(kind=pr), public :: g real(kind=pr), public :: gv real(kind=pr), public :: gv2 integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","loc":"proc/helmrkpr.html"},{"title":"HelmSRKPR – yaeos","text":"public  subroutine HelmSRKPR(nc, nd, nt, rn, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components integer, intent(in) :: nd Compositional derivatives integer, intent(in) :: nt Temperature derivatives real(kind=pr), intent(in) :: rn (nc) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (nc) dAr/dn real(kind=pr), intent(out) :: ArVn (nc) dAr2/dVn real(kind=pr), intent(out) :: ArTn (nc) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (nc,nc) dAr2/dn2 Calls proc~~helmsrkpr~~CallsGraph proc~helmsrkpr legacy_ar_models::HelmSRKPR proc~bnder legacy_ar_models::Bnder proc~helmsrkpr->proc~bnder proc~dandtnder legacy_ar_models::DandTnder proc~helmsrkpr->proc~dandtnder proc~aijtder legacy_ar_models::aijTder proc~dandtnder->proc~aijtder proc~atder legacy_ar_models::aTder proc~aijtder->proc~atder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~helmsrkpr~~CalledByGraph proc~helmsrkpr legacy_ar_models::HelmSRKPR proc~ar_srkpr legacy_ar_models::ar_srkpr proc~ar_srkpr->proc~helmsrkpr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AUX real(kind=pr), public :: ArT real(kind=pr), public :: ArTT real(kind=pr), public :: Bmix real(kind=pr), public :: D real(kind=pr), public :: FFB real(kind=pr), public :: FFBB real(kind=pr), public :: FFBV real(kind=pr), public :: a real(kind=pr), public :: b_v real(kind=pr), public :: d1 real(kind=pr), public :: d2 real(kind=pr), public :: dBi (nc) real(kind=pr), public :: dBij (nc,nc) real(kind=pr), public :: dDdT real(kind=pr), public :: dDdT2 real(kind=pr), public :: dDi (nc) real(kind=pr), public :: dDiT (nc) real(kind=pr), public :: dDij (nc,nc) real(kind=pr), public :: f real(kind=pr), public :: fB real(kind=pr), public :: fv real(kind=pr), public :: fv2 real(kind=pr), public :: g real(kind=pr), public :: gv real(kind=pr), public :: gv2 integer, public :: i integer, public :: j real(kind=pr), public :: totn","tags":"","loc":"proc/helmsrkpr.html"},{"title":"PR76_factory – yaeos","text":"public  subroutine PR76_factory(moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) PengRobinson 76 factory Takes either the critical parameters or the fitted model parameters\nand gets ones in base of the others Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) Calls proc~~pr76_factory~~CallsGraph proc~pr76_factory legacy_ar_models::PR76_factory proc~get_zc_oma_omb legacy_ar_models::get_Zc_OMa_OMb proc~pr76_factory->proc~get_zc_oma_omb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: RTc (nc) real(kind=pr), public :: al real(kind=pr), public :: be logical, public :: critical_spec real(kind=pr), public :: ga (nc) integer, public :: i real(kind=pr), public :: oma (nc) real(kind=pr), public :: omb (nc) logical, public :: params_spec real(kind=pr), public :: vceos (nc) real(kind=pr), public :: zc (nc)","tags":"","loc":"proc/pr76_factory.html"},{"title":"PR78_factory – yaeos","text":"public  subroutine PR78_factory(moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) PengRobinson 78 factory Takes either the critical parameters or the fitted model parameters\nand gets ones in base of the others Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) Calls proc~~pr78_factory~~CallsGraph proc~pr78_factory legacy_ar_models::PR78_factory proc~get_zc_oma_omb legacy_ar_models::get_Zc_OMa_OMb proc~pr78_factory->proc~get_zc_oma_omb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: RTc (nc) real(kind=pr), public :: al real(kind=pr), public :: be logical, public :: critical_spec real(kind=pr), public :: ga (nc) integer, public :: i real(kind=pr), public :: oma (nc) real(kind=pr), public :: omb (nc) logical, public :: params_spec real(kind=pr), public :: vceos (nc) real(kind=pr), public :: zc (nc)","tags":"","loc":"proc/pr78_factory.html"},{"title":"SRK_factory – yaeos","text":"public  subroutine SRK_factory(moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) SoaveRedlichKwong factory Takes either the critical parameters or the fitted model parameters\nand gets ones in base of the others Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) Calls proc~~srk_factory~~CallsGraph proc~srk_factory legacy_ar_models::SRK_factory proc~get_zc_oma_omb legacy_ar_models::get_Zc_OMa_OMb proc~srk_factory->proc~get_zc_oma_omb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: RTc (nc) real(kind=pr), public :: al real(kind=pr), public :: be logical, public :: critical_spec real(kind=pr), public :: ga (nc) integer, public :: i integer, public :: j real(kind=pr), public :: oma (nc) real(kind=pr), public :: omb (nc) logical, public :: params_spec real(kind=pr), public :: vceos (nc) real(kind=pr), public :: zc (nc)","tags":"","loc":"proc/srk_factory.html"},{"title":"aTder – yaeos","text":"public  subroutine aTder(ac, Tc, k, T, a, dadT, dadT2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: ac real(kind=pr), intent(in) :: Tc real(kind=pr), intent(in) :: k real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: a real(kind=pr), intent(out) :: dadT real(kind=pr), intent(out) :: dadT2 Called by proc~~atder~~CalledByGraph proc~atder legacy_ar_models::aTder proc~aijtder legacy_ar_models::aijTder proc~aijtder->proc~atder proc~dandtnder legacy_ar_models::DandTnder proc~dandtnder->proc~aijtder proc~helmrkpr legacy_ar_models::HelmRKPR proc~helmrkpr->proc~dandtnder proc~helmsrkpr legacy_ar_models::HelmSRKPR proc~helmsrkpr->proc~dandtnder proc~ar_rkpr legacy_ar_models::ar_rkpr proc~ar_rkpr->proc~helmrkpr proc~ar_srkpr legacy_ar_models::ar_srkpr proc~ar_srkpr->proc~helmsrkpr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Tr","tags":"","loc":"proc/atder.html"},{"title":"aijTder – yaeos","text":"public  subroutine aijTder(ntd, nc, T, aij, daijdT, daijdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: aij (nc,nc) real(kind=pr), intent(out) :: daijdT (nc,nc) real(kind=pr), intent(out) :: daijdT2 (nc,nc) Calls proc~~aijtder~~CallsGraph proc~aijtder legacy_ar_models::aijTder proc~atder legacy_ar_models::aTder proc~aijtder->proc~atder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aijtder~~CalledByGraph proc~aijtder legacy_ar_models::aijTder proc~dandtnder legacy_ar_models::DandTnder proc~dandtnder->proc~aijtder proc~helmrkpr legacy_ar_models::HelmRKPR proc~helmrkpr->proc~dandtnder proc~helmsrkpr legacy_ar_models::HelmSRKPR proc~helmsrkpr->proc~dandtnder proc~ar_rkpr legacy_ar_models::ar_rkpr proc~ar_rkpr->proc~helmrkpr proc~ar_srkpr legacy_ar_models::ar_srkpr proc~ar_srkpr->proc~helmsrkpr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ai (nc) real(kind=pr), public :: aux (nc,nc) real(kind=pr), public :: daidT (nc) real(kind=pr), public :: daidT2 (nc) integer, public :: i integer, public :: j real(kind=pr), public :: ratK (nc,nc)","tags":"","loc":"proc/aijtder.html"},{"title":"ar_rkpr – yaeos","text":"public  subroutine ar_rkpr(z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (size(z)) dAr/dn real(kind=pr), intent(out) :: ArVn (size(z)) dAr2/dVn real(kind=pr), intent(out) :: ArTn (size(z)) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) dAr2/dn2 Calls proc~~ar_rkpr~~CallsGraph proc~ar_rkpr legacy_ar_models::ar_rkpr proc~helmrkpr legacy_ar_models::HelmRKPR proc~ar_rkpr->proc~helmrkpr proc~bnder legacy_ar_models::Bnder proc~helmrkpr->proc~bnder proc~dandtnder legacy_ar_models::DandTnder proc~helmrkpr->proc~dandtnder proc~deltander legacy_ar_models::DELTAnder proc~helmrkpr->proc~deltander proc~aijtder legacy_ar_models::aijTder proc~dandtnder->proc~aijtder proc~atder legacy_ar_models::aTder proc~aijtder->proc~atder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: nd Compositional derivatives integer, public :: nt Temperature derivatives","tags":"","loc":"proc/ar_rkpr.html"},{"title":"ar_srkpr – yaeos","text":"public  subroutine ar_srkpr(z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Wrapper subroutine to the SRK/PR Residula Helmholtz function to\nuse the general interface Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (size(z)) dAr/dn real(kind=pr), intent(out) :: ArVn (size(z)) dAr2/dVn real(kind=pr), intent(out) :: ArTn (size(z)) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) dAr2/dn2 Calls proc~~ar_srkpr~~CallsGraph proc~ar_srkpr legacy_ar_models::ar_srkpr proc~helmsrkpr legacy_ar_models::HelmSRKPR proc~ar_srkpr->proc~helmsrkpr proc~bnder legacy_ar_models::Bnder proc~helmsrkpr->proc~bnder proc~dandtnder legacy_ar_models::DandTnder proc~helmsrkpr->proc~dandtnder proc~aijtder legacy_ar_models::aijTder proc~dandtnder->proc~aijtder proc~atder legacy_ar_models::aTder proc~aijtder->proc~atder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: nd Compositional derivatives integer, public :: nt Temperature derivatives","tags":"","loc":"proc/ar_srkpr.html"},{"title":"get_Zc_OMa_OMb – yaeos","text":"public  subroutine get_Zc_OMa_OMb(del1, Zc, OMa, OMb) Calculate Zc, OMa and OMb from the delta_1 parameter. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: del1 (:) delta_1 parameter real(kind=pr), intent(out) :: Zc (:) Critical compressibility factor real(kind=pr), intent(out) :: OMa (:) OMa real(kind=pr), intent(out) :: OMb (:) OMb Called by proc~~get_zc_oma_omb~~CalledByGraph proc~get_zc_oma_omb legacy_ar_models::get_Zc_OMa_OMb proc~pr76_factory legacy_ar_models::PR76_factory proc~pr76_factory->proc~get_zc_oma_omb proc~pr78_factory legacy_ar_models::PR78_factory proc~pr78_factory->proc~get_zc_oma_omb proc~srk_factory legacy_ar_models::SRK_factory proc~srk_factory->proc~get_zc_oma_omb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: d1 (size(del1)) real(kind=pr), public :: y (size(del1))","tags":"","loc":"proc/get_zc_oma_omb.html"},{"title":"setup – yaeos","text":"public  subroutine setup(n, nmodel, ntdep, ncomb) Setup the basics variables that describe the model. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Number of components integer, intent(in) :: nmodel Number of model integer, intent(in) :: ntdep Kij dependant of temperature integer, intent(in) :: ncomb Combining rule","tags":"","loc":"proc/setup.html"},{"title":"PUREFUG_CALC – yaeos","text":"public  subroutine PUREFUG_CALC(nc, icomp, T, P, V, phi) Fugacity of a pure component Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: icomp real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: V real(kind=pr), intent(out) :: phi Calls proc~~purefug_calc~~CallsGraph proc~purefug_calc legacy_thermo_properties::PUREFUG_CALC proc~arvnder legacy_ar_models::ArVnder proc~purefug_calc->proc~arvnder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ar real(kind=pr), public :: ArTV real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArV2 real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: Arv real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: philog real(kind=pr), public :: rn (nc)","tags":"","loc":"proc/purefug_calc.html"},{"title":"TERMO – yaeos","text":"public  subroutine TERMO(nc, mtyp, indic, t, p, rn, v, PHILOG, DLPHIP, DLPHIT, FUGN) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components integer, intent(in) :: mtyp Type of root desired (-1 vapor, 1 liquid, 0 lower Gr) integer, intent(in) :: indic Desired element, this should be setted with optionals real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: rn (nc) Mixture mole numbers real(kind=pr), intent(out) :: v Volume [L] real(kind=pr), intent(out) :: PHILOG (nc) ln(phi*p) vector real(kind=pr), intent(out), optional :: DLPHIP (nc) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: DLPHIT (nc) ln(phi) Temp derivative real(kind=pr), intent(out), optional :: FUGN (nc,nc) ln(phi) compositional derivative Calls proc~~termo~~CallsGraph proc~termo legacy_thermo_properties::TERMO proc~arvnder legacy_ar_models::ArVnder proc~termo->proc~arvnder proc~vcalc legacy_thermo_properties::VCALC proc~termo->proc~vcalc proc~vcalc->proc~arvnder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: DPDN (nc) real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: ar real(kind=pr), public :: artv real(kind=pr), public :: arv real(kind=pr), public :: arv2 real(kind=pr), public :: dpdt real(kind=pr), public :: dpv integer, public :: i integer, public :: igz integer, public :: k integer, public :: nder integer, public :: ntemp real(kind=pr), public :: totn","tags":"","loc":"proc/termo.html"},{"title":"VCALC – yaeos","text":"public recursive subroutine VCALC(ITYP, nc, ntemp, rn, T, P, V) ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP TYPE OF ROOT DESIRED (-1 vapor, 1 liquid, 0 lower Gibbs energy phase) integer, intent(in) :: nc NO. OF COMPONENTS integer, intent(in) :: ntemp 1 if T-derivatives are required real(kind=pr), intent(in) :: rn (nc) FEED MOELS real(kind=pr), intent(in) :: T TEMPERATURE real(kind=pr), intent(in) :: P PRESURE real(kind=pr), intent(out) :: V VOLUME Calls proc~~vcalc~~CallsGraph proc~vcalc legacy_thermo_properties::VCALC proc~arvnder legacy_ar_models::ArVnder proc~vcalc->proc~arvnder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~vcalc~~CalledByGraph proc~vcalc legacy_thermo_properties::VCALC proc~termo legacy_thermo_properties::TERMO proc~termo->proc~vcalc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AT real(kind=pr), public :: AVAP real(kind=pr), public :: Ar real(kind=pr), public :: ArTV real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArV real(kind=pr), public :: ArV2 real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: B real(kind=pr), public :: CPV logical, public :: FIRST_RUN real(kind=pr), public :: S3R real(kind=pr), public :: VVAP real(kind=pr), public :: ZETA real(kind=pr), public :: ZETMAX real(kind=pr), public :: ZETMIN real(kind=pr), public :: del real(kind=pr), public :: der integer, public :: iter integer, public :: nder real(kind=pr), public :: pcalc real(kind=pr), public :: totn","tags":"","loc":"proc/vcalc.html"},{"title":"zTVTERMO – yaeos","text":"public  subroutine zTVTERMO(nc, indic, t, rn, v, p, dpv, PHILOG, DLPHIP, DLPHIT, FUGN) Calculation of lnphi P and derivatives\n rn        mixture mole numbers                       (input)\n t         temperature (k)                            (input)\n v         volume      (L)                            (input)\n p         pressure    (bar)                          (output)\n PHILOG    vector of ln(phi(i) P)                     (output)  0 < INDIC < 5\n DLPHIT    t-derivative of ln(phi(i)) (const P, n)    (output)  0 < INDIC = 2 or 4\n DLPHIP    P-derivative of ln(phi(i)) (const T, n)    (output)  0 < INDIC < 5\n FUGN      comp-derivative of ln(phi(i)) (const t & P)(output)  2 < INDIC Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: indic real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: v real(kind=pr), intent(out) :: p real(kind=pr), intent(out) :: dpv real(kind=pr), intent(out) :: PHILOG (nc) real(kind=pr), intent(out) :: DLPHIP (nc) real(kind=pr), intent(out) :: DLPHIT (nc) real(kind=pr), intent(out) :: FUGN (nc,nc) Calls proc~~ztvtermo~~CallsGraph proc~ztvtermo legacy_thermo_properties::zTVTERMO proc~arvnder legacy_ar_models::ArVnder proc~ztvtermo->proc~arvnder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: ArTn (nc) real(kind=pr), public :: ArVn (nc) real(kind=pr), public :: Arn (nc) real(kind=pr), public :: Arn2 (nc,nc) real(kind=pr), public :: DPDN (nc) real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: ar real(kind=pr), public :: artv real(kind=pr), public :: arv real(kind=pr), public :: arv2 real(kind=pr), public :: dpdt integer, public :: i integer, public :: igz integer, public :: k integer, public :: nder integer, public :: ntemp real(kind=pr), public :: totn","tags":"","loc":"proc/ztvtermo.html"},{"title":"get_v0 – yaeos","text":"private  function get_v0(self, n, p, t) Type Bound ArModelTapenade Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr)","tags":"","loc":"proc/get_v0.html"},{"title":"residual_helmholtz – yaeos","text":"private  subroutine residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz model generic interface Type Bound ArModelTapenade Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Calls proc~~residual_helmholtz~2~~CallsGraph proc~residual_helmholtz~2 yaeos_tapenade_ar_api::ArModelTapenade%residual_helmholtz none~get_arnx residual_helmholtz::get_ArnX proc~residual_helmholtz~2->none~get_arnx none~get_dardx2 residual_helmholtz::get_dArdX2 proc~residual_helmholtz~2->none~get_dardx2 none~reset_vars~2 residual_helmholtz::reset_vars proc~residual_helmholtz~2->none~reset_vars~2 none~get_arnx->none~reset_vars~2 none~get_dardx2->none~reset_vars~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), private :: arval real(kind=pr), private :: arvalb real(kind=pr), private :: arvald real(kind=pr), private :: arvald0 real(kind=pr), private :: arvaldb real(kind=pr), private :: arvaldd real(kind=pr), private :: df (size(n)+2) real(kind=pr), private :: df2 (size(n)+2,size(n)+2) integer, private :: i real(kind=pr), private :: nb (size(n)) integer, private :: nc real(kind=pr), private :: nd (size(n)) real(kind=pr), private :: ndb (size(n)) real(kind=pr), private :: tb real(kind=pr), private :: td real(kind=pr), private :: td0 real(kind=pr), private :: tdb real(kind=pr), private :: vb real(kind=pr), private :: vd real(kind=pr), private :: vd0 real(kind=pr), private :: vdb Functions function get_ArnX (var) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Return Value real(kind=pr), (size(n)) function get_dArdX2 (var) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Return Value real(kind=pr) Subroutines subroutine reset_vars () Arguments None","tags":"","loc":"proc/residual_helmholtz~2.html"},{"title":"v0 – yaeos","text":"public  function v0(self, n, p, t) Cubic EoS volume initializer.\nFor a Cubic Equation of State, the covolume calculated with the mixing\nrule is a good estimate for the initial volume solver on the liquid\nregion. Type Bound CubicEoS Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) Calls proc~~v0~~CallsGraph proc~v0 yaeos_models_ar_genericcubic::CubicEoS%v0 Bmix Bmix proc~v0->Bmix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dbi (size(n)) real(kind=pr), public :: dbij (size(n),size(n))","tags":"","loc":"proc/v0.html"},{"title":"GenericCubic_Ar – yaeos","text":"public  subroutine GenericCubic_Ar(self, n, v, t, ar, arv, ArT, artv, arv2, ArT2, Arn, ArVn, ArTn, Arn2) Uses yaeos_constants proc~~genericcubic_ar~~UsesGraph proc~genericcubic_ar yaeos_models_ar_genericcubic::CubicEoS%GenericCubic_Ar module~yaeos_constants yaeos_constants proc~genericcubic_ar->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Residual Helmholtz Energy for a generic Cubic Equation of State. Calculates the residual Helmholtz Energy for a generic Cubic EoS as\ndefined by Michelsen and Møllerup: Type Bound CubicEoS Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: ar Residual Helmholtz real(kind=pr), intent(out), optional :: arv real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: artv real(kind=pr), intent(out), optional :: arv2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) Calls proc~~genericcubic_ar~~CallsGraph proc~genericcubic_ar yaeos_models_ar_genericcubic::CubicEoS%GenericCubic_Ar Bmix Bmix proc~genericcubic_ar->Bmix Dmix Dmix proc~genericcubic_ar->Dmix alpha alpha proc~genericcubic_ar->alpha Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AUX real(kind=pr), public :: Bmix real(kind=pr), public :: D real(kind=pr), public :: FFB real(kind=pr), public :: FFBB real(kind=pr), public :: FFBV real(kind=pr), public :: Tr (size(n)) real(kind=pr), public :: a (size(n)) real(kind=pr), public :: d1 real(kind=pr), public :: d2 real(kind=pr), public :: dBi (size(n)) real(kind=pr), public :: dBij (size(n),size(n)) real(kind=pr), public :: dDdT real(kind=pr), public :: dDdT2 real(kind=pr), public :: dDi (size(n)) real(kind=pr), public :: dDidT (size(n)) real(kind=pr), public :: dDij (size(n),size(n)) real(kind=pr), public :: dadt (size(n)) real(kind=pr), public :: dadt2 (size(n)) real(kind=pr), public :: f real(kind=pr), public :: fB real(kind=pr), public :: fv real(kind=pr), public :: fv2 real(kind=pr), public :: g real(kind=pr), public :: gv real(kind=pr), public :: gv2 integer, public :: i integer, public :: j integer, public :: nc real(kind=pr), public :: totn","tags":"","loc":"proc/genericcubic_ar.html"},{"title":"flash – yaeos","text":"public  function flash(self, z, t, v_spec, p_spec, k0, iters) This algorithm assumes that the specified T and P correspond to\nvapor-liquid separation predicted by the provided model (0<beta<1) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Thermodynamic model real(kind=pr), intent(in) :: z (:) Global composition (molar fractions) real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in), optional :: v_spec Specified Volume [L/mol] real(kind=pr), intent(in), optional :: p_spec Specified Pressure [bar] real(kind=pr), intent(in) :: k0 (:) Initial K factors (y/x) integer, intent(out), optional :: iters Number of iterations Return Value type( EquilibriaState ) Calls proc~~flash~~CallsGraph proc~flash yaeos_equilibria_flash::flash proc~betalimits yaeos_equilibria_flash::betalimits proc~flash->proc~betalimits proc~betato01 yaeos_equilibria_flash::betato01 proc~flash->proc~betato01 proc~fugacity_tp yaeos_thermoprops::fugacity_tp proc~flash->proc~fugacity_tp proc~pressure yaeos_thermoprops::pressure proc~flash->proc~pressure proc~solve_rr yaeos_equilibria_flash::solve_rr proc~flash->proc~solve_rr proc~fugacity_vt yaeos_thermoprops::fugacity_vt proc~fugacity_tp->proc~fugacity_vt proc~vcalc~2 yaeos_thermoprops::VCALC proc~fugacity_tp->proc~vcalc~2 residual_helmholtz residual_helmholtz proc~pressure->residual_helmholtz proc~solve_rr->proc~betalimits proc~rachford_rice yaeos_equilibria_flash::rachford_rice proc~solve_rr->proc~rachford_rice proc~fugacity_vt->residual_helmholtz proc~vcalc~2->residual_helmholtz get_v0 get_v0 proc~vcalc~2->get_v0 optval optval proc~vcalc~2->optval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: DPVl real(kind=pr), public, dimension(size(z)) :: K real(kind=pr), public :: Vx real(kind=pr), public :: Vy real(kind=pr), public :: aux real(kind=pr), public :: beta real(kind=pr), public :: bmax real(kind=pr), public :: bmin real(kind=pr), public :: bx real(kind=pr), public, dimension(size(z)) :: dK real(kind=pr), public, dimension(size(z)) :: dKold real(kind=pr), public :: dVydVl real(kind=pr), public, dimension(size(z), size(z)) :: dlnphidn real(kind=pr), public :: dpvv real(kind=pr), public :: g0 real(kind=pr), public :: g1 real(kind=pr), public :: h real(kind=pr), public, dimension(size(z)) :: lnK real(kind=pr), public, dimension(size(z)) :: lnKold real(kind=pr), public, dimension(size(z)) :: lnfug_x real(kind=pr), public, dimension(size(z)) :: lnfug_y real(kind=pr), public :: log_k2 (size(z)) real(kind=pr), public :: p real(kind=pr), public :: pl real(kind=pr), public :: pold real(kind=pr), public :: pold2 real(kind=pr), public :: pv real(kind=pr), public :: rho_x real(kind=pr), public :: rho_y real(kind=pr), public :: savek (size(z)) character(len=2), public :: spec Flash specification [PT | VT] real(kind=pr), public :: step real(kind=pr), public :: stepv logical, public :: stopflash real(kind=pr), public :: told real(kind=pr), public :: told2 real(kind=pr), public :: v real(kind=pr), public, dimension(size(z)) :: x real(kind=pr), public, dimension(size(z)) :: y","tags":"","loc":"proc/flash.html"},{"title":"betalimits – yaeos","text":"public  subroutine betalimits(z, K, bmin, bmax) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: K (:) real(kind=pr), intent(out) :: bmin real(kind=pr), intent(out) :: bmax Called by proc~~betalimits~~CalledByGraph proc~betalimits yaeos_equilibria_flash::betalimits proc~flash yaeos_equilibria_flash::flash proc~flash->proc~betalimits proc~solve_rr yaeos_equilibria_flash::solve_rr proc~flash->proc~solve_rr proc~solve_rr->proc~betalimits Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: in integer, public :: ix real(kind=pr), public, dimension(size(z)) :: vmax real(kind=pr), public, dimension(size(z)) :: vmin","tags":"","loc":"proc/betalimits.html"},{"title":"betato01 – yaeos","text":"public  subroutine betato01(z, K) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr) :: K (:) Called by proc~~betato01~~CalledByGraph proc~betato01 yaeos_equilibria_flash::betato01 proc~flash yaeos_equilibria_flash::flash proc~flash->proc~betato01 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: g0 real(kind=pr), public :: g1","tags":"","loc":"proc/betato01.html"},{"title":"rachford_rice – yaeos","text":"public  subroutine rachford_rice(z, K, beta, rr, drrdb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: K (:) real(kind=pr), intent(in) :: beta real(kind=pr), intent(out) :: rr real(kind=pr), intent(out) :: drrdb Called by proc~~rachford_rice~~CalledByGraph proc~rachford_rice yaeos_equilibria_flash::rachford_rice proc~solve_rr yaeos_equilibria_flash::solve_rr proc~solve_rr->proc~rachford_rice proc~flash yaeos_equilibria_flash::flash proc~flash->proc~solve_rr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: denom (size(z))","tags":"","loc":"proc/rachford_rice.html"},{"title":"solve_rr – yaeos","text":"public  subroutine solve_rr(z, K, beta, beta_min, beta_max) Solve the Rachford-Rice Equation. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Mole fractions vector real(kind=pr), intent(in) :: K (:) K-factors real(kind=pr), intent(out) :: beta real(kind=pr), intent(out) :: beta_min real(kind=pr), intent(out) :: beta_max Calls proc~~solve_rr~~CallsGraph proc~solve_rr yaeos_equilibria_flash::solve_rr proc~betalimits yaeos_equilibria_flash::betalimits proc~solve_rr->proc~betalimits proc~rachford_rice yaeos_equilibria_flash::rachford_rice proc~solve_rr->proc~rachford_rice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~solve_rr~~CalledByGraph proc~solve_rr yaeos_equilibria_flash::solve_rr proc~flash yaeos_equilibria_flash::flash proc~flash->proc~solve_rr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dgdb real(kind=pr), public :: g real(kind=pr), public :: step","tags":"","loc":"proc/solve_rr.html"},{"title":"PUREFUG_CALC – yaeos","text":"public  subroutine PUREFUG_CALC(self, nc, icomp, T, P, V, fug) Fugacity of a pure component. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self model integer, intent(in) :: nc Number of components integer, intent(in) :: icomp Component index real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(out) :: fug Fugacity of component icomp Calls proc~~purefug_calc~2~~CallsGraph proc~purefug_calc~2 yaeos_thermoprops::PUREFUG_CALC residual_helmholtz residual_helmholtz proc~purefug_calc~2->residual_helmholtz Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ar real(kind=pr), public :: Arn (nc) real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: lnfug real(kind=pr), public :: n (nc)","tags":"","loc":"proc/purefug_calc~2.html"},{"title":"VCALC – yaeos","text":"public recursive subroutine VCALC(self, root_type, nc, rn, T, P, V, max_iters) Uses iso_fortran_env stdlib_optval proc~~vcalc~2~~UsesGraph proc~vcalc~2 yaeos_thermoprops::VCALC iso_fortran_env iso_fortran_env proc~vcalc~2->iso_fortran_env stdlib_optval stdlib_optval proc~vcalc~2->stdlib_optval Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Volume solver at a given pressure. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self character(len=*), intent(in) :: root_type Type of root [-1: vapor, 1:liquid, 0:lower Gibbs energy phase] integer, intent(in) :: nc Number of components real(kind=pr), intent(in) :: rn (nc) Mixture moles real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(out) :: V Volume [L] integer, intent(in), optional :: max_iters Maxiumum number of iterations, defaults to 100 Calls proc~~vcalc~2~~CallsGraph proc~vcalc~2 yaeos_thermoprops::VCALC get_v0 get_v0 proc~vcalc~2->get_v0 optval optval proc~vcalc~2->optval residual_helmholtz residual_helmholtz proc~vcalc~2->residual_helmholtz Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~vcalc~2~~CalledByGraph proc~vcalc~2 yaeos_thermoprops::VCALC proc~fugacity_tp yaeos_thermoprops::fugacity_tp proc~fugacity_tp->proc~vcalc~2 proc~flash yaeos_equilibria_flash::flash proc~flash->proc~fugacity_tp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AT real(kind=pr), public :: AVAP real(kind=pr), public :: Ar real(kind=pr), public :: ArV real(kind=pr), public :: ArV2 real(kind=pr), public :: B real(kind=pr), public :: CPV logical, public :: FIRST_RUN real(kind=pr), public :: S3R real(kind=pr), public :: VVAP real(kind=pr), public :: ZETA real(kind=pr), public :: ZETMAX real(kind=pr), public :: ZETMIN real(kind=pr), public :: del real(kind=pr), public :: der integer, public :: iter integer, public :: maximum_iterations real(kind=pr), public :: pcalc real(kind=pr), public :: totn","tags":"","loc":"proc/vcalc~2.html"},{"title":"fugacity_tp – yaeos","text":"public  subroutine fugacity_tp(self, n, t, p, v, root_type, lnfug, dlnphidp, dlnphidt, dlnphidn) Uses iso_fortran_env proc~~fugacity_tp~~UsesGraph proc~fugacity_tp yaeos_thermoprops::fugacity_tp iso_fortran_env iso_fortran_env proc~fugacity_tp->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calculate logarithm of fugacity, given pressure and temperature. This routine will obtain the desired volume root at the specified\npressure and calculate fugacity at that point. Note While the natural output variable is . The calculated\nderivatives will be the derivatives of the fugacity coefficient Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(out), optional :: v Volume [L] character(len=*), intent(in) :: root_type Type of root desired [“liquid”, “vapor”, “stable”] real(kind=pr), intent(out) :: lnfug (size(n)) vector real(kind=pr), intent(out), optional :: dlnphidp (size(n)) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: dlnphidt (size(n)) ln(phi) Temp derivative real(kind=pr), intent(out), optional :: dlnphidn (size(n),size(n)) ln(phi) compositional derivative Calls proc~~fugacity_tp~~CallsGraph proc~fugacity_tp yaeos_thermoprops::fugacity_tp proc~fugacity_vt yaeos_thermoprops::fugacity_vt proc~fugacity_tp->proc~fugacity_vt proc~vcalc~2 yaeos_thermoprops::VCALC proc~fugacity_tp->proc~vcalc~2 residual_helmholtz residual_helmholtz proc~fugacity_vt->residual_helmholtz get_v0 get_v0 proc~vcalc~2->get_v0 optval optval proc~vcalc~2->optval proc~vcalc~2->residual_helmholtz Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~fugacity_tp~~CalledByGraph proc~fugacity_tp yaeos_thermoprops::fugacity_tp proc~flash yaeos_equilibria_flash::flash proc~flash->proc~fugacity_tp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: p_in real(kind=pr), public :: v_in","tags":"","loc":"proc/fugacity_tp.html"},{"title":"fugacity_vt – yaeos","text":"public  subroutine fugacity_vt(self, n, v, t, p, lnfug, dlnphidp, dlnphidt, dlnphidn) Calculate fugacity given volume and temperature. Note While the natural output variable is . The calculated\nderivatives will be the derivatives of the fugacity coefficient Arguments Type Intent Optional Attributes Name class( ArModel ) :: self Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: p Pressure [bar] real(kind=pr), intent(out), optional :: lnfug (size(n)) vector real(kind=pr), intent(out), optional :: dlnphidp (size(n)) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: dlnphidt (size(n)) ln(phi) Temp derivative real(kind=pr), intent(out), optional :: dlnphidn (size(n),size(n)) ln(phi) compositional derivative Calls proc~~fugacity_vt~~CallsGraph proc~fugacity_vt yaeos_thermoprops::fugacity_vt residual_helmholtz residual_helmholtz proc~fugacity_vt->residual_helmholtz Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~fugacity_vt~~CalledByGraph proc~fugacity_vt yaeos_thermoprops::fugacity_vt proc~fugacity_tp yaeos_thermoprops::fugacity_tp proc~fugacity_tp->proc~fugacity_vt proc~flash yaeos_equilibria_flash::flash proc~flash->proc~fugacity_tp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ar real(kind=pr), public :: ArTV real(kind=pr), public, dimension(size(n)) :: ArTn real(kind=pr), public :: ArV real(kind=pr), public :: ArV2 real(kind=pr), public, dimension(size(n)) :: ArVn real(kind=pr), public, dimension(size(n)) :: Arn real(kind=pr), public :: Arn2 (size(n),size(n)) real(kind=pr), public :: RT real(kind=pr), public :: Z real(kind=pr), public :: dPdN (size(n)) real(kind=pr), public :: dPdT real(kind=pr), public :: dPdV integer, public :: i integer, public :: j integer, public :: nc real(kind=pr), public :: totn","tags":"","loc":"proc/fugacity_vt.html"},{"title":"pressure – yaeos","text":"public  subroutine pressure(self, n, v, t, p, dpdv, dpdt, dpdn) Pressure calculation. Calculate pressure using residual helmholtz models. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: p Pressure [bar] real(kind=pr), intent(out), optional :: dpdv real(kind=pr), intent(out), optional :: dpdt real(kind=pr), intent(out), optional :: dpdn (:) Calls proc~~pressure~~CallsGraph proc~pressure yaeos_thermoprops::pressure residual_helmholtz residual_helmholtz proc~pressure->residual_helmholtz Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~pressure~~CalledByGraph proc~pressure yaeos_thermoprops::pressure proc~flash yaeos_equilibria_flash::flash proc~flash->proc~pressure Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Ar real(kind=pr), public :: ArTV real(kind=pr), public :: ArV real(kind=pr), public :: ArV2 real(kind=pr), public :: ArVn (size(n)) integer, public :: nc real(kind=pr), public :: totn","tags":"","loc":"proc/pressure.html"},{"title":"ADMM_REBASE – yaeos","text":"public interface ADMM_REBASE Subroutines public  subroutine ADMM_REBASE(base) bind(c, name='ADMM_rebase') Arguments Type Intent Optional Attributes Name type(C_PTR) :: base","tags":"","loc":"interface/admm_rebase.html"},{"title":"ADMM_REBASESHADOWED – yaeos","text":"public interface ADMM_REBASESHADOWED Subroutines public  subroutine ADMM_REBASESHADOWED(base, baseb) bind(c, name=     'ADMM_rebaseShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR) :: base type(C_PTR) :: baseb","tags":"","loc":"interface/admm_rebaseshadowed.html"},{"title":"ADMM_REGISTER – yaeos","text":"public interface ADMM_REGISTER Subroutines public  subroutine ADMM_REGISTER(base, obase, size, nbelem) bind(c, name=     'ADMM_register') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size integer, VALUE :: nbelem","tags":"","loc":"interface/admm_register.html"},{"title":"ADMM_REGISTERSHADOWED – yaeos","text":"public interface ADMM_REGISTERSHADOWED Subroutines public  subroutine ADMM_REGISTERSHADOWED(base, obase, size, baseb, obaseb, sizeb, nbelem) bind(c, name='ADMM_registerShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size type(C_PTR), VALUE :: baseb type(C_PTR), VALUE :: obaseb integer, VALUE :: sizeb integer, VALUE :: nbelem","tags":"","loc":"interface/admm_registershadowed.html"},{"title":"ADMM_UNREGISTER – yaeos","text":"public interface ADMM_UNREGISTER Subroutines public  subroutine ADMM_UNREGISTER(base, nbelem) bind(c, name=     'ADMM_unregister') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base integer :: nbelem","tags":"","loc":"interface/admm_unregister.html"},{"title":"ADMM_UNREGISTERSHADOWED – yaeos","text":"public interface ADMM_UNREGISTERSHADOWED Subroutines public  subroutine ADMM_UNREGISTERSHADOWED(base, baseb, nbelem) bind(c,      name='ADMM_unregisterShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: baseb integer :: nbelem","tags":"","loc":"interface/admm_unregistershadowed.html"},{"title":"POPPOINTER8 – yaeos","text":"public interface POPPOINTER8 Subroutines public  subroutine POPPOINTER8(pp) bind(c, name='popPointer8') Arguments Type Intent Optional Attributes Name type(C_PTR) :: pp","tags":"","loc":"interface/poppointer8.html"},{"title":"PUSHPOINTER8 – yaeos","text":"public interface PUSHPOINTER8 Subroutines public  subroutine PUSHPOINTER8(pp) bind(c, name='pushPointer8') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: pp","tags":"","loc":"interface/pushpointer8.html"},{"title":"yaeos_models_ar_cubic_implementations – yaeos","text":"Implemented Cubic Equations of State. PengRobinson76 PengRobinson78 SoaveRedlichKwong Used by module~~yaeos_models_ar_cubic_implementations~~UsedByGraph module~yaeos_models_ar_cubic_implementations yaeos_models_ar_cubic_implementations module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar_cubic_implementations module~yaeos yaeos module~yaeos->module~yaeos_models module~yaeos_equilibria yaeos_equilibria module~yaeos->module~yaeos_equilibria module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria_flash->module~yaeos_models module~yaeos_equilibria_saturation_points yaeos_equilibria_saturation_points module~yaeos_equilibria_saturation_points->module~yaeos_models module~yaeos_equilibria->module~yaeos_equilibria_flash Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function PengRobinson76 (tc, pc, w, kij, lij) result(model) PengRobinson76. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical Temperatures [K] real(kind=pr), intent(in) :: pc (:) Critical Pressures [bar] real(kind=pr), intent(in) :: w (:) Acentric Factors real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS ) public  function PengRobinson78 (tc, pc, w, kij, lij) result(model) PengRobinson78. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical Temperatures [K] real(kind=pr), intent(in) :: pc (:) Critical Pressures [bar] real(kind=pr), intent(in) :: w (:) Acentric Factors real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS ) public  function SoaveRedlichKwong (tc, pc, w, kij, lij) result(model) SoaveRedlichKwong. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: tc (:) Critical temperature [K] real(kind=pr), intent(in) :: pc (:) Critical pressure [bar] real(kind=pr), intent(in) :: w (:) Acentric factor real(kind=pr), intent(in), optional :: kij (:,:) matrix real(kind=pr), intent(in), optional :: lij (:,:) matrix Return Value type( CubicEoS )","tags":"","loc":"module/yaeos_models_ar_cubic_implementations.html"},{"title":"tapenade_interfaces – yaeos","text":"Interfaces public        interface popinteger4 public  subroutine popinteger4(intnum) Arguments Type Intent Optional Attributes Name integer :: intnum public        interface popreal8 public  subroutine popreal8(realnum) Arguments Type Intent Optional Attributes Name real(kind=8) :: realnum public        interface pushcontrol1b public  subroutine pushcontrol1b(intnum) Arguments Type Intent Optional Attributes Name integer :: intnum public        interface pushinteger4 public  subroutine pushinteger4(intnum) Arguments Type Intent Optional Attributes Name integer :: intnum public        interface pushreal8 public  subroutine pushreal8(realnum) Arguments Type Intent Optional Attributes Name real(kind=8) :: realnum public  subroutine pushreal8array(realnum) Arguments Type Intent Optional Attributes Name real(kind=8) :: realnum (:)","tags":"","loc":"module/tapenade_interfaces.html"},{"title":"yaeos_ar_models_hyperdual – yaeos","text":"Module that contains the automatic differentiation logic for an Ar model. All that is needed to define an Ar model that uses automatic\ndifferentiation with hyperdual numbers is to define a new derived type\nthat overloads the method to the Ar function that you want to use.\nA minimal example follows: module newmodel use yaeos_ar_models_hyperdual , only : ArModelAdiff type , extends ( ArModelAdiff ) :: YourNewModel type ( Substances ) :: composition real ( 8 ) :: parameters (:) contains procedure :: Ar => arfun procedure :: get_v0 => v0 end type contains subroutine arfun ( self , n , v , t , Ar ) class ( YourNewModel ), intent ( in ) :: self type ( hyperdual ), intent ( in ) :: n (:) ! Number of moles type ( hyperdual ), intent ( in ) :: v ! Volume [L] type ( hyperdual ), intent ( in ) :: t ! Temperature [K] type ( hyperdual ), intent ( out ) :: ar_value ! Residual Helmholtz Energy ! A very complicated residual helmholtz function of a mixture Ar = sum ( n ) * v * t end subroutine function v0 ( self , n , p , t ) class ( YourNewModel ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) ! Number of moles real ( pr ), intent ( in ) :: p ! Pressure [bar] real ( pr ), intent ( in ) :: t ! Temperature [K] real ( pr ) :: v0 v0 = self % parameters ( 3 ) end function A complete implementation of the PR76 Equation of State can me found in example/adiff/adiff_pr76.f90 Uses yaeos_constants yaeos_models_ar yaeos_autodiff module~~yaeos_ar_models_hyperdual~~UsesGraph module~yaeos_ar_models_hyperdual yaeos_ar_models_hyperdual module~yaeos_autodiff yaeos_autodiff module~yaeos_ar_models_hyperdual->module~yaeos_autodiff module~yaeos_constants yaeos_constants module~yaeos_ar_models_hyperdual->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_ar_models_hyperdual->module~yaeos_models_ar module~hyperdual_mod hyperdual_mod module~yaeos_autodiff->module~hyperdual_mod iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar->module~yaeos_constants module~hyperdual_mod->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface public  function hyperdual_Ar(self, n, v, t) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ) :: self type( hyperdual ), intent(in) :: n (:) type( hyperdual ), intent(in) :: v type( hyperdual ), intent(in) :: t Return Value type( hyperdual ) Derived Types type, public, extends( ArModel ) :: ArModelAdiff Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure( hyperdual_Ar ), public, deferred :: Ar procedure( abs_volume_initializer ), public, deferred :: get_v0 ../../../ Volume initializer procedure, public :: residual_helmholtz Subroutines public  subroutine residual_helmholtz (self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name class( ArModelAdiff ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"module/yaeos_ar_models_hyperdual.html"},{"title":"yaeos_equilibria_saturation_points – yaeos","text":"Uses yaeos_constants yaeos_equilibria_equilibria_state yaeos_thermoprops yaeos_models module~~yaeos_equilibria_saturation_points~~UsesGraph module~yaeos_equilibria_saturation_points yaeos_equilibria_saturation_points module~yaeos_constants yaeos_constants module~yaeos_equilibria_saturation_points->module~yaeos_constants module~yaeos_equilibria_equilibria_state yaeos_equilibria_equilibria_state module~yaeos_equilibria_saturation_points->module~yaeos_equilibria_equilibria_state module~yaeos_models yaeos_models module~yaeos_equilibria_saturation_points->module~yaeos_models module~yaeos_thermoprops yaeos_thermoprops module~yaeos_equilibria_saturation_points->module~yaeos_thermoprops iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_equilibria_equilibria_state->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_models->module~yaeos_models_ar module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_implementations yaeos_models_ar_cubic_implementations module~yaeos_models->module~yaeos_models_ar_cubic_implementations module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_thermoprops->module~yaeos_constants module~yaeos_thermoprops->module~yaeos_models_ar module~yaeos_models_ar->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_substance yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_substance->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public :: max_iterations = 100 real(kind=pr), public :: step_tol = 0.1_pr real(kind=pr), public :: tol = 1e-5_pr","tags":"","loc":"module/yaeos_equilibria_saturation_points.html"},{"title":"yaeos_models_ar_cubic_alphas – yaeos","text":"functions defined in the library. Uses yaeos_constants yaeos_substance yaeos_models_ar_genericcubic module~~yaeos_models_ar_cubic_alphas~~UsesGraph module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_constants yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_substance yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_substance iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_substance->module~yaeos_constants module~yaeos_models_ar->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_models_ar_cubic_alphas~~UsedByGraph module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar_cubic_alphas proc~pengrobinson76 yaeos_models_ar_cubic_implementations::PengRobinson76 proc~pengrobinson76->module~yaeos_models_ar_cubic_alphas proc~pengrobinson78 yaeos_models_ar_cubic_implementations::PengRobinson78 proc~pengrobinson78->module~yaeos_models_ar_cubic_alphas proc~soaveredlichkwong yaeos_models_ar_cubic_implementations::SoaveRedlichKwong proc~soaveredlichkwong->module~yaeos_models_ar_cubic_alphas module~yaeos yaeos module~yaeos->module~yaeos_models module~yaeos_equilibria yaeos_equilibria module~yaeos->module~yaeos_equilibria module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria_flash->module~yaeos_models module~yaeos_equilibria_saturation_points yaeos_equilibria_saturation_points module~yaeos_equilibria_saturation_points->module~yaeos_models module~yaeos_equilibria->module~yaeos_equilibria_flash Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public, extends( AlphaFunction ) :: AlphaSoave Soave function. Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: k (:) parameter. Type-Bound Procedures procedure, public :: alpha ../../../ Alpha function Subroutines public  subroutine alpha (self, Tr, a, dadt, dadt2) Soave function and it’s derivatives. Arguments Type Intent Optional Attributes Name class( AlphaSoave ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) Reduced temperature real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:)","tags":"","loc":"module/yaeos_models_ar_cubic_alphas.html"},{"title":"hyperdual_mod – yaeos","text":"Hyperdual number definition & type declaration Uses yaeos_constants module~~hyperdual_mod~~UsesGraph module~hyperdual_mod hyperdual_mod module~yaeos_constants yaeos_constants module~hyperdual_mod->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hyperdual_mod~~UsedByGraph module~hyperdual_mod hyperdual_mod module~yaeos_autodiff yaeos_autodiff module~yaeos_autodiff->module~hyperdual_mod module~yaeos_ar_models_hyperdual yaeos_ar_models_hyperdual module~yaeos_ar_models_hyperdual->module~yaeos_autodiff Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface abs public elemental function absHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface acos public elemental function acosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface asin public elemental function asinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface assignment (=) public elemental subroutine EqualHyperDualHyperDual (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp public elemental subroutine EqualHyperDualReal (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp public        interface atan public elemental function atanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface atan2 public elemental function atan2HyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface cos public elemental function cosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface cosh public elemental function coshHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface exp public elemental function expHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface int public elemental function intHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public        interface log public elemental function logHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface log10 public elemental function log10HyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface max public elemental function max_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_ddd (v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual ) public elemental function max_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface min public elemental function min_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface nint public elemental function nintHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public        interface operator (*) public elemental function MultiplyHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyIntHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface operator (**) public elemental function PowerHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public        interface operator (+) public elemental function PlusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface operator (+) public elemental function AddHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface operator (-) public elemental function MinusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface operator (-) public elemental function SubtractHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface operator (.eq.) public  function eq_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function eq_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public elemental function eq_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function eq_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function eq_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (.ge.) public  function ge_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ge_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ge_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (.gt.) public  function gt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function gt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function gt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (.le.) public  function le_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function le_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function le_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (.lt.) public  function lt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function lt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function lt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (.ne.) public  function ne_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ne_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ne_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public        interface operator (/) public elemental function DivideHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface real public elemental function realHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr) public        interface sign public elemental function sign_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public        interface sin public elemental function sinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface sinh public elemental function sinhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface sqrt public elemental function sqrtHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface sum public pure function SumHyperDual (v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) public pure function SumHyperDual2 (v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ), allocatable, (:) public        interface tan public elemental function tanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public        interface tanh public elemental function tanhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Derived Types type, public :: hyperdual Components Type Visibility Attributes Name Initial real(kind=pr), public :: f0 = 0 real part of the hyperdual number real(kind=pr), public :: f1 = 0 \\f$\\varepsilon_1\\f$-part of  the hyperdual number real(kind=pr), public :: f12 = 0 \\f$\\varepsilon_1\\varepsilon_2\\f$-part of the real(kind=pr), public :: f2 = 0 \\f$\\varepsilon_2\\f$-part of  the hyperdual number Functions public elemental function AddHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function AddRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function DivideRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MinusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function MultiplyHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyIntHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function MultiplyRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PlusHyperDualHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function PowerHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualInt (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 integer, intent(in) :: v2 Return Value type( hyperdual ) public elemental function PowerHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractHyperDualReal (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function SubtractRealHyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public pure function SumHyperDual (v1, mask) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:) logical, intent(in), optional :: mask (:) Return Value type( hyperdual ) public pure function SumHyperDual2 (v1, dim) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 (:,:) integer, intent(in) :: dim Return Value type( hyperdual ), allocatable, (:) public elemental function absHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function acosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function asinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function atan2HyperDual (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function atanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function cosHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function coshHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public  function eq_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function eq_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public elemental function eq_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function eq_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function eq_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function expHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public  function ge_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ge_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ge_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ge_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function gt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function gt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function gt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function intHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public  function le_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function le_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function le_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function le_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function log10HyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function logHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public  function lt_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function lt_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function lt_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function lt_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function max_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_ddd (v1, v2, v3) result(v4) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 type( hyperdual ), intent(in) :: v3 Return Value type( hyperdual ) public elemental function max_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function max_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function min_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public  function ne_dd (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_di (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs integer, intent(in) :: rhs Return Value logical public  function ne_dr (lhs, rhs) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: lhs real(kind=pr), intent(in) :: rhs Return Value logical public  function ne_id (lhs, rhs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public  function ne_rd (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lhs type( hyperdual ), intent(in) :: rhs Return Value logical public elemental function nintHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value integer public elemental function realHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value real(kind=pr) public elemental function sign_dd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_dr (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 real(kind=pr), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sign_rd (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: v1 type( hyperdual ), intent(in) :: v2 Return Value type( hyperdual ) public elemental function sinHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function sinhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function sqrtHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function tanHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) public elemental function tanhHyperDual (v1) result(v2) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(in) :: v1 Return Value type( hyperdual ) Subroutines public elemental subroutine EqualHyperDualHyperDual (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res type( hyperdual ), intent(in) :: inp public elemental subroutine EqualHyperDualReal (res, inp) Arguments Type Intent Optional Attributes Name type( hyperdual ), intent(out) :: res real(kind=pr), intent(in) :: inp","tags":"","loc":"module/hyperdual_mod.html"},{"title":"yaeos_models – yaeos","text":"yaeos thermodynamic models On yaeos there are implemented a series of both residual Helmholtz\nenergy ( ) and excess Gibbs energy ( ) models. This module takes all the relevant procedures and derived types\nrelated to them. Residual Helmholtz model base type ArModel base derived type\n  that provides the basic structure that a residual Helmholtz model\n  should provide. Cubic Equations of state : AlphaFunction type CubicMixRule type CubicEos type that extends ArModel to use a generic\n     two-parameter EoS. Implemented models that use this type can be\n     seen at yaeos_models_ar_cubic_implementations QMR (Quadratic Mixing Rule) type: extensible derived type that \n      defaults to classic vdW mixing rules Uses yaeos_models_ar yaeos_models_ar_cubic_alphas yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic yaeos_models_ar_cubic_implementations module~~yaeos_models~~UsesGraph module~yaeos_models yaeos_models module~yaeos_models_ar yaeos_models_ar module~yaeos_models->module~yaeos_models_ar module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_implementations yaeos_models_ar_cubic_implementations module~yaeos_models->module~yaeos_models_ar_cubic_implementations module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_constants yaeos_constants module~yaeos_models_ar->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_substance yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_substance->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_models~~UsedByGraph module~yaeos_models yaeos_models module~yaeos yaeos module~yaeos->module~yaeos_models module~yaeos_equilibria yaeos_equilibria module~yaeos->module~yaeos_equilibria module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria_flash->module~yaeos_models module~yaeos_equilibria_saturation_points yaeos_equilibria_saturation_points module~yaeos_equilibria_saturation_points->module~yaeos_models module~yaeos_equilibria->module~yaeos_equilibria_flash Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses.","tags":"","loc":"module/yaeos_models.html"},{"title":"yaeos_constants – yaeos","text":"Constants used on the whole package Uses iso_fortran_env module~~yaeos_constants~~UsesGraph module~yaeos_constants yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_constants~~UsedByGraph module~yaeos_constants yaeos_constants module~ar_interface ar_interface module~ar_interface->module~yaeos_constants module~hyperdual_mod hyperdual_mod module~hyperdual_mod->module~yaeos_constants module~legacy_ar_models legacy_ar_models module~legacy_ar_models->module~yaeos_constants module~legacy_ar_models->module~ar_interface module~legacy_thermo_properties legacy_thermo_properties module~legacy_thermo_properties->module~yaeos_constants module~legacy_thermo_properties->module~legacy_ar_models module~yaeos yaeos module~yaeos->module~yaeos_constants module~yaeos_substance yaeos_substance module~yaeos->module~yaeos_substance module~yaeos_thermoprops yaeos_thermoprops module~yaeos->module~yaeos_thermoprops module~yaeos_equilibria yaeos_equilibria module~yaeos->module~yaeos_equilibria module~yaeos_models yaeos_models module~yaeos->module~yaeos_models module~yaeos_ar_models_hyperdual yaeos_ar_models_hyperdual module~yaeos_ar_models_hyperdual->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_ar_models_hyperdual->module~yaeos_models_ar module~yaeos_autodiff yaeos_autodiff module~yaeos_ar_models_hyperdual->module~yaeos_autodiff module~yaeos_equilibria_equilibria_state yaeos_equilibria_equilibria_state module~yaeos_equilibria_equilibria_state->module~yaeos_constants module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria_flash->module~yaeos_constants module~yaeos_equilibria_flash->module~yaeos_equilibria_equilibria_state module~yaeos_equilibria_flash->module~yaeos_thermoprops module~yaeos_equilibria_flash->module~yaeos_models module~yaeos_equilibria_saturation_points yaeos_equilibria_saturation_points module~yaeos_equilibria_saturation_points->module~yaeos_constants module~yaeos_equilibria_saturation_points->module~yaeos_equilibria_equilibria_state module~yaeos_equilibria_saturation_points->module~yaeos_thermoprops module~yaeos_equilibria_saturation_points->module~yaeos_models module~yaeos_models_ar->module~yaeos_constants module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_substance->module~yaeos_constants module~yaeos_tapenade_ar_api yaeos_tapenade_ar_api module~yaeos_tapenade_ar_api->module~yaeos_constants module~yaeos_tapenade_ar_api->module~yaeos_models_ar module~yaeos_thermoprops->module~yaeos_constants module~yaeos_thermoprops->module~yaeos_models_ar proc~genericcubic_ar yaeos_models_ar_genericcubic::CubicEoS%GenericCubic_Ar proc~genericcubic_ar->module~yaeos_constants proc~pengrobinson76 yaeos_models_ar_cubic_implementations::PengRobinson76 proc~pengrobinson76->module~yaeos_constants proc~pengrobinson76->module~yaeos_models_ar_cubic_alphas proc~pengrobinson76->module~yaeos_models_ar_genericcubic proc~pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~pengrobinson76->module~yaeos_substance proc~pengrobinson78 yaeos_models_ar_cubic_implementations::PengRobinson78 proc~pengrobinson78->module~yaeos_constants proc~pengrobinson78->module~yaeos_models_ar_cubic_alphas proc~pengrobinson78->module~yaeos_models_ar_genericcubic proc~pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~pengrobinson78->module~yaeos_substance proc~soaveredlichkwong yaeos_models_ar_cubic_implementations::SoaveRedlichKwong proc~soaveredlichkwong->module~yaeos_constants proc~soaveredlichkwong->module~yaeos_models_ar_cubic_alphas proc~soaveredlichkwong->module~yaeos_models_ar_genericcubic proc~soaveredlichkwong->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~soaveredlichkwong->module~yaeos_substance module~yaeos_autodiff->module~hyperdual_mod module~yaeos_equilibria->module~yaeos_equilibria_equilibria_state module~yaeos_equilibria->module~yaeos_equilibria_flash module~yaeos_models->module~yaeos_models_ar module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=pr), public, parameter :: NOT_IMPLEMENTED = huge(R) real(kind=pr), public, parameter :: R = 0.08314472_pr Ideal Gas constant character(len=254), public :: database_path = \"database\" Path to find database character(len=1), public :: path_sep = \"/\" File separator (to preprocess on Win or Mac/linux) integer, public, parameter :: pr = real64 Used precision","tags":"","loc":"module/yaeos_constants.html"},{"title":"ar_interface – yaeos","text":"Uses yaeos_constants iso_fortran_env module~~ar_interface~~UsesGraph module~ar_interface ar_interface iso_fortran_env iso_fortran_env module~ar_interface->iso_fortran_env module~yaeos_constants yaeos_constants module~ar_interface->module~yaeos_constants module~yaeos_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ar_interface~~UsedByGraph module~ar_interface ar_interface module~legacy_ar_models legacy_ar_models module~legacy_ar_models->module~ar_interface module~legacy_thermo_properties legacy_thermo_properties module~legacy_thermo_properties->module~legacy_ar_models Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial procedure( Ares ), public, pointer :: ar_fun procedure( initial_volume ), public, pointer :: vinit Abstract Interfaces abstract interface public  subroutine Ares(z, v, t, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) abstract interface public  function initial_volume(z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr)","tags":"","loc":"module/ar_interface.html"},{"title":"yaeos_models_ar – yaeos","text":"Module that defines the basics of a residual Helmholtz energy. All the residual properties that are calculated in this library are\nbased on residual Helmholtz Equations of State. Following the book by\nMichelsen and Mollerup. In this library up to second derivatives of residual Helmholtz energy\nare used. Because they’re the fundamentals for phase equilibria\ncalculation. Note Later on, third derivative with respect to volume will be included\nsince it’s importance on calculation of critical points. Uses yaeos_constants module~~yaeos_models_ar~~UsesGraph module~yaeos_models_ar yaeos_models_ar module~yaeos_constants yaeos_constants module~yaeos_models_ar->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_models_ar~~UsedByGraph module~yaeos_models_ar yaeos_models_ar module~yaeos_ar_models_hyperdual yaeos_ar_models_hyperdual module~yaeos_ar_models_hyperdual->module~yaeos_models_ar module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_tapenade_ar_api yaeos_tapenade_ar_api module~yaeos_tapenade_ar_api->module~yaeos_models_ar module~yaeos_thermoprops yaeos_thermoprops module~yaeos_thermoprops->module~yaeos_models_ar module~yaeos yaeos module~yaeos->module~yaeos_models module~yaeos->module~yaeos_thermoprops module~yaeos_equilibria yaeos_equilibria module~yaeos->module~yaeos_equilibria module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria_flash->module~yaeos_models module~yaeos_equilibria_flash->module~yaeos_thermoprops module~yaeos_equilibria_saturation_points yaeos_equilibria_saturation_points module~yaeos_equilibria_saturation_points->module~yaeos_models module~yaeos_equilibria_saturation_points->module~yaeos_thermoprops module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic proc~pengrobinson76 yaeos_models_ar_cubic_implementations::PengRobinson76 proc~pengrobinson76->module~yaeos_models_ar_genericcubic proc~pengrobinson76->module~yaeos_models_ar_cubic_alphas proc~pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~pengrobinson78 yaeos_models_ar_cubic_implementations::PengRobinson78 proc~pengrobinson78->module~yaeos_models_ar_genericcubic proc~pengrobinson78->module~yaeos_models_ar_cubic_alphas proc~pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~soaveredlichkwong yaeos_models_ar_cubic_implementations::SoaveRedlichKwong proc~soaveredlichkwong->module~yaeos_models_ar_genericcubic proc~soaveredlichkwong->module~yaeos_models_ar_cubic_alphas proc~soaveredlichkwong->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_equilibria->module~yaeos_equilibria_flash Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface public  subroutine abs_residual_helmholtz(self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz model generic interface. This interface represents how an Ar model should be implemented.\nBy our standard, a Resiudal Helmholtz model takes as input: The mixture’s number of moles vector. Volume, by default in liters. Temperature, by default in Kelvin. All the output arguments are optional. While this keeps a long\nsignature for the implementation, this is done this way to take\nadvantage of any inner optimizations to calculate derivatives\ninside the procedure. Once the model is implemented, the signature can be short like model%residual_helmholtz(n, v, t, ArT2=dArdT2) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self ArModel real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: Ar Residual Helmoltz energy real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n)) abstract interface public  function abs_volume_initializer(self, n, p, t) Initialization of volume. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Ar Model real(kind=pr), intent(in) :: n (:) Moles vector real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: t Temperature [K] Return Value real(kind=pr) Initial volume [L] Derived Types type, public :: ArModel Abstract residual Helmholtz model. Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure( abs_volume_initializer ), public, deferred :: get_v0 ../../../ Volume initializer procedure( abs_residual_helmholtz ), public, deferred :: residual_helmholtz ../../../ Method to calculate residual helmholtz energy and derivatives.","tags":"","loc":"module/yaeos_models_ar.html"},{"title":"yaeos_models_ar_genericcubic_quadratic_mixing – yaeos","text":"Quadratic Mixing Rules for Cubic EoS. Uses yaeos_constants yaeos_substance yaeos_models_ar_genericcubic module~~yaeos_models_ar_genericcubic_quadratic_mixing~~UsesGraph module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_constants yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_substance yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_substance->module~yaeos_constants module~yaeos_models_ar->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_models_ar_genericcubic_quadratic_mixing~~UsedByGraph module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~pengrobinson76 yaeos_models_ar_cubic_implementations::PengRobinson76 proc~pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~pengrobinson78 yaeos_models_ar_cubic_implementations::PengRobinson78 proc~pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~soaveredlichkwong yaeos_models_ar_cubic_implementations::SoaveRedlichKwong proc~soaveredlichkwong->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos yaeos module~yaeos->module~yaeos_models module~yaeos_equilibria yaeos_equilibria module~yaeos->module~yaeos_equilibria module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria_flash->module~yaeos_models module~yaeos_equilibria_saturation_points yaeos_equilibria_saturation_points module~yaeos_equilibria_saturation_points->module~yaeos_models module~yaeos_equilibria->module~yaeos_equilibria_flash Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface public  subroutine get_aij(self, ai, daidt, daidt2, aij, daijdt, daijdt2) Combining rule for the attractive parameter. From previously calculated attractive parameters calculate the matrix and it’s corresponding derivatives. Arguments Type Intent Optional Attributes Name class( QMR ) :: self real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: aij (:,:) real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:) Derived Types type, public, extends( CubicMixRule ) :: QMR Quadratic Mixing Rule (QMR) derived type. Classic Van der Waals mixing\nrules. Read more… Components Type Visibility Attributes Name Initial procedure( get_aij ), public, pointer :: aij => kij_constant Procedure to calculate matrix. Can be overloaded\nby any method that respets the interface get_aij . real(kind=pr), public, allocatable :: k (:,:) Attractive Binary Interatction parameter matrix real(kind=pr), public, allocatable :: l (:,:) Repulsive Binary Interatction parameter matrix Type-Bound Procedures procedure, public :: Bmix ../../../ Repulsive parameter mixing rule procedure, public :: Dmix ../../../ Attractive parameter mixing rule Subroutines public  subroutine Bmix (self, n, bi, B, dBi, dBij) Mixture repulsive parameter. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector. real(kind=pr), intent(in) :: bi (:) Pure components repulsive parameters. real(kind=pr), intent(out) :: B Mixture repulsive parameter. real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) public  subroutine Dmix (self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Attractive parameter mixing rule with quadratic mix. Read more… Arguments Type Intent Optional Attributes Name class( QMR ), intent(in) :: self Mixing rule object. real(kind=pr), intent(in) :: n (:) Moles vector [mol] real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: ai (:) Pure components attractive parameters real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D Mixture attractive parameter real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) public  subroutine kij_constant (self, a, dadt, dadt2, aij, daijdt, daijdt2) Combining rule that uses constant values. Arguments Type Intent Optional Attributes Name class( QMR ) :: self real(kind=pr), intent(in) :: a (:) Pure components attractive parameters (\\a) real(kind=pr), intent(in) :: dadt (:) real(kind=pr), intent(in) :: dadt2 (:) real(kind=pr), intent(out) :: aij (:,:) Matrix real(kind=pr), intent(out) :: daijdt (:,:) real(kind=pr), intent(out) :: daijdt2 (:,:)","tags":"","loc":"module/yaeos_models_ar_genericcubic_quadratic_mixing.html"},{"title":"legacy_ar_models – yaeos","text":"Legacy Thermodynamic routines\nModule for a cubic eos system, made with the intention to keep\ncompatiblity with legacy codes but with a better structure.\nthis should be later adapted into a simple oop system where an eos object\nstores the relevant parameters (or some functional oriented approach) Uses yaeos_constants ar_interface module~~legacy_ar_models~~UsesGraph module~legacy_ar_models legacy_ar_models module~ar_interface ar_interface module~legacy_ar_models->module~ar_interface module~yaeos_constants yaeos_constants module~legacy_ar_models->module~yaeos_constants module~ar_interface->module~yaeos_constants iso_fortran_env iso_fortran_env module~ar_interface->iso_fortran_env module~yaeos_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~legacy_ar_models~~UsedByGraph module~legacy_ar_models legacy_ar_models module~legacy_thermo_properties legacy_thermo_properties module~legacy_thermo_properties->module~legacy_ar_models Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: ac (:) Critical attractive parameter [bar (L/mol)&#94;2] real(kind=pr), public, allocatable :: b (:) repulsive parameter [L] real(kind=pr), public, allocatable :: bij (:,:) real(kind=pr), public, allocatable :: dc (:) Critical density [mol/L] real(kind=pr), public, allocatable :: del1 (:) parameter real(kind=pr), public, allocatable :: k (:) Attractive parameter constant real(kind=pr), public, allocatable :: kij (:,:) Attractive BIP real(kind=pr), public, allocatable :: kij0 (:,:) real(kind=pr), public, allocatable :: kinf (:,:) real(kind=pr), public, allocatable :: lij (:,:) Repulsive BIP integer, public :: mixing_rule What mixing rule to use integer, public :: nc Number of components real(kind=pr), public, allocatable :: pc (:) Critical pressure [bar] real(kind=pr), public, allocatable :: tc (:) Critical temperature [K] integer, public :: tdep Temperature dependance of kij integer, public :: thermo_model Which thermodynamic model to use real(kind=pr), public, allocatable :: tstar (:,:) real(kind=pr), public, allocatable :: w (:) Acentric factor real(kind=pr), public, allocatable :: z (:) Mole fractions vector Functions public  function cubic_v0 (z, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr) :: z (:) real(kind=pr) :: p real(kind=pr) :: t Return Value real(kind=pr) Subroutines public  subroutine ArVnder (nc, nder, ntemp, z, V, T, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: nder integer, intent(in) :: ntemp real(kind=pr), intent(in) :: z (nc) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: ar real(kind=pr), intent(out) :: arv real(kind=pr), intent(out) :: artv real(kind=pr), intent(out) :: arv2 real(kind=pr), intent(out), dimension(size(z)) :: Arn real(kind=pr), intent(out), dimension(size(z)) :: ArVn real(kind=pr), intent(out), dimension(size(z)) :: ArTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) public  subroutine Bnder (nc, rn, Bmix, dBi, dBij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: Bmix real(kind=pr), intent(out) :: dBi (nc) real(kind=pr), intent(out) :: dBij (nc,nc) public  subroutine DELTAnder (nc, rn, D1m, dD1i, dD1ij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D1m real(kind=pr), intent(out) :: dD1i (nc) real(kind=pr), intent(out) :: dD1ij (nc,nc) public  subroutine DandTnder (ntd, nc, T, rn, D, dDi, dDiT, dDij, dDdT, dDdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDi (nc) real(kind=pr), intent(out) :: dDiT (nc) real(kind=pr), intent(out) :: dDij (nc,nc) real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 public  subroutine HelmRKPR (nco, NDE, NTD, rn, V, T, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Calculate the reduced residual Helmholtz Energy and it’s derivatives with the RKPR EOS Arguments Type Intent Optional Attributes Name integer, intent(in) :: nco integer, intent(in) :: NDE integer, intent(in) :: NTD real(kind=pr), intent(in) :: rn (nco) real(kind=pr), intent(in) :: V real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: Ar real(kind=pr), intent(out) :: ArV real(kind=pr), intent(out) :: ArTV real(kind=pr), intent(out) :: ArV2 real(kind=pr), intent(out) :: Arn (nco) real(kind=pr), intent(out) :: ArVn (nco) real(kind=pr), intent(out) :: ArTn (nco) real(kind=pr), intent(out) :: Arn2 (nco,nco) public  subroutine HelmSRKPR (nc, nd, nt, rn, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components integer, intent(in) :: nd Compositional derivatives integer, intent(in) :: nt Temperature derivatives real(kind=pr), intent(in) :: rn (nc) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (nc) dAr/dn real(kind=pr), intent(out) :: ArVn (nc) dAr2/dVn real(kind=pr), intent(out) :: ArTn (nc) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (nc,nc) dAr2/dn2 public  subroutine PR76_factory (moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) PengRobinson 76 factory Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) public  subroutine PR78_factory (moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) PengRobinson 78 factory Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) public  subroutine SRK_factory (moles_in, ac_in, b_in, tc_in, pc_in, w_in, k_in) SoaveRedlichKwong factory Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: moles_in (nc) real(kind=pr), intent(in), optional :: ac_in (nc) real(kind=pr), intent(in), optional :: b_in (nc) real(kind=pr), intent(in), optional :: tc_in (nc) real(kind=pr), intent(in), optional :: pc_in (nc) real(kind=pr), intent(in), optional :: w_in (nc) real(kind=pr), intent(in), optional :: k_in (nc) public  subroutine aTder (ac, Tc, k, T, a, dadT, dadT2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: ac real(kind=pr), intent(in) :: Tc real(kind=pr), intent(in) :: k real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: a real(kind=pr), intent(out) :: dadT real(kind=pr), intent(out) :: dadT2 public  subroutine aijTder (ntd, nc, T, aij, daijdT, daijdT2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntd integer, intent(in) :: nc real(kind=pr), intent(in) :: T real(kind=pr), intent(out) :: aij (nc,nc) real(kind=pr), intent(out) :: daijdT (nc,nc) real(kind=pr), intent(out) :: daijdT2 (nc,nc) public  subroutine ar_rkpr (z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (size(z)) dAr/dn real(kind=pr), intent(out) :: ArVn (size(z)) dAr2/dVn real(kind=pr), intent(out) :: ArTn (size(z)) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) dAr2/dn2 public  subroutine ar_srkpr (z, v, t, ar, arv, artv, arv2, Arn, ArVn, ArTn, Arn2) Wrapper subroutine to the SRK/PR Residula Helmholtz function to\nuse the general interface Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: ar Residual Helmholtz real(kind=pr), intent(out) :: arv dAr/dV real(kind=pr), intent(out) :: artv dAr2/dTV real(kind=pr), intent(out) :: arv2 dAr2/dV2 real(kind=pr), intent(out) :: Arn (size(z)) dAr/dn real(kind=pr), intent(out) :: ArVn (size(z)) dAr2/dVn real(kind=pr), intent(out) :: ArTn (size(z)) dAr2/dTn real(kind=pr), intent(out) :: Arn2 (size(z),size(z)) dAr2/dn2 public  subroutine get_Zc_OMa_OMb (del1, Zc, OMa, OMb) Calculate Zc, OMa and OMb from the delta_1 parameter. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: del1 (:) delta_1 parameter real(kind=pr), intent(out) :: Zc (:) Critical compressibility factor real(kind=pr), intent(out) :: OMa (:) OMa real(kind=pr), intent(out) :: OMb (:) OMb public  subroutine setup (n, nmodel, ntdep, ncomb) Setup the basics variables that describe the model. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Number of components integer, intent(in) :: nmodel Number of model integer, intent(in) :: ntdep Kij dependant of temperature integer, intent(in) :: ncomb Combining rule","tags":"","loc":"module/legacy_ar_models.html"},{"title":"legacy_thermo_properties – yaeos","text":"Uses yaeos_constants legacy_ar_models module~~legacy_thermo_properties~~UsesGraph module~legacy_thermo_properties legacy_thermo_properties module~legacy_ar_models legacy_ar_models module~legacy_thermo_properties->module~legacy_ar_models module~yaeos_constants yaeos_constants module~legacy_thermo_properties->module~yaeos_constants module~legacy_ar_models->module~yaeos_constants module~ar_interface ar_interface module~legacy_ar_models->module~ar_interface iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~ar_interface->module~yaeos_constants module~ar_interface->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine PUREFUG_CALC (nc, icomp, T, P, V, phi) Fugacity of a pure component Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: icomp real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: V real(kind=pr), intent(out) :: phi public  subroutine TERMO (nc, mtyp, indic, t, p, rn, v, PHILOG, DLPHIP, DLPHIT, FUGN) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components integer, intent(in) :: mtyp Type of root desired (-1 vapor, 1 liquid, 0 lower Gr) integer, intent(in) :: indic Desired element, this should be setted with optionals real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: rn (nc) Mixture mole numbers real(kind=pr), intent(out) :: v Volume [L] real(kind=pr), intent(out) :: PHILOG (nc) ln(phi*p) vector real(kind=pr), intent(out), optional :: DLPHIP (nc) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: DLPHIT (nc) ln(phi) Temp derivative real(kind=pr), intent(out), optional :: FUGN (nc,nc) ln(phi) compositional derivative public recursive subroutine VCALC (ITYP, nc, ntemp, rn, T, P, V) ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP TYPE OF ROOT DESIRED (-1 vapor, 1 liquid, 0 lower Gibbs energy phase) integer, intent(in) :: nc NO. OF COMPONENTS integer, intent(in) :: ntemp 1 if T-derivatives are required real(kind=pr), intent(in) :: rn (nc) FEED MOELS real(kind=pr), intent(in) :: T TEMPERATURE real(kind=pr), intent(in) :: P PRESURE real(kind=pr), intent(out) :: V VOLUME public  subroutine zTVTERMO (nc, indic, t, rn, v, p, dpv, PHILOG, DLPHIP, DLPHIT, FUGN) Calculation of lnphi P and derivatives\n rn        mixture mole numbers                       (input)\n t         temperature (k)                            (input)\n v         volume      (L)                            (input)\n p         pressure    (bar)                          (output)\n PHILOG    vector of ln(phi(i) P)                     (output)  0 < INDIC < 5\n DLPHIT    t-derivative of ln(phi(i)) (const P, n)    (output)  0 < INDIC = 2 or 4\n DLPHIP    P-derivative of ln(phi(i)) (const T, n)    (output)  0 < INDIC < 5\n FUGN      comp-derivative of ln(phi(i)) (const t & P)(output)  2 < INDIC Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: indic real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: rn (nc) real(kind=pr), intent(in) :: v real(kind=pr), intent(out) :: p real(kind=pr), intent(out) :: dpv real(kind=pr), intent(out) :: PHILOG (nc) real(kind=pr), intent(out) :: DLPHIP (nc) real(kind=pr), intent(out) :: DLPHIT (nc) real(kind=pr), intent(out) :: FUGN (nc,nc)","tags":"","loc":"module/legacy_thermo_properties.html"},{"title":"yaeos_equilibria – yaeos","text":"Uses yaeos_equilibria_flash yaeos_equilibria_equilibria_state module~~yaeos_equilibria~~UsesGraph module~yaeos_equilibria yaeos_equilibria module~yaeos_equilibria_equilibria_state yaeos_equilibria_equilibria_state module~yaeos_equilibria->module~yaeos_equilibria_equilibria_state module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria->module~yaeos_equilibria_flash module~yaeos_constants yaeos_constants module~yaeos_equilibria_equilibria_state->module~yaeos_constants module~yaeos_equilibria_flash->module~yaeos_equilibria_equilibria_state module~yaeos_equilibria_flash->module~yaeos_constants module~yaeos_models yaeos_models module~yaeos_equilibria_flash->module~yaeos_models module~yaeos_thermoprops yaeos_thermoprops module~yaeos_equilibria_flash->module~yaeos_thermoprops iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar yaeos_models_ar module~yaeos_models->module~yaeos_models_ar module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_implementations yaeos_models_ar_cubic_implementations module~yaeos_models->module~yaeos_models_ar_cubic_implementations module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_thermoprops->module~yaeos_constants module~yaeos_thermoprops->module~yaeos_models_ar module~yaeos_models_ar->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_substance yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_substance->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_equilibria~~UsedByGraph module~yaeos_equilibria yaeos_equilibria module~yaeos yaeos module~yaeos->module~yaeos_equilibria Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses.","tags":"","loc":"module/yaeos_equilibria.html"},{"title":"yaeos_tapenade_ar_api – yaeos","text":"Module that wraps tapenade generated routines to calculate !\nAr and derivatives. Uses yaeos_constants yaeos_models_ar module~~yaeos_tapenade_ar_api~~UsesGraph module~yaeos_tapenade_ar_api yaeos_tapenade_ar_api module~yaeos_constants yaeos_constants module~yaeos_tapenade_ar_api->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_tapenade_ar_api->module~yaeos_models_ar iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  subroutine tapenade_ar(n, v, t, arval) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out) :: arval abstract interface private  subroutine tapenade_ar_b(n, nb, v, vb, t, tb, arval, arvalb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr) :: arval real(kind=pr) :: arvalb abstract interface private  subroutine tapenade_ar_d(n, nd, v, vd, t, td, arval, arvald) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald abstract interface private  subroutine tapenade_ar_d_b(n, nb, nd, ndb, v, vb, vd, vdb, t, tb, td, tdb, arval, arvalb, arvald, arvaldb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr) :: nb (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr) :: ndb (:) real(kind=pr), intent(in) :: v real(kind=pr) :: vb real(kind=pr), intent(in) :: vd real(kind=pr) :: vdb real(kind=pr), intent(in) :: t real(kind=pr) :: tb real(kind=pr), intent(in) :: td real(kind=pr) :: tdb real(kind=pr) :: arval real(kind=pr) :: arvalb real(kind=pr) :: arvald real(kind=pr) :: arvaldb abstract interface private  subroutine tapenade_ar_d_d(n, nd, v, vd0, vd, t, td0, td, arval, arvald0, arvald, arvaldd) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: nd (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: vd0 real(kind=pr), intent(in) :: vd real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: td0 real(kind=pr), intent(in) :: td real(kind=pr), intent(out) :: arval real(kind=pr), intent(out) :: arvald0 real(kind=pr), intent(out) :: arvald real(kind=pr), intent(out) :: arvaldd abstract interface private  function tapenade_v0(n, p, t) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) Derived Types type, public, extends( ArModel ) :: ArModelTapenade Components Type Visibility Attributes Name Initial procedure( tapenade_ar ), public, pointer, nopass :: ar procedure( tapenade_ar_b ), public, pointer, nopass :: ar_b procedure( tapenade_ar_d ), public, pointer, nopass :: ar_d procedure( tapenade_ar_d_b ), public, pointer, nopass :: ar_d_b procedure( tapenade_ar_d_d ), public, pointer, nopass :: ar_d_d character(len=:), public, allocatable :: name Name of the model procedure( tapenade_v0 ), public, pointer, nopass :: v0 Type-Bound Procedures procedure, public :: get_v0 procedure, public :: residual_helmholtz Functions private  function get_v0 (self, n, p, t) Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) Subroutines private  subroutine residual_helmholtz (self, n, v, t, Ar, ArV, ArT, ArTV, ArV2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz model generic interface Arguments Type Intent Optional Attributes Name class( ArModelTapenade ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: v real(kind=pr), intent(in) :: t real(kind=pr), intent(out), optional :: Ar real(kind=pr), intent(out), optional :: ArV real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: ArTV real(kind=pr), intent(out), optional :: ArV2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional, dimension(size(n)) :: Arn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArVn real(kind=pr), intent(out), optional, dimension(size(n)) :: ArTn real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"module/yaeos_tapenade_ar_api.html"},{"title":"yaeos_models_ar_genericcubic – yaeos","text":"Uses yaeos_constants yaeos_substance yaeos_models_ar module~~yaeos_models_ar_genericcubic~~UsesGraph module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_constants yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_substance yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_substance iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar->module~yaeos_constants module~yaeos_substance->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_models_ar_genericcubic~~UsedByGraph module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models yaeos_models module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic proc~pengrobinson76 yaeos_models_ar_cubic_implementations::PengRobinson76 proc~pengrobinson76->module~yaeos_models_ar_genericcubic proc~pengrobinson76->module~yaeos_models_ar_cubic_alphas proc~pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~pengrobinson78 yaeos_models_ar_cubic_implementations::PengRobinson78 proc~pengrobinson78->module~yaeos_models_ar_genericcubic proc~pengrobinson78->module~yaeos_models_ar_cubic_alphas proc~pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~soaveredlichkwong yaeos_models_ar_cubic_implementations::SoaveRedlichKwong proc~soaveredlichkwong->module~yaeos_models_ar_genericcubic proc~soaveredlichkwong->module~yaeos_models_ar_cubic_alphas proc~soaveredlichkwong->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos yaeos module~yaeos->module~yaeos_models module~yaeos_equilibria yaeos_equilibria module~yaeos->module~yaeos_equilibria module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria_flash->module~yaeos_models module~yaeos_equilibria_saturation_points yaeos_equilibria_saturation_points module~yaeos_equilibria_saturation_points->module~yaeos_models module~yaeos_equilibria->module~yaeos_equilibria_flash Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface public  subroutine abs_Bmix(self, n, bi, B, dBi, dBij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: bi (:) real(kind=pr), intent(out) :: B real(kind=pr), intent(out) :: dBi (:) real(kind=pr), intent(out) :: dBij (:,:) abstract interface public  subroutine abs_Dmix(self, n, T, ai, daidt, daidt2, D, dDdT, dDdT2, dDi, dDidT, dDij) Arguments Type Intent Optional Attributes Name class( CubicMixRule ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: T real(kind=pr), intent(in) :: ai (:) real(kind=pr), intent(in) :: daidt (:) real(kind=pr), intent(in) :: daidt2 (:) real(kind=pr), intent(out) :: D real(kind=pr), intent(out) :: dDdT real(kind=pr), intent(out) :: dDdT2 real(kind=pr), intent(out) :: dDi (:) real(kind=pr), intent(out) :: dDidT (:) real(kind=pr), intent(out) :: dDij (:,:) abstract interface public  subroutine abs_alpha(self, Tr, a, dadt, dadt2) Arguments Type Intent Optional Attributes Name class( AlphaFunction ), intent(in) :: self real(kind=pr), intent(in) :: Tr (:) real(kind=pr), intent(out) :: a (:) real(kind=pr), intent(out) :: dadt (:) real(kind=pr), intent(out) :: dadt2 (:) Derived Types type, public :: AlphaFunction Abstract derived type that describe the required\nprocedure for an alpha function. Type-Bound Procedures procedure( abs_alpha ), public, deferred :: alpha type, public, extends( ArModel ) :: CubicEoS Cubic Equation of State. Read more… Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: ac (:) Attractive critical parameter class( AlphaFunction ), public, allocatable :: alpha real(kind=pr), public, allocatable :: b (:) Repulsive parameter class( Substances ), public, allocatable :: components real(kind=pr), public, allocatable :: del1 (:) paramter real(kind=pr), public, allocatable :: del2 (:) paramter class( CubicMixRule ), public, allocatable :: mixrule character(len=:), public, allocatable :: name Name of the model Type-Bound Procedures procedure, public :: get_v0 => v0 procedure, public :: residual_helmholtz => GenericCubic_Ar type, public :: CubicMixRule Abstract derived type that describe the required\nprocedure for a mixing rule on a Cubic EoS Type-Bound Procedures procedure( abs_Bmix ), public, deferred :: Bmix procedure( abs_Dmix ), public, deferred :: Dmix Functions public  function v0 (self, n, p, t) Cubic EoS volume initializer.\nFor a Cubic Equation of State, the covolume calculated with the mixing\nrule is a good estimate for the initial volume solver on the liquid\nregion. Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) real(kind=pr), intent(in) :: p real(kind=pr), intent(in) :: t Return Value real(kind=pr) Subroutines public  subroutine GenericCubic_Ar (self, n, v, t, ar, arv, ArT, artv, arv2, ArT2, Arn, ArVn, ArTn, Arn2) Residual Helmholtz Energy for a generic Cubic Equation of State. Read more… Arguments Type Intent Optional Attributes Name class( CubicEoS ), intent(in) :: self real(kind=pr), intent(in) :: n (:) Number of moles real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: ar Residual Helmholtz real(kind=pr), intent(out), optional :: arv real(kind=pr), intent(out), optional :: ArT real(kind=pr), intent(out), optional :: artv real(kind=pr), intent(out), optional :: arv2 real(kind=pr), intent(out), optional :: ArT2 real(kind=pr), intent(out), optional :: Arn (size(n)) real(kind=pr), intent(out), optional :: ArVn (size(n)) real(kind=pr), intent(out), optional :: ArTn (size(n)) real(kind=pr), intent(out), optional :: Arn2 (size(n),size(n))","tags":"","loc":"module/yaeos_models_ar_genericcubic.html"},{"title":"yaeos_equilibria_flash – yaeos","text":"Uses yaeos_constants yaeos_equilibria_equilibria_state yaeos_thermoprops yaeos_models module~~yaeos_equilibria_flash~~UsesGraph module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_constants yaeos_constants module~yaeos_equilibria_flash->module~yaeos_constants module~yaeos_equilibria_equilibria_state yaeos_equilibria_equilibria_state module~yaeos_equilibria_flash->module~yaeos_equilibria_equilibria_state module~yaeos_models yaeos_models module~yaeos_equilibria_flash->module~yaeos_models module~yaeos_thermoprops yaeos_thermoprops module~yaeos_equilibria_flash->module~yaeos_thermoprops iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_equilibria_equilibria_state->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_models->module~yaeos_models_ar module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_implementations yaeos_models_ar_cubic_implementations module~yaeos_models->module~yaeos_models_ar_cubic_implementations module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_thermoprops->module~yaeos_constants module~yaeos_thermoprops->module~yaeos_models_ar module~yaeos_models_ar->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_substance yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_substance->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_equilibria_flash~~UsedByGraph module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria yaeos_equilibria module~yaeos_equilibria->module~yaeos_equilibria_flash module~yaeos yaeos module~yaeos->module~yaeos_equilibria Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function flash (self, z, t, v_spec, p_spec, k0, iters) This algorithm assumes that the specified T and P correspond to\nvapor-liquid separation predicted by the provided model (0<beta<1) Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Thermodynamic model real(kind=pr), intent(in) :: z (:) Global composition (molar fractions) real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in), optional :: v_spec Specified Volume [L/mol] real(kind=pr), intent(in), optional :: p_spec Specified Pressure [bar] real(kind=pr), intent(in) :: k0 (:) Initial K factors (y/x) integer, intent(out), optional :: iters Number of iterations Return Value type( EquilibriaState ) Subroutines public  subroutine betalimits (z, K, bmin, bmax) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: K (:) real(kind=pr), intent(out) :: bmin real(kind=pr), intent(out) :: bmax public  subroutine betato01 (z, K) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr) :: K (:) public  subroutine rachford_rice (z, K, beta, rr, drrdb) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: K (:) real(kind=pr), intent(in) :: beta real(kind=pr), intent(out) :: rr real(kind=pr), intent(out) :: drrdb public  subroutine solve_rr (z, K, beta, beta_min, beta_max) Solve the Rachford-Rice Equation. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Mole fractions vector real(kind=pr), intent(in) :: K (:) K-factors real(kind=pr), intent(out) :: beta real(kind=pr), intent(out) :: beta_min real(kind=pr), intent(out) :: beta_max","tags":"","loc":"module/yaeos_equilibria_flash.html"},{"title":"yaeos_thermoprops – yaeos","text":"Residual thermodyamic properties using residual Helmholtz model. Available properties: pressure(n, V, T) fugacity(n, V, T) fugacity(n, P, T, root=[vapor, liquid, stable]) volume Calculate thermodynamic properties using Helmholtz energy as a basis.\nAll the routines in this module work with the logic: call foo ( x , V , T , [ dfoodv , dfoodt , ...]) Where the user can call the routine of the desired property. And include \nas optional values the desired derivatives of said properties. Uses yaeos_constants yaeos_models_ar module~~yaeos_thermoprops~~UsesGraph module~yaeos_thermoprops yaeos_thermoprops module~yaeos_constants yaeos_constants module~yaeos_thermoprops->module~yaeos_constants module~yaeos_models_ar yaeos_models_ar module~yaeos_thermoprops->module~yaeos_models_ar iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_models_ar->module~yaeos_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_thermoprops~~UsedByGraph module~yaeos_thermoprops yaeos_thermoprops module~yaeos yaeos module~yaeos->module~yaeos_thermoprops module~yaeos_equilibria yaeos_equilibria module~yaeos->module~yaeos_equilibria module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria_flash->module~yaeos_thermoprops module~yaeos_equilibria_saturation_points yaeos_equilibria_saturation_points module~yaeos_equilibria_saturation_points->module~yaeos_thermoprops module~yaeos_equilibria->module~yaeos_equilibria_flash Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine PUREFUG_CALC (self, nc, icomp, T, P, V, fug) Fugacity of a pure component. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self model integer, intent(in) :: nc Number of components integer, intent(in) :: icomp Component index real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(in) :: V Volume [L] real(kind=pr), intent(out) :: fug Fugacity of component icomp public recursive subroutine VCALC (self, root_type, nc, rn, T, P, V, max_iters) Volume solver at a given pressure. Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self character(len=*), intent(in) :: root_type Type of root [-1: vapor, 1:liquid, 0:lower Gibbs energy phase] integer, intent(in) :: nc Number of components real(kind=pr), intent(in) :: rn (nc) Mixture moles real(kind=pr), intent(in) :: T Temperature [K] real(kind=pr), intent(in) :: P Pressure [bar] real(kind=pr), intent(out) :: V Volume [L] integer, intent(in), optional :: max_iters Maxiumum number of iterations, defaults to 100 public  subroutine fugacity_tp (self, n, t, p, v, root_type, lnfug, dlnphidp, dlnphidt, dlnphidn) Calculate logarithm of fugacity, given pressure and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(out), optional :: v Volume [L] character(len=*), intent(in) :: root_type Type of root desired [“liquid”, “vapor”, “stable”] real(kind=pr), intent(out) :: lnfug (size(n)) vector real(kind=pr), intent(out), optional :: dlnphidp (size(n)) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: dlnphidt (size(n)) ln(phi) Temp derivative real(kind=pr), intent(out), optional :: dlnphidn (size(n),size(n)) ln(phi) compositional derivative public  subroutine fugacity_vt (self, n, v, t, p, lnfug, dlnphidp, dlnphidt, dlnphidn) Calculate fugacity given volume and temperature. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ) :: self Model real(kind=pr), intent(in) :: n (:) Mixture mole numbers real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out), optional :: p Pressure [bar] real(kind=pr), intent(out), optional :: lnfug (size(n)) vector real(kind=pr), intent(out), optional :: dlnphidp (size(n)) ln(phi) Presssure derivative real(kind=pr), intent(out), optional :: dlnphidt (size(n)) ln(phi) Temp derivative real(kind=pr), intent(out), optional :: dlnphidn (size(n),size(n)) ln(phi) compositional derivative public  subroutine pressure (self, n, v, t, p, dpdv, dpdt, dpdn) Pressure calculation. Read more… Arguments Type Intent Optional Attributes Name class( ArModel ), intent(in) :: self Model real(kind=pr), intent(in) :: n (:) Moles number vector real(kind=pr), intent(in) :: v Volume [L] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: p Pressure [bar] real(kind=pr), intent(out), optional :: dpdv real(kind=pr), intent(out), optional :: dpdt real(kind=pr), intent(out), optional :: dpdn (:)","tags":"","loc":"module/yaeos_thermoprops.html"},{"title":"yaeos_autodiff – yaeos","text":"This module holds the diferent ways of automatic differentiation Uses hyperdual_mod module~~yaeos_autodiff~~UsesGraph module~yaeos_autodiff yaeos_autodiff module~hyperdual_mod hyperdual_mod module~yaeos_autodiff->module~hyperdual_mod module~yaeos_constants yaeos_constants module~hyperdual_mod->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_autodiff~~UsedByGraph module~yaeos_autodiff yaeos_autodiff module~yaeos_ar_models_hyperdual yaeos_ar_models_hyperdual module~yaeos_ar_models_hyperdual->module~yaeos_autodiff Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses.","tags":"","loc":"module/yaeos_autodiff.html"},{"title":"ADMM_TAPENADE_INTERFACE – yaeos","text":"Interfaces public        interface ADMM_REBASE public  subroutine ADMM_REBASE(base) bind(c, name='ADMM_rebase') Arguments Type Intent Optional Attributes Name type(C_PTR) :: base public        interface ADMM_REBASESHADOWED public  subroutine ADMM_REBASESHADOWED(base, baseb) bind(c, name=     'ADMM_rebaseShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR) :: base type(C_PTR) :: baseb public        interface ADMM_REGISTER public  subroutine ADMM_REGISTER(base, obase, size, nbelem) bind(c, name=     'ADMM_register') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size integer, VALUE :: nbelem public        interface ADMM_REGISTERSHADOWED public  subroutine ADMM_REGISTERSHADOWED(base, obase, size, baseb, obaseb, sizeb, nbelem) bind(c, name='ADMM_registerShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: obase integer, VALUE :: size type(C_PTR), VALUE :: baseb type(C_PTR), VALUE :: obaseb integer, VALUE :: sizeb integer, VALUE :: nbelem public        interface ADMM_UNREGISTER public  subroutine ADMM_UNREGISTER(base, nbelem) bind(c, name=     'ADMM_unregister') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base integer :: nbelem public        interface ADMM_UNREGISTERSHADOWED public  subroutine ADMM_UNREGISTERSHADOWED(base, baseb, nbelem) bind(c,      name='ADMM_unregisterShadowed') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: base type(C_PTR), VALUE :: baseb integer :: nbelem public        interface POPPOINTER8 public  subroutine POPPOINTER8(pp) bind(c, name='popPointer8') Arguments Type Intent Optional Attributes Name type(C_PTR) :: pp public        interface PUSHPOINTER8 public  subroutine PUSHPOINTER8(pp) bind(c, name='pushPointer8') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: pp","tags":"","loc":"module/admm_tapenade_interface.html"},{"title":"yaeos_equilibria_equilibria_state – yaeos","text":"Uses yaeos_constants module~~yaeos_equilibria_equilibria_state~~UsesGraph module~yaeos_equilibria_equilibria_state yaeos_equilibria_equilibria_state module~yaeos_constants yaeos_constants module~yaeos_equilibria_equilibria_state->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_equilibria_equilibria_state~~UsedByGraph module~yaeos_equilibria_equilibria_state yaeos_equilibria_equilibria_state module~yaeos_equilibria yaeos_equilibria module~yaeos_equilibria->module~yaeos_equilibria_equilibria_state module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria->module~yaeos_equilibria_flash module~yaeos_equilibria_flash->module~yaeos_equilibria_equilibria_state module~yaeos_equilibria_saturation_points yaeos_equilibria_saturation_points module~yaeos_equilibria_saturation_points->module~yaeos_equilibria_equilibria_state module~yaeos yaeos module~yaeos->module~yaeos_equilibria Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: EquilibriaState Components Type Visibility Attributes Name Initial real(kind=pr), public :: Vx Liquid volume [L/mol] real(kind=pr), public :: Vy Vapor volume [L/mol] integer, public :: iters Iterations needed to reach the state real(kind=pr), public :: p Pressure [bar] real(kind=pr), public :: t Temperature [K] real(kind=pr), public, allocatable :: x (:) Liquid molar fractions real(kind=pr), public, allocatable :: y (:) Vapour molar fractions","tags":"","loc":"module/yaeos_equilibria_equilibria_state.html"},{"title":"yaeos_substance – yaeos","text":"Ya_EoS Subtance module. Module containing pure components properties and parameters. Uses yaeos_constants module~~yaeos_substance~~UsesGraph module~yaeos_substance yaeos_substance module~yaeos_constants yaeos_constants module~yaeos_substance->module~yaeos_constants iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~yaeos_substance~~UsedByGraph module~yaeos_substance yaeos_substance module~yaeos yaeos module~yaeos->module~yaeos_substance module~yaeos_models yaeos_models module~yaeos->module~yaeos_models module~yaeos_equilibria yaeos_equilibria module~yaeos->module~yaeos_equilibria module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic proc~pengrobinson76 yaeos_models_ar_cubic_implementations::PengRobinson76 proc~pengrobinson76->module~yaeos_substance proc~pengrobinson76->module~yaeos_models_ar_cubic_alphas proc~pengrobinson76->module~yaeos_models_ar_genericcubic proc~pengrobinson76->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~pengrobinson78 yaeos_models_ar_cubic_implementations::PengRobinson78 proc~pengrobinson78->module~yaeos_substance proc~pengrobinson78->module~yaeos_models_ar_cubic_alphas proc~pengrobinson78->module~yaeos_models_ar_genericcubic proc~pengrobinson78->module~yaeos_models_ar_genericcubic_quadratic_mixing proc~soaveredlichkwong yaeos_models_ar_cubic_implementations::SoaveRedlichKwong proc~soaveredlichkwong->module~yaeos_substance proc~soaveredlichkwong->module~yaeos_models_ar_cubic_alphas proc~soaveredlichkwong->module~yaeos_models_ar_genericcubic proc~soaveredlichkwong->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria_flash->module~yaeos_models module~yaeos_equilibria_saturation_points yaeos_equilibria_saturation_points module~yaeos_equilibria_saturation_points->module~yaeos_models module~yaeos_equilibria->module~yaeos_equilibria_flash Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: Substances Set of pure components Components Type Visibility Attributes Name Initial character(len=50), public, allocatable :: names (:) Composition names. real(kind=pr), public, allocatable :: pc (:) Critical Pressure [bar] real(kind=pr), public, allocatable :: tc (:) Critical Temperature [K] real(kind=pr), public, allocatable :: w (:) Acentric factor","tags":"","loc":"module/yaeos_substance.html"},{"title":"yaeos – yaeos","text":"Yet Another Equation-Of-State (library) Library to use EoS-based calculations. This main module imports all the\nrelevant constants, procedures and objects to have better access to them\nThe main submodules that it uses are: yaeos_constants : All the relevant costants and also the used precision (default=double precision). yaeos_substance : Derived type that holds the important data (for example, critical constants) from a mixture. yaeos_models : All the implemented models, also their base types for making extensions. yaeos_thermoprops : Available thermodynamic properties to calculate. yaeos_equilibria : Phase equilibria related procedures. Uses yaeos_substance yaeos_thermoprops yaeos_constants yaeos_equilibria yaeos_models module~~yaeos~~UsesGraph module~yaeos yaeos module~yaeos_constants yaeos_constants module~yaeos->module~yaeos_constants module~yaeos_equilibria yaeos_equilibria module~yaeos->module~yaeos_equilibria module~yaeos_models yaeos_models module~yaeos->module~yaeos_models module~yaeos_substance yaeos_substance module~yaeos->module~yaeos_substance module~yaeos_thermoprops yaeos_thermoprops module~yaeos->module~yaeos_thermoprops iso_fortran_env iso_fortran_env module~yaeos_constants->iso_fortran_env module~yaeos_equilibria_equilibria_state yaeos_equilibria_equilibria_state module~yaeos_equilibria->module~yaeos_equilibria_equilibria_state module~yaeos_equilibria_flash yaeos_equilibria_flash module~yaeos_equilibria->module~yaeos_equilibria_flash module~yaeos_models_ar yaeos_models_ar module~yaeos_models->module~yaeos_models_ar module~yaeos_models_ar_cubic_alphas yaeos_models_ar_cubic_alphas module~yaeos_models->module~yaeos_models_ar_cubic_alphas module~yaeos_models_ar_cubic_implementations yaeos_models_ar_cubic_implementations module~yaeos_models->module~yaeos_models_ar_cubic_implementations module~yaeos_models_ar_genericcubic yaeos_models_ar_genericcubic module~yaeos_models->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic_quadratic_mixing yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_models->module~yaeos_models_ar_genericcubic_quadratic_mixing module~yaeos_substance->module~yaeos_constants module~yaeos_thermoprops->module~yaeos_constants module~yaeos_thermoprops->module~yaeos_models_ar module~yaeos_equilibria_equilibria_state->module~yaeos_constants module~yaeos_equilibria_flash->module~yaeos_constants module~yaeos_equilibria_flash->module~yaeos_models module~yaeos_equilibria_flash->module~yaeos_thermoprops module~yaeos_equilibria_flash->module~yaeos_equilibria_equilibria_state module~yaeos_models_ar->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_constants module~yaeos_models_ar_cubic_alphas->module~yaeos_substance module~yaeos_models_ar_cubic_alphas->module~yaeos_models_ar_genericcubic module~yaeos_models_ar_genericcubic->module~yaeos_constants module~yaeos_models_ar_genericcubic->module~yaeos_substance module~yaeos_models_ar_genericcubic->module~yaeos_models_ar module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_constants module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_substance module~yaeos_models_ar_genericcubic_quadratic_mixing->module~yaeos_models_ar_genericcubic Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: version = \"0.1.0b2\" This version.","tags":"","loc":"module/yaeos.html"},{"title":"implementations.f90 – yaeos","text":"This file depends on sourcefile~~implementations.f90~~EfferentGraph sourcefile~implementations.f90 implementations.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~implementations.f90->sourcefile~alphas.f90 sourcefile~constants.f90 constants.f90 sourcefile~implementations.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~implementations.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~implementations.f90->sourcefile~mixing_rules.f90 sourcefile~substance.f90 substance.f90 sourcefile~implementations.f90->sourcefile~substance.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~implementations.f90~~AfferentGraph sourcefile~implementations.f90 implementations.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~flash.f90 flash.f90 sourcefile~flash.f90->sourcefile~models.f90 sourcefile~saturations_points.f90 saturations_points.f90 sourcefile~saturations_points.f90->sourcefile~models.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_models_ar_cubic_implementations !! Implemented Cubic Equations of State. !! !! - PengRobinson76 !! - PengRobinson78 !! - SoaveRedlichKwong private public :: PengRobinson76 public :: PengRobinson78 public :: SoaveRedlichKwong contains type ( CubicEoS ) function PengRobinson76 ( tc , pc , w , kij , lij ) result ( model ) !! PengRobinson76. !! !! Using the critical constants setup the parameters to use the !! PengRobinson Equation of State !! !! - \\alpha(T_r) = (1 + k (1 - \\sqrt{T_r}))&#94;2 !! - k = 0.37464 + 1.54226 * \\omega - 0.26993 \\omega&#94;2  !! - a_c = 0.45723553  R&#94;2 T_c&#94;2 / P_c !! - b = 0.07779607r  R T_c/P_c !! - \\delta_1 = 1 + \\sqrt{2} !! - \\delta_2 = 1 - \\sqrt{2} !! !! There is also the optional posibility to include the k_{ij} and !! l_{ij} matrices. Using by default Classic Van der Waals mixing !! rules. !! !! After setting up the model, it is possible to redefine either the !! mixing rule or the alpha function using a different derived type !! defined outside the function. use yaeos_constants , only : pr , R use yaeos_substance , only : Substances use yaeos_models_ar_genericcubic , only : CubicEoS use yaeos_models_ar_cubic_alphas , only : AlphaSoave use yaeos_models_ar_genericcubic_quadratic_mixing , only : QMR real ( pr ), intent ( in ) :: tc (:) !! Critical Temperatures [K] real ( pr ), intent ( in ) :: pc (:) !! Critical Pressures [bar] real ( pr ), intent ( in ) :: w (:) !! Acentric Factors real ( pr ), optional , intent ( in ) :: kij (:, :) !! k_{ij} matrix real ( pr ), optional , intent ( in ) :: lij (:, :) !! l_{ij} matrix type ( Substances ) :: composition type ( QMR ) :: mixrule type ( AlphaSoave ) :: alpha integer :: nc integer :: i nc = size ( tc ) composition % tc = tc composition % pc = pc composition % w = w alpha % k = 0.37464_pr & + 1.54226_pr * composition % w & - 0.26993_pr * composition % w ** 2 if ( present ( kij )) then mixrule % k = kij else mixrule % k = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif if ( present ( lij )) then mixrule % l = lij else mixrule % l = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif model % components = composition model % ac = 0.45723553_pr * R ** 2 * composition % tc ** 2 / composition % pc model % b = 0.07779607_pr * R * composition % tc / composition % pc model % del1 = [ 1 + sqrt ( 2.0_pr )] model % del2 = [ 1 - sqrt ( 2.0_pr )] model % alpha = alpha model % mixrule = mixrule end function type ( CubicEoS ) function PengRobinson78 ( tc , pc , w , kij , lij ) result ( model ) !! PengRobinson78. !! !! Using the critical constants setup the parameters to use the !! PengRobinson Equation of State !! !! - \\alpha(T_r) = (1 + k (1 - \\sqrt{T_r}))&#94;2 !! - k = 0.37464 + 1.54226 \\omega - 0.26992 \\omega&#94;2  \\text{ where } \\omega <=0.491 !! - k = 0.37464 + 1.48503 \\omega - 0.16442 \\omega&#94;2  + 0.016666 \\omega&#94;3 \\text{ where } \\omega > 0.491 !! - a_c = 0.45723553  R&#94;2 T_c&#94;2 / P_c !! - b = 0.07779607r  R T_c/P_c !! - \\delta_1 = 1 + \\sqrt{2} !! - \\delta_2 = 1 - \\sqrt{2} !! !! There is also the optional posibility to include the k_{ij} and !! l_{ij} matrices. Using by default Classic Van der Waals mixing !! rules. !! !! After setting up the model, it is possible to redefine either the !! mixing rule or the alpha function using a different derived type !! defined outside the function. use yaeos_constants , only : pr , R use yaeos_substance , only : Substances use yaeos_models_ar_genericcubic , only : CubicEoS use yaeos_models_ar_cubic_alphas , only : AlphaSoave use yaeos_models_ar_genericcubic_quadratic_mixing , only : QMR real ( pr ), intent ( in ) :: tc (:) !! Critical Temperatures [K] real ( pr ), intent ( in ) :: pc (:) !! Critical Pressures [bar] real ( pr ), intent ( in ) :: w (:) !! Acentric Factors real ( pr ), optional , intent ( in ) :: kij (:, :) !! k_{ij} matrix real ( pr ), optional , intent ( in ) :: lij (:, :) !! l_{ij} matrix type ( Substances ) :: composition type ( QMR ) :: mixrule type ( AlphaSoave ) :: alpha integer :: nc integer :: i nc = size ( tc ) composition % tc = tc composition % pc = pc composition % w = w allocate ( alpha % k ( nc )) where ( composition % w <= 0.491 ) alpha % k = 0.37464 + 1.54226 * composition % w - 0.26992 * composition % w ** 2 elsewhere alpha % k = 0.379642 + 1.48503 * composition % w - 0.164423 * composition % w ** 2 + 0.016666 * composition % w ** 3 end where if ( present ( kij )) then mixrule % k = kij else mixrule % k = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif if ( present ( lij )) then mixrule % l = lij else mixrule % l = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif model % components = composition model % ac = 0.45723553_pr * R ** 2 * composition % tc ** 2 / composition % pc model % b = 0.07779607_pr * R * composition % tc / composition % pc model % del1 = [ 1 + sqrt ( 2.0_pr )] model % del2 = [ 1 - sqrt ( 2.0_pr )] model % alpha = alpha model % mixrule = mixrule end function type ( CubicEoS ) function SoaveRedlichKwong ( tc , pc , w , kij , lij ) result ( model ) !! SoaveRedlichKwong. !! !! Using the critical constants setup the parameters to use the !! SoaveRedlichKwong Equation of State !! !! - \\alpha(T_r) = (1 + k (1 - \\sqrt{T_r}))&#94;2 !! - k = 0.48 + 1.574 \\omega - 0.175 \\omega&#94;2  !! - a_c = 0.427480  R&#94;2 * T_c&#94;2/P_c !! - b = 0.086640  R T_c/P_c !! - \\delta_1 = 1 !! - \\delta_2 = 0 !! !! There is also the optional posibility to include the k_{ij} and l_{ij} !! matrices. Using by default Classic Van der Waals mixing rules. !! !! After setting up the model, it is possible to redefine either the !! mixing rule or the alpha function using a different derived type !! defined outside the function. use yaeos_constants , only : pr , R use yaeos_substance , only : Substances use yaeos_models_ar_genericcubic , only : CubicEoS use yaeos_models_ar_cubic_alphas , only : AlphaSoave use yaeos_models_ar_genericcubic_quadratic_mixing , only : QMR real ( pr ), intent ( in ) :: tc (:) !! Critical temperature [K] real ( pr ), intent ( in ) :: pc (:) !! Critical pressure [bar] real ( pr ), intent ( in ) :: w (:) !! Acentric factor real ( pr ), optional , intent ( in ) :: kij (:, :) !! k_{ij} matrix real ( pr ), optional , intent ( in ) :: lij (:, :) !! l_{ij} matrix type ( Substances ) :: composition type ( QMR ) :: mixrule type ( AlphaSoave ) :: alpha integer :: nc integer :: i nc = size ( tc ) composition % tc = tc composition % pc = pc composition % w = w alpha % k = 0.48_pr + 1.574_pr * composition % w - 0.175_pr * composition % w ** 2 if ( present ( kij )) then mixrule % k = kij else mixrule % k = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif if ( present ( lij )) then mixrule % l = lij else mixrule % l = reshape ([( 0 , i = 1 , nc ** 2 )], [ nc , nc ]) endif model % components = composition model % ac = 0.427480_pr * R ** 2 * composition % tc ** 2 / composition % pc model % b = 0.086640_pr * R * composition % tc / composition % pc model % del1 = [ 1 ] model % del2 = [ 0 ] model % alpha = alpha model % mixrule = mixrule end function end module","tags":"","loc":"sourcefile/implementations.f90.html"},{"title":"interfaces.f90 – yaeos","text":"Source Code module tapenade_interfaces implicit none interface pushreal8 subroutine pushreal8 ( realnum ) real ( 8 ) :: realnum end subroutine subroutine pushreal8array ( realnum ) real ( 8 ) :: realnum (:) end subroutine end interface interface popreal8 subroutine popreal8 ( realnum ) real ( 8 ) :: realnum end subroutine end interface interface pushinteger4 subroutine pushinteger4 ( intnum ) integer :: intnum end subroutine end interface interface popinteger4 subroutine popinteger4 ( intnum ) integer :: intnum end subroutine end interface interface pushcontrol1b subroutine pushcontrol1b ( intnum ) integer :: intnum end subroutine end interface end module","tags":"","loc":"sourcefile/interfaces.f90.html"},{"title":"armodel_adiff_api.f90 – yaeos","text":"This file depends on sourcefile~~armodel_adiff_api.f90~~EfferentGraph sourcefile~armodel_adiff_api.f90 armodel_adiff_api.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~armodel_adiff_api.f90->sourcefile~ar_models.f90 sourcefile~autodiff.f90 autodiff.f90 sourcefile~armodel_adiff_api.f90->sourcefile~autodiff.f90 sourcefile~constants.f90 constants.f90 sourcefile~armodel_adiff_api.f90->sourcefile~constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~hyperdual.f90 hyperdual.f90 sourcefile~autodiff.f90->sourcefile~hyperdual.f90 sourcefile~hyperdual.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_ar_models_hyperdual !! Module that contains the automatic differentiation logic for an Ar model. !! !! All that is needed to define an Ar model that uses automatic !! differentiation with hyperdual numbers is to define a new derived type !! that overloads the method to the Ar function that you want to use. !! A minimal example follows: !! !! ```fortran !! module newmodel !! use yaeos_ar_models_hyperdual, only: ArModelAdiff !! !! type, extends(ArModelAdiff) :: YourNewModel !!       type(Substances) :: composition !!       real(8) :: parameters(:) !!     contains !!       procedure :: Ar => arfun !!       procedure :: get_v0 => v0 !! end type !! contains !! subroutine arfun(self, n, v, t, Ar) !!    class(YourNewModel), intent(in) :: self !!    type(hyperdual), intent(in) :: n(:) ! Number of moles !!    type(hyperdual), intent(in) :: v ! Volume [L] !!    type(hyperdual), intent(in) :: t ! Temperature [K] !!    type(hyperdual), intent(out) :: ar_value ! Residual Helmholtz Energy !! !!    ! A very complicated residual helmholtz function of a mixture !!    Ar = sum(n) * v * t !! end subroutine !! !! function v0(self, n, p, t) !!    class(YourNewModel), intent(in) :: self !!    real(pr), intent(in) :: n(:) ! Number of moles !!    real(pr), intent(in) :: p ! Pressure [bar] !!    real(pr), intent(in) :: t ! Temperature [K] !!    real(pr) :: v0 !! !!    v0 = self%parameters(3) !! end function !! ``` !! !! A complete implementation of the PR76 Equation of State can me found in !! `example/adiff/adiff_pr76.f90` !! use yaeos_constants , only : pr use yaeos_models_ar , only : ArModel use yaeos_autodiff implicit none type , abstract , extends ( ArModel ) :: ArModelAdiff contains procedure ( hyperdual_ar ), deferred :: Ar procedure :: residual_helmholtz => residual_helmholtz end type abstract interface type ( hyperdual ) function hyperdual_Ar ( self , n , v , t ) import hyperdual , ArModelAdiff class ( ArModelAdiff ) :: self type ( hyperdual ), intent ( in ) :: n (:) type ( hyperdual ), intent ( in ) :: v type ( hyperdual ), intent ( in ) :: t end function end interface contains subroutine residual_helmholtz (& self , n , v , t , Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) class ( ArModelAdiff ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: v , t real ( pr ), optional , intent ( out ) :: Ar , ArV , ArT , ArT2 , ArTV , ArV2 real ( pr ), optional , dimension ( size ( n )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) type ( hyperdual ) :: d_v , d_t , d_n ( size ( n )) type ( hyperdual ) :: d_Ar if ( present ( ArV )) then if ( present ( ArV2 )) call get_dardv2 if ( present ( ArVn )) call get_dardvn if ( present ( ArTV )) call get_dardvt if (. not . ( present ( ArV2 ) . and . present ( ArVn ) . and . present ( ArTV ))) & call get_dardv end if if ( present ( ArT )) then if ( present ( ArT2 )) call get_dardt2 if ( present ( ArTn )) call get_dardtn if (. not . ( present ( ArT2 ) . and . present ( ArTn ))) call get_dardt end if if ( present ( Arn )) then if ( present ( Arn2 )) then call get_dardn2 else call get_dardn end if end if if ( present ( Ar )) Ar = d_Ar % f0 contains subroutine get_dardn () integer :: i , j do i = 1 , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i ) = d_Ar % f1 end do end subroutine subroutine get_dardn2 () integer :: i , j do i = 1 , size ( n ) do j = i , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_n ( j )% f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i ) = d_Ar % f1 Arn2 ( i , j ) = d_Ar % f12 Arn2 ( j , i ) = d_Ar % f12 end do end do end subroutine subroutine get_dardvn () integer :: i do i = 1 , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_v % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i ) = d_Ar % f1 ArV = d_Ar % f2 ArVn ( i ) = d_Ar % f12 end do end subroutine subroutine get_dardtn () integer :: i do i = 1 , size ( n ) call reset_vars d_n ( i )% f1 = 1 d_t % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) Arn ( i ) = d_Ar % f1 ArT = d_Ar % f2 ArTn ( i ) = d_Ar % f12 end do end subroutine subroutine get_dardv () call reset_vars d_v % f1 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArV = d_Ar % f1 end subroutine subroutine get_dardt () call reset_vars d_t % f1 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArT = d_Ar % f1 end subroutine subroutine get_dardt2 () call reset_vars d_t % f1 = 1 d_t % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArT = d_Ar % f1 ArT2 = d_Ar % f12 end subroutine subroutine get_dardv2 () call reset_vars d_v % f1 = 1 d_v % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArV = d_Ar % f1 ArV2 = d_Ar % f12 end subroutine subroutine get_dardvt () call reset_vars d_v % f1 = 1 d_t % f2 = 1 d_Ar = self % Ar ( d_n , d_v , d_t ) ArV = d_Ar % f1 ArTV = d_Ar % f12 end subroutine subroutine reset_vars () d_n = n d_v = v d_t = t end subroutine end subroutine end module","tags":"","loc":"sourcefile/armodel_adiff_api.f90.html"},{"title":"saturations_points.f90 – yaeos","text":"This file depends on sourcefile~~saturations_points.f90~~EfferentGraph sourcefile~saturations_points.f90 saturations_points.f90 sourcefile~constants.f90 constants.f90 sourcefile~saturations_points.f90->sourcefile~constants.f90 sourcefile~equilibria_state.f90 equilibria_state.f90 sourcefile~saturations_points.f90->sourcefile~equilibria_state.f90 sourcefile~models.f90 models.f90 sourcefile~saturations_points.f90->sourcefile~models.f90 sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~saturations_points.f90->sourcefile~thermoprops.f90 sourcefile~equilibria_state.f90->sourcefile~constants.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~models.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90 implementations.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~thermoprops.f90->sourcefile~constants.f90 sourcefile~thermoprops.f90->sourcefile~ar_models.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~substance.f90 substance.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~implementations.f90->sourcefile~constants.f90 sourcefile~implementations.f90->sourcefile~alphas.f90 sourcefile~implementations.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90->sourcefile~mixing_rules.f90 sourcefile~implementations.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~substance.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_equilibria_saturation_points use yaeos_constants , only : pr use yaeos_models , only : ArModel use yaeos_thermoprops , only : fugacity_vt use yaeos_equilibria_equilibria_state , only : EquilibriaState real ( pr ) :: tol = 1e-5_pr integer :: max_iterations = 100 real ( pr ) :: step_tol = 0.1_pr end module","tags":"","loc":"sourcefile/saturations_points.f90.html"},{"title":"alphas.f90 – yaeos","text":"This file depends on sourcefile~~alphas.f90~~EfferentGraph sourcefile~alphas.f90 alphas.f90 sourcefile~constants.f90 constants.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~substance.f90 substance.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~alphas.f90~~AfferentGraph sourcefile~alphas.f90 alphas.f90 sourcefile~implementations.f90 implementations.f90 sourcefile~implementations.f90->sourcefile~alphas.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~flash.f90 flash.f90 sourcefile~flash.f90->sourcefile~models.f90 sourcefile~saturations_points.f90 saturations_points.f90 sourcefile~saturations_points.f90->sourcefile~models.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_models_ar_cubic_alphas !! \\alpha functions defined in the library. use yaeos_constants , only : pr use yaeos_substance , only : substances use yaeos_models_ar_genericcubic , only : CubicEoS , AlphaFunction implicit none type , extends ( AlphaFunction ) :: AlphaSoave !! Soave \\alpha function. !!  \\alpha(T_r) = (1 + k (1 - \\sqrt{Tr}))&#94;2  real ( pr ), allocatable :: k (:) !! k parameter. contains procedure :: alpha !! Alpha function end type contains subroutine alpha ( self , Tr , a , dadt , dadt2 ) !! Soave \\alpha function and it's derivatives. class ( AlphaSoave ), intent ( in ) :: self real ( pr ), intent ( in ) :: Tr (:) !! Reduced temperature real ( pr ), intent ( out ) :: a (:) !! \\alpha real ( pr ), intent ( out ) :: dadt (:) !! \\frac{d\\alpha}{dT} real ( pr ), intent ( out ) :: dadt2 (:) !! \\frac{d&#94;2\\alpha}{dT&#94;2} associate ( k => self % k ) a = ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 dadT = k * ( k * ( sqrt ( Tr ) - 1 ) - 1 ) / sqrt ( Tr ) dadT2 = ( 1.0_pr / 2.0_pr ) * k * ( k + 1 ) / Tr ** ( 1.5_pr ) end associate end subroutine end module","tags":"","loc":"sourcefile/alphas.f90.html"},{"title":"hyperdual.f90 – yaeos","text":"This file depends on sourcefile~~hyperdual.f90~~EfferentGraph sourcefile~hyperdual.f90 hyperdual.f90 sourcefile~constants.f90 constants.f90 sourcefile~hyperdual.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~hyperdual.f90~~AfferentGraph sourcefile~hyperdual.f90 hyperdual.f90 sourcefile~autodiff.f90 autodiff.f90 sourcefile~autodiff.f90->sourcefile~hyperdual.f90 sourcefile~armodel_adiff_api.f90 armodel_adiff_api.f90 sourcefile~armodel_adiff_api.f90->sourcefile~autodiff.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hyperdual_mod !> Hyperdual number definition & type declaration ! ! Original code provided by Philipp Rehner and Gernot Bauer, ! Institute of Thermodynamics and Thermal Process Engineering (ITT), ! University of Stuttgart, Stuttgart, Germany ! ! #### Hypderdual numbers ! ! Hypderdual numbers extend the idea of additional, non-real ! components from one non-real component (complex numbers) to four ! non-real components: \\f$\\varepsilon_1\\f$, \\f$\\varepsilon_2\\f$ and ! \\f$\\varepsilon_1 \\varepsilon_2\\f$. ! Hyperdual numbers require: \\f$(\\varepsilon_1)&#94;2 = 0\\f$, ! \\f$(\\varepsilon_2)&#94;2 = 0\\f$ and ! \\f$(\\varepsilon_1\\varepsilon_2)&#94;2 = 0\\f$ ! This leads to the fact, that the Taylor series of a function with ! hyperdual arguments can be truncated _exactly_ after the second ! derivative term: ! ! \\f[ !    f(\\mathbf{x} + h_1 \\varepsilon_1 + h_2 \\varepsilon_2 !      + h_1 h_2 \\varepsilon_1 \\varepsilon_2) !    = f(\\mathbf{x}) + h_1 f'(\\mathbf{x}) \\varepsilon_1 !      + h_2 f'(\\mathbf{x}) \\varepsilon_2 !      + h_1 h_2 f''(\\mathbf{x}) \\varepsilon_1 \\varepsilon_2 ! \\f] ! ! Because there is _no truncation error_, all first and second order ! derivatives can be obtained _exactly_, regardless of the step size '' ! \\f$h_1\\f$ and \\f$h_2\\f$. ! The derivatives can be obtained for a function \\f$ f(\\mathbf{x}) \\f$ ! with multiple variables \\f$ \\mathbf{x} \\in \\mathbb{R}&#94;n \\f$ via ! \\f{eqnarray*}{ !   \\frac{\\partial f(\\mathbf{x})}{\\partial x_i} &=& \\frac{ !     \\varepsilon_{1, \\mathrm{part}} \\Big\\{ !     f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e}_i !     + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big\\}} !     {h_1}\\\\ !   \\frac{\\partial f(\\mathbf{x})}{\\partial x_i} &=& \\frac{ !      \\varepsilon_{2, \\mathrm{part}} \\Big\\{ !      f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e}_i !      + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big\\}} !      {h_2}\\\\ !   \\frac{\\partial&#94;2 f(\\mathbf{x})}{\\partial x_i \\partial x_j} &=& !     \\frac{(\\varepsilon_1 \\varepsilon_2)_\\mathrm{part} \\Big\\{ !     f(\\mathbf{x} + h_1 \\varepsilon_1 \\mathbf{e}_i !     + h_2 \\varepsilon_2 \\mathbf{e}_j + h_1 h_2 \\mathbf{0})\\Big\\}} !     {h_1 h_2}  \\\\ ! \\f} ! where \\f$\\mathbf{e}_i\\f$ and \\f$\\mathbf{e}_j\\f$ are unit vectors, ! which are all zero except for the \\f$i\\f$-th and \\f$j\\f$-th ! component, respectively. ! ! #### Computation principles for hypderdual numbers ! ! Hyperdual numbers \\f$\\mathbf{x} \\in \\mathbb{HD}\\f$ can be expressed ! as tuples: \\f$\\mathbf{x} = [x_0, x_1, x_2, x_{12}] = x_0 ! + x_1 \\varepsilon_1 + x_2 \\varepsilon_2 ! + x_{12} \\varepsilon_1\\varepsilon_2\\f$. ! By using the Taylor expansion of the function \\f$f(\\mathbf{x})\\f$ ! one gets computation priniple for functions with hyperdual ! arguments from ! ! \\f[ !    f(\\mathbf{x}) = f(x_0) + x_1 f'(x_0) \\varepsilon_1 !    + x_2 f'(x_0) \\varepsilon_2 + \\big( x_{12} f'(x_0) !    + x_1 x_2 f''(x_0) \\big) \\varepsilon_1 \\varepsilon_2 ! \\f] ! ! A hyperdual number derived type is provided by: \\ref hyperdual. ! ! #### References ! ! [[1]](https://doi.org/10.2514/6.2011-886) !      Fike, Alonso: **The Development of Hyper-Dual Numbers for Exact !                      Second-Derivative Calculations.** !      _49th AIAA Aerospace Sciences Meeting including the New !       Horizons Forum and Aerospace Exposition_ (2011) \\n ! [[2]](https://doi.org/10.3389/fceng.2021.758090) !      Rehner, P. and Bauer, G.: **Application of Generalized !                                  (Hyper-) Dual Numbers in Equation !                                  of State Modeling.** !      Frontiers in Chemical Engineering_ (2021) \\n ! use yaeos_constants , only : pr implicit none type , bind ( c ) :: hyperdual !-| Derived type for hyperdual numbers ! !  Hyperdual numbers are represented by the tuple \\f$\\mathbf{f} = !  [f_0, f_1, f_2, f_{12}] = f_0 + f_1 \\varepsilon_1 !  + f_2 \\varepsilon_2 + f_{12} \\varepsilon_1 \\varepsilon_2 \\f$. !  Calculations specificaions are defined in module hyperdual_mod. ! sequence real ( pr ) :: f0 = 0 !! real part of the hyperdual number real ( pr ) :: f1 = 0 !! \\f$\\varepsilon_1\\f$-part of  the hyperdual number real ( pr ) :: f2 = 0 !! \\f$\\varepsilon_2\\f$-part of  the hyperdual number real ( pr ) :: f12 = 0 !! \\f$\\varepsilon_1\\varepsilon_2\\f$-part of the end type hyperdual !--------------------------------------------------------------------- !--- Operator interfaces --------------------------------------------- !--------------------------------------------------------------------- ! Equal assignment interface assignment ( = ) procedure EqualHyperDualHyperDual procedure EqualHyperDualReal end interface ! Unary operator + interface operator ( + ) procedure PlusHyperDualHyperDual end interface ! Addition operator interface operator ( + ) procedure AddHyperDualHyperDual procedure AddHyperDualReal procedure AddRealHyperDual end interface ! Unary operator - interface operator ( - ) procedure MinusHyperDualHyperDual end interface ! Subtraction operator interface operator ( - ) procedure SubtractHyperDualHyperDual procedure SubtractHyperDualReal procedure SubtractRealHyperDual end interface ! Multiplication operator interface operator ( * ) procedure MultiplyHyperDualHyperDual procedure MultiplyHyperDualReal procedure MultiplyRealHyperDual procedure MultiplyHyperDualInt procedure MultiplyIntHyperDual end interface ! Division operator interface operator ( / ) procedure DivideHyperDualHyperDual procedure DivideHyperDualReal procedure DivideRealHyperDual end interface ! Power operator interface operator ( ** ) procedure PowerHyperDualInt procedure PowerHyperDualHyperDual procedure PowerHyperDualReal end interface !--------------------------------------------------------------------- !--- Summation interface --------------------------------------------- !--------------------------------------------------------------------- interface sum module procedure SumHyperDual module procedure SumHyperDual2 end interface sum !--------------------------------------------------------------------- !--- Logical operator interfaces ------------------------------------- !--------------------------------------------------------------------- ! Equal operator. interface operator (. eq .) ! or (==) procedure eq_dd procedure eq_dr procedure eq_rd procedure eq_di procedure eq_id end interface ! Not equal operator. interface operator (. ne .) ! or (/=) procedure ne_dd procedure ne_dr procedure ne_rd procedure ne_di procedure ne_id end interface ! Less than operator. interface operator (. lt .) ! or (<) procedure lt_dd procedure lt_dr procedure lt_rd procedure lt_di procedure lt_id end interface ! Less than or equal operator. interface operator (. le .) ! or (<=) procedure le_dd procedure le_dr procedure le_rd procedure le_di procedure le_id end interface ! Greater than operator. interface operator (. gt .) ! or (>) procedure gt_dd procedure gt_dr procedure gt_rd procedure gt_di procedure gt_id end interface ! Greater than or equal operator. interface operator (. ge .) ! or (>=) procedure ge_dd procedure ge_dr procedure ge_rd procedure ge_di procedure ge_id end interface !--------------------------------------------------------------------- !--- Math function interfaces ---------------------------------------- !--------------------------------------------------------------------- ! Absolute value function interface abs module procedure absHyperDual end interface ! Integer function interface int module procedure intHyperDual end interface ! Nearest integer function interface nint module procedure nintHyperDual end interface ! Real function interface real module procedure realHyperDual end interface ! Sign function interface sign module procedure sign_dd module procedure sign_dr module procedure sign_rd end interface ! Sine function interface sin module procedure sinHyperDual end interface ! Cosine function interface cos module procedure cosHyperDual end interface ! Tangent function interface tan module procedure tanHyperDual end interface ! Sqrt function interface sqrt module procedure sqrtHyperDual end interface ! Log function interface log module procedure logHyperDual end interface ! Log10 function interface log10 module procedure log10HyperDual end interface ! Exp function interface exp module procedure expHyperDual end interface ! Sinh function interface sinh module procedure sinhHyperDual end interface ! Cosh function interface cosh module procedure coshHyperDual end interface ! Tanh function interface tanh module procedure tanhHyperDual end interface ! Acos function interface acos module procedure acosHyperDual end interface ! Asin function interface asin module procedure asinHyperDual end interface ! Atan function interface atan module procedure atanHyperDual end interface ! Atan2 function interface atan2 module procedure atan2HyperDual end interface ! Max function (limited to combinations below, but that ! can be extended) interface max module procedure max_dd module procedure max_ddd module procedure max_dr module procedure max_rd end interface ! Min function (limited for now to 2 arguments, but that ! can be extended) interface min module procedure min_dd module procedure min_dr module procedure min_rd end interface !===================================================================== contains !------------------------------------------------------------------- !--- Functions for the equal assignment. --------------------------- !------------------------------------------------------------------- elemental subroutine EqualHyperDualHyperDual ( res , inp ) implicit none type ( hyperdual ), intent ( out ) :: res type ( hyperdual ), intent ( in ) :: inp res % f0 = inp % f0 res % f1 = inp % f1 res % f2 = inp % f2 res % f12 = inp % f12 end subroutine EqualHyperDualHyperDual elemental subroutine EqualHyperDualReal ( res , inp ) implicit none type ( hyperdual ), intent ( out ) :: res real ( pr ), intent ( in ) :: inp res % f0 = inp res % f1 = 0.0_pr res % f2 = 0.0_pr res % f12 = 0.0_pr end subroutine EqualHyperDualReal !------------------------------------------------------------------- !--- Function for the unary operator +. ---------------------------- !------------------------------------------------------------------- elemental function PlusHyperDualHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 v2 % f0 = v1 % f0 v2 % f1 = v1 % f1 v2 % f2 = v1 % f2 v2 % f12 = v1 % f12 end function PlusHyperDualHyperDual !------------------------------------------------------------------- !--- Functions for the addition operator. -------------------------- !------------------------------------------------------------------- elemental function AddHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 + v2 % f0 v3 % f1 = v1 % f1 + v2 % f1 v3 % f2 = v1 % f2 + v2 % f2 v3 % f12 = v1 % f12 + v2 % f12 end function AddHyperDualHyperDual elemental function AddHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 + v2 v3 % f1 = v1 % f1 v3 % f2 = v1 % f2 v3 % f12 = v1 % f12 end function AddHyperDualReal elemental function AddRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 + v2 % f0 v3 % f1 = v2 % f1 v3 % f2 = v2 % f2 v3 % f12 = v2 % f12 end function AddRealHyperDual !------------------------------------------------------------------- !--- Function for the unary operator -. ---------------------------- !------------------------------------------------------------------- elemental function MinusHyperDualHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 v2 % f0 = - v1 % f0 v2 % f1 = - v1 % f1 v2 % f2 = - v1 % f2 v2 % f12 = - v1 % f12 end function MinusHyperDualHyperDual !------------------------------------------------------------------- !--- Functions for the subtraction operator. ----------------------- !------------------------------------------------------------------- elemental function SubtractHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 - v2 % f0 v3 % f1 = v1 % f1 - v2 % f1 v3 % f2 = v1 % f2 - v2 % f2 v3 % f12 = v1 % f12 - v2 % f12 end function SubtractHyperDualHyperDual elemental function SubtractHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 - v2 v3 % f1 = v1 % f1 v3 % f2 = v1 % f2 v3 % f12 = v1 % f12 end function SubtractHyperDualReal elemental function SubtractRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 - v2 % f0 v3 % f1 = - v2 % f1 v3 % f2 = - v2 % f2 v3 % f12 = - v2 % f12 end function SubtractRealHyperDual !------------------------------------------------------------------- !--- Functions for the multiplication operator. -------------------- !------------------------------------------------------------------- elemental function MultiplyHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 * v2 % f0 v3 % f1 = v1 % f0 * v2 % f1 + v1 % f1 * v2 % f0 v3 % f2 = v1 % f0 * v2 % f2 + v1 % f2 * v2 % f0 v3 % f12 = v1 % f0 * v2 % f12 + v1 % f1 * v2 % f2 + v1 % f2 * v2 % f1 + v1 % f12 * v2 % f0 end function MultiplyHyperDualHyperDual elemental function MultiplyHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 * v2 v3 % f1 = v1 % f1 * v2 v3 % f2 = v1 % f2 * v2 v3 % f12 = v1 % f12 * v2 end function MultiplyHyperDualReal elemental function MultiplyRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 * v2 % f0 v3 % f1 = v1 * v2 % f1 v3 % f2 = v1 * v2 % f2 v3 % f12 = v1 * v2 % f12 end function MultiplyRealHyperDual elemental function MultiplyHyperDualInt ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 integer , intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 % f0 * v2 v3 % f1 = v1 % f1 * v2 v3 % f2 = v1 % f2 * v2 v3 % f12 = v1 % f12 * v2 end function MultiplyHyperDualInt elemental function MultiplyIntHyperDual ( v1 , v2 ) result ( v3 ) integer , intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 v3 % f0 = v1 * v2 % f0 v3 % f1 = v1 * v2 % f1 v3 % f2 = v1 * v2 % f2 v3 % f12 = v1 * v2 % f12 end function MultiplyIntHyperDual !------------------------------------------------------------------- !--- Functions for the division operator. -------------------------- !------------------------------------------------------------------- elemental function DivideHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 v3 = v1 * v2 ** ( - 1 ) end function DivideHyperDualHyperDual elemental function DivideHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ) :: invV2 invV2 = 1.0_pr / v2 v3 = v1 * invV2 end function DivideHyperDualReal elemental function DivideRealHyperDual ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: invV2 , v3 invV2 = 1.0_pr * v2 ** ( - 1.0_pr ) v3 = v1 * invV2 end function DivideRealHyperDual !------------------------------------------------------------------- !--- Functions for the power operator. ----------------------------- !------------------------------------------------------------------- elemental function PowerHyperDualInt ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 integer , intent ( in ) :: v2 integer :: i , vv2 type ( hyperdual ) :: v3 v3 = 1.0_pr vv2 = abs ( v2 ) do i = 1 , vv2 v3 = v3 * v1 enddo if ( v2 < 0 ) v3 = 1.0_pr / v3 end function PowerHyperDualInt elemental function PowerHyperDualHyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 , v4 v4 = logHyperDual ( v1 ) v3 = expHyperDual ( v2 * v4 ) end function PowerHyperDualHyperDual elemental function PowerHyperDualReal ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ), parameter :: tol = 1.0e-15_pr real ( pr ) :: xval , deriv xval = v1 % f0 if ( abs ( xval ) < tol ) then if ( xval >= 0.0_pr ) then xval = tol else xval = - tol endif endif deriv = v2 * ( xval ** ( v2 - 1.0_pr )) v3 % f0 = ( v1 % f0 ) ** v2 v3 % f1 = v1 % f1 * deriv v3 % f2 = v1 % f2 * deriv v3 % f12 = v1 % f12 * deriv & & + v2 * ( v2 - 1.0_pr ) * v1 % f1 * v1 % f2 * xval ** ( v2 - 2.0_pr ) end function PowerHyperDualReal !------------------------------------------------------------------- !--- Sum ----------------------------------------------------------- !------------------------------------------------------------------- pure type ( hyperdual ) function SumHyperDual ( v1 , mask ) type ( hyperdual ), intent ( in ) :: v1 (:) logical , intent ( in ), optional :: mask (:) integer :: i SumHyperDual = hyperdual ( 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr ) if ( present ( mask )) then do i = 1 , size ( v1 ) if ( mask ( i )) SumHyperDual = SumHyperDual + v1 ( i ) end do else do i = 1 , size ( v1 ) SumHyperDual = SumHyperDual + v1 ( i ) end do end if end function SumHyperDual pure function SumHyperDual2 ( v1 , dim ) type ( hyperdual ), intent ( in ) :: v1 (:,:) integer , intent ( in ) :: dim type ( hyperdual ), allocatable :: SumHyperDual2 (:) integer :: i allocate ( SumHyperDual2 ( size ( v1 ) / size ( v1 , dim ))) SumHyperDual2 = hyperdual ( 0.0_pr , 0.0_pr , 0.0_pr , 0.0_pr ) do i = 1 , size ( v1 , dim ) if ( dim == 1 ) then SumHyperDual2 = SumHyperDual2 + v1 ( i ,:) else SumHyperDual2 = SumHyperDual2 + v1 (:, i ) end if end do end function SumHyperDual2 !------------------------------------------------------------------- !--- Functions for the equal operator. ----------------------------- !------------------------------------------------------------------- logical function eq_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs eq_dd = lhs % f0 == rhs % f0 end function eq_dd elemental logical function eq_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs eq_dr = lhs % f0 == rhs end function eq_dr elemental logical function eq_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs eq_rd = lhs == rhs % f0 end function eq_rd logical function eq_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs eq_di = lhs % f0 == rhs end function eq_di logical function eq_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs eq_id = lhs == rhs % f0 end function eq_id !------------------------------------------------------------------- !--- Functions for the not equal operator. ------------------------- !------------------------------------------------------------------- logical function ne_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs ne_dd = lhs % f0 /= rhs % f0 end function ne_dd logical function ne_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs ne_dr = lhs % f0 /= rhs end function ne_dr logical function ne_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ne_rd = lhs /= rhs % f0 end function ne_rd logical function ne_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs ne_di = lhs % f0 /= rhs end function ne_di logical function ne_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ne_id = lhs /= rhs % f0 end function ne_id !------------------------------------------------------------------- !--- Functions for the less than operator. ------------------------- !------------------------------------------------------------------- logical function lt_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs lt_dd = lhs % f0 < rhs % f0 end function lt_dd logical function lt_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs lt_dr = lhs % f0 < rhs end function lt_dr logical function lt_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs lt_rd = lhs < rhs % f0 end function lt_rd logical function lt_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs lt_di = lhs % f0 < rhs end function lt_di logical function lt_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs lt_id = lhs < rhs % f0 end function lt_id !------------------------------------------------------------------- !--- Functions for the less than or equal operator. ---------------- !------------------------------------------------------------------- logical function le_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs le_dd = lhs % f0 <= rhs % f0 end function le_dd logical function le_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs le_dr = lhs % f0 <= rhs end function le_dr logical function le_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs le_rd = lhs <= rhs % f0 end function le_rd logical function le_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs le_di = lhs % f0 <= rhs end function le_di logical function le_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs le_id = lhs <= rhs % f0 end function le_id !------------------------------------------------------------------- !--- Functions for the greater than operator. ---------------------- !------------------------------------------------------------------- logical function gt_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs gt_dd = lhs % f0 > rhs % f0 end function gt_dd logical function gt_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs gt_dr = lhs % f0 > rhs end function gt_dr logical function gt_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs gt_rd = lhs > rhs % f0 end function gt_rd logical function gt_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs gt_di = lhs % f0 > rhs end function gt_di logical function gt_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs gt_id = lhs > rhs % f0 end function gt_id !------------------------------------------------------------------- !--- Functions for the greater than or equal operator. ------------- !------------------------------------------------------------------- logical function ge_dd ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs , rhs ge_dd = lhs % f0 >= rhs % f0 end function ge_dd logical function ge_dr ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs real ( pr ), intent ( in ) :: rhs ge_dr = lhs % f0 >= rhs end function ge_dr logical function ge_rd ( lhs , rhs ) real ( pr ), intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ge_rd = lhs >= rhs % f0 end function ge_rd logical function ge_di ( lhs , rhs ) type ( hyperdual ), intent ( in ) :: lhs integer , intent ( in ) :: rhs ge_di = lhs % f0 >= rhs end function ge_di logical function ge_id ( lhs , rhs ) integer , intent ( in ) :: lhs type ( hyperdual ), intent ( in ) :: rhs ge_id = lhs >= rhs % f0 end function ge_id !------------------------------------------------------------------- !--- Math functions. ----------------------------------------------- !------------------------------------------------------------------- ! Absolute value function. elemental function absHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 if ( v1 % f0 >= 0.0 ) then v2 % f0 = v1 % f0 v2 % f1 = v1 % f1 v2 % f2 = v1 % f2 v2 % f12 = v1 % f12 else v2 % f0 = - v1 % f0 v2 % f1 = - v1 % f1 v2 % f2 = - v1 % f2 v2 % f12 = - v1 % f12 endif end function absHyperDual ! Integer function. elemental function intHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 integer :: v2 v2 = int ( v1 % f0 ) end function intHyperDual ! Nearest integer function. elemental function nintHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 integer :: v2 v2 = nint ( v1 % f0 ) end function nintHyperDual ! Real function. elemental function realHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ) :: v2 v2 = v1 % f0 end function realHyperDual ! Functions for the sign function. elemental function sign_dd ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 real ( pr ) :: ssign if ( v2 % f0 < 0.0 ) then ssign = - 1.0 else ssign = 1.0 endif v3 = ssign * v1 end function sign_dd elemental function sign_dr ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ) :: ssign if ( v2 < 0.0 ) then ssign = - 1.0 else ssign = 1.0 endif v3 = ssign * v1 end function sign_dr elemental function sign_rd ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 real ( pr ) :: ssign if ( v2 % f0 < 0.0 ) then ssign = - 1.0 else ssign = 1.0 endif v3 = ssign * v1 end function sign_rd ! Sine function. elemental function sinHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: f , dx f = sin ( v1 % f0 ) dx = cos ( v1 % f0 ) v2 % f0 = f v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * v1 % f12 - f * v1 % f1 * v1 % f2 end function sinHyperDual ! Cosine function. elemental function cosHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: f , dx f = cos ( v1 % f0 ) dx = - sin ( v1 % f0 ) v2 % f0 = f v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * v1 % f12 - f * v1 % f1 * v1 % f2 end function cosHyperDual ! Tangent function. elemental function tanHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: f , dx f = tan ( v1 % f0 ) dx = f * f + 1.0_pr v2 % f0 = f v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * v1 % f12 + v1 % f1 * v1 % f2 * 2.0_pr * f * dx end function tanHyperDual ! Sqrt function elemental function sqrtHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ), parameter :: expo = 3.0_pr / 2.0_pr real ( pr ) :: square square = sqrt ( v1 % f0 ) v2 % f0 = square v2 % f1 = 0.5_pr / square * v1 % f1 v2 % f2 = 0.5_pr / square * v1 % f2 v2 % f12 = 0.5_pr * v1 % f12 / square - 0.25_pr * v1 % f1 * v1 % f2 / ( v1 % f0 ** expo ) end function sqrtHyperDual ! Log function elemental function logHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: dx1 , dx2 dx1 = v1 % f1 / v1 % f0 dx2 = v1 % f2 / v1 % f0 v2 % f0 = log ( v1 % f0 ) v2 % f1 = dx1 v2 % f2 = dx2 v2 % f12 = v1 % f12 / v1 % f0 - ( dx1 * dx2 ) end function logHyperDual ! Log10 function elemental function log10HyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 v2 = log ( v1 ) / log ( 1 0.0_pr ) end function log10HyperDual ! Exp function elemental function expHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: dx dx = exp ( v1 % f0 ) v2 % f0 = dx v2 % f1 = dx * v1 % f1 v2 % f2 = dx * v1 % f2 v2 % f12 = dx * ( v1 % f12 + v1 % f1 * v1 % f2 ) end function expHyperDual ! Sinh function elemental function sinhHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: t1 , t2 , v2 t1 = exp ( v1 ) t2 = exp ( - v1 ) v2 = 0.5_pr * ( t1 - t2 ) end function sinhHyperDual ! Cosh function elemental function coshHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: t1 , t2 , v2 t1 = exp ( v1 ) t2 = exp ( - v1 ) v2 = 0.5_pr * ( t1 + t2 ) end function coshHyperDual ! Tanh function elemental function tanhHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: t1 , t2 , v2 t1 = exp ( v1 ) t2 = exp ( - v1 ) v2 = ( t1 - t2 ) / ( t1 + t2 ) end function tanhHyperDual ! Acos function elemental function acosHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: deriv , deriv1 deriv1 = 1.0_pr - v1 % f0 * v1 % f0 deriv = - 1.0_pr / sqrt ( deriv1 ) v2 % f0 = acos ( v1 % f0 ) v2 % f1 = deriv * v1 % f1 v2 % f2 = deriv * v1 % f2 v2 % f12 = deriv * v1 % f12 & & + v1 % f1 * v1 % f2 * ( - v1 % f0 * deriv1 ** ( - 1.5_pr )) end function acosHyperDual ! Asin function elemental function asinHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: deriv , deriv1 deriv1 = 1.0_pr - v1 % f0 * v1 % f0 deriv = 1.0_pr / sqrt ( deriv1 ) v2 % f0 = asin ( v1 % f0 ) v2 % f1 = deriv * v1 % f1 v2 % f2 = deriv * v1 % f2 v2 % f12 = deriv * v1 % f12 & & + v1 % f1 * v1 % f2 * ( v1 % f0 * deriv1 ** ( - 1.5_pr )) end function asinHyperDual ! Atan function elemental function atanHyperDual ( v1 ) result ( v2 ) type ( hyperdual ), intent ( in ) :: v1 type ( hyperdual ) :: v2 real ( pr ) :: deriv , deriv1 deriv1 = 1.0_pr + v1 % f0 * v1 % f0 deriv = 1.0_pr / deriv1 v2 % f0 = atan ( v1 % f0 ) v2 % f1 = deriv * v1 % f1 v2 % f2 = deriv * v1 % f2 v2 % f12 = deriv * v1 % f12 & & + v1 % f1 * v1 % f2 * ( - 2.0_pr * v1 % f0 / ( deriv1 * deriv1 )) end function atanHyperDual ! Atan2 function elemental function atan2HyperDual ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 real ( pr ) :: a , b , c , d a = v1 % f0 b = v1 % f1 c = v2 % f0 d = v2 % f1 v3 % f0 = atan2 ( a , c ) v3 % f1 = ( c * b - a * d ) / ( a * a + c * c ) end function atan2HyperDual ! Max functions elemental function max_dd ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 if ( v1 % f0 > v2 % f0 ) then v3 = v1 else v3 = v2 endif end function max_dd elemental function max_ddd ( v1 , v2 , v3 ) result ( v4 ) type ( hyperdual ), intent ( in ) :: v1 , v2 , v3 type ( hyperdual ) :: v4 if ( v1 % f0 > v2 % f0 ) then v4 = v1 else v4 = v2 endif if ( v3 % f0 > v4 % f0 ) v4 = v3 end function max_ddd elemental function max_dr ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 % f0 > v2 ) then v3 = v1 else v3 = v2 endif end function max_dr elemental function max_rd ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 > v2 % f0 ) then v3 = v1 else v3 = v2 endif end function max_rd ! Min functions elemental function min_dd ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 , v2 type ( hyperdual ) :: v3 if ( v1 % f0 < v2 % f0 ) then v3 = v1 else v3 = v2 endif end function min_dd elemental function min_dr ( v1 , v2 ) result ( v3 ) type ( hyperdual ), intent ( in ) :: v1 real ( pr ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 % f0 < v2 ) then v3 = v1 else v3 = v2 endif end function min_dr elemental function min_rd ( v1 , v2 ) result ( v3 ) real ( pr ), intent ( in ) :: v1 type ( hyperdual ), intent ( in ) :: v2 type ( hyperdual ) :: v3 if ( v1 < v2 % f0 ) then v3 = v1 else v3 = v2 endif end function min_rd end module","tags":"","loc":"sourcefile/hyperdual.f90.html"},{"title":"models.f90 – yaeos","text":"This file depends on sourcefile~~models.f90~~EfferentGraph sourcefile~models.f90 models.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~models.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90 implementations.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~constants.f90 constants.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~substance.f90 substance.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~implementations.f90->sourcefile~alphas.f90 sourcefile~implementations.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90->sourcefile~mixing_rules.f90 sourcefile~implementations.f90->sourcefile~constants.f90 sourcefile~implementations.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~substance.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~models.f90~~AfferentGraph sourcefile~models.f90 models.f90 sourcefile~flash.f90 flash.f90 sourcefile~flash.f90->sourcefile~models.f90 sourcefile~saturations_points.f90 saturations_points.f90 sourcefile~saturations_points.f90->sourcefile~models.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_models !! `yaeos` thermodynamic models !! !! On `yaeos` there are implemented a series of both residual Helmholtz !! energy (A_r) and excess Gibbs energy (G&#94;E) models. !! !! This module takes all the relevant procedures and derived types !! related to them. !! !! - Residual Helmholtz model base type `ArModel` base derived type !!   that provides the basic structure that a residual Helmholtz model !!   should provide. !! - **Cubic Equations of state**: !!    - `AlphaFunction` type !!    - `CubicMixRule` type !!    - `CubicEos` type that extends `ArModel` to use a generic !!      two-parameter EoS. Implemented models that use this type can be !!      seen at [[yaeos_models_ar_cubic_implementations(module)]] !!    - `QMR` (Quadratic Mixing Rule) type: extensible derived type that !!       defaults to classic vdW mixing rules ! Residual Helmholtz Models use yaeos_models_ar , only : ArModel ! Cubic EoS models use yaeos_models_ar_genericcubic , only : CubicEoS , GenericCubic_Ar , AlphaFunction , CubicMixRule ! Alpha functions use yaeos_models_ar_cubic_alphas ! Mixing Rules use yaeos_models_ar_genericcubic_quadratic_mixing ! Implemented models use yaeos_models_ar_cubic_implementations end module","tags":"","loc":"sourcefile/models.f90.html"},{"title":"constants.f90 – yaeos","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~substance.f90 substance.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~ar_interface.f90 ar_interface.f90 sourcefile~ar_interface.f90->sourcefile~constants.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~armodel_adiff_api.f90 armodel_adiff_api.f90 sourcefile~armodel_adiff_api.f90->sourcefile~constants.f90 sourcefile~armodel_adiff_api.f90->sourcefile~ar_models.f90 sourcefile~autodiff.f90 autodiff.f90 sourcefile~armodel_adiff_api.f90->sourcefile~autodiff.f90 sourcefile~equilibria_state.f90 equilibria_state.f90 sourcefile~equilibria_state.f90->sourcefile~constants.f90 sourcefile~flash.f90 flash.f90 sourcefile~flash.f90->sourcefile~constants.f90 sourcefile~flash.f90->sourcefile~equilibria_state.f90 sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~flash.f90->sourcefile~thermoprops.f90 sourcefile~models.f90 models.f90 sourcefile~flash.f90->sourcefile~models.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~hyperdual.f90 hyperdual.f90 sourcefile~hyperdual.f90->sourcefile~constants.f90 sourcefile~implementations.f90 implementations.f90 sourcefile~implementations.f90->sourcefile~constants.f90 sourcefile~implementations.f90->sourcefile~alphas.f90 sourcefile~implementations.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~implementations.f90->sourcefile~mixing_rules.f90 sourcefile~implementations.f90->sourcefile~substance.f90 sourcefile~legacy.f90 legacy.f90 sourcefile~legacy.f90->sourcefile~constants.f90 sourcefile~legacy.f90->sourcefile~ar_interface.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~saturations_points.f90 saturations_points.f90 sourcefile~saturations_points.f90->sourcefile~constants.f90 sourcefile~saturations_points.f90->sourcefile~equilibria_state.f90 sourcefile~saturations_points.f90->sourcefile~thermoprops.f90 sourcefile~saturations_points.f90->sourcefile~models.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~tapenade_ar_api.f90 tapenade_ar_api.f90 sourcefile~tapenade_ar_api.f90->sourcefile~constants.f90 sourcefile~tapenade_ar_api.f90->sourcefile~ar_models.f90 sourcefile~thermoprops.f90->sourcefile~constants.f90 sourcefile~thermoprops.f90->sourcefile~ar_models.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~constants.f90 sourcefile~yaeos.f90->sourcefile~substance.f90 sourcefile~yaeos.f90->sourcefile~thermoprops.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 sourcefile~autodiff.f90->sourcefile~hyperdual.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~models.f90->sourcefile~ar_models.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~phase_equilibria.f90->sourcefile~equilibria_state.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_constants !! Constants used on the whole package use iso_fortran_env , only : real32 , real64 , real128 implicit none integer , parameter :: pr = real64 !! Used precision real ( pr ), parameter :: R = 0.08314472_pr !! Ideal Gas constant character ( len = 254 ) :: database_path = \"database\" !! Path to find database character ( len = 1 ) :: path_sep = \"/\" !! File separator (to preprocess on Win or Mac/linux) real ( pr ), parameter :: NOT_IMPLEMENTED = huge ( R ) end module","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"ar_interface.f90 – yaeos","text":"This file depends on sourcefile~~ar_interface.f90~~EfferentGraph sourcefile~ar_interface.f90 ar_interface.f90 sourcefile~constants.f90 constants.f90 sourcefile~ar_interface.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ar_interface.f90~~AfferentGraph sourcefile~ar_interface.f90 ar_interface.f90 sourcefile~legacy.f90 legacy.f90 sourcefile~legacy.f90->sourcefile~ar_interface.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module ar_interface !-| Generic interfaces to an ArModel compatible with legacy codes, using !   pointers. use yaeos_constants , only : pr , R use iso_fortran_env , only : error_unit implicit none procedure ( Ares ), pointer :: ar_fun procedure ( initial_volume ), pointer :: vinit abstract interface subroutine Ares ( z , v , t , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) !| Residual Helmholtz model interface import pr real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( in ) :: v , t real ( pr ), intent ( out ) :: Ar , ArV , ArTV , ArV2 real ( pr ), dimension ( size ( z )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) end subroutine function initial_volume ( z , p , t ) import pr real ( pr ) :: z (:) real ( pr ) :: p real ( pr ) :: t real ( pr ) :: initial_volume end function end interface end module","tags":"","loc":"sourcefile/ar_interface.f90.html"},{"title":"ar_models.f90 – yaeos","text":"This file depends on sourcefile~~ar_models.f90~~EfferentGraph sourcefile~ar_models.f90 ar_models.f90 sourcefile~constants.f90 constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ar_models.f90~~AfferentGraph sourcefile~ar_models.f90 ar_models.f90 sourcefile~armodel_adiff_api.f90 armodel_adiff_api.f90 sourcefile~armodel_adiff_api.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~ar_models.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~implementations.f90 implementations.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~tapenade_ar_api.f90 tapenade_ar_api.f90 sourcefile~tapenade_ar_api.f90->sourcefile~ar_models.f90 sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~thermoprops.f90->sourcefile~ar_models.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~flash.f90 flash.f90 sourcefile~flash.f90->sourcefile~models.f90 sourcefile~flash.f90->sourcefile~thermoprops.f90 sourcefile~implementations.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90->sourcefile~alphas.f90 sourcefile~implementations.f90->sourcefile~mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~saturations_points.f90 saturations_points.f90 sourcefile~saturations_points.f90->sourcefile~models.f90 sourcefile~saturations_points.f90->sourcefile~thermoprops.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~yaeos.f90->sourcefile~thermoprops.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_models_ar !! Module that defines the basics of a residual Helmholtz energy. !! !! All the residual properties that are calculated in this library are !! based on residual Helmholtz Equations of State. Following the book by !! Michelsen and Mollerup. !! !! In this library up to second derivatives of residual Helmholtz energy !! are used. Because they're the fundamentals for phase equilibria !! calculation. !! !! @note Later on, third derivative with respect to volume will be included !! since it's importance on calculation of critical points. use yaeos_constants , only : pr implicit none type , abstract :: ArModel !! Abstract residual Helmholtz model. !! !! This derived type defines the basics needed for the calculation !! of residual properties. !! The basics of a residual Helmholtz model is a routine that calculates !! all the needed derivatives of Ar `residual_helmholtz` and !! a volume initializer function, that is used to initialize a Newton !! solver of volume when specifying pressure. character ( len = :), allocatable :: name !! Name of the model contains procedure ( abs_residual_helmholtz ), deferred :: residual_helmholtz !! Method to calculate residual helmholtz energy and derivatives. procedure ( abs_volume_initializer ), deferred :: get_v0 !! Volume initializer end type abstract interface subroutine abs_residual_helmholtz (& self , n , v , t , Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) !! Residual Helmholtz model generic interface. !! !! This interface represents how an Ar model should be implemented. !! By our standard, a Resiudal Helmholtz model takes as input: !! !! - The mixture's number of moles vector. !! - Volume, by default in liters. !! - Temperature, by default in Kelvin. !! !! All the output arguments are optional. While this keeps a long !! signature for the implementation, this is done this way to take !! advantage of any inner optimizations to calculate derivatives !! inside the procedure. !! !! Once the model is implemented, the signature can be short like !! `model%residual_helmholtz(n, v, t, ArT2=dArdT2)` import ArModel , pr class ( ArModel ), intent ( in ) :: self !! ArModel real ( pr ), intent ( in ) :: n (:) !! Moles vector real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), optional , intent ( out ) :: Ar !! Residual Helmoltz energy real ( pr ), optional , intent ( out ) :: ArV !! \\frac{dAr}{dV} real ( pr ), optional , intent ( out ) :: ArT !! \\frac{dAr}{dT} real ( pr ), optional , intent ( out ) :: ArT2 !! \\frac{d&#94;2Ar}{dT&#94;2} real ( pr ), optional , intent ( out ) :: ArTV !! \\frac{d&#94;2Ar}{dTV} real ( pr ), optional , intent ( out ) :: ArV2 !! \\frac{d&#94;2Ar}{dV&#94;2} real ( pr ), optional , intent ( out ) :: Arn ( size ( n )) !! \\frac{dAr}{dn_i} real ( pr ), optional , intent ( out ) :: ArVn ( size ( n )) !! \\frac{d&#94;2Ar}{dVn_i} real ( pr ), optional , intent ( out ) :: ArTn ( size ( n )) !! \\frac{d&#94;2Ar}{dTn_i} real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) !! \\frac{d&#94;2Ar}{dn_{ij}} end subroutine function abs_volume_initializer ( self , n , p , t ) !! Initialization of volume. import ArModel , pr class ( ArModel ), intent ( in ) :: self !! Ar Model real ( pr ), intent ( in ) :: n (:) !! Moles vector real ( pr ), intent ( in ) :: p !! Pressure [bar] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ) :: abs_volume_initializer !! Initial volume [L] end function end interface end module","tags":"","loc":"sourcefile/ar_models.f90.html"},{"title":"mixing_rules.f90 – yaeos","text":"This file depends on sourcefile~~mixing_rules.f90~~EfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~constants.f90 constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~substance.f90 substance.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mixing_rules.f90~~AfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~implementations.f90 implementations.f90 sourcefile~implementations.f90->sourcefile~mixing_rules.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~flash.f90 flash.f90 sourcefile~flash.f90->sourcefile~models.f90 sourcefile~saturations_points.f90 saturations_points.f90 sourcefile~saturations_points.f90->sourcefile~models.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_models_ar_genericcubic_quadratic_mixing !! Quadratic Mixing Rules for Cubic EoS. use yaeos_constants , only : pr use yaeos_substance , only : substances use yaeos_models_ar_genericcubic , only : CubicMixRule implicit none type , extends ( CubicMixRule ) :: QMR !! Quadratic Mixing Rule (QMR) derived type. Classic Van der Waals mixing !! rules. !! !! QMR depends on binary interaction parameters, on a Cubic EoS !! the mixture is obtained by the combination of an attractive and !! repulsive parameter matrices. !! !! By default the attractive parameter matrix is calculated with: !! a_{ij} = \\sqrt{a_i a_j}(1 - k_{ij}) !! generating the a_{ij} matrix, but this procedure can be overriden !! replacing the `aij` pointer procedure. real ( pr ), allocatable :: k (:, :) !! Attractive Binary Interatction parameter matrix real ( pr ), allocatable :: l (:, :) !! Repulsive Binary Interatction parameter matrix procedure ( get_aij ), pointer :: aij => kij_constant !! Procedure to calculate a_{ij} matrix. Can be overloaded !! by any method that respets the interface [[get_aij(interface)]]. contains procedure :: Dmix !! Attractive parameter mixing rule procedure :: Bmix !! Repulsive parameter mixing rule end type abstract interface subroutine get_aij ( self , ai , daidt , daidt2 , aij , daijdt , daijdt2 ) !! Combining rule for the attractive parameter. !! !! From previously calculated attractive parameters calculate the !! a_{ij} matrix and it's corresponding derivatives. import pr , QMR class ( QMR ) :: self real ( pr ), intent ( in ) :: ai (:), daidt (:), daidt2 (:) real ( pr ), intent ( out ) :: aij (:, :), daijdt (:, :), daijdt2 (:, :) end subroutine end interface contains subroutine Dmix ( self , n , T , & ai , daidt , daidt2 , & D , dDdT , dDdT2 , dDi , dDidT , dDij ) !! Attractive parameter mixing rule with quadratic mix. !! !! Takes the all the pure components attractive parameters and their !! derivatives with respect to temperature and mix them with the !! Van der Waals quadratic mixing rule: !! !!  !!   D = \\sum_i \\sum_j n_i n_j a_{ij} = n&#94;2 a_{mix} !!  !! !! Inside the routine the a_{ij} matrix is calculated using the !! procedure contained in the `QMR` object, this procedures defaults !! to the common combining rule: a_{ij} = \\sqrt{a_i a_j} (1 - k_{ij})  !! !! The procedure can be overloaded by a common one that respects the !! interface [[get_aij(interface)]] !! !! ```fortran !! type(QMR) :: my_mixing_rule !! my_mixing_rule%aij => new_aij_procedure !! ``` class ( QMR ), intent ( in ) :: self !! Mixing rule object. real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: n (:) !! Moles vector [mol] real ( pr ), intent ( in ) :: ai (:) !! Pure components attractive parameters a_i real ( pr ), intent ( in ) :: daidt (:) !! \\frac{da_i}{dT} real ( pr ), intent ( in ) :: daidt2 (:) !! \\frac{d&#94;2a_i}{dT&#94;2} real ( pr ), intent ( out ) :: D !! Mixture attractive parameter n&#94;2a_{mix} real ( pr ), intent ( out ) :: dDdT !! \\frac{dD}{dT} real ( pr ), intent ( out ) :: dDdT2 !! \\frac{d&#94;2D}{dT&#94;2} real ( pr ), intent ( out ) :: dDi (:) !! \\frac{dD}{dn_i} real ( pr ), intent ( out ) :: dDidT (:) !! \\frac{d&#94;2D}{dTn_i} real ( pr ), intent ( out ) :: dDij (:, :) !! \\frac{d&#94;2D}{dn_{ij}} integer :: i , j , nc real ( pr ) :: aux , aux2 real ( pr ) :: aij ( size ( ai ), size ( ai )) real ( pr ) :: daijdt ( size ( ai ), size ( ai )) real ( pr ) :: daijdt2 ( size ( ai ), size ( ai )) nc = size ( ai ) if ( associated ( self % aij )) then call self % aij ( ai , daidt , daidt2 , aij , daijdt , daijdt2 ) else write ( * , * ) \"ERROR: aij matrix calculation not defined\" call exit ( 1 ) end if D = 0 dDdT = 0 dDdT2 = 0 do i = 1 , nc aux = 0 aux2 = 0 dDi ( i ) = 0 dDidT ( i ) = 0 do j = 1 , nc dDi ( i ) = dDi ( i ) + 2 * n ( j ) * aij ( i , j ) dDidT ( i ) = dDidT ( i ) + 2 * n ( j ) * daijdT ( i , j ) aux2 = aux2 + n ( j ) * daijdT2 ( i , j ) dDij ( i , j ) = 2 * aij ( i , j ) aux = aux + n ( j ) * aij ( i , j ) end do D = D + n ( i ) * aux dDdT = dDdT + n ( i ) * dDidT ( i ) * 0.5_pr dDdT2 = dDdT2 + n ( i ) * aux2 end do end subroutine subroutine Bmix ( self , n , bi , B , dBi , dBij ) !! Mixture repulsive parameter. !! !! Calculate the mixture's repulsive parameter and it's derivatives !! with respect to composition: !! !!  !!    B = \\sum_i \\sum_j n_i n_j \\frac{b_i + b_j}{2} (1 - l_{ij}) !!  !! class ( QMR ), intent ( in ) :: self !! Mixing rule object. real ( pr ), intent ( in ) :: n (:) !! Moles vector. real ( pr ), intent ( in ) :: bi (:) !! Pure components repulsive parameters. real ( pr ), intent ( out ) :: B !! Mixture repulsive parameter. real ( pr ), intent ( out ) :: dBi (:) !! \\frac{dB}{dn_i} real ( pr ), intent ( out ) :: dBij (:, :) !!\\frac{d&#94;2B}{dn_{ij}} real ( pr ) :: bij ( size ( n ), size ( n )) real ( pr ) :: totn , aux ( size ( n )) integer :: i , j , nc nc = size ( n ) TOTN = sum ( n ) B = 0.0_pr aux = 0.0_pr do i = 1 , nc do j = 1 , nc bij ( i , j ) = 0.5_pr * ( bi ( i ) + bi ( j )) * ( 1.0_pr - self % l ( i , j )) aux ( i ) = aux ( i ) + n ( j ) * bij ( i , j ) end do B = B + n ( i ) * aux ( i ) end do B = B / totn do i = 1 , nc dBi ( i ) = ( 2 * aux ( i ) - B ) / totn do j = 1 , i dBij ( i , j ) = ( 2 * bij ( i , j ) - dBi ( i ) - dBi ( j )) / totn dBij ( j , i ) = dBij ( i , j ) end do end do end subroutine subroutine kij_constant (& self , a , dadt , dadt2 , & aij , daijdt , daijdt2 & ) !! Combining rule that uses constant k_{ij} values. class ( QMR ) :: self real ( pr ), intent ( in ) :: a (:) !! Pure components attractive parameters (\\a real ( pr ), intent ( in ) :: dadt (:) !! \\frac{da}{dT} real ( pr ), intent ( in ) :: dadt2 (:) !! \\frac{d&#94;2a}{dT&#94;2} real ( pr ), intent ( out ) :: aij (:, :) !! a_{ij} Matrix real ( pr ), intent ( out ) :: daijdt (:, :) !! \\frac{da_{ij}}{dT} real ( pr ), intent ( out ) :: daijdt2 (:, :) !! \\frac{d&#94;2a_{ij}}{dT&#94;2} integer :: i , j real ( pr ) :: sqrt_aii_ajj real ( pr ) :: ai2 ( size ( a )), inner_sum , inner_sum_2 real ( pr ) :: aij_daidt ai2 = a * a do i = 1 , size ( a ) aij ( i , i ) = a ( i ) daijdt ( i , i ) = dadt ( i ) daijdt2 ( i , i ) = dadt2 ( i ) do j = i + 1 , size ( a ) sqrt_aii_ajj = sqrt ( a ( i ) * a ( j )) aij ( i , j ) = sqrt_aii_ajj * ( 1 - self % k ( i , j )) inner_sum = a ( i ) * dadt ( j ) + a ( j ) * dadt ( i ) aij_daidt = aij ( i , j ) * ( 0.5_pr * inner_sum ) daijdt ( i , j ) = 0.5_pr * aij ( i , j ) * ( inner_sum ) / ( a ( i ) * a ( j )) daijdt2 ( i , j ) = & aij_daidt / ( ai2 ( i ) * ai2 ( j )) & - aij_daidt * dadt ( j ) / ( a ( i ) * ai2 ( j )) & - aij_daidt * dadt ( i ) / ( a ( j ) * ai2 ( i )) & + aij ( i , j ) * (& 0.5_pr * ( a ( i ) * dadt2 ( j ) + a ( j ) * dadt2 ( i )) & + dadt ( i ) * dadt ( j )& ) / ( a ( i ) * a ( j )) aij ( j , i ) = aij ( i , j ) daijdt ( j , i ) = daijdt ( i , j ) daijdt2 ( j , i ) = daijdt2 ( i , j ) end do end do end subroutine end module","tags":"","loc":"sourcefile/mixing_rules.f90.html"},{"title":"legacy.f90 – yaeos","text":"This file depends on sourcefile~~legacy.f90~~EfferentGraph sourcefile~legacy.f90 legacy.f90 sourcefile~ar_interface.f90 ar_interface.f90 sourcefile~legacy.f90->sourcefile~ar_interface.f90 sourcefile~constants.f90 constants.f90 sourcefile~legacy.f90->sourcefile~constants.f90 sourcefile~ar_interface.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module legacy_ar_models !! Legacy Thermodynamic routines !! Module for a cubic eos system, made with the intention to keep !! compatiblity with legacy codes but with a better structure. !! this should be later adapted into a simple oop system where an eos object !! stores the relevant parameters (or some functional oriented approach) use yaeos_constants , only : pr , R use ar_interface , only : ar_fun , vinit implicit none ! Model settings integer :: thermo_model !! Which thermodynamic model to use integer :: tdep !! Temperature dependance of kij integer :: mixing_rule !! What mixing rule to use integer :: nc !! Number of components ! Mole fractions real ( pr ), allocatable :: z (:) !! Mole fractions vector ! ========================================================================== !  Cubic EoS Possible parameters ! -------------------------------------------------------------------------- ! Critical constants real ( pr ), allocatable :: tc (:) !! Critical temperature [K] real ( pr ), allocatable :: pc (:) !! Critical pressure [bar] real ( pr ), allocatable :: dc (:) !! Critical density [mol/L] real ( pr ), allocatable :: w (:) !! Acentric factor ! Model parameters real ( pr ), allocatable :: ac (:) !! Critical attractive parameter [bar (L/mol)&#94;2] real ( pr ), allocatable :: b (:) !! repulsive parameter [L] real ( pr ), allocatable :: del1 (:) !! \\delta_1 parameter real ( pr ), allocatable :: k (:) !! Attractive parameter constant ! Classic VdW mixing rules parameters real ( pr ), allocatable :: kij (:, :) !! Attractive BIP real ( pr ), allocatable :: lij (:, :) !! Repulsive BIP real ( pr ), allocatable :: bij (:, :) ! T dependant mixing rule parameters real ( pr ), allocatable :: kij0 (:, :), kinf (:, :), tstar (:, :) ! ========================================================================== contains ! ========================================================================== !  Initializer routines ! -------------------------------------------------------------------------- subroutine setup ( n , nmodel , ntdep , ncomb ) !! Setup the basics variables that describe the model. ! TODO: With a more integrated legacy code maybe this can be !       avoided or at least better set up integer , intent ( in ) :: n !! Number of components integer , intent ( in ) :: nmodel !! Number of model integer , intent ( in ) :: ntdep !! Kij dependant of temperature integer , intent ( in ) :: ncomb !! Combining rule thermo_model = nmodel tdep = ntdep mixing_rule = ncomb nc = n if ( allocated ( tc )) deallocate ( tc ) if ( allocated ( pc )) deallocate ( pc ) if ( allocated ( dc )) deallocate ( dc ) if ( allocated ( w )) deallocate ( w ) if ( allocated ( ac )) deallocate ( ac ) if ( allocated ( b )) deallocate ( b ) if ( allocated ( del1 )) deallocate ( del1 ) if ( allocated ( k )) deallocate ( k ) if ( allocated ( kij )) deallocate ( kij ) if ( allocated ( lij )) deallocate ( lij ) if ( allocated ( kinf )) deallocate ( kinf ) if ( allocated ( tstar )) deallocate ( tstar ) if ( allocated ( bij )) deallocate ( bij ) allocate ( tc ( n )) allocate ( pc ( n )) allocate ( dc ( n )) allocate ( w ( n )) allocate ( ac ( n )) allocate ( b ( n )) allocate ( del1 ( n )) allocate ( k ( n )) allocate ( kij ( n , n )) allocate ( lij ( n , n )) allocate ( kinf ( n , n )) allocate ( tstar ( n , n )) allocate ( bij ( n , n )) end subroutine setup subroutine PR78_factory ( moles_in , ac_in , b_in , tc_in , pc_in , w_in , k_in ) !! PengRobinson 78 factory !! !! Takes either the critical parameters or the fitted model parameters !! and gets ones in base of the others real ( pr ), intent ( in ) :: moles_in ( nc ) real ( pr ), optional , intent ( in ) :: ac_in ( nc ) real ( pr ), optional , intent ( in ) :: b_in ( nc ) real ( pr ), optional , intent ( in ) :: tc_in ( nc ) real ( pr ), optional , intent ( in ) :: pc_in ( nc ) real ( pr ), optional , intent ( in ) :: w_in ( nc ) real ( pr ), optional , intent ( in ) :: k_in ( nc ) integer :: i logical :: params_spec , critical_spec real ( pr ) :: zc ( nc ), oma ( nc ), omb ( nc ) real ( pr ) :: vceos ( nc ), al , be , ga ( nc ) real ( pr ) :: RTc ( nc ) ar_fun => ar_srkpr vinit => cubic_v0 del1 = 1 + sqrt ( 2.0_pr ) z = moles_in params_spec = ( present ( ac_in ) . and . present ( b_in ) . and . present ( k_in )) critical_spec = ( present ( tc_in ) . and . present ( pc_in ) . and . present ( w_in )) if ( params_spec ) then ac = ac_in b = b_in k = k_in call get_Zc_OMa_OMb ( del1 , zc , oma , omb ) Tc = OMb * ac / ( OMa * R * b ) RTc = R * Tc Pc = OMb * RTc / b Vceos = Zc * RTc / Pc al = - 0.26992 be = 1.54226 ga = 0.37464 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al else if ( critical_spec ) then tc = tc_in pc = pc_in w = w_in RTc = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RTc ** 2 / Pc b = OMb * RTc / Pc Vceos = Zc * RTc / Pc ! k (or m) constant to calculate attractive parameter depending on temperature do i = 1 , nc if ( w ( i ) <= 0.491 ) then ! m from PR k ( i ) = 0.37464 + 1.54226 * w ( i ) - 0.26992 * w ( i ) ** 2 else ! PR78 k ( i ) = 0.379642 + 1.48503 * w ( i ) - 0.164423 * w ( i ) ** 2 + 0.016666 * w ( i ) ** 3 end if end do end if end subroutine subroutine PR76_factory ( moles_in , ac_in , b_in , tc_in , pc_in , w_in , k_in ) !! PengRobinson 76 factory !! !! Takes either the critical parameters or the fitted model parameters !! and gets ones in base of the others real ( pr ), intent ( in ) :: moles_in ( nc ) real ( pr ), optional , intent ( in ) :: ac_in ( nc ) real ( pr ), optional , intent ( in ) :: b_in ( nc ) real ( pr ), optional , intent ( in ) :: tc_in ( nc ) real ( pr ), optional , intent ( in ) :: pc_in ( nc ) real ( pr ), optional , intent ( in ) :: w_in ( nc ) real ( pr ), optional , intent ( in ) :: k_in ( nc ) integer :: i logical :: params_spec , critical_spec real ( pr ) :: zc ( nc ), oma ( nc ), omb ( nc ) real ( pr ) :: vceos ( nc ), al , be , ga ( nc ) real ( pr ) :: RTc ( nc ) ar_fun => ar_srkpr vinit => cubic_v0 del1 = 1 + sqrt ( 2.0_pr ) z = moles_in params_spec = ( present ( ac_in ) . and . present ( b_in ) . and . present ( k_in )) critical_spec = ( present ( tc_in ) . and . present ( pc_in ) . and . present ( w_in )) if ( params_spec ) then ac = ac_in b = b_in k = k_in call get_Zc_OMa_OMb ( del1 , zc , oma , omb ) Tc = OMb * ac / ( OMa * R * b ) RTc = R * Tc Pc = OMb * RTc / b Vceos = Zc * RTc / Pc al = - 0.26992 be = 1.54226 ga = 0.37464 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al else if ( critical_spec ) then tc = tc_in pc = pc_in w = w_in RTc = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RTc ** 2 / Pc b = OMb * RTc / Pc Vceos = Zc * RTc / Pc ! k (or m) constant to calculate attractive parameter depending on temperature do i = 1 , nc k ( i ) = 0.37464 + 1.54226 * w ( i ) - 0.26992 * w ( i ) ** 2 end do end if ! ac = 0.45723553_pr * R**2 * tc**2 / pc ! b = 0.07779607_pr * R * tc/pc ! k = 0.37464_pr + 1.54226_pr * w - 0.26993_pr * w**2 end subroutine subroutine SRK_factory ( moles_in , ac_in , b_in , tc_in , pc_in , w_in , k_in ) !! SoaveRedlichKwong factory !! !! Takes either the critical parameters or the fitted model parameters !! and gets ones in base of the others real ( pr ), intent ( in ) :: moles_in ( nc ) real ( pr ), optional , intent ( in ) :: ac_in ( nc ) real ( pr ), optional , intent ( in ) :: b_in ( nc ) real ( pr ), optional , intent ( in ) :: tc_in ( nc ) real ( pr ), optional , intent ( in ) :: pc_in ( nc ) real ( pr ), optional , intent ( in ) :: w_in ( nc ) real ( pr ), optional , intent ( in ) :: k_in ( nc ) logical :: params_spec , critical_spec real ( pr ) :: zc ( nc ), oma ( nc ), omb ( nc ) real ( pr ) :: vceos ( nc ), al , be , ga ( nc ) real ( pr ) :: RTc ( nc ) integer :: i , j ar_fun => ar_srkpr vinit => cubic_v0 del1 = 1 z = moles_in params_spec = ( present ( ac_in ) . and . present ( b_in ) . and . present ( k_in )) critical_spec = ( present ( tc_in ) . and . present ( pc_in ) . and . present ( w_in )) if ( params_spec ) then ac = ac_in b = b_in k = k_in call get_Zc_OMa_OMb ( del1 , zc , oma , omb ) Tc = OMb * ac / ( OMa * R * b ) RTc = R * Tc Pc = OMb * RTc / b Vceos = Zc * RTc / Pc dc = 1 / vceos al = - 0.26992 be = 1.54226 ga = 0.37464 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al else if ( critical_spec ) then tc = tc_in pc = pc_in w = w_in RTc = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RTc ** 2 / Pc b = OMb * RTc / Pc Vceos = Zc * RTc / Pc k = 0.48 + 1.574 * w - 0.175 * w ** 2 end if end subroutine subroutine get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) !! Calculate Zc, OMa and OMb from the delta_1 parameter. real ( pr ), intent ( in ) :: del1 (:) !! delta_1 parameter real ( pr ), intent ( out ) :: Zc (:) !! Critical compressibility factor real ( pr ), intent ( out ) :: OMa (:) !! OMa real ( pr ), intent ( out ) :: OMb (:) !! OMb real ( pr ) :: d1 ( size ( del1 )), y ( size ( del1 )) d1 = ( 1._pr + del1 ** 2._pr ) / ( 1._pr + del1 ) y = 1._pr + ( 2._pr * ( 1._pr + del1 )) ** ( 1.0_pr / 3._pr ) + ( 4._pr / ( 1._pr + del1 )) ** ( 1.0_pr / 3 ) OMa = ( 3._pr * y * y + 3._pr * y * d1 + d1 ** 2._pr + d1 - 1.0_pr ) / ( 3._pr * y + d1 - 1.0_pr ) ** 2._pr OMb = 1._pr / ( 3._pr * y + d1 - 1.0_pr ) Zc = y / ( 3._pr * y + d1 - 1.0_pr ) end subroutine get_Zc_OMa_OMb ! ========================================================================== ! ========================================================================== !  Ar Functions ! -------------------------------------------------------------------------- subroutine ar_srkpr ( z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) !! Wrapper subroutine to the SRK/PR Residula Helmholtz function to !! use the general interface real ( pr ), intent ( in ) :: z (:) !! Number of moles real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( out ) :: ar !! Residual Helmholtz real ( pr ), intent ( out ) :: arv !! dAr/dV real ( pr ), intent ( out ) :: artv !! dAr2/dTV real ( pr ), intent ( out ) :: arv2 !! dAr2/dV2 real ( pr ), intent ( out ) :: Arn ( size ( z )) !! dAr/dn real ( pr ), intent ( out ) :: ArVn ( size ( z )) !! dAr2/dVn real ( pr ), intent ( out ) :: ArTn ( size ( z )) !! dAr2/dTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) !! dAr2/dn2 integer :: nd !! Compositional derivatives integer :: nt !! Temperature derivatives nd = 2 nt = 1 call HelmSRKPR ( size ( z ), nd , nt , z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) end subroutine subroutine ar_rkpr ( z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) real ( pr ), intent ( in ) :: z (:) !! Number of moles real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( out ) :: ar !! Residual Helmholtz real ( pr ), intent ( out ) :: arv !! dAr/dV real ( pr ), intent ( out ) :: artv !! dAr2/dTV real ( pr ), intent ( out ) :: arv2 !! dAr2/dV2 real ( pr ), intent ( out ) :: Arn ( size ( z )) !! dAr/dn real ( pr ), intent ( out ) :: ArVn ( size ( z )) !! dAr2/dVn real ( pr ), intent ( out ) :: ArTn ( size ( z )) !! dAr2/dTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) !! dAr2/dn2 integer :: nd !! Compositional derivatives integer :: nt !! Temperature derivatives nd = 2 nt = 1 call HelmRKPR ( size ( z ), nd , nt , z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) end subroutine subroutine HelmSRKPR ( nc , ND , NT , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) integer , intent ( in ) :: nc !! Number of components integer , intent ( in ) :: nd !! Compositional derivatives integer , intent ( in ) :: nt !! Temperature derivatives real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( in ) :: rn ( nc ) !! Number of moles real ( pr ), intent ( out ) :: ar !! Residual Helmholtz real ( pr ), intent ( out ) :: arv !! dAr/dV real ( pr ), intent ( out ) :: artv !! dAr2/dTV real ( pr ), intent ( out ) :: arv2 !! dAr2/dV2 real ( pr ), intent ( out ) :: Arn ( nc ) !! dAr/dn real ( pr ), intent ( out ) :: ArVn ( nc ) !! dAr2/dVn real ( pr ), intent ( out ) :: ArTn ( nc ) !! dAr2/dTn real ( pr ), intent ( out ) :: Arn2 ( nc , nc ) !! dAr2/dn2 real ( pr ) :: ArT , ArTT real ( pr ) :: Bmix , dBi ( nc ), dBij ( nc , nc ) real ( pr ) :: D , dDi ( nc ), dDij ( nc , nc ), dDiT ( nc ), dDdT , dDdT2 real ( pr ) :: totn , d1 , d2 real ( pr ) :: f , g , fv , fB , gv , fv2 , gv2 , AUX , FFB , FFBV , FFBB integer :: i , j real ( pr ) :: b_v , a TOTN = sum ( rn ) D1 = del1 ( 1 ) D2 = ( 1._pr - D1 ) / ( 1._pr + D1 ) if ( mixing_rule . lt . 2 ) then call Bnder ( nc , rn , Bmix , dBi , dBij ) call DandTnder ( NT , nc , T , rn , D , dDi , dDiT , dDij , dDdT , dDdT2 ) end if ! The f's and g's used here are for Ar, not F (reduced Ar) ! This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = R * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) fB = - ( f + V * fv ) / Bmix gv = R * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = R * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) ! Reduced Helmholtz Energy and derivatives Ar = - TOTN * g * T - D * f ArV = - TOTN * gv * T - D * fv ArV2 = - TOTN * gv2 * T - D * fv2 AUX = R * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 do i = 1 , nc Arn ( i ) = - g * T + FFB * dBi ( i ) - f * dDi ( i ) ArVn ( i ) = - gv * T + FFBV * dBi ( i ) - fv * dDi ( i ) if ( ND . eq . 2 ) then do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end if end do ! TEMPERATURE DERIVATIVES if ( NT . eq . 1 ) then ArT = - TOTN * g - dDdT * f ArTV = - TOTN * gv - dDdT * fV ArTT = - dDdT2 * f do i = 1 , nc ArTn ( i ) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi ( i ) - f * dDiT ( i ) end do end if end subroutine HelmSRKPR subroutine HelmRKPR ( nco , NDE , NTD , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) !! Calculate the reduced residual Helmholtz Energy and it's derivatives with the RKPR EOS integer , intent ( in ) :: nco integer , intent ( in ) :: NDE integer , intent ( in ) :: NTD real ( pr ), intent ( in ) :: rn ( nco ) real ( pr ), intent ( in ) :: V real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: Ar , ArV , ArTV , ArV2 real ( pr ), intent ( out ) :: Arn ( nco ), ArVn ( nco ), ArTn ( nco ), Arn2 ( nco , nco ) real ( pr ) :: totn real ( pr ) :: Bmix , dBi ( nco ), dBij ( nco , nco ), dD1i ( nco ), dD1ij ( nco , nco ) real ( pr ) :: D , dDi ( nco ), dDij ( nco , nco ), dDiT ( nco ), dDdT , dDdT2 real ( pr ) :: D1 , D2 ! Auxiliar functions for Ar real ( pr ) :: f , g , fv , fB , gv , fv2 , gv2 , AUX , FFB , FFBV , FFBB ! Extra auxiliar functions for RKPR real ( pr ) :: auxD2 , fD1 , fBD1 , fVD1 , fD1D1 real ( pr ) :: ArT , ArTT integer :: i , j nc = nco TOTN = sum ( rn ) call DELTAnder ( nc , rn , D1 , dD1i , dD1ij ) D2 = ( 1 - D1 ) / ( 1 + D1 ) if ( mixing_rule . lt . 2 ) then call Bnder ( nc , rn , Bmix , dBi , dBij ) call DandTnder ( NTD , nc , T , rn , D , dDi , dDiT , dDij , dDdT , dDdT2 ) else ! call Bcubicnder(nc,rn,Bmix,dBi,dBij) ! call DCubicandTnder(NTD,nc,T,rn,D,dDi,dDiT,dDij,dDdT,dDdT2) end if !  The f's and g's used here are for Ar, not F (reduced Ar) !  This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = R * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) fB = - ( f + V * fv ) / Bmix gv = R * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = R * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) ! DERIVATIVES OF f WITH RESPECT TO DELTA1 auxD2 = ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1 = ( 1 / ( V + D1 * Bmix ) + 2 / ( V + D2 * Bmix ) / ( 1 + D1 ) ** 2 ) - f * auxD2 fD1 = fD1 / ( D1 - D2 ) fBD1 = - ( fB * auxD2 + D1 / ( V + D1 * Bmix ) ** 2 + 2 * D2 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 2 ) fBD1 = fBD1 / ( D1 - D2 ) fVD1 = - ( fV * auxD2 + 1 / ( V + D1 * Bmix ) ** 2 + 2 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 2 ) / ( D1 - D2 ) fD1D1 = 4 * ( f - 1 / ( V + D2 * Bmix )) / ( 1 + D1 ) ** 3 + Bmix * ( - 1 / ( V + D1 * Bmix ) ** 2 & + 4 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 4 ) - 2 * fD1 * ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1D1 = fD1D1 / ( D1 - D2 ) ! Reduced Helmholtz Energy and derivatives Ar = - TOTN * g * T - D * f ArV = - TOTN * gv * T - D * fv ArV2 = - TOTN * gv2 * T - D * fv2 AUX = R * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 do i = 1 , nc Arn ( i ) = - g * T + FFB * dBi ( i ) - f * dDi ( i ) - D * fD1 * dD1i ( i ) ArVn ( i ) = - gv * T + FFBV * dBi ( i ) - fv * dDi ( i ) - D * fVD1 * dD1i ( i ) if ( NDE . eq . 2 ) then do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( i , j ) = Arn2 ( i , j ) - D * fBD1 * ( dBi ( i ) * dD1i ( j ) + dBi ( j ) * dD1i ( i )) & - fD1 * ( dDi ( i ) * dD1i ( j ) + dDi ( j ) * dD1i ( i )) & - D * fD1 * dD1ij ( i , j ) - D * fD1D1 * dD1i ( i ) * dD1i ( j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end if end do ! TEMPERATURE DERIVATIVES if ( NTD . eq . 1 ) then ArT = - TOTN * g - dDdT * f ArTV = - TOTN * gv - dDdT * fV ArTT = - dDdT2 * f do i = 1 , nc ArTn ( i ) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi ( i ) - f * dDiT ( i ) - dDdT * fD1 * dD1i ( i ) end do end if end subroutine HelmRKPR subroutine ArVnder ( nc , NDER , NTEMP , z , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) integer , intent ( in ) :: nc integer , intent ( in ) :: nder ! Get compositional derivatives integer , intent ( in ) :: ntemp ! Get temperature derivatives real ( pr ), intent ( in ) :: z ( nc ) real ( pr ), intent ( in ) :: V real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: ar , arv , artv , arv2 real ( pr ), dimension ( size ( z )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), intent ( out ) :: Arn2 ( size ( z ), size ( z )) vinit => cubic_v0 call ar_fun ( z , v , t , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) end subroutine ArVnder ! ========================================================================== ! ========================================================================== !  Attractive parameter routines ! -------------------------------------------------------------------------- subroutine aTder ( ac , Tc , k , T , a , dadT , dadT2 ) ! Given ac,Tc and the k parameter of the RKPR correlation, as well as the actual T, ! this subroutine calculates a(T) and its first and second derivatives with T. real ( pr ), intent ( in ) :: ac real ( pr ), intent ( in ) :: Tc real ( pr ), intent ( in ) :: k real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: a real ( pr ), intent ( out ) :: dadT real ( pr ), intent ( out ) :: dadT2 real ( pr ) :: Tr Tr = T / Tc if ( thermo_model . le . 3 ) then a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc dadT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5D0 ) else if ( thermo_model == 4 ) then a = ac * ( 3 / ( 2 + Tr )) ** k dadT = - k * a / Tc / ( 2 + Tr ) dadT2 = - ( k + 1 ) * dadT / Tc / ( 2 + Tr ) end if end subroutine aTder subroutine aijTder ( NTD , nc , T , aij , daijdT , daijdT2 ) integer , intent ( in ) :: ntd integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: T real ( pr ), intent ( out ) :: aij ( nc , nc ), daijdT ( nc , nc ), daijdT2 ( nc , nc ) real ( pr ) :: ai ( nc ), daidT ( nc ), daidT2 ( nc ) real ( pr ) :: aux ( nc , nc ), ratK ( nc , nc ) integer :: i , j if ( tdep . ge . 1 ) then Kij = 0.0D0 do i = 1 , nc Kij (: i - 1 , i ) = Kinf (: i - 1 , i ) + Kij0 (: i - 1 , i ) * exp ( - T / Tstar (: i - 1 , i )) end do end if do i = 1 , nc call aTder ( ac ( i ), Tc ( i ), k ( i ), T , ai ( i ), daidT ( i ), daidT2 ( i )) aij ( i , i ) = ai ( i ) daijdT ( i , i ) = daidT ( i ) daijdT2 ( i , i ) = daidT2 ( i ) if ( i . gt . 1 ) then do j = 1 , i - 1 aij ( j , i ) = sqrt ( ai ( i ) * ai ( j )) * ( 1 - Kij ( j , i )) aij ( i , j ) = aij ( j , i ) if ( NTD . eq . 1 ) then daijdT ( j , i ) = ( 1 - Kij ( j , i )) * ( sqrt ( ai ( i ) / ai ( j )) * daidT ( j ) & + sqrt ( ai ( j ) / ai ( i )) * daidT ( i )) / 2 daijdT2 ( j , i ) = ( 1 - Kij ( j , i )) * ( daidT ( j ) * daidT ( i ) / sqrt ( ai ( i ) * ai ( j )) & + sqrt ( ai ( i ) / ai ( j )) * ( daidT2 ( j ) - daidT ( j ) ** 2 / ( 2 * ai ( j ))) & + sqrt ( ai ( j ) / ai ( i )) * ( daidT2 ( i ) - daidT ( i ) ** 2 / ( 2 * ai ( i )))) / 2 daijdT ( i , j ) = daijdT ( j , i ) daijdT2 ( i , j ) = daijdT2 ( j , i ) end if end do end if end do end subroutine aijTder subroutine DandTnder ( NTD , nc , T , rn , D , dDi , dDiT , dDij , dDdT , dDdT2 ) integer , intent ( in ) :: ntd integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: T real ( pr ), intent ( in ) :: rn ( nc ) real ( pr ), intent ( out ) :: D real ( pr ), intent ( out ) :: dDiT ( nc ) real ( pr ), intent ( out ) :: dDdT real ( pr ), intent ( out ) :: dDdT2 real ( pr ), intent ( out ) :: dDi ( nc ) real ( pr ), intent ( out ) :: dDij ( nc , nc ) real ( pr ) :: aij ( nc , nc ), daijdT ( nc , nc ), daijdT2 ( nc , nc ) real ( pr ) :: aux , aux2 integer :: i , j call aijTder ( NTD , nc , T , aij , daijdT , daijdT2 ) D = 0 dDdT = 0 dDdT2 = 0 do i = 1 , nc aux = 0 aux2 = 0 dDi ( i ) = 0 dDiT ( i ) = 0 do j = 1 , nc dDi ( i ) = dDi ( i ) + 2 * rn ( j ) * aij ( i , j ) if ( NTD . eq . 1 ) then dDiT ( i ) = dDiT ( i ) + 2 * rn ( j ) * daijdT ( i , j ) aux2 = aux2 + rn ( j ) * daijdT2 ( i , j ) end if dDij ( i , j ) = 2 * aij ( i , j ) aux = aux + rn ( j ) * aij ( i , j ) end do D = D + rn ( i ) * aux if ( NTD . eq . 1 ) then dDdT = dDdT + rn ( i ) * dDiT ( i ) / 2 dDdT2 = dDdT2 + rn ( i ) * aux2 end if end do end subroutine DandTnder ! ========================================================================== subroutine DELTAnder ( nc , rn , D1m , dD1i , dD1ij ) integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: rn ( nc ) real ( pr ), intent ( out ) :: D1m , dD1i ( nc ), dD1ij ( nc , nc ) real ( pr ) :: totn integer :: i , j D1m = 0.0_pr do i = 1 , nc D1m = D1m + rn ( i ) * del1 ( i ) end do TOTN = sum ( rn ) D1m = D1m / totn do i = 1 , nc dD1i ( i ) = ( del1 ( i ) - D1m ) / totn do j = 1 , nc dD1ij ( i , j ) = ( 2.0_pr * D1m - del1 ( i ) - del1 ( j )) / totn ** 2 end do end do end subroutine DELTAnder ! ========================================================================== !  Repulsive parameter routines ! -------------------------------------------------------------------------- subroutine Bnder ( nc , rn , Bmix , dBi , dBij ) integer , intent ( in ) :: nc real ( pr ), intent ( in ) :: rn ( nc ) real ( pr ), intent ( out ) :: Bmix , dBi ( nc ), dBij ( nc , nc ) real ( pr ) :: totn , aux ( nc ) integer :: i , j TOTN = sum ( rn ) Bmix = 0.0_pr aux = 0.0_pr do i = 1 , nc do j = 1 , nc bij ( i , j ) = ( b ( i ) + b ( j )) * 0.5_pr * ( 1.0_pr - lij ( i , j )) aux ( i ) = aux ( i ) + rn ( j ) * bij ( i , j ) end do Bmix = Bmix + rn ( i ) * aux ( i ) end do Bmix = Bmix / totn do i = 1 , nc dBi ( i ) = ( 2 * aux ( i ) - Bmix ) / totn do j = 1 , i dBij ( i , j ) = ( 2 * bij ( i , j ) - dBi ( i ) - dBi ( j )) / totn dBij ( j , i ) = dBij ( i , j ) end do end do end subroutine Bnder ! ========================================================================== ! ========================================================================== !  Properties ! -------------------------------------------------------------------------- function cubic_v0 ( z , p , t ) real ( pr ) :: z (:) real ( pr ) :: p real ( pr ) :: t real ( pr ) :: cubic_v0 real ( pr ) :: dbi ( nc ), dbij ( nc , nc ) call bnder ( nc , z , cubic_v0 , dBi , dBij ) end function end module module legacy_thermo_properties use yaeos_constants , only : R , pr use legacy_ar_models , only : ArVnder , vinit implicit none contains subroutine TERMO ( nc , MTYP , INDIC , T , P , rn , V , PHILOG , DLPHIP , DLPHIT , FUGN ) !  MTYP      TYPE OF ROOT DESIRED (-1 vapor, 1 liquid, 0 lower Gibbs energy phase) !  rn        mixture mole numbers                        (input) !  t         temperature (k)                             (input)x, y !  p         pressure    (bar)                          (input) !  v         volume      (L)                            (output) !  PHILOG    vector of ln(phi(i)*P)                     (output)   INDIC < 5 !  DLPHIT    t-derivative of ln(phi(i)) (const P, n)    (output)   INDIC = 2 or 4 !  DLPHIP    P-derivative of ln(phi(i)) (const T, n)    (output)   INDIC < 5 !  FUGN      comp-derivative of ln(phi(i)) (const t & P)(output)   INDIC > 2 !  ------------------------------------------------------------------------- integer , intent ( in ) :: nc !! Number of components integer , intent ( in ) :: indic !! Desired element, this should be setted with optionals integer , intent ( in ) :: mtyp !! Type of root desired (-1 vapor, 1 liquid, 0 lower Gr) real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( in ) :: p !! Pressure [bar] real ( pr ), intent ( in ) :: rn ( nc ) !! Mixture mole numbers real ( pr ), intent ( out ) :: v !! Volume [L] real ( pr ), intent ( out ) :: PHILOG ( nc ) !! ln(phi*p) vector real ( pr ), optional , intent ( out ) :: DLPHIT ( nc ) !! ln(phi) Temp derivative real ( pr ), optional , intent ( out ) :: DLPHIP ( nc ) !! ln(phi) Presssure derivative real ( pr ), optional , intent ( out ) :: FUGN ( nc , nc ) !! ln(phi) compositional derivative real ( pr ) :: ar , arv , artv , arv2 real ( pr ) :: RT , Z , dpv , dpdt real ( pr ) :: Arn ( nc ) real ( pr ) :: ArVn ( nc ) real ( pr ) :: ArTn ( nc ) real ( pr ) :: Arn2 ( nc , nc ) real ( pr ) :: DPDN ( nc ) real ( pr ) :: totn integer :: ntemp , igz , nder , i , k !  The output PHILOG is actually the vector ln(phi(i)*P) NTEMP = 0 IGZ = 0 NDER = 1 if ( INDIC . gt . 2 ) NDER = 2 if ( INDIC . eq . 2 . or . INDIC . eq . 4 ) NTEMP = 1 TOTN = sum ( rn ) ! if (P .le. 0.0d0) MTYP = 1 call VCALC ( MTYP , NC , NTEMP , rn , T , P , V ) RT = R * T Z = V / ( TOTN * RT ) ! this is Z/P call ArVnder ( nc , NDER , NTEMP , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) DPV = - ArV2 - RT * TOTN / V ** 2 DPDT = - ArTV + TOTN * R / V do I = 1 , NC PHILOG ( I ) = - log ( Z ) + Arn ( I ) / RT DPDN ( I ) = RT / V - ArVn ( I ) if ( present ( dlphip )) DLPHIP ( I ) = - DPDN ( I ) / DPV / RT - 1.D0 / P if ( NTEMP . ne . 0 ) then if ( present ( dlphit )) then DLPHIT ( I ) = ( ArTn ( I ) - Arn ( I ) / T ) / RT + DPDN ( I ) * DPDT / DPV / RT + 1.D0 / T end if end if end do if ( present ( fugn )) then do I = 1 , NC do K = I , NC FUGN ( I , K ) = 1.D0 / TOTN + ( Arn2 ( I , K ) + DPDN ( I ) * DPDN ( K ) / DPV ) / RT FUGN ( K , I ) = FUGN ( I , K ) end do end do end if end subroutine TERMO subroutine zTVTERMO ( nc , INDIC , T , rn , V , P , DPV , PHILOG , DLPHIP , DLPHIT , FUGN ) !! Calculation of lnphi*P and derivatives !!  rn        mixture mole numbers                       (input) !!  t         temperature (k)                            (input) !!  v         volume      (L)                            (input) !!  p         pressure    (bar)                          (output) !!  PHILOG    vector of ln(phi(i)*P)                     (output)  0 < INDIC < 5 !!  DLPHIT    t-derivative of ln(phi(i)) (const P, n)    (output)  0 < INDIC = 2 or 4 !!  DLPHIP    P-derivative of ln(phi(i)) (const T, n)    (output)  0 < INDIC < 5 !!  FUGN      comp-derivative of ln(phi(i)) (const t & P)(output)  2 < INDIC !!  ------------------------------------------------------------------------- implicit none integer , intent ( in ) :: nc , indic real ( pr ), intent ( in ) :: t , rn ( nc ), v real ( pr ), intent ( out ) :: p , dpv real ( pr ), intent ( out ) :: PHILOG ( nc ), DLPHIT ( nc ), DLPHIP ( nc ) real ( pr ), intent ( out ) :: FUGN ( nc , nc ) real ( pr ) :: Arn ( nc ), ArVn ( nc ), ArTn ( nc ), Arn2 ( nc , nc ), DPDN ( nc ), totn real ( pr ) :: ar , arv , artv , arv2 , RT , Z , dpdt integer :: ntemp , igz , nder , i , k NTEMP = 0 IGZ = 0 NDER = 1 if ( INDIC . gt . 2 ) NDER = 2 if ( INDIC . eq . 2 . or . INDIC . eq . 4 ) NTEMP = 1 TOTN = sum ( rn ) RT = R * T Z = V / ( TOTN * RT ) ! this is Z/P call ArVnder ( nc , NDER , NTEMP , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) P = TOTN * RT / V - ArV DPV = - ArV2 - RT * TOTN / V ** 2 DPDT = - ArTV + TOTN * R / V if ( INDIC > 0 ) then do I = 1 , NC PHILOG ( I ) = - log ( Z ) + Arn ( I ) / RT DPDN ( I ) = RT / V - ArVn ( I ) DLPHIP ( I ) = - DPDN ( I ) / DPV / RT - 1.D0 / P if ( NTEMP . ne . 0 ) then DLPHIT ( I ) = ( ArTn ( I ) - Arn ( I ) / T ) / RT + DPDN ( I ) * DPDT / DPV / RT + 1.D0 / T end if end do end if if ( NDER . ge . 2 ) then do I = 1 , NC do K = I , NC FUGN ( I , K ) = 1.D0 / TOTN + ( Arn2 ( I , K ) + DPDN ( I ) * DPDN ( K ) / DPV ) / RT FUGN ( K , I ) = FUGN ( I , K ) end do end do end if end subroutine zTVTERMO subroutine PUREFUG_CALC ( nc , icomp , T , P , V , phi ) !! Fugacity of a pure component integer , intent ( in ) :: nc integer , intent ( in ) :: icomp real ( pr ), intent ( in ) :: T , P , V real ( pr ), intent ( out ) :: phi real ( pr ) :: rn ( nc ), Ar , Arv , ArTV , ArV2 , Arn ( nc ), ArVn ( nc ), ArTn ( nc ), Arn2 ( nc , nc ) real ( pr ) :: RT , Z , philog rn = 0.0 rn ( icomp ) = 1.0 RT = R * T Z = P * V / RT call ArVnder ( nc , 0 , 0 , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) PHILOG = - log ( Z ) + Arn ( icomp ) / RT phi = exp ( PHILOG ) end subroutine purefug_calc recursive subroutine VCALC ( ITYP , nc , NTEMP , rn , T , P , V ) !! ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE integer , intent ( in ) :: ITYP !! TYPE OF ROOT DESIRED (-1 vapor, 1 liquid, 0 lower Gibbs energy phase) integer , intent ( in ) :: nc !! NO. OF COMPONENTS integer , intent ( in ) :: ntemp !! 1 if T-derivatives are required real ( pr ), intent ( in ) :: rn ( nc ) !! FEED MOELS real ( pr ), intent ( in ) :: T !! TEMPERATURE real ( pr ), intent ( in ) :: P !! PRESURE real ( pr ), intent ( out ) :: V !! VOLUME real ( pr ) :: Ar , ArV , ArTV , ArV2 , Arn ( nc ), ArVn ( nc ), ArTn ( nc ), Arn2 ( nc , nc ) logical :: FIRST_RUN integer :: nder real ( pr ) :: totn real ( pr ) :: B , CPV , S3R real ( pr ) :: ZETMIN , ZETA , ZETMAX real ( pr ) :: del , pcalc , der , AT , AVAP , VVAP integer :: iter NDER = 0 FIRST_RUN = . true . TOTN = sum ( rn ) CPV = vinit ( rn , p , t ) B = CPV S3R = 1.D0 / CPV ITER = 0 ZETMIN = 0.D0 !ZETMAX = 1.D0-0.01*T/5000        !.99D0  This is flexible for low T (V very close to B) ZETMAX = 1.D0 - 0.01 * T / ( 10000 * B ) ! improvement for cases with heavy components if ( ITYP . gt . 0 ) then ZETA = . 5 D0 else ! IDEAL GAS ESTIMATE ZETA = min (. 5 D0 , CPV * P / ( TOTN * R * T )) end if 100 continue DEL = 1 pcalc = 2 * p do while ( abs ( DEL ) > 1 d - 10 . and . iter < 100 ) V = CPV / ZETA ITER = ITER + 1 call ArVnder (& nc , NDER , NTEMP , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 & ) PCALC = TOTN * R * T / V - ArV if ( PCALC . gt . P ) then ZETMAX = ZETA else ZETMIN = ZETA end if AT = ( Ar + V * P ) / ( T * R ) - TOTN * log ( V ) ! AT is something close to Gr(P,T) DER = ( ArV2 * V ** 2 + TOTN * R * T ) * S3R ! this is dPdrho/B DEL = - ( PCALC - P ) / DER ZETA = ZETA + max ( min ( DEL , 0.1D0 ), - . 1 D0 ) if ( ZETA . gt . ZETMAX . or . ZETA . lt . ZETMIN ) & ZETA = . 5 D0 * ( ZETMAX + ZETMIN ) end do if ( ITYP . eq . 0 ) then ! FIRST RUN WAS VAPOUR; RERUN FOR LIQUID if ( FIRST_RUN ) then VVAP = V AVAP = AT FIRST_RUN = . false . ZETA = 0.5D0 ZETMAX = 1.D0 - 0.01 * T / 500 goto 100 else if ( AT . gt . AVAP ) V = VVAP end if end if end subroutine vcalc ! ========================================================================== end module","tags":"","loc":"sourcefile/legacy.f90.html"},{"title":"phase_equilibria.f90 – yaeos","text":"This file depends on sourcefile~~phase_equilibria.f90~~EfferentGraph sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~equilibria_state.f90 equilibria_state.f90 sourcefile~phase_equilibria.f90->sourcefile~equilibria_state.f90 sourcefile~flash.f90 flash.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 sourcefile~constants.f90 constants.f90 sourcefile~equilibria_state.f90->sourcefile~constants.f90 sourcefile~flash.f90->sourcefile~equilibria_state.f90 sourcefile~flash.f90->sourcefile~constants.f90 sourcefile~models.f90 models.f90 sourcefile~flash.f90->sourcefile~models.f90 sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~flash.f90->sourcefile~thermoprops.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~models.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90 implementations.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~thermoprops.f90->sourcefile~constants.f90 sourcefile~thermoprops.f90->sourcefile~ar_models.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~substance.f90 substance.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~implementations.f90->sourcefile~constants.f90 sourcefile~implementations.f90->sourcefile~alphas.f90 sourcefile~implementations.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90->sourcefile~mixing_rules.f90 sourcefile~implementations.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~substance.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~phase_equilibria.f90~~AfferentGraph sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_equilibria use yaeos_equilibria_equilibria_state , only : EquilibriaState use yaeos_equilibria_flash , only : flash implicit none end module","tags":"","loc":"sourcefile/phase_equilibria.f90.html"},{"title":"tapenade_ar_api.f90 – yaeos","text":"This file depends on sourcefile~~tapenade_ar_api.f90~~EfferentGraph sourcefile~tapenade_ar_api.f90 tapenade_ar_api.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~tapenade_ar_api.f90->sourcefile~ar_models.f90 sourcefile~constants.f90 constants.f90 sourcefile~tapenade_ar_api.f90->sourcefile~constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_tapenade_ar_api !! Module that wraps tapenade generated routines to calculate ! !! Ar and derivatives. use yaeos_constants , only : pr use yaeos_models_ar , only : ArModel implicit none private public :: ArModelTapenade type , extends ( ArModel ) :: ArModelTapenade procedure ( tapenade_ar ), pointer , nopass :: ar procedure ( tapenade_ar_d ), pointer , nopass :: ar_d procedure ( tapenade_ar_b ), pointer , nopass :: ar_b procedure ( tapenade_ar_d_b ), pointer , nopass :: ar_d_b procedure ( tapenade_ar_d_d ), pointer , nopass :: ar_d_d procedure ( tapenade_v0 ), pointer , nopass :: v0 contains procedure :: residual_helmholtz => residual_helmholtz procedure :: get_v0 => get_v0 end type abstract interface subroutine tapenade_ar ( n , v , t , arval ) import pr real ( pr ), intent ( in ) :: n (:), v , t real ( pr ), intent ( out ) :: arval end subroutine subroutine tapenade_ar_d ( n , nd , v , vd , t , td , arval , arvald ) import pr real ( pr ), intent ( in ) :: n (:), v , t real ( pr ), intent ( in ) :: nd (:), vd , td real ( pr ), intent ( out ) :: arval , arvald end subroutine subroutine tapenade_ar_b ( n , nb , v , vb , t , tb , arval , arvalb ) import pr real ( pr ), intent ( in ) :: n (:), v , t real ( pr ) :: arvalb real ( pr ) :: nb (:), vb , tb real ( pr ) :: arval end subroutine subroutine tapenade_ar_d_b (& n , nb , nd , ndb , v , vb , vd , vdb , t , tb , td , tdb , & arval , arvalb , arvald , arvaldb ) import pr real ( pr ), intent ( in ) :: n (:), v , t real ( pr ) :: arval real ( pr ), intent ( in ) :: nd (:), vd , td real ( pr ) :: arvald real ( pr ) :: nb (:), vb , tb real ( pr ) :: arvalb real ( pr ) :: ndb (:), vdb , tdb real ( pr ) :: arvaldb end subroutine subroutine tapenade_ar_d_d ( n , nd , v , vd0 , vd , t , td0 , td , & arval , arvald0 , arvald , arvaldd ) import pr real ( pr ), intent ( in ) :: n (:), v , t real ( pr ), intent ( in ) :: vd0 , td0 real ( pr ), intent ( in ) :: nd (:), vd , td real ( pr ), intent ( out ) :: arval , arvald0 , arvald , arvaldd end subroutine function tapenade_v0 ( n , p , t ) import pr real ( pr ), intent ( in ) :: n (:), p , t real ( pr ) :: tapenade_v0 end function end interface contains subroutine residual_helmholtz (& self , n , v , t , Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) !! Residual Helmholtz model generic interface class ( ArModelTapenade ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: v , t real ( pr ), optional , intent ( out ) :: Ar , ArV , ArT , ArT2 , ArTV , ArV2 real ( pr ), optional , dimension ( size ( n )), intent ( out ) :: Arn , ArVn , ArTn real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) real ( pr ) :: df ( size ( n ) + 2 ), df2 ( size ( n ) + 2 , size ( n ) + 2 ) real ( pr ) :: nb ( size ( n )), nd ( size ( n )), ndb ( size ( n )) real ( pr ) :: vb , vd , vdb , vd0 real ( pr ) :: tb , td , tdb , td0 real ( pr ) :: arval , arvalb , arvald , arvaldb , arvald0 , arvaldd integer :: i , nc nc = size ( n ) if ( present ( Arn2 )) then do i = 1 , nc call reset_vars arvaldb = 1 if ( i <= nc ) then nd ( i ) = 1 end if call self % ar_d_b (& n , nb , nd , ndb , & v , vb , vd , vdb , & t , tb , td , tdb , & arval , arvalb , arvald , arvaldb & ) Arn2 ( i , :) = nb end do if ( present ( Arn )) Arn = ndb if ( present ( ArV )) ArV = vdb if ( present ( ArT )) ArT = tdb else if ( present ( Arn )) then call reset_vars arvalb = 1 call self % ar_b ( n , nb , v , vb , t , tb , arval , arvalb ) Arn = nb if ( present ( ArT )) ArT = tb if ( present ( ArV )) ArV = vb end if end if if ( present ( ArTn )) ArTn = get_ArnX ( \"T\" ) if ( present ( ArVn )) ArVn = get_ArnX ( \"V\" ) if ( present ( ArTV )) ArTV = get_dArdX2 ( \"TV\" ) if ( present ( ArT2 )) ArT2 = get_dArdX2 ( \"T2\" ) if ( present ( ArV2 )) ArV2 = get_dArdX2 ( \"V2\" ) if ( present ( Ar )) Ar = arval contains subroutine reset_vars nb = 0 nd = 0 ndb = 0 vb = 0 vd = 0 vd0 = 0 vdb = 0 tb = 0 td = 0 td0 = 0 tdb = 0 arval = 0 arvalb = 0 arvald = 0 arvald0 = 0 arvaldb = 0 end subroutine function get_dArdX2 ( var ) character ( len =* ), intent ( in ) :: var real ( pr ) :: get_dArdX2 call reset_vars select case ( var ) case ( \"TV\" ) vd = 1 td0 = 1 case ( \"V2\" ) vd = 1 vd0 = 1 case ( \"T2\" ) td = 1 td0 = 1 end select call self % ar_d_d (& n , nd , v , vd0 , vd , t , td0 , td , & arval , arvald0 , arvald , arvaldd & ) get_dArdX2 = arvaldd end function function get_ArnX ( var ) character ( len =* ), intent ( in ) :: var real ( pr ) :: get_ArnX ( size ( n )) call reset_vars arvaldb = 1 select case ( var ) case ( \"V\" ) vd = 1 case ( \"T\" ) td = 1 end select call self % ar_d_b (& n , nb , nd , ndb , & v , vb , vd , vdb , & t , tb , td , tdb , & arval , arvalb , arvald , arvaldb & ) get_ArnX = nb end function end subroutine function get_v0 ( self , n , p , t ) class ( ArModelTapenade ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:), p , t real ( pr ) :: get_v0 get_v0 = self % v0 ( n , p , t ) end function end module","tags":"","loc":"sourcefile/tapenade_ar_api.f90.html"},{"title":"generic_cubic.f90 – yaeos","text":"This file depends on sourcefile~~generic_cubic.f90~~EfferentGraph sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~constants.f90 constants.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~substance.f90 substance.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~substance.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~generic_cubic.f90~~AfferentGraph sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90 implementations.f90 sourcefile~implementations.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90->sourcefile~alphas.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~implementations.f90->sourcefile~mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~models.f90 models.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~flash.f90 flash.f90 sourcefile~flash.f90->sourcefile~models.f90 sourcefile~saturations_points.f90 saturations_points.f90 sourcefile~saturations_points.f90->sourcefile~models.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_models_ar_genericcubic use yaeos_constants , only : pr use yaeos_models_ar , only : ArModel use yaeos_substance , only : Substances implicit none type , abstract :: AlphaFunction !! Abstract derived type that describe the required !! procedure for an alpha function. contains procedure ( abs_alpha ), deferred :: alpha end type type , abstract :: CubicMixRule !! Abstract derived type that describe the required !! procedure for a mixing rule on a Cubic EoS contains procedure ( abs_Dmix ), deferred :: Dmix procedure ( abs_Bmix ), deferred :: Bmix end type type , extends ( ArModel ) :: CubicEoS !! Cubic Equation of State. !! !! Generic Cubic Equation of State as defined by Michelsen and Mollerup !! with constant \\delta_1 and \\delta_2 parameters. class ( Substances ), allocatable :: components class ( CubicMixRule ), allocatable :: mixrule class ( AlphaFunction ), allocatable :: alpha real ( pr ), allocatable :: ac (:) !! Attractive critical parameter real ( pr ), allocatable :: b (:) !! Repulsive parameter real ( pr ), allocatable :: del1 (:) !! \\delta_1 paramter real ( pr ), allocatable :: del2 (:) !! \\delta_2 paramter contains procedure :: residual_helmholtz => GenericCubic_Ar procedure :: get_v0 => v0 end type abstract interface subroutine abs_alpha ( self , Tr , a , dadt , dadt2 ) import AlphaFunction , pr class ( AlphaFunction ), intent ( in ) :: self real ( pr ), intent ( in ) :: Tr (:) real ( pr ), intent ( out ) :: a (:), dadt (:), dadt2 (:) end subroutine subroutine abs_Dmix ( self , n , T , & ai , daidt , daidt2 , & D , dDdT , dDdT2 , dDi , dDidT , dDij & ) import CubicMixRule , pr class ( CubicMixRule ), intent ( in ) :: self real ( pr ), intent ( in ) :: T , n (:) real ( pr ), intent ( in ) :: ai (:), daidt (:), daidt2 (:) real ( pr ), intent ( out ) :: D , dDdT , dDdT2 , dDi (:), dDidT (:), dDij (:, :) end subroutine subroutine abs_Bmix ( self , n , bi , B , dBi , dBij ) import CubicMixRule , pr class ( CubicMixRule ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) real ( pr ), intent ( in ) :: bi (:) real ( pr ), intent ( out ) :: B , dBi (:), dBij (:, :) end subroutine end interface contains subroutine GenericCubic_Ar (& self , n , V , T , Ar , ArV , ArT , ArTV , ArV2 , ArT2 , Arn , ArVn , ArTn , Arn2 & ) !! Residual Helmholtz Energy for a generic Cubic Equation of State. !! !! Calculates the residual Helmholtz Energy for a generic Cubic EoS as !! defined by Michelsen and Møllerup: !! !! P = \\frac{RT}{V-b} - \\frac{a_c\\alpha(T_r)}{(V+b\\delta_1)(V+b\\delta_2)} use yaeos_constants , only : R class ( CubicEoS ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:) !! Number of moles real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), optional , intent ( out ) :: ar !! Residual Helmholtz real ( pr ), optional , intent ( out ) :: arv !! \\frac{dAr}{dV} real ( pr ), optional , intent ( out ) :: ArT !! \\frac{dAr}{dT} real ( pr ), optional , intent ( out ) :: artv !! \\frac{d&#94;2Ar}{dTdV} real ( pr ), optional , intent ( out ) :: arv2 !! \\frac{d&#94;2Ar}{dV&#94;2} real ( pr ), optional , intent ( out ) :: ArT2 !! \\frac{d&#94;2Ar}{dT&#94;2} real ( pr ), optional , intent ( out ) :: Arn ( size ( n )) !! \\frac{dAr}{dn_i} real ( pr ), optional , intent ( out ) :: ArVn ( size ( n )) !! \\frac{d&#94;2Ar}{dVdn_i} real ( pr ), optional , intent ( out ) :: ArTn ( size ( n )) !! \\frac{d&#94;2Ar}{dTdn_i} real ( pr ), optional , intent ( out ) :: Arn2 ( size ( n ), size ( n )) !! \\frac{d&#94;2Ar}{dn_{ij}} real ( pr ) :: Bmix , dBi ( size ( n )), dBij ( size ( n ), size ( n )) real ( pr ) :: D , dDi ( size ( n )), dDij ( size ( n ), size ( n )), dDidT ( size ( n )), dDdT , dDdT2 real ( pr ) :: totn , d1 , d2 real ( pr ) :: f , g , fv , fB , gv , fv2 , gv2 , AUX , FFB , FFBV , FFBB real ( pr ) :: Tr ( size ( n )), a ( size ( n )), dadt ( size ( n )), dadt2 ( size ( n )) integer :: i , j , nc nc = size ( n ) TOTN = sum ( n ) D1 = self % del1 ( 1 ) D2 = ( 1._pr - D1 ) / ( 1._pr + D1 ) Tr = T / self % components % Tc call self % alpha % alpha ( Tr , a , dadt , dadt2 ) call self % mixrule % Bmix ( n , self % b , Bmix , dBi , dBij ) a = self % ac * a dadt = self % ac * dadt / self % components % Tc dadt2 = self % ac * dadt2 / self % components % Tc ** 2 call self % mixrule % Dmix (& n , T , a , dadt , dadt2 , D , dDdT , dDdT2 , dDi , dDidT , dDij & ) ! The f's and g's used here are for Ar, not F (reduced Ar) ! This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = R * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) fB = - ( f + V * fv ) / Bmix gv = R * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = R * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) ! Reduced Helmholtz Energy and derivatives if ( present ( Ar )) Ar = - TOTN * g * T - D * f if ( present ( ArV )) ArV = - TOTN * gv * T - D * fv if ( present ( ArV2 )) ArV2 = - TOTN * gv2 * T - D * fv2 AUX = R * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 if ( present ( Arn )) Arn (:) = - g * T + FFB * dBi (:) - f * dDi (:) if ( present ( ArVn )) ArVn (:) = - gv * T + FFBV * dBi (:) - fv * dDi (:) if ( present ( ArTn )) ArTn (:) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi (:) - f * dDidT (:) if ( present ( Arn2 )) then do i = 1 , nc do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end do end if ! TEMPERATURE DERIVATIVES if ( present ( ArT )) ArT = - TOTN * g - dDdT * f if ( present ( ArTV )) ArTV = - TOTN * gv - dDdT * fV if ( present ( ArT2 )) ArT2 = - dDdT2 * f end subroutine GenericCubic_Ar function v0 ( self , n , p , t ) !! Cubic EoS volume initializer. !! For a Cubic Equation of State, the covolume calculated with the mixing !! rule is a good estimate for the initial volume solver on the liquid !! region. class ( CubicEoS ), intent ( in ) :: self real ( pr ), intent ( in ) :: n (:), p , t real ( pr ) :: v0 real ( pr ) :: dbi ( size ( n )), dbij ( size ( n ), size ( n )) call self % mixrule % Bmix ( n , self % b , v0 , dbi , dbij ) end function end module","tags":"","loc":"sourcefile/generic_cubic.f90.html"},{"title":"flash.f90 – yaeos","text":"This file depends on sourcefile~~flash.f90~~EfferentGraph sourcefile~flash.f90 flash.f90 sourcefile~constants.f90 constants.f90 sourcefile~flash.f90->sourcefile~constants.f90 sourcefile~equilibria_state.f90 equilibria_state.f90 sourcefile~flash.f90->sourcefile~equilibria_state.f90 sourcefile~models.f90 models.f90 sourcefile~flash.f90->sourcefile~models.f90 sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~flash.f90->sourcefile~thermoprops.f90 sourcefile~equilibria_state.f90->sourcefile~constants.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~models.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90 implementations.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~thermoprops.f90->sourcefile~constants.f90 sourcefile~thermoprops.f90->sourcefile~ar_models.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~substance.f90 substance.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~implementations.f90->sourcefile~constants.f90 sourcefile~implementations.f90->sourcefile~alphas.f90 sourcefile~implementations.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90->sourcefile~mixing_rules.f90 sourcefile~implementations.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~substance.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~flash.f90~~AfferentGraph sourcefile~flash.f90 flash.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_equilibria_flash use yaeos_constants , only : pr use yaeos_models , only : ArModel use yaeos_equilibria_equilibria_state , only : EquilibriaState use yaeos_thermoprops , only : fugacity_vt , fugacity_tp , pressure implicit none contains type ( EquilibriaState ) function flash ( self , z , t , v_spec , p_spec , k0 , iters ) !! This algorithm assumes that the specified T and P correspond to !! vapor-liquid separation predicted by the provided model (0<beta<1) class ( ArModel ), intent ( in ) :: self !! Thermodynamic model real ( pr ), intent ( in ) :: z (:) !! Global composition (molar fractions) real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), optional , intent ( in ) :: v_spec !! Specified Volume [L/mol] real ( pr ), optional , intent ( in ) :: p_spec !! Specified Pressure [bar] real ( pr ), intent ( in ) :: k0 (:) !! Initial K factors (y/x) integer , optional , intent ( out ) :: iters !! Number of iterations logical :: stopflash ! Results from flash calculation real ( pr ), dimension ( size ( z )) :: x ! composition of liquid (molar fractions) real ( pr ), dimension ( size ( z )) :: y ! composition of vapour (molar fractions) real ( pr ) :: rho_x ! density of liquid (moles/L) real ( pr ) :: rho_y ! density of vapour (moles/L) real ( pr ) :: beta ! total fraction of vapour (molar base) ! Intermediate variables during calculation process real ( pr ) :: p , v real ( pr ), dimension ( size ( z )) :: lnfug_y , lnfug_x real ( pr ), dimension ( size ( z )) :: K , dK , lnK , dKold , lnKold real ( pr ), dimension ( size ( z ), size ( z )) :: dlnphidn real ( pr ) :: g0 , g1 ! function g valuated at beta=0 and 1, based on Wilson K factors real ( pr ) :: bmin , bmax , Vy , Vx real ( pr ) :: aux , bx , savek ( size ( z )), log_k2 ( size ( z )) real ( pr ) :: DPVl , dpvv , dVydVl , h , pl , pold , pold2 , pv , step , stepv real ( pr ) :: told , told2 character ( len = 2 ) :: spec !! Flash specification [PT | VT] ! ======================================================================== ! Starting steps ! ------------------------------------------------------------------------ if ( present ( v_spec ) . and . present ( p_spec )) then write ( * , * ) \"ERROR: Can't specify pressure and volume in Flash\" else if ( present ( v_spec ) ) then spec = \"TV\" v = v_spec else if ( present ( p_spec ) ) then spec = \"TP\" p = p_spec end if if ( spec == 'TV' . or . spec == 'isoV' ) then Vx = 0.0 ! if (FIRST) then ! the EoS one-phase pressure will be used to estimate Wilson K factors call pressure ( self , z , v_spec , t , p = p ) if ( P < 0 ) P = 1.0 ! end if end if K = K0 call betato01 ( z , K ) ! adapted 26/11/2014 lnK = log ( K ) ! now we must have  g0>0 and g1<0 and therefore 0<beta<1 (M&M page 252) call betalimits ( z , K , bmin , bmax ) beta = ( bmin + bmax ) / 2 ! first guess for beta ! ======================================================================== ! Succesive sustitution loop starts here dK = 1.0 iters = 0 do while ( maxval ( abs ( dK )) > 1.d-6 ) iters = iters + 1 if ( maxval ( abs ( dK )) > 1.10_pr ) then ! 26/11/2014 g0 = sum ( z * K ) - 1._pr g1 = 1._pr - sum ( z / K ) if ( g0 < 0 . or . g1 > 0 ) then ! bring beta back to range, by touching K call betato01 ( z , K ) call betalimits ( z , K , bmin , bmax ) beta = ( bmin + bmax ) / 2 ! new guess for beta end if end if call solve_rr ( z , K , beta , bmin , bmax ) y = z * K / ( 1 + beta * ( K - 1._pr )) x = y / K ! new for TV Flash select case ( spec ) case ( \"TV\" , \"isoV\" ) ! find Vy,Vx (vV and vL) from V balance and P equality equations ! TODO: Add TV specification case ( \"TP\" ) ! for TP Flash call fugacity_tp ( self , y , T , P , V = Vy , root_type = \"stable\" , lnfug = lnfug_y ) call fugacity_tp ( self , x , T , P , V = Vx , root_type = \"liquid\" , lnfug = lnfug_x ) end select dKold = dK lnKold = lnK lnK = lnfug_x - lnfug_y dK = lnK - lnKold aux = sum ( dK + dKold ) if ( iters > 10 . and . abs ( aux ) < 0.05 ) then ! oscilation behavior detected (27/06/15) lnK = ( lnK + lnKold ) / 2 end if K = exp ( lnK ) call betalimits ( z , K , bmin , bmax ) ! 26/06/15 if (( beta < bmin ) . or . ( bmax < beta )) then beta = ( bmin + bmax ) / 2 end if if ( iters > 500 ) then p = - 1 return end if end do if ( spec == 'TP' ) v = beta * Vy + ( 1 - beta ) * Vx if ( spec == 'TV' . or . spec == 'isoV' ) write ( 4 , * ) T , P , Pv if ( spec == 'TV' . or . spec == 'isoV' ) P = Pv if ( maxval ( K ) < 1.001 . and . minval ( K ) > 0.999 ) then ! trivial solution P = - 1.0 flash % x = x / x flash % y = y / y flash % iters = iters flash % p = p flash % t = t return end if flash % iters = iters flash % p = p flash % t = t if ( Vy < Vx ) then ! `y` phase is the heaviest phase flash % y = x flash % x = y flash % vy = Vx flash % vx = vy else flash % x = x flash % y = y flash % vx = Vx flash % vy = vy end if end function flash subroutine betato01 ( z , K ) implicit none real ( pr ), intent ( in ) :: z (:) ! composition of the system real ( pr ) :: K (:) ! K factors (modified in this routine) real ( pr ) :: g0 , g1 ! function g valuated at beta=0 and 1, based on K factors g1 = 1.0 do while ( g0 < 0 . or . g1 > 0 ) g0 = sum ( z * K ) - 1.D0 g1 = 1.D0 - sum ( z / K ) if ( g0 < 0 ) then K = 1.1 * K ! increased volatiliy will bring the solution from subcooled liquid into VLE else if ( g1 > 0 ) then K = 0.9 * K ! decreased volatiliy will bring the solution from superheated vapor into VLE end if end do end subroutine betato01 subroutine betalimits ( z , K , bmin , bmax ) real ( pr ), intent ( in ) :: z (:), K (:) ! composition of the system and K factors real ( pr ), intent ( out ) :: bmin , bmax real ( pr ), dimension ( size ( z )) :: vmin , vmax integer :: i , in , ix in = 0 ix = 0 vmin = 0.d0 ! max=1.001d0    ! modified  3/3/15 (not to generate false separations with beta 0.9999...) vmax = 1.00001d0 ! modified 28/6/15 (to prevent overshooting in the Newton for solving RR eq.) do i = 1 , size ( z ) if ( K ( i ) * z ( i ) > 1 ) then in = in + 1 vmin ( in ) = ( K ( i ) * z ( i ) - 1.d0 ) / ( K ( i ) - 1.d0 ) else if ( K ( i ) < z ( i )) then ix = ix + 1 vmax ( ix ) = ( 1.d0 - z ( i )) / ( 1.d0 - K ( i )) end if end do bmin = maxval ( vmin ) bmax = minval ( vmax ) end subroutine betalimits subroutine rachford_rice ( z , K , beta , rr , drrdb ) real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( in ) :: K (:) real ( pr ), intent ( in ) :: beta real ( pr ), intent ( out ) :: rr real ( pr ), intent ( out ) :: drrdb real ( pr ) :: denom ( size ( z )) denom = 1 + beta * ( K - 1._pr ) rr = sum ( z * ( K - 1._pr ) / denom ) drrdb = - sum ( z * ( K - 1._pr ) ** 2 / denom ** 2 ) end subroutine subroutine solve_rr ( z , K , beta , beta_min , beta_max ) !! Solve the Rachford-Rice Equation. real ( pr ), intent ( in ) :: z (:) !! Mole fractions vector real ( pr ), intent ( in ) :: K (:) !! K-factors real ( pr ), intent ( out ) :: beta_min !! real ( pr ), intent ( out ) :: beta_max real ( pr ), intent ( out ) :: beta real ( pr ) :: g , dgdb real ( pr ) :: step g = 1.0 step = 1.0 call betalimits ( z , k , beta_min , beta_max ) do while ( abs ( g ) > 1.d-5 . and . abs ( step ) > 1.d-10 ) call rachford_rice ( z , k , beta , g , dgdb ) step = - g / dgdb beta = beta + step do while (( beta < beta_min . or . beta_max < beta ) . and . step > 1e-10 ) step = step / 2 beta = beta - step end do end do end subroutine ! subroutine tv_loop !    dVydVl = -(1 - beta)/beta !    ! call Bcalc(n, x, T, Bx) !    ! TODO: Add this intiial volume !    if (Vx < Bx) Vx = 1.625*Bx  ! First evaluation will be with Vx = 1.5*Bx !    ! Pl = -1.0 !    call zTVTERMO(n, 0, T, x, Vx, Pl, DPVl, lnfug_y, dlnphidp, dlnphitp, dlnphidn)  ! 26/06/15 !    do while (Pl < 0 .or. DPVl >= 0) !       Vx = Vx - 0.2*(Vx - Bx) !       call zTVTERMO(n, 0, T, x, Vx, Pl, DPVl, lnfug_y, dlnphidp, dlnphitp, dlnphidn) !    end do !    Vy = (v - (1 - beta)*Vx)/beta !    h = 1.0 !    iterv = 0 !    stopflash = .false. !    do while (abs(h) > 1.d-4)  ! Newton for solving P equality, with Vx as independent variable !       iterv = iterv + 1 !       if (iterv >= 100) then !          write (2, *) 'volume convergence problems' !          P = -1.0 !          stopflash = .true. !          exit !       end if !       call zTVTERMO(n, 0, T, x, Vx, Pl, DPVl, lnfug_y, dlnphidp, dlnphitp, dlnphidn) !       call zTVTERMO(n, 0, T, y, Vy, Pv, DPVv, lnfug_y, dlnphidp, dlnphitp, dlnphidn) !       h = Pv - Pl !       dh = -DPVv*dVydVl - DPVl !       stepv = -h/dh !       if (iterv >= 10) stepv = stepv/2 !       Vx = Vx + stepv !       do while (Vx < 1.001*Bx) !          stepv = stepv/2 !          Vx = Vx - stepv !       end do !       Vy = (v - (1 - beta)*Vx)/beta !    end do !    if (stopflash .eqv. .true.) exit !    call zTVTERMO(n, 1, T, x, Vx, Pl, DPVl, PHILOGx, dlnphidp, dlnphitp, dlnphidn) !    call zTVTERMO(n, 1, T, y, Vy, Pv, DPVv, lnfug_y, dlnphidp, dlnphitp, dlnphidn) ! end subroutine end module","tags":"","loc":"sourcefile/flash.f90.html"},{"title":"thermoprops.f90 – yaeos","text":"This file depends on sourcefile~~thermoprops.f90~~EfferentGraph sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~thermoprops.f90->sourcefile~ar_models.f90 sourcefile~constants.f90 constants.f90 sourcefile~thermoprops.f90->sourcefile~constants.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~thermoprops.f90~~AfferentGraph sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~flash.f90 flash.f90 sourcefile~flash.f90->sourcefile~thermoprops.f90 sourcefile~saturations_points.f90 saturations_points.f90 sourcefile~saturations_points.f90->sourcefile~thermoprops.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~thermoprops.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_thermoprops !! Residual thermodyamic properties using residual Helmholtz model. !! !! Available properties: !! !! - pressure(n, V, T) !! - fugacity(n, V, T) !! - fugacity(n, P, T, root=[vapor, liquid, stable]) !! - volume !! !! Calculate thermodynamic properties using Helmholtz energy as a basis. !! All the routines in this module work with the logic: !! !! ```fortran !! call foo(x, V, T, [dfoodv, dfoodt, ...]) !! ``` !! Where the user can call the routine of the desired property. And include !! as optional values the desired derivatives of said properties. use yaeos_constants , only : R , pr use yaeos_models_ar , only : ArModel implicit none contains subroutine pressure ( self , n , v , t , p , dpdv , dpdt , dpdn ) !! Pressure calculation. !! !! Calculate pressure using residual helmholtz models. !! class ( ArModel ), intent ( in ) :: self !! Model real ( pr ), intent ( in ) :: n (:) !! Moles number vector real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( out ) :: p !! Pressure [bar] real ( pr ), optional , intent ( out ) :: dpdv !! \\frac{dP}}{dV} real ( pr ), optional , intent ( out ) :: dpdt !! \\frac{dP}}{dT} real ( pr ), optional , intent ( out ) :: dpdn (:) !! \\frac{dP}}{dn_i} real ( pr ) :: totn real ( pr ) :: Ar , ArV , ArV2 , ArTV , ArVn ( size ( n )) integer :: nc TOTN = sum ( n ) nc = size ( n ) call self % residual_helmholtz (& n , v , t , Ar = Ar , ArV = ArV , ArV2 = ArV2 , ArTV = ArTV , ArVn = ArVn & ) P = TOTN * R * T / V - ArV if ( present ( dPdV )) dPdV = - ArV2 - R * t * TOTN / V ** 2 if ( present ( dPdT )) dPdT = - ArTV + TOTN * R / V if ( present ( dPdN )) dPdN (:) = R * T / V - ArVn (:) end subroutine subroutine fugacity_tp ( self , & n , T , P , V , root_type , lnfug , dlnPhidP , dlnphidT , dlnPhidn & ) !! Calculate logarithm of fugacity, given pressure and temperature. !! !! This routine will obtain the desired volume root at the specified !! pressure and calculate fugacity at that point. !! !! @note !! While the natural output variable is ln f_i. The calculated !! derivatives will be the derivatives of the fugacity coefficient !! ln \\phi_i !! @endnote !! use iso_fortran_env , only : error_unit class ( ArModel ), intent ( in ) :: self !! Model real ( pr ), intent ( in ) :: n (:) !! Mixture mole numbers character ( len =* ), intent ( in ) :: root_type !! Type of root desired [\"liquid\", \"vapor\", \"stable\"] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( in ) :: p !! Pressure [bar] real ( pr ), intent ( out ) :: lnfug ( size ( n )) !! \\ln(f_i) vector real ( pr ), optional , intent ( out ) :: v !! Volume [L] real ( pr ), optional , intent ( out ) :: dlnphidt ( size ( n )) !! ln(phi) Temp derivative real ( pr ), optional , intent ( out ) :: dlnphidp ( size ( n )) !! ln(phi) Presssure derivative real ( pr ), optional , intent ( out ) :: dlnphidn ( size ( n ), size ( n )) !! ln(phi) compositional derivative real ( pr ) :: v_in , p_in call VCALC ( self , root_type , size ( n ), n , T , P , V_in ) call fugacity_vt ( self , n , v_in , T , P_in , lnfug , dlnphidp , dlnphidt , dlnphidn ) if ( present ( v )) v = v_in ! if(abs(p-p_in) > 1e-5) write(error_unit, *) & !  \"WARN: Possible wrong root calculating fugacity!\" , p, p_in end subroutine fugacity_tp subroutine fugacity_vt ( self , & n , V , T , P , lnfug , dlnPhidP , dlnphidT , dlnPhidn & ) !! Calculate fugacity given volume and temperature. !! !!@note !!While the natural output variable is ln f_i. The calculated !!derivatives will be the derivatives of the fugacity coefficient !!ln \\phi_i !!@endnote !! class ( ArModel ) :: self !! Model real ( pr ), intent ( in ) :: n (:) !! Mixture mole numbers real ( pr ), intent ( in ) :: v !! Volume [L] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), optional , intent ( out ) :: p !! Pressure [bar] real ( pr ), optional , intent ( out ) :: lnfug ( size ( n )) !! \\ln(\\phi*p) vector real ( pr ), optional , intent ( out ) :: dlnphidt ( size ( n )) !! ln(phi) Temp derivative real ( pr ), optional , intent ( out ) :: dlnphidp ( size ( n )) !! ln(phi) Presssure derivative real ( pr ), optional , intent ( out ) :: dlnphidn ( size ( n ), size ( n )) !! ln(phi) compositional derivative real ( pr ) :: Ar , ArTV , ArV , ArV2 real ( pr ), dimension ( size ( n )) :: Arn , ArVn , ArTn real ( pr ) :: Arn2 ( size ( n ), size ( n )) real ( pr ) :: dPdV , dPdT , dPdN ( size ( n )) real ( pr ) :: RT , Z real ( pr ) :: totn integer :: nc , i , j TOTN = sum ( n ) nc = size ( n ) RT = R * T Z = V / ( TOTN * RT ) ! this is Z/P if ( present ( lnfug ) . and . . not . (& present ( dlnphidn ) & . and . present ( dlnphidp ) & . and . present ( dlnphidt ) & . and . present ( p ) & )) then call self % residual_helmholtz ( n , v , t , Arn = Arn ) lnfug (:) = Arn (:) / RT - log ( Z ) return else if ( present ( dlnphidn )) then call self % residual_helmholtz (& n , V , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 , ArTV = ArTV , & Arn = Arn , ArVn = ArVn , ArTn = ArTn , Arn2 = Arn2 & ) else call self % residual_helmholtz (& n , V , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 , ArTV = ArTV , & Arn = Arn , ArVn = ArVn , ArTn = ArTn & ) end if lnfug (:) = Arn (:) / RT - log ( Z ) P = TOTN * RT / V - ArV dPdV = - ArV2 - RT * TOTN / V ** 2 dPdT = - ArTV + TOTN * R / V dPdN (:) = RT / V - ArVn (:) if ( present ( dlnphidp )) dlnphidp (:) = - dPdN (:) / dPdV / RT - 1._pr / P if ( present ( dlnphidt )) then dlnphidt (:) = ( ArTn (:) - Arn (:) / T ) / RT + dPdN (:) * dPdT / dPdV / RT + 1._pr / T end if if ( present ( dlnphidn )) then do i = 1 , nc do j = i , nc dlnphidn ( i , j ) = 1._pr / TOTN + ( Arn2 ( i , j ) + dPdN ( i ) * dPdN ( j ) / dPdV ) / RT dlnphidn ( j , i ) = dlnphidn ( i , j ) end do end do end if end subroutine subroutine PUREFUG_CALC ( self , nc , icomp , T , P , V , fug ) !! Fugacity of a pure component. class ( ArModel ), intent ( in ) :: self !! model integer , intent ( in ) :: nc !! Number of components integer , intent ( in ) :: icomp !! Component index real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: P !! Pressure [bar] real ( pr ), intent ( in ) :: V !! Volume [L] real ( pr ), intent ( out ) :: fug !! Fugacity of component `icomp` real ( pr ) :: n ( nc ), Ar , Arn ( nc ) real ( pr ) :: RT , Z , lnfug n = 0.0 n ( icomp ) = 1.0 RT = R * T Z = P * V / RT call self % residual_helmholtz ( n , V , T , Ar , Arn = Arn ) lnfug = - log ( Z ) + Arn ( icomp ) / RT fug = exp ( fug ) end subroutine purefug_calc recursive subroutine VCALC ( self , root_type , nc , rn , T , P , V , max_iters ) !! Volume solver at a given pressure. ! ! This routine still requires some work to be easier to understand use iso_fortran_env , only : error_unit use stdlib_optval , only : optval class ( ArModel ), intent ( in ) :: self character ( len =* ), intent ( in ) :: root_type !! Type of root [-1: vapor, 1:liquid, 0:lower Gibbs energy phase] integer , intent ( in ) :: nc !! Number of components real ( pr ), intent ( in ) :: rn ( nc ) !! Mixture moles real ( pr ), intent ( in ) :: T !! Temperature [K] real ( pr ), intent ( in ) :: P !! Pressure [bar] real ( pr ), intent ( out ) :: V !! Volume [L] integer , optional , intent ( in ) :: max_iters !! Maxiumum number of iterations, defaults to 100 real ( pr ) :: Ar , ArV , ArV2 logical :: FIRST_RUN real ( pr ) :: totn real ( pr ) :: B , CPV , S3R real ( pr ) :: ZETMIN , ZETA , ZETMAX real ( pr ) :: del , pcalc , der , AT , AVAP , VVAP integer :: iter , maximum_iterations maximum_iterations = optval ( max_iters , 100 ) FIRST_RUN = . true . TOTN = sum ( rn ) CPV = self % get_v0 ( rn , p , t ) B = CPV S3R = 1._pr / CPV ITER = 0 ZETMIN = 0._pr ZETMAX = 1._pr - 0.01 * T / ( 10000 * B ) ! improvement for cases with heavy components if ( root_type == \"liquid\" ) then ZETA = 0.5_pr else ! IDEAL GAS ESTIMATE ZETA = min (. 5 D0 , CPV * P / ( TOTN * R * T )) end if 100 continue DEL = 1 pcalc = 2 * p do while ( abs ( DEL ) > 1.e-10_pr . and . iter < maximum_iterations ) V = CPV / ZETA ITER = ITER + 1 call self % residual_helmholtz (& rn , V , T , Ar = Ar , ArV = ArV , ArV2 = ArV2 & ) PCALC = TOTN * R * T / V - ArV if ( PCALC . gt . P ) then ZETMAX = ZETA else ZETMIN = ZETA end if ! AT is something close to Gr(P,T) AT = ( Ar + V * P ) / ( T * R ) - TOTN * log ( V ) DER = ( ArV2 * V ** 2 + TOTN * R * T ) * S3R ! this is dPdrho/B DEL = - ( PCALC - P ) / DER ZETA = ZETA + max ( min ( DEL , 0.1_pr ), - . 1_pr ) if ( ZETA . gt . ZETMAX . or . ZETA . lt . ZETMIN ) & ZETA = . 5_pr * ( ZETMAX + ZETMIN ) end do if ( iter >= maximum_iterations ) write ( error_unit , * ) & \"WARN: Volume solver exceeded maximum number of iterations\" if ( root_type == \"stable\" ) then ! FIRST RUN WAS VAPOUR; RERUN FOR LIQUID if ( FIRST_RUN ) then VVAP = V AVAP = AT FIRST_RUN = . false . ZETA = 0.5_pr ZETMAX = 1._pr - 0.01_pr * T / 50 0._pr goto 100 else if ( AT . gt . AVAP ) V = VVAP end if end if end subroutine vcalc ! ========================================================================== end module","tags":"","loc":"sourcefile/thermoprops.f90.html"},{"title":"autodiff.f90 – yaeos","text":"This file depends on sourcefile~~autodiff.f90~~EfferentGraph sourcefile~autodiff.f90 autodiff.f90 sourcefile~hyperdual.f90 hyperdual.f90 sourcefile~autodiff.f90->sourcefile~hyperdual.f90 sourcefile~constants.f90 constants.f90 sourcefile~hyperdual.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~autodiff.f90~~AfferentGraph sourcefile~autodiff.f90 autodiff.f90 sourcefile~armodel_adiff_api.f90 armodel_adiff_api.f90 sourcefile~armodel_adiff_api.f90->sourcefile~autodiff.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_autodiff !! This module holds the diferent ways of automatic differentiation use hyperdual_mod implicit none end module","tags":"","loc":"sourcefile/autodiff.f90.html"},{"title":"admm_tapenade_interface.f90 – yaeos","text":"Source Code MODULE ADMM_TAPENADE_INTERFACE IMPLICIT NONE INTERFACE PUSHPOINTER8 SUBROUTINE PUSHPOINTER8 ( pp ) BIND ( c , name = 'pushPointer8' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: pp END SUBROUTINE PUSHPOINTER8 END INTERFACE PUSHPOINTER8 INTERFACE POPPOINTER8 SUBROUTINE POPPOINTER8 ( pp ) BIND ( c , name = 'popPointer8' ) USE ISO_C_BINDING TYPE ( C_PTR ) :: pp END SUBROUTINE POPPOINTER8 END INTERFACE POPPOINTER8 INTERFACE ADMM_REGISTERSHADOWED SUBROUTINE ADMM_REGISTERSHADOWED ( base , obase , size , baseb , obaseb & & , sizeb , nbelem ) BIND ( c , name = 'ADMM_registerShadowed' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base , obase TYPE ( C_PTR ), VALUE :: baseb , obaseb INTEGER , VALUE :: size , sizeb INTEGER , VALUE :: nbelem END SUBROUTINE ADMM_REGISTERSHADOWED END INTERFACE ADMM_REGISTERSHADOWED INTERFACE ADMM_REGISTER SUBROUTINE ADMM_REGISTER ( base , obase , size , nbelem ) BIND ( c , name = & & 'ADMM_register' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base , obase INTEGER , VALUE :: size INTEGER , VALUE :: nbelem END SUBROUTINE ADMM_REGISTER END INTERFACE ADMM_REGISTER INTERFACE ADMM_UNREGISTERSHADOWED SUBROUTINE ADMM_UNREGISTERSHADOWED ( base , baseb , nbelem ) BIND ( c , & & name = 'ADMM_unregisterShadowed' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base , baseb INTEGER :: nbelem END SUBROUTINE ADMM_UNREGISTERSHADOWED END INTERFACE ADMM_UNREGISTERSHADOWED INTERFACE ADMM_UNREGISTER SUBROUTINE ADMM_UNREGISTER ( base , nbelem ) BIND ( c , name = & & 'ADMM_unregister' ) USE ISO_C_BINDING TYPE ( C_PTR ), VALUE :: base INTEGER :: nbelem END SUBROUTINE ADMM_UNREGISTER END INTERFACE ADMM_UNREGISTER INTERFACE ADMM_REBASESHADOWED SUBROUTINE ADMM_REBASESHADOWED ( base , baseb ) BIND ( c , name = & & 'ADMM_rebaseShadowed' ) USE ISO_C_BINDING TYPE ( C_PTR ) :: base , baseb END SUBROUTINE ADMM_REBASESHADOWED END INTERFACE ADMM_REBASESHADOWED INTERFACE ADMM_REBASE SUBROUTINE ADMM_REBASE ( base ) BIND ( c , name = 'ADMM_rebase' ) USE ISO_C_BINDING TYPE ( C_PTR ) :: base END SUBROUTINE ADMM_REBASE END INTERFACE ADMM_REBASE END MODULE ADMM_TAPENADE_INTERFACE","tags":"","loc":"sourcefile/admm_tapenade_interface.f90.html"},{"title":"equilibria_state.f90 – yaeos","text":"This file depends on sourcefile~~equilibria_state.f90~~EfferentGraph sourcefile~equilibria_state.f90 equilibria_state.f90 sourcefile~constants.f90 constants.f90 sourcefile~equilibria_state.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~equilibria_state.f90~~AfferentGraph sourcefile~equilibria_state.f90 equilibria_state.f90 sourcefile~flash.f90 flash.f90 sourcefile~flash.f90->sourcefile~equilibria_state.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~phase_equilibria.f90->sourcefile~equilibria_state.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 sourcefile~saturations_points.f90 saturations_points.f90 sourcefile~saturations_points.f90->sourcefile~equilibria_state.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_equilibria_equilibria_state use yaeos_constants , only : pr implicit none type :: EquilibriaState integer :: iters !! Iterations needed to reach the state real ( pr ), allocatable :: y (:) !! Vapour molar fractions real ( pr ), allocatable :: x (:) !! Liquid molar fractions real ( pr ) :: Vx !! Liquid volume [L/mol] real ( pr ) :: Vy !! Vapor volume [L/mol] real ( pr ) :: t !! Temperature [K] real ( pr ) :: p !! Pressure [bar] end type end module","tags":"","loc":"sourcefile/equilibria_state.f90.html"},{"title":"substance.f90 – yaeos","text":"This file depends on sourcefile~~substance.f90~~EfferentGraph sourcefile~substance.f90 substance.f90 sourcefile~constants.f90 constants.f90 sourcefile~substance.f90->sourcefile~constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~substance.f90~~AfferentGraph sourcefile~substance.f90 substance.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~implementations.f90 implementations.f90 sourcefile~implementations.f90->sourcefile~substance.f90 sourcefile~implementations.f90->sourcefile~alphas.f90 sourcefile~implementations.f90->sourcefile~generic_cubic.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~implementations.f90->sourcefile~mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 sourcefile~yaeos.f90 yaeos.f90 sourcefile~yaeos.f90->sourcefile~substance.f90 sourcefile~models.f90 models.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~flash.f90 flash.f90 sourcefile~flash.f90->sourcefile~models.f90 sourcefile~saturations_points.f90 saturations_points.f90 sourcefile~saturations_points.f90->sourcefile~models.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos_substance !! Ya_EoS Subtance module. !! !! Module containing pure components properties and parameters. use yaeos_constants , only : pr type :: Substances !! Set of pure components character ( len = 50 ), allocatable :: names (:) !! Composition names. real ( pr ), allocatable :: tc (:) !! Critical Temperature [K] real ( pr ), allocatable :: pc (:) !! Critical Pressure [bar] real ( pr ), allocatable :: w (:) !! Acentric factor end type end module","tags":"","loc":"sourcefile/substance.f90.html"},{"title":"yaeos.f90 – yaeos","text":"This file depends on sourcefile~~yaeos.f90~~EfferentGraph sourcefile~yaeos.f90 yaeos.f90 sourcefile~constants.f90 constants.f90 sourcefile~yaeos.f90->sourcefile~constants.f90 sourcefile~models.f90 models.f90 sourcefile~yaeos.f90->sourcefile~models.f90 sourcefile~phase_equilibria.f90 phase_equilibria.f90 sourcefile~yaeos.f90->sourcefile~phase_equilibria.f90 sourcefile~substance.f90 substance.f90 sourcefile~yaeos.f90->sourcefile~substance.f90 sourcefile~thermoprops.f90 thermoprops.f90 sourcefile~yaeos.f90->sourcefile~thermoprops.f90 sourcefile~alphas.f90 alphas.f90 sourcefile~models.f90->sourcefile~alphas.f90 sourcefile~ar_models.f90 ar_models.f90 sourcefile~models.f90->sourcefile~ar_models.f90 sourcefile~generic_cubic.f90 generic_cubic.f90 sourcefile~models.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90 implementations.f90 sourcefile~models.f90->sourcefile~implementations.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~models.f90->sourcefile~mixing_rules.f90 sourcefile~equilibria_state.f90 equilibria_state.f90 sourcefile~phase_equilibria.f90->sourcefile~equilibria_state.f90 sourcefile~flash.f90 flash.f90 sourcefile~phase_equilibria.f90->sourcefile~flash.f90 sourcefile~substance.f90->sourcefile~constants.f90 sourcefile~thermoprops.f90->sourcefile~constants.f90 sourcefile~thermoprops.f90->sourcefile~ar_models.f90 sourcefile~alphas.f90->sourcefile~constants.f90 sourcefile~alphas.f90->sourcefile~substance.f90 sourcefile~alphas.f90->sourcefile~generic_cubic.f90 sourcefile~ar_models.f90->sourcefile~constants.f90 sourcefile~equilibria_state.f90->sourcefile~constants.f90 sourcefile~flash.f90->sourcefile~constants.f90 sourcefile~flash.f90->sourcefile~models.f90 sourcefile~flash.f90->sourcefile~thermoprops.f90 sourcefile~flash.f90->sourcefile~equilibria_state.f90 sourcefile~generic_cubic.f90->sourcefile~constants.f90 sourcefile~generic_cubic.f90->sourcefile~substance.f90 sourcefile~generic_cubic.f90->sourcefile~ar_models.f90 sourcefile~implementations.f90->sourcefile~constants.f90 sourcefile~implementations.f90->sourcefile~substance.f90 sourcefile~implementations.f90->sourcefile~alphas.f90 sourcefile~implementations.f90->sourcefile~generic_cubic.f90 sourcefile~implementations.f90->sourcefile~mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~substance.f90 sourcefile~mixing_rules.f90->sourcefile~generic_cubic.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module yaeos !! Yet Another Equation-Of-State (library) !! !! Library to use EoS-based calculations. This main module imports all the !! relevant constants, procedures and objects to have better access to them !! The main submodules that it uses are: !! !! - [[yaeos_constants(module)]]: All the relevant costants and also the used precision (default=double precision). !! - [[yaeos_substance(module)]]: Derived type that holds the important data (for example, critical constants) from a mixture. !! - [[yaeos_models(module)]]: All the implemented models, also their base types for making extensions. !! - [[yaeos_thermoprops(module)]]: Available thermodynamic properties to calculate. !! - [[yaeos_equilibria(module)]]: Phase equilibria related procedures. use yaeos_constants use yaeos_substance use yaeos_models use yaeos_thermoprops use yaeos_equilibria character ( len =* ), parameter :: version = \"0.1.0b2\" !! This version. end module","tags":"","loc":"sourcefile/yaeos.f90.html"},{"title":"User documentation – yaeos","text":"Welcome to yaeos user documentation yaeos is a Fortran library that handles thermodynamic Equations of State-based\ncalculations, mostly phase-equilibria related ones and properties estimation\nones. This is a work-in-progress library (and documentation) so don’t hesisate to report any problem/requirement as an issue in our GitHub page . Basic usage The base object that represents most of yaeos functionality is the ArModel object, which holds the basic interface of how a $A_r$ model behaves. Since all the properties that yaeos calculates are based on residual Helmholtz\nenergy, once the object is set-up all the library functionality is available. use yaeos class ( ArModel ), allocatable :: model ! Variable that holds the model ! A setup function that returns a setted model model = setup_model ( < the properties that define a model > ) ! Once the model is set up, the user has access to the properties call pressure ( model , V , T , P , dPdN = dPdN )","tags":"","loc":"page/index.html"},{"title":"Using yaeos – yaeos","text":"Getting started Fortran Getting yaeos Setting up a model Calculating thermodynamic properties Phase equilibria Getting started Fortran Maybe you’ve heard of Fortran as that old and cryptic language that everyone is\nafraid of. Well, not anymore! Fortran is really easy to understand and has been\nupdated a lot in the recent decades. There is a fairly direct guide on the fortran-lang site Getting yaeos yaeos is a Fortran library intended to be used as a fpm package, fpm can be easily easily obtained with\nthe Python package manager pip with a simple: pip install --user fpm With fpm installed you can create a new Fortran project by running: fpm new your_project_name A new directory with the name of your project will be created. You include yaeos in your fpm project by adding it as a dependency on your fpm.toml file by adding this: [dependencies] stdlib = \"*\" yaeos = { git = \"https://github.com/ipqa-research/yaeos\" } Or maybe you want a specific version: [dependencies] stdlib = \"*\" yaeos = { git = \"https://github.com/ipqa-research/yaeos\" , tag = \"0.1.0b2\" } Setting up a model On yaeos there is a series of models implemented, right now we include\nResidual Helmholtz energy models (like Cubic Equations of State), but plan on\nextening to a broader variety. In this example we’ll show how a model in yaeos can be used. We’ll take\nthe Peng-Robinson equation of state as an example, but all the implemented\nmodels can be seen at yaeos_models . Inside\nyour app/main.f90 file use program main use yaeos ! Set the variable `model` as a generic `ArModel` class ( ArModel ), allocatable :: model ! Set the the variables that we're going to use ! as variable lenght arrays real ( pr ), allocatable :: n (:), tc (:), pc (:), w (:) n = [ 0.3 , 0.7 ] ! Number of moles of each component tc = [ 190 , 310 ] ! Critical temperatures pc = [ 14 , 30 ] ! Critical pressures w = [ 0.001 , 0.03 ] ! Acentric factors ! Now we set our model as the PengRobinson76 ! Equation of state. model = PengRobinson76 ( tc , pc , w ) end program And then it’s all set, now we’ve set the model variable to use in our\ncalculations Calculating thermodynamic properties Some thermodynamic properties can be calculated with yaeos models, and we’re\nadding more! In this example we’ll calculate a PV isotherm from our previously\ndefined model. For the sake of simplicity all the next code blocks are assumed\nto be extensions of the previous one, before the end program sentence. pv_isotherm : block real ( pr ) :: v , t , p ! Thermodynamic variables real ( pr ) :: v0 , vf , dv ! End and start volumes integer :: i , n_points ! iteration variable and how many points to calc v0 = 0.001 vf = 10 dv = ( vf - v0 ) / n_points do i = 1 , n_points v = v0 + i * dv ! Set new volume point call pressure ( model , n , v , t , p ) ! Calculate pressure print * , v , p end do end block pv_isotherm Also some useful derivatives are available when calculating each property, they\ncan be easily accessed as optional arguments of the routine. For example, to \nobtain the derivative of pressure with respect to volume the line that\ncalculates pressure should be changed to: call pressure ( model , n , v , t , p , dpdv = dpdv ) ! Calculate pressure and dPdV The available thermodynamic properties to calculate can be seen at the yaeos_thermoprops module. Phase equilibria","tags":"","loc":"page/usage/index.html"},{"title":"Adding your own models – yaeos","text":"Most of thermodynamic properties calculated in yaeos heavily depend on\ndifferent kind of models and their respective derivatives.\nSince obtaining the derivatives of complex models can be a tedious and\nerror-prone task. We provide two different ways of getting them automatically\n(in some cases with some performance-cost), but there is also the possibility\nof using anallyitical obtained expressions instead. The calculation of thermodynamic properties heavily depends on On yaeos there are three different ways of adding your own model:W Residual Helmholtz models Using operator overloading automatic differentiation with hyperdual numbers Using source-to-source automatic differentiation with tapenade Using analytical obtained expressions Residual Helmholtz models Residual Helmholtz models are the basis to obtain the residual properties. The main basis in yaeos to define a new object that extends the abstract type called ArModel . Which enforces the expected functionality of these\nkind of models. use yaeos , only : ArModel type , extends ( ArModel ) :: MyNewModel end type The definition of an ArModel expects that two procedures are defined: abs_residual_helmholtz : Procedure to calculate residual Helmholtz energy and it’s derivatives abs_volume_initializer : Volume initializer to find a liquid root, given a pressure and temperature. use yaeos , only : ArModel type , extends ( ArModel ) :: MyNewModel contains procedure :: residual_helmholtz => an_Ar_implementation procedure :: volume_initializer => an_v0_implementation end type Satisfying those requirements, our model will be ready to make calculations! use yaeos , only : pressure use my_model , only : MyNewModel type ( MyNewModel ) :: model ! Assuming model parameters are set-up call pressure ( model , n , V , T , P ) Using operator overloading automatic differentiation with hyperdual numbers Using source-to-source automatic differentiation with tapenade Using analytical obtained expressions","tags":"","loc":"page/usage/newmodel.html"},{"title":"Theorical background – yaeos","text":"","tags":"","loc":"page/theory/index.html"},{"title":"Contributing – yaeos","text":"Contributing to yaeos First off, thanks for your interesnt and taking the time to contribute! All types of contributions are encouraged and valued. \nSee the Table of Contents for different ways to help and\ndetails about how this project handles them. Please make sure to read the\nrelevant section before making your contribution. It will make it a lot easier\nfor us maintainers and smooth out the experience for all involved. The\ncommunity looks forward to your contributions. 🎉 And if you like the project, but just don’t have time to contribute, that’s\nfine. There are other easy ways to support the project and show your\nappreciation, which we would also be very happy about:\n- Star the project\n- Tweet about it\n- Refer this project in your project’s readme\n- Mention the project at local meetups and tell your friends/colleagues Table of Contents I Have a Question I Want To Contribute Reporting Bugs Suggesting Enhancements Your First Code Contribution Improving The Documentation Styleguides Commit Messages Join The Project Team I Have a Question If you want to ask a question, we assume that you have read the available Documentation . Before you ask a question, it is best to search for existing Issues that might help you. In\ncase you have found a suitable issue and still need clarification, you can\nwrite your question in this issue. It is also advisable to search the internet\nfor answers first. If you then still feel the need to ask a question and need clarification, we\nrecommend the following: Open an Issue . Provide as much context as you can about what you’re running into. Provide project and platform versions, depending on what seems relevant. We will then take care of the issue as soon as possible. I Want To Contribute Legal Notice When contributing to this project, you must agree that you have authored 100%\nof the content, that you have the necessary rights to the content and that\nthe content you contribute may be provided under the project license. Reporting Bugs Before Submitting a Bug Report A good bug report shouldn’t leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible. Make sure that you are using the latest version. Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the documentation . If you are looking for support, you might want to check this section ). To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the bug tracker . Also make sure to search the internet (including Stack Overflow) to see if users outside of the GitHub community have discussed the issue. Collect information about the bug: Stack trace (Traceback) OS, Platform and Version (Windows, Linux, macOS, x86, ARM) Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant. Possibly your input and the output Can you reliably reproduce the issue? And can you also reproduce it with older versions? How Do I Submit a Good Bug Report? You must never report security related issues, vulnerabilities or bugs including sensitive information to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by email to <>. We use GitHub issues to track bugs and errors. If you run into an issue with the project: Open an Issue . (Since we can’t be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.) Explain the behavior you would expect and the actual behavior. Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case. Provide the information you collected in the previous section. Once it’s filed: The project team will label the issue accordingly. A team member will try to reproduce the issue with your provided steps. If there are no reproduction steps or no obvious way to reproduce the issue, the team will ask you for those steps and mark the issue as needs-repro . Bugs with the needs-repro tag will not be addressed until they are reproduced. If the team is able to reproduce the issue, it will be marked needs-fix , as well as possibly other tags (such as critical ), and the issue will be left to be implemented by someone . Suggesting Enhancements This section guides you through submitting an enhancement suggestion for yaeos, including completely new features and minor improvements to existing\nfunctionality . Following these guidelines will help maintainers and the\ncommunity to understand your suggestion and find related suggestions. Before Submitting an Enhancement Make sure that you are using the latest version. Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration. Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one. Find out whether your idea fits with the scope and aims of the project. It’s up to you to make a strong case to convince the project’s developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you’re just targeting a minority of users, consider writing an add-on/plugin library. How Do I Submit a Good Enhancement Suggestion? Enhancement suggestions are tracked as GitHub issues . Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Describe the current behavior and explain which behavior you expected to see instead and why. At this point you can also tell which alternatives do not work for you. You may want to include screenshots and animated GIFs which help you demonstrate the steps or point out the part which the suggestion is related to. You can use this tool to record GIFs on macOS and Windows, and this tool or this tool on Linux. Explain why this enhancement would be useful to most yaeos users. You may also want to point out the other projects that solved it better and which could serve as inspiration. Your First Code Contribution Improving The Documentation Styleguides Our code style can be read at Style Guide Commit Messages We encourage the use of commitizen styling on commit\nmessages. Join The Project Team mail me","tags":"","loc":"page/contributing/index.html"},{"title":"Style guide – yaeos","text":"yaeos Style Guide Adopting a consistent style can improve code legibility through the choice of good naming conventions.\nIn addition, style checks will be run during CI to flag any severe non-conformance.\nThis allows code review discussions to focus on semantics and substance rather than pedantry.\nConsistent whitespace usage, and not polluting line endings with trailing white space makes git diff s considerably more legible.\nThis style guide is a living document and proposed changes may be adopted after discussing them and coming to a consensus. Use (modern) standard Fortran Do not use obsolescent or deleted language features\n  E.g., common , pause , entry , arithmetic if and computed goto Do not use vendor extensions in the form of non-standard syntax and vendor supplied intrinsic procedures\n  E.g., real*8 or etime() , use real(pr) File naming conventions Source files should contain at most one program , module , or submodule The filename should match the program or module name and have the file extension .f90 or .F90 if preprocessing is required module names should include it’s subdirectory. Using yaeos for the parent src directory. For example the module in src/phase_equilibria/flash.f90 should be named yaeos_phase_equilibria_flash If the interface and implementation is split using submodules the implementation submodule file should have the same name as the\n  interface (parent) module but end in _implementation E.g., string_class.f90 and string_class_implementation.f90 Tests should be added in the test subdirectory and have the same name as the module they are testing with the test_ prefix\n  added E.g., string_class.f90 and test/test_string_class.f90 Indentation & whitespace By setting and following a convention for indentation and whitespace, code\nreviews and git-diffs can focus on the semantics of the proposed changes rather\nthan style and formatting. We recommend ~~enforce~~ the use of findent to format your files. The body of every Fortran construct should be indented by four (4) spaces Line length should be limited to 80 characters and must not exceed 132 Do not use Tab characters for indentation Remove trailing white space before committing code Variable and procedure naming Variable and procedure names, as well as Fortran keywords, should be written in lowercase Variable and procedure names should be made up of one or more full words separated by an underscore,\n  for example has_failed is preferred over hasfailed Where conventional and appropriate shortening of a word is used then the underscore may be omitted,\n  for example linspace is preferred over lin_space Attributes Always specify intent for dummy arguments. Don’t use dimension attribute to declare arrays because it is more verbose.\n  Use this: real, allocatable :: a(:), b(:,:) instead of: real, dimension(:), allocatable :: a real, dimension(:,:), allocatable :: b When defining many arrays of the same dimension, dimension can be used as an exception if it makes the code less verbose. If the optional attribute is used to declare a dummy argument, it should follow the intent attribute. End block closing statements Fortran allows certain block constructs or scopes to include the name of the program unit in the end statement.\nThe convention adopted herein is to include procedure names, module names and program names in the end statement,\nunless the closing statement can reasonably be expected to be on the same screen or page, within about 25 lines. Document public API code with FORD Documentation strings should be provided for all public and protected entities and their arguments or parameters.\nThis is currently accomplished using the FORD tool .\nFor help writing FORD style documentation please see the FORD wiki .\nThe following two sections are most relevant for contributing new code: Writing Documentation Documentation Meta Data Limitations To write the “spec” (specification) for a new proposal, please place it in the FORD “pages” directory at doc/specs/ .\nTo get help please see the “Writing Pages” and “Writing Documentation” pages\non the FORD wiki .","tags":"","loc":"page/contributing/styleguide.html"}]}